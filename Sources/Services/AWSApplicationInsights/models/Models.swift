// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes.ApplicationComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case componentRemarks = "ComponentRemarks"
        case detectedWorkload = "DetectedWorkload"
        case monitor = "Monitor"
        case osType = "OsType"
        case resourceType = "ResourceType"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentRemarks = self.componentRemarks {
            try encodeContainer.encode(componentRemarks, forKey: .componentRemarks)
        }
        if let detectedWorkload = detectedWorkload {
            var detectedWorkloadContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .detectedWorkload)
            for (dictKey0, detectedWorkload0) in detectedWorkload {
                var detectedWorkload0Container = detectedWorkloadContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, workloadMetaData1) in detectedWorkload0 {
                    try detectedWorkload0Container.encode(workloadMetaData1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let monitor = self.monitor {
            try encodeContainer.encode(monitor, forKey: .monitor)
        }
        if let osType = self.osType {
            try encodeContainer.encode(osType.rawValue, forKey: .osType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentRemarksDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRemarks)
        componentRemarks = componentRemarksDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let osTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.OsType.self, forKey: .osType)
        osType = osTypeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let monitorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let detectedWorkloadContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .detectedWorkload)
        var detectedWorkloadDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let detectedWorkloadContainer = detectedWorkloadContainer {
            detectedWorkloadDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, workloadmetadata0) in detectedWorkloadContainer {
                var workloadmetadata0Decoded0: [Swift.String: Swift.String]? = nil
                if let workloadmetadata0 = workloadmetadata0 {
                    workloadmetadata0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, metadatavalue1) in workloadmetadata0 {
                        if let metadatavalue1 = metadatavalue1 {
                            workloadmetadata0Decoded0?[key1] = metadatavalue1
                        }
                    }
                }
                detectedWorkloadDecoded0?[key0] = workloadmetadata0Decoded0
            }
        }
        detectedWorkload = detectedWorkloadDecoded0
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes a standalone resource or similarly grouped resources that the application is made up of.
    public struct ApplicationComponent: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// If logging is supported for the resource type, indicates whether the component has configured logs to be monitored.
        public var componentRemarks: Swift.String?
        /// Workloads detected in the application component.
        public var detectedWorkload: [Swift.String:[Swift.String:Swift.String]]?
        /// Indicates whether the application component is monitored.
        public var monitor: Swift.Bool?
        /// The operating system of the component.
        public var osType: ApplicationInsightsClientTypes.OsType?
        /// The resource type. Supported resource types include EC2 instances, Auto Scaling group, Classic ELB, Application ELB, and SQS Queue.
        public var resourceType: Swift.String?
        /// The stack tier of the application component.
        public var tier: ApplicationInsightsClientTypes.Tier?

        public init (
            componentName: Swift.String? = nil,
            componentRemarks: Swift.String? = nil,
            detectedWorkload: [Swift.String:[Swift.String:Swift.String]]? = nil,
            monitor: Swift.Bool? = nil,
            osType: ApplicationInsightsClientTypes.OsType? = nil,
            resourceType: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil
        )
        {
            self.componentName = componentName
            self.componentRemarks = componentRemarks
            self.detectedWorkload = detectedWorkload
            self.monitor = monitor
            self.osType = osType
            self.resourceType = resourceType
            self.tier = tier
        }
    }

}

extension ApplicationInsightsClientTypes.ApplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case discoveryType = "DiscoveryType"
        case lifeCycle = "LifeCycle"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case remarks = "Remarks"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let cweMonitorEnabled = self.cweMonitorEnabled {
            try encodeContainer.encode(cweMonitorEnabled, forKey: .cweMonitorEnabled)
        }
        if let discoveryType = self.discoveryType {
            try encodeContainer.encode(discoveryType.rawValue, forKey: .discoveryType)
        }
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let opsCenterEnabled = self.opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = self.opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let remarks = self.remarks {
            try encodeContainer.encode(remarks, forKey: .remarks)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cweMonitorEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cweMonitorEnabled)
        cweMonitorEnabled = cweMonitorEnabledDecoded
        let remarksDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remarks)
        remarks = remarksDecoded
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
        let discoveryTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.DiscoveryType.self, forKey: .discoveryType)
        discoveryType = discoveryTypeDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes the status of the application.
    public struct ApplicationInfo: Swift.Equatable {
        /// Indicates whether auto-configuration is turned on for this application.
        public var autoConfigEnabled: Swift.Bool?
        /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
        public var cweMonitorEnabled: Swift.Bool?
        /// The method used by Application Insights to onboard your resources.
        public var discoveryType: ApplicationInsightsClientTypes.DiscoveryType?
        /// The lifecycle of the application.
        public var lifeCycle: Swift.String?
        /// Indicates whether Application Insights will create opsItems for any problem detected by Application Insights for an application.
        public var opsCenterEnabled: Swift.Bool?
        /// The SNS topic provided to Application Insights that is associated to the created opsItems to receive SNS notifications for opsItem updates.
        public var opsItemSNSTopicArn: Swift.String?
        /// The issues on the user side that block Application Insights from successfully monitoring an application. Example remarks include:
        ///
        /// * “Configuring application, detected 1 Errors, 3 Warnings”
        ///
        /// * “Configuring application, detected 1 Unconfigured Components”
        public var remarks: Swift.String?
        /// The name of the resource group used for the application.
        public var resourceGroupName: Swift.String?

        public init (
            autoConfigEnabled: Swift.Bool? = nil,
            cweMonitorEnabled: Swift.Bool? = nil,
            discoveryType: ApplicationInsightsClientTypes.DiscoveryType? = nil,
            lifeCycle: Swift.String? = nil,
            opsCenterEnabled: Swift.Bool? = nil,
            opsItemSNSTopicArn: Swift.String? = nil,
            remarks: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.autoConfigEnabled = autoConfigEnabled
            self.cweMonitorEnabled = cweMonitorEnabled
            self.discoveryType = discoveryType
            self.lifeCycle = lifeCycle
            self.opsCenterEnabled = opsCenterEnabled
            self.opsItemSNSTopicArn = opsItemSNSTopicArn
            self.remarks = remarks
            self.resourceGroupName = resourceGroupName
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not understood by the server.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum CloudWatchEventSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codeDeploy
        case ec2
        case health
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchEventSource] {
            return [
                .codeDeploy,
                .ec2,
                .health,
                .rds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codeDeploy: return "CODE_DEPLOY"
            case .ec2: return "EC2"
            case .health: return "HEALTH"
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchEventSource(rawValue: rawValue) ?? CloudWatchEventSource.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.ConfigurationEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDetail = "EventDetail"
        case eventResourceName = "EventResourceName"
        case eventResourceType = "EventResourceType"
        case eventStatus = "EventStatus"
        case eventTime = "EventTime"
        case monitoredResourceARN = "MonitoredResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDetail = self.eventDetail {
            try encodeContainer.encode(eventDetail, forKey: .eventDetail)
        }
        if let eventResourceName = self.eventResourceName {
            try encodeContainer.encode(eventResourceName, forKey: .eventResourceName)
        }
        if let eventResourceType = self.eventResourceType {
            try encodeContainer.encode(eventResourceType.rawValue, forKey: .eventResourceType)
        }
        if let eventStatus = self.eventStatus {
            try encodeContainer.encode(eventStatus.rawValue, forKey: .eventStatus)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let monitoredResourceARN = self.monitoredResourceARN {
            try encodeContainer.encode(monitoredResourceARN, forKey: .monitoredResourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoredResourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoredResourceARN)
        monitoredResourceARN = monitoredResourceARNDecoded
        let eventStatusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ConfigurationEventStatus.self, forKey: .eventStatus)
        eventStatus = eventStatusDecoded
        let eventResourceTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ConfigurationEventResourceType.self, forKey: .eventResourceType)
        eventResourceType = eventResourceTypeDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDetail)
        eventDetail = eventDetailDecoded
        let eventResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventResourceName)
        eventResourceName = eventResourceNameDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// The event information.
    public struct ConfigurationEvent: Swift.Equatable {
        /// The details of the event in plain text.
        public var eventDetail: Swift.String?
        /// The name of the resource Application Insights attempted to configure.
        public var eventResourceName: Swift.String?
        /// The resource type that Application Insights attempted to configure, for example, CLOUDWATCH_ALARM.
        public var eventResourceType: ApplicationInsightsClientTypes.ConfigurationEventResourceType?
        /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
        public var eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
        /// The timestamp of the event.
        public var eventTime: ClientRuntime.Date?
        /// The resource monitored by Application Insights.
        public var monitoredResourceARN: Swift.String?

        public init (
            eventDetail: Swift.String? = nil,
            eventResourceName: Swift.String? = nil,
            eventResourceType: ApplicationInsightsClientTypes.ConfigurationEventResourceType? = nil,
            eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus? = nil,
            eventTime: ClientRuntime.Date? = nil,
            monitoredResourceARN: Swift.String? = nil
        )
        {
            self.eventDetail = eventDetail
            self.eventResourceName = eventResourceName
            self.eventResourceType = eventResourceType
            self.eventStatus = eventStatus
            self.eventTime = eventTime
            self.monitoredResourceARN = monitoredResourceARN
        }
    }

}

extension ApplicationInsightsClientTypes {
    public enum ConfigurationEventResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudformation
        case cloudwatchAlarm
        case cloudwatchLog
        case ssmAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationEventResourceType] {
            return [
                .cloudformation,
                .cloudwatchAlarm,
                .cloudwatchLog,
                .ssmAssociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
            case .cloudwatchLog: return "CLOUDWATCH_LOG"
            case .ssmAssociation: return "SSM_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationEventResourceType(rawValue: rawValue) ?? ConfigurationEventResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum ConfigurationEventStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationEventStatus] {
            return [
                .error,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationEventStatus(rawValue: rawValue) ?? ConfigurationEventStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case autoCreate = "AutoCreate"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case groupingType = "GroupingType"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case resourceGroupName = "ResourceGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let autoCreate = self.autoCreate {
            try encodeContainer.encode(autoCreate, forKey: .autoCreate)
        }
        if let cweMonitorEnabled = self.cweMonitorEnabled {
            try encodeContainer.encode(cweMonitorEnabled, forKey: .cweMonitorEnabled)
        }
        if let groupingType = self.groupingType {
            try encodeContainer.encode(groupingType.rawValue, forKey: .groupingType)
        }
        if let opsCenterEnabled = self.opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = self.opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Indicates whether Application Insights automatically configures unmonitored resources in the resource group.
    public var autoConfigEnabled: Swift.Bool?
    /// Configures all of the resources in the resource group by applying the recommended configurations.
    public var autoCreate: Swift.Bool?
    /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
    public var cweMonitorEnabled: Swift.Bool?
    /// Application Insights can create applications based on a resource group or on an account. To create an account-based application using all of the resources in the account, set this parameter to ACCOUNT_BASED.
    public var groupingType: ApplicationInsightsClientTypes.GroupingType?
    /// When set to true, creates opsItems for any problems detected on an application.
    public var opsCenterEnabled: Swift.Bool?
    /// The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
    public var opsItemSNSTopicArn: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?
    /// List of tags to add to the application. tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init (
        autoConfigEnabled: Swift.Bool? = nil,
        autoCreate: Swift.Bool? = nil,
        cweMonitorEnabled: Swift.Bool? = nil,
        groupingType: ApplicationInsightsClientTypes.GroupingType? = nil,
        opsCenterEnabled: Swift.Bool? = nil,
        opsItemSNSTopicArn: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.autoCreate = autoCreate
        self.cweMonitorEnabled = cweMonitorEnabled
        self.groupingType = groupingType
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.resourceGroupName = resourceGroupName
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let opsCenterEnabled: Swift.Bool?
    let cweMonitorEnabled: Swift.Bool?
    let opsItemSNSTopicArn: Swift.String?
    let tags: [ApplicationInsightsClientTypes.Tag]?
    let autoConfigEnabled: Swift.Bool?
    let autoCreate: Swift.Bool?
    let groupingType: ApplicationInsightsClientTypes.GroupingType?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case autoCreate = "AutoCreate"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case groupingType = "GroupingType"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case resourceGroupName = "ResourceGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cweMonitorEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cweMonitorEnabled)
        cweMonitorEnabled = cweMonitorEnabledDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationInsightsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationInsightsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
        let autoCreateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCreate)
        autoCreate = autoCreateDecoded
        let groupingTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.GroupingType.self, forKey: .groupingType)
        groupingType = groupingTypeDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsAlreadyExistException" : self = .tagsAlreadyExistException(try TagsAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsAlreadyExistException(TagsAlreadyExistException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init (
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceList = resourceList {
            var resourceListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceList)
            for resourcearn0 in resourceList {
                try resourceListContainer.encode(resourcearn0)
            }
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The list of resource ARNs that belong to the component.
    /// This member is required.
    public var resourceList: [Swift.String]?

    public init (
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let resourceList: [Swift.String]?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceList)
        var resourceListDecoded0:[Swift.String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [Swift.String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension CreateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateComponentOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension CreateLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLogPatternInput: Swift.Equatable {
    /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
    /// This member is required.
    public var pattern: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
    /// This member is required.
    public var rank: Swift.Int
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        pattern: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        rank: Swift.Int = 0,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

struct CreateLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
    let pattern: Swift.String?
    let rank: Swift.Int
}

extension CreateLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank) ?? 0
        rank = rankDecoded
    }
}

extension CreateLogPatternOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLogPatternOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLogPatternOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLogPatternOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLogPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct CreateLogPatternOutputResponse: Swift.Equatable {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init (
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct CreateLogPatternOutputResponseBody: Swift.Equatable {
    let logPattern: ApplicationInsightsClientTypes.LogPattern?
    let resourceGroupName: Swift.String?
}

extension CreateLogPatternOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logPatternDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        resourceGroupName: Swift.String? = nil
    )
    {
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
}

extension DeleteComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DeleteComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteComponentOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DeleteLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLogPatternInput: Swift.Equatable {
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
}

extension DeleteLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
    }
}

extension DeleteLogPatternOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLogPatternOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLogPatternOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLogPatternOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLogPatternOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationInput: Swift.Equatable {
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        resourceGroupName: Swift.String? = nil
    )
    {
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
}

extension DescribeApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension DescribeApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct DescribeApplicationOutputResponse: Swift.Equatable {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init (
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct DescribeApplicationOutputResponseBody: Swift.Equatable {
    let applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?
}

extension DescribeApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

extension DescribeComponentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeComponentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeComponentConfigurationInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeComponentConfigurationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
}

extension DescribeComponentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DescribeComponentConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeComponentConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeComponentConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentConfiguration = output.componentConfiguration
            self.monitor = output.monitor
            self.tier = output.tier
        } else {
            self.componentConfiguration = nil
            self.monitor = nil
            self.tier = nil
        }
    }
}

public struct DescribeComponentConfigurationOutputResponse: Swift.Equatable {
    /// The configuration settings of the component. The value is the escaped JSON of the configuration.
    public var componentConfiguration: Swift.String?
    /// Indicates whether the application component is monitored.
    public var monitor: Swift.Bool?
    /// The tier of the application component. Supported tiers include DOT_NET_CORE, DOT_NET_WORKER, DOT_NET_WEB, SQL_SERVER, and DEFAULT
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init (
        componentConfiguration: Swift.String? = nil,
        monitor: Swift.Bool? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
        self.monitor = monitor
        self.tier = tier
    }
}

struct DescribeComponentConfigurationOutputResponseBody: Swift.Equatable {
    let monitor: Swift.Bool?
    let tier: ApplicationInsightsClientTypes.Tier?
    let componentConfiguration: Swift.String?
}

extension DescribeComponentConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentConfiguration = "ComponentConfiguration"
        case monitor = "Monitor"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

extension DescribeComponentConfigurationRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension DescribeComponentConfigurationRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeComponentConfigurationRecommendationInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The tier of the application component.
    /// This member is required.
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init (
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

struct DescribeComponentConfigurationRecommendationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let tier: ApplicationInsightsClientTypes.Tier?
}

extension DescribeComponentConfigurationRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension DescribeComponentConfigurationRecommendationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentConfigurationRecommendationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeComponentConfigurationRecommendationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentConfigurationRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeComponentConfigurationRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentConfiguration = output.componentConfiguration
        } else {
            self.componentConfiguration = nil
        }
    }
}

public struct DescribeComponentConfigurationRecommendationOutputResponse: Swift.Equatable {
    /// The recommended configuration settings of the component. The value is the escaped JSON of the configuration.
    public var componentConfiguration: Swift.String?

    public init (
        componentConfiguration: Swift.String? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
    }
}

struct DescribeComponentConfigurationRecommendationOutputResponseBody: Swift.Equatable {
    let componentConfiguration: Swift.String?
}

extension DescribeComponentConfigurationRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentConfiguration = "ComponentConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

extension DescribeComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
}

extension DescribeComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DescribeComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponent = output.applicationComponent
            self.resourceList = output.resourceList
        } else {
            self.applicationComponent = nil
            self.resourceList = nil
        }
    }
}

public struct DescribeComponentOutputResponse: Swift.Equatable {
    /// Describes a standalone resource or similarly grouped resources that the application is made up of.
    public var applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent?
    /// The list of resource ARNs that belong to the component.
    public var resourceList: [Swift.String]?

    public init (
        applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.applicationComponent = applicationComponent
        self.resourceList = resourceList
    }
}

struct DescribeComponentOutputResponseBody: Swift.Equatable {
    let applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent?
    let resourceList: [Swift.String]?
}

extension DescribeComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponent = "ApplicationComponent"
        case resourceList = "ResourceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationComponent.self, forKey: .applicationComponent)
        applicationComponent = applicationComponentDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceList)
        var resourceListDecoded0:[Swift.String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [Swift.String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension DescribeLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLogPatternInput: Swift.Equatable {
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
}

extension DescribeLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
    }
}

extension DescribeLogPatternOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLogPatternOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLogPatternOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLogPatternOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLogPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct DescribeLogPatternOutputResponse: Swift.Equatable {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init (
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeLogPatternOutputResponseBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let logPattern: ApplicationInsightsClientTypes.LogPattern?
}

extension DescribeLogPatternOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
    }
}

extension DescribeObservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observationId = "ObservationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observationId = self.observationId {
            try encodeContainer.encode(observationId, forKey: .observationId)
        }
    }
}

extension DescribeObservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeObservationInput: Swift.Equatable {
    /// The ID of the observation.
    /// This member is required.
    public var observationId: Swift.String?

    public init (
        observationId: Swift.String? = nil
    )
    {
        self.observationId = observationId
    }
}

struct DescribeObservationInputBody: Swift.Equatable {
    let observationId: Swift.String?
}

extension DescribeObservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observationId = "ObservationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observationId)
        observationId = observationIdDecoded
    }
}

extension DescribeObservationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeObservationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeObservationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeObservationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeObservationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.observation = output.observation
        } else {
            self.observation = nil
        }
    }
}

public struct DescribeObservationOutputResponse: Swift.Equatable {
    /// Information about the observation.
    public var observation: ApplicationInsightsClientTypes.Observation?

    public init (
        observation: ApplicationInsightsClientTypes.Observation? = nil
    )
    {
        self.observation = observation
    }
}

struct DescribeObservationOutputResponseBody: Swift.Equatable {
    let observation: ApplicationInsightsClientTypes.Observation?
}

extension DescribeObservationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observation = "Observation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Observation.self, forKey: .observation)
        observation = observationDecoded
    }
}

extension DescribeProblemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problemId = "ProblemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let problemId = self.problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
    }
}

extension DescribeProblemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProblemInput: Swift.Equatable {
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?

    public init (
        problemId: Swift.String? = nil
    )
    {
        self.problemId = problemId
    }
}

struct DescribeProblemInputBody: Swift.Equatable {
    let problemId: Swift.String?
}

extension DescribeProblemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problemId = "ProblemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .problemId)
        problemId = problemIdDecoded
    }
}

extension DescribeProblemObservationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problemId = "ProblemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let problemId = self.problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
    }
}

extension DescribeProblemObservationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProblemObservationsInput: Swift.Equatable {
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?

    public init (
        problemId: Swift.String? = nil
    )
    {
        self.problemId = problemId
    }
}

struct DescribeProblemObservationsInputBody: Swift.Equatable {
    let problemId: Swift.String?
}

extension DescribeProblemObservationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problemId = "ProblemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .problemId)
        problemId = problemIdDecoded
    }
}

extension DescribeProblemObservationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProblemObservationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProblemObservationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProblemObservationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProblemObservationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.relatedObservations = output.relatedObservations
        } else {
            self.relatedObservations = nil
        }
    }
}

public struct DescribeProblemObservationsOutputResponse: Swift.Equatable {
    /// Observations related to the problem.
    public var relatedObservations: ApplicationInsightsClientTypes.RelatedObservations?

    public init (
        relatedObservations: ApplicationInsightsClientTypes.RelatedObservations? = nil
    )
    {
        self.relatedObservations = relatedObservations
    }
}

struct DescribeProblemObservationsOutputResponseBody: Swift.Equatable {
    let relatedObservations: ApplicationInsightsClientTypes.RelatedObservations?
}

extension DescribeProblemObservationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relatedObservations = "RelatedObservations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedObservationsDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.RelatedObservations.self, forKey: .relatedObservations)
        relatedObservations = relatedObservationsDecoded
    }
}

extension DescribeProblemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProblemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProblemOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProblemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProblemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.problem = output.problem
        } else {
            self.problem = nil
        }
    }
}

public struct DescribeProblemOutputResponse: Swift.Equatable {
    /// Information about the problem.
    public var problem: ApplicationInsightsClientTypes.Problem?

    public init (
        problem: ApplicationInsightsClientTypes.Problem? = nil
    )
    {
        self.problem = problem
    }
}

struct DescribeProblemOutputResponseBody: Swift.Equatable {
    let problem: ApplicationInsightsClientTypes.Problem?
}

extension DescribeProblemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problem = "Problem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Problem.self, forKey: .problem)
        problem = problemDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum DiscoveryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountBased
        case resourceGroupBased
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryType] {
            return [
                .accountBased,
                .resourceGroupBased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountBased: return "ACCOUNT_BASED"
            case .resourceGroupBased: return "RESOURCE_GROUP_BASED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiscoveryType(rawValue: rawValue) ?? DiscoveryType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum FeedbackKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insightsFeedback
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackKey] {
            return [
                .insightsFeedback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insightsFeedback: return "INSIGHTS_FEEDBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeedbackKey(rawValue: rawValue) ?? FeedbackKey.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum FeedbackValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notSpecified
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackValue] {
            return [
                .notSpecified,
                .notUseful,
                .useful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notSpecified: return "NOT_SPECIFIED"
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeedbackValue(rawValue: rawValue) ?? FeedbackValue.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum GroupingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountBased
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupingType] {
            return [
                .accountBased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountBased: return "ACCOUNT_BASED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupingType(rawValue: rawValue) ?? GroupingType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfoList = output.applicationInfoList
            self.nextToken = output.nextToken
        } else {
            self.applicationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// The list of applications.
    public var applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInfoList = applicationInfoList
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfoList = "ApplicationInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.ApplicationInfo?].self, forKey: .applicationInfoList)
        var applicationInfoListDecoded0:[ApplicationInsightsClientTypes.ApplicationInfo]? = nil
        if let applicationInfoListContainer = applicationInfoListContainer {
            applicationInfoListDecoded0 = [ApplicationInsightsClientTypes.ApplicationInfo]()
            for structure0 in applicationInfoListContainer {
                if let structure0 = structure0 {
                    applicationInfoListDecoded0?.append(structure0)
                }
            }
        }
        applicationInfoList = applicationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentList = output.applicationComponentList
            self.nextToken = output.nextToken
        } else {
            self.applicationComponentList = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    /// The list of application components.
    public var applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationComponentList = applicationComponentList
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    let applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentList = "ApplicationComponentList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.ApplicationComponent?].self, forKey: .applicationComponentList)
        var applicationComponentListDecoded0:[ApplicationInsightsClientTypes.ApplicationComponent]? = nil
        if let applicationComponentListContainer = applicationComponentListContainer {
            applicationComponentListDecoded0 = [ApplicationInsightsClientTypes.ApplicationComponent]()
            for structure0 in applicationComponentListContainer {
                if let structure0 = structure0 {
                    applicationComponentListDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentList = applicationComponentListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventStatus = "EventStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventStatus = self.eventStatus {
            try encodeContainer.encode(eventStatus.rawValue, forKey: .eventStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListConfigurationHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConfigurationHistoryInput: Swift.Equatable {
    /// The end time of the event.
    public var endTime: ClientRuntime.Date?
    /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
    public var eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
    /// The maximum number of results returned by ListConfigurationHistory in paginated output. When this parameter is used, ListConfigurationHistory returns only MaxResults in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another ListConfigurationHistory request with the returned NextToken value. If this parameter is not used, then ListConfigurationHistory returns all results.
    public var maxResults: Swift.Int?
    /// The NextToken value returned from a previous paginated ListConfigurationHistory request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Resource group to which the application belongs.
    public var resourceGroupName: Swift.String?
    /// The start time of the event.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
    }
}

struct ListConfigurationHistoryInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConfigurationHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventStatus = "EventStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let eventStatusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ConfigurationEventStatus.self, forKey: .eventStatus)
        eventStatus = eventStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConfigurationHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConfigurationHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventList = output.eventList
            self.nextToken = output.nextToken
        } else {
            self.eventList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationHistoryOutputResponse: Swift.Equatable {
    /// The list of configuration events and their corresponding details.
    public var eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]?
    /// The NextToken value to include in a future ListConfigurationHistory request. When the results of a ListConfigurationHistory request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventList = eventList
        self.nextToken = nextToken
    }
}

struct ListConfigurationHistoryOutputResponseBody: Swift.Equatable {
    let eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]?
    let nextToken: Swift.String?
}

extension ListConfigurationHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventList = "EventList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.ConfigurationEvent?].self, forKey: .eventList)
        var eventListDecoded0:[ApplicationInsightsClientTypes.ConfigurationEvent]? = nil
        if let eventListContainer = eventListContainer {
            eventListDecoded0 = [ApplicationInsightsClientTypes.ConfigurationEvent]()
            for structure0 in eventListContainer {
                if let structure0 = structure0 {
                    eventListDecoded0?.append(structure0)
                }
            }
        }
        eventList = eventListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogPatternSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListLogPatternSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLogPatternSetsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternSetsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLogPatternSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogPatternSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLogPatternSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLogPatternSetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLogPatternSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLogPatternSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPatternSets = output.logPatternSets
            self.nextToken = output.nextToken
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPatternSets = nil
            self.nextToken = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListLogPatternSetsOutputResponse: Swift.Equatable {
    /// The list of log pattern sets.
    public var logPatternSets: [Swift.String]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init (
        logPatternSets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPatternSets = logPatternSets
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternSetsOutputResponseBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let logPatternSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListLogPatternSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPatternSets = "LogPatternSets"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logPatternSets)
        var logPatternSetsDecoded0:[Swift.String]? = nil
        if let logPatternSetsContainer = logPatternSetsContainer {
            logPatternSetsDecoded0 = [Swift.String]()
            for string0 in logPatternSetsContainer {
                if let string0 = string0 {
                    logPatternSetsDecoded0?.append(string0)
                }
            }
        }
        logPatternSets = logPatternSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogPatternsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListLogPatternsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLogPatternsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the log pattern set.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLogPatternsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogPatternsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLogPatternsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLogPatternsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLogPatternsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLogPatternsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPatterns = output.logPatterns
            self.nextToken = output.nextToken
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPatterns = nil
            self.nextToken = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListLogPatternsOutputResponse: Swift.Equatable {
    /// The list of log patterns.
    public var logPatterns: [ApplicationInsightsClientTypes.LogPattern]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init (
        logPatterns: [ApplicationInsightsClientTypes.LogPattern]? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPatterns = logPatterns
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternsOutputResponseBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let logPatterns: [ApplicationInsightsClientTypes.LogPattern]?
    let nextToken: Swift.String?
}

extension ListLogPatternsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPatterns = "LogPatterns"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.LogPattern?].self, forKey: .logPatterns)
        var logPatternsDecoded0:[ApplicationInsightsClientTypes.LogPattern]? = nil
        if let logPatternsContainer = logPatternsContainer {
            logPatternsDecoded0 = [ApplicationInsightsClientTypes.LogPattern]()
            for structure0 in logPatternsContainer {
                if let structure0 = structure0 {
                    logPatternsDecoded0?.append(structure0)
                }
            }
        }
        logPatterns = logPatternsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProblemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListProblemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProblemsInput: Swift.Equatable {
    /// The name of the component.
    public var componentName: Swift.String?
    /// The time when the problem ended, in epoch seconds. If not specified, problems within the past seven days are returned.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?
    /// The time when the problem was detected, in epoch seconds. If you don't specify a time frame for the request, problems within the past seven days are returned.
    public var startTime: ClientRuntime.Date?

    public init (
        componentName: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.componentName = componentName
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
    }
}

struct ListProblemsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let componentName: Swift.String?
}

extension ListProblemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension ListProblemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProblemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProblemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProblemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProblemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.problemList = output.problemList
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.nextToken = nil
            self.problemList = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListProblemsOutputResponse: Swift.Equatable {
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of problems.
    public var problemList: [ApplicationInsightsClientTypes.Problem]?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        problemList: [ApplicationInsightsClientTypes.Problem]? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.problemList = problemList
        self.resourceGroupName = resourceGroupName
    }
}

struct ListProblemsOutputResponseBody: Swift.Equatable {
    let problemList: [ApplicationInsightsClientTypes.Problem]?
    let nextToken: Swift.String?
    let resourceGroupName: Swift.String?
}

extension ListProblemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case problemList = "ProblemList"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Problem?].self, forKey: .problemList)
        var problemListDecoded0:[ApplicationInsightsClientTypes.Problem]? = nil
        if let problemListContainer = problemListContainer {
            problemListDecoded0 = [ApplicationInsightsClientTypes.Problem]()
            for structure0 in problemListContainer {
                if let structure0 = structure0 {
                    problemListDecoded0?.append(structure0)
                }
            }
        }
        problemList = problemListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application that you want to retrieve tag information for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An array that lists all the tags that are associated with the application. Each tag consists of a required tag key (Key) and an associated tag value (Value).
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init (
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ApplicationInsightsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationInsightsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationInsightsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApplicationInsightsClientTypes {
    public enum LogFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogFilter] {
            return [
                .error,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogFilter(rawValue: rawValue) ?? LogFilter.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.LogPattern: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank) ?? 0
        rank = rankDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// An object that defines the log patterns that belongs to a LogPatternSet.
    public struct LogPattern: Swift.Equatable {
        /// A regular expression that defines the log pattern. A log pattern can contain as many as 50 characters, and it cannot be empty. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
        public var pattern: Swift.String?
        /// The name of the log pattern. A log pattern name can contain as many as 50 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public var patternName: Swift.String?
        /// The name of the log pattern. A log pattern name can contain as many as 30 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public var patternSetName: Swift.String?
        /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
        public var rank: Swift.Int

        public init (
            pattern: Swift.String? = nil,
            patternName: Swift.String? = nil,
            patternSetName: Swift.String? = nil,
            rank: Swift.Int = 0
        )
        {
            self.pattern = pattern
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.rank = rank
        }
    }

}

extension ApplicationInsightsClientTypes.Observation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchEventDetailType = "CloudWatchEventDetailType"
        case cloudWatchEventId = "CloudWatchEventId"
        case cloudWatchEventSource = "CloudWatchEventSource"
        case codeDeployApplication = "CodeDeployApplication"
        case codeDeployDeploymentGroup = "CodeDeployDeploymentGroup"
        case codeDeployDeploymentId = "CodeDeployDeploymentId"
        case codeDeployInstanceGroupId = "CodeDeployInstanceGroupId"
        case codeDeployState = "CodeDeployState"
        case ebsCause = "EbsCause"
        case ebsEvent = "EbsEvent"
        case ebsRequestId = "EbsRequestId"
        case ebsResult = "EbsResult"
        case ec2State = "Ec2State"
        case endTime = "EndTime"
        case healthEventArn = "HealthEventArn"
        case healthEventDescription = "HealthEventDescription"
        case healthEventTypeCategory = "HealthEventTypeCategory"
        case healthEventTypeCode = "HealthEventTypeCode"
        case healthService = "HealthService"
        case id = "Id"
        case lineTime = "LineTime"
        case logFilter = "LogFilter"
        case logGroup = "LogGroup"
        case logText = "LogText"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case rdsEventCategories = "RdsEventCategories"
        case rdsEventMessage = "RdsEventMessage"
        case s3EventName = "S3EventName"
        case sourceARN = "SourceARN"
        case sourceType = "SourceType"
        case startTime = "StartTime"
        case statesArn = "StatesArn"
        case statesExecutionArn = "StatesExecutionArn"
        case statesInput = "StatesInput"
        case statesStatus = "StatesStatus"
        case unit = "Unit"
        case value = "Value"
        case xRayErrorPercent = "XRayErrorPercent"
        case xRayFaultPercent = "XRayFaultPercent"
        case xRayNodeName = "XRayNodeName"
        case xRayNodeType = "XRayNodeType"
        case xRayRequestAverageLatency = "XRayRequestAverageLatency"
        case xRayRequestCount = "XRayRequestCount"
        case xRayThrottlePercent = "XRayThrottlePercent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchEventDetailType = self.cloudWatchEventDetailType {
            try encodeContainer.encode(cloudWatchEventDetailType, forKey: .cloudWatchEventDetailType)
        }
        if let cloudWatchEventId = self.cloudWatchEventId {
            try encodeContainer.encode(cloudWatchEventId, forKey: .cloudWatchEventId)
        }
        if let cloudWatchEventSource = self.cloudWatchEventSource {
            try encodeContainer.encode(cloudWatchEventSource.rawValue, forKey: .cloudWatchEventSource)
        }
        if let codeDeployApplication = self.codeDeployApplication {
            try encodeContainer.encode(codeDeployApplication, forKey: .codeDeployApplication)
        }
        if let codeDeployDeploymentGroup = self.codeDeployDeploymentGroup {
            try encodeContainer.encode(codeDeployDeploymentGroup, forKey: .codeDeployDeploymentGroup)
        }
        if let codeDeployDeploymentId = self.codeDeployDeploymentId {
            try encodeContainer.encode(codeDeployDeploymentId, forKey: .codeDeployDeploymentId)
        }
        if let codeDeployInstanceGroupId = self.codeDeployInstanceGroupId {
            try encodeContainer.encode(codeDeployInstanceGroupId, forKey: .codeDeployInstanceGroupId)
        }
        if let codeDeployState = self.codeDeployState {
            try encodeContainer.encode(codeDeployState, forKey: .codeDeployState)
        }
        if let ebsCause = self.ebsCause {
            try encodeContainer.encode(ebsCause, forKey: .ebsCause)
        }
        if let ebsEvent = self.ebsEvent {
            try encodeContainer.encode(ebsEvent, forKey: .ebsEvent)
        }
        if let ebsRequestId = self.ebsRequestId {
            try encodeContainer.encode(ebsRequestId, forKey: .ebsRequestId)
        }
        if let ebsResult = self.ebsResult {
            try encodeContainer.encode(ebsResult, forKey: .ebsResult)
        }
        if let ec2State = self.ec2State {
            try encodeContainer.encode(ec2State, forKey: .ec2State)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let healthEventArn = self.healthEventArn {
            try encodeContainer.encode(healthEventArn, forKey: .healthEventArn)
        }
        if let healthEventDescription = self.healthEventDescription {
            try encodeContainer.encode(healthEventDescription, forKey: .healthEventDescription)
        }
        if let healthEventTypeCategory = self.healthEventTypeCategory {
            try encodeContainer.encode(healthEventTypeCategory, forKey: .healthEventTypeCategory)
        }
        if let healthEventTypeCode = self.healthEventTypeCode {
            try encodeContainer.encode(healthEventTypeCode, forKey: .healthEventTypeCode)
        }
        if let healthService = self.healthService {
            try encodeContainer.encode(healthService, forKey: .healthService)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lineTime = self.lineTime {
            try encodeContainer.encodeTimestamp(lineTime, format: .epochSeconds, forKey: .lineTime)
        }
        if let logFilter = self.logFilter {
            try encodeContainer.encode(logFilter.rawValue, forKey: .logFilter)
        }
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let logText = self.logText {
            try encodeContainer.encode(logText, forKey: .logText)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = self.metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let rdsEventCategories = self.rdsEventCategories {
            try encodeContainer.encode(rdsEventCategories, forKey: .rdsEventCategories)
        }
        if let rdsEventMessage = self.rdsEventMessage {
            try encodeContainer.encode(rdsEventMessage, forKey: .rdsEventMessage)
        }
        if let s3EventName = self.s3EventName {
            try encodeContainer.encode(s3EventName, forKey: .s3EventName)
        }
        if let sourceARN = self.sourceARN {
            try encodeContainer.encode(sourceARN, forKey: .sourceARN)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statesArn = self.statesArn {
            try encodeContainer.encode(statesArn, forKey: .statesArn)
        }
        if let statesExecutionArn = self.statesExecutionArn {
            try encodeContainer.encode(statesExecutionArn, forKey: .statesExecutionArn)
        }
        if let statesInput = self.statesInput {
            try encodeContainer.encode(statesInput, forKey: .statesInput)
        }
        if let statesStatus = self.statesStatus {
            try encodeContainer.encode(statesStatus, forKey: .statesStatus)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let xRayErrorPercent = self.xRayErrorPercent {
            try encodeContainer.encode(xRayErrorPercent, forKey: .xRayErrorPercent)
        }
        if let xRayFaultPercent = self.xRayFaultPercent {
            try encodeContainer.encode(xRayFaultPercent, forKey: .xRayFaultPercent)
        }
        if let xRayNodeName = self.xRayNodeName {
            try encodeContainer.encode(xRayNodeName, forKey: .xRayNodeName)
        }
        if let xRayNodeType = self.xRayNodeType {
            try encodeContainer.encode(xRayNodeType, forKey: .xRayNodeType)
        }
        if let xRayRequestAverageLatency = self.xRayRequestAverageLatency {
            try encodeContainer.encode(xRayRequestAverageLatency, forKey: .xRayRequestAverageLatency)
        }
        if let xRayRequestCount = self.xRayRequestCount {
            try encodeContainer.encode(xRayRequestCount, forKey: .xRayRequestCount)
        }
        if let xRayThrottlePercent = self.xRayThrottlePercent {
            try encodeContainer.encode(xRayThrottlePercent, forKey: .xRayThrottlePercent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceARN)
        sourceARN = sourceARNDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
        let lineTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lineTime)
        lineTime = lineTimeDecoded
        let logTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logText)
        logText = logTextDecoded
        let logFilterDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogFilter.self, forKey: .logFilter)
        logFilter = logFilterDecoded
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let cloudWatchEventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchEventId)
        cloudWatchEventId = cloudWatchEventIdDecoded
        let cloudWatchEventSourceDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.CloudWatchEventSource.self, forKey: .cloudWatchEventSource)
        cloudWatchEventSource = cloudWatchEventSourceDecoded
        let cloudWatchEventDetailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchEventDetailType)
        cloudWatchEventDetailType = cloudWatchEventDetailTypeDecoded
        let healthEventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventArn)
        healthEventArn = healthEventArnDecoded
        let healthServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthService)
        healthService = healthServiceDecoded
        let healthEventTypeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventTypeCode)
        healthEventTypeCode = healthEventTypeCodeDecoded
        let healthEventTypeCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventTypeCategory)
        healthEventTypeCategory = healthEventTypeCategoryDecoded
        let healthEventDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventDescription)
        healthEventDescription = healthEventDescriptionDecoded
        let codeDeployDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployDeploymentId)
        codeDeployDeploymentId = codeDeployDeploymentIdDecoded
        let codeDeployDeploymentGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployDeploymentGroup)
        codeDeployDeploymentGroup = codeDeployDeploymentGroupDecoded
        let codeDeployStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployState)
        codeDeployState = codeDeployStateDecoded
        let codeDeployApplicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployApplication)
        codeDeployApplication = codeDeployApplicationDecoded
        let codeDeployInstanceGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployInstanceGroupId)
        codeDeployInstanceGroupId = codeDeployInstanceGroupIdDecoded
        let ec2StateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2State)
        ec2State = ec2StateDecoded
        let rdsEventCategoriesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsEventCategories)
        rdsEventCategories = rdsEventCategoriesDecoded
        let rdsEventMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsEventMessage)
        rdsEventMessage = rdsEventMessageDecoded
        let s3EventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3EventName)
        s3EventName = s3EventNameDecoded
        let statesExecutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesExecutionArn)
        statesExecutionArn = statesExecutionArnDecoded
        let statesArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesArn)
        statesArn = statesArnDecoded
        let statesStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesStatus)
        statesStatus = statesStatusDecoded
        let statesInputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesInput)
        statesInput = statesInputDecoded
        let ebsEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEvent)
        ebsEvent = ebsEventDecoded
        let ebsResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsResult)
        ebsResult = ebsResultDecoded
        let ebsCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsCause)
        ebsCause = ebsCauseDecoded
        let ebsRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsRequestId)
        ebsRequestId = ebsRequestIdDecoded
        let xRayFaultPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayFaultPercent)
        xRayFaultPercent = xRayFaultPercentDecoded
        let xRayThrottlePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayThrottlePercent)
        xRayThrottlePercent = xRayThrottlePercentDecoded
        let xRayErrorPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayErrorPercent)
        xRayErrorPercent = xRayErrorPercentDecoded
        let xRayRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayRequestCount)
        xRayRequestCount = xRayRequestCountDecoded
        let xRayRequestAverageLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayRequestAverageLatency)
        xRayRequestAverageLatency = xRayRequestAverageLatencyDecoded
        let xRayNodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xRayNodeName)
        xRayNodeName = xRayNodeNameDecoded
        let xRayNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xRayNodeType)
        xRayNodeType = xRayNodeTypeDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes an anomaly or error with the application.
    public struct Observation: Swift.Equatable {
        /// The detail type of the CloudWatch Event-based observation, for example, EC2 Instance State-change Notification.
        public var cloudWatchEventDetailType: Swift.String?
        /// The ID of the CloudWatch Event-based observation related to the detected problem.
        public var cloudWatchEventId: Swift.String?
        /// The source of the CloudWatch Event.
        public var cloudWatchEventSource: ApplicationInsightsClientTypes.CloudWatchEventSource?
        /// The CodeDeploy application to which the deployment belongs.
        public var codeDeployApplication: Swift.String?
        /// The deployment group to which the CodeDeploy deployment belongs.
        public var codeDeployDeploymentGroup: Swift.String?
        /// The deployment ID of the CodeDeploy-based observation related to the detected problem.
        public var codeDeployDeploymentId: Swift.String?
        /// The instance group to which the CodeDeploy instance belongs.
        public var codeDeployInstanceGroupId: Swift.String?
        /// The status of the CodeDeploy deployment, for example SUCCESS or  FAILURE.
        public var codeDeployState: Swift.String?
        /// The cause of an EBS CloudWatch event.
        public var ebsCause: Swift.String?
        /// The type of EBS CloudWatch event, such as createVolume, deleteVolume or attachVolume.
        public var ebsEvent: Swift.String?
        /// The request ID of an EBS CloudWatch event.
        public var ebsRequestId: Swift.String?
        /// The result of an EBS CloudWatch event, such as failed or succeeded.
        public var ebsResult: Swift.String?
        /// The state of the instance, such as STOPPING or TERMINATING.
        public var ec2State: Swift.String?
        /// The time when the observation ended, in epoch seconds.
        public var endTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the AWS Health Event-based observation.
        public var healthEventArn: Swift.String?
        /// The description of the AWS Health event provided by the service, such as Amazon EC2.
        public var healthEventDescription: Swift.String?
        /// The category of the AWS Health event, such as issue.
        public var healthEventTypeCategory: Swift.String?
        /// The type of the AWS Health event, for example, AWS_EC2_POWER_CONNECTIVITY_ISSUE.
        public var healthEventTypeCode: Swift.String?
        /// The service to which the AWS Health Event belongs, such as EC2.
        public var healthService: Swift.String?
        /// The ID of the observation type.
        public var id: Swift.String?
        /// The timestamp in the CloudWatch Logs that specifies when the matched line occurred.
        public var lineTime: ClientRuntime.Date?
        /// The log filter of the observation.
        public var logFilter: ApplicationInsightsClientTypes.LogFilter?
        /// The log group name.
        public var logGroup: Swift.String?
        /// The log text of the observation.
        public var logText: Swift.String?
        /// The name of the observation metric.
        public var metricName: Swift.String?
        /// The namespace of the observation metric.
        public var metricNamespace: Swift.String?
        /// The category of an RDS event.
        public var rdsEventCategories: Swift.String?
        /// The message of an RDS event.
        public var rdsEventMessage: Swift.String?
        /// The name of the S3 CloudWatch Event-based observation.
        public var s3EventName: Swift.String?
        /// The source resource ARN of the observation.
        public var sourceARN: Swift.String?
        /// The source type of the observation.
        public var sourceType: Swift.String?
        /// The time when the observation was first detected, in epoch seconds.
        public var startTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the step function-based observation.
        public var statesArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the step function execution-based observation.
        public var statesExecutionArn: Swift.String?
        /// The input to the step function-based observation.
        public var statesInput: Swift.String?
        /// The status of the step function-related observation.
        public var statesStatus: Swift.String?
        /// The unit of the source observation metric.
        public var unit: Swift.String?
        /// The value of the source observation metric.
        public var value: Swift.Double?
        /// The X-Ray request error percentage for this node.
        public var xRayErrorPercent: Swift.Int?
        /// The X-Ray request fault percentage for this node.
        public var xRayFaultPercent: Swift.Int?
        /// The name of the X-Ray node.
        public var xRayNodeName: Swift.String?
        /// The type of the X-Ray node.
        public var xRayNodeType: Swift.String?
        /// The X-Ray node request average latency for this node.
        public var xRayRequestAverageLatency: Swift.Int?
        /// The X-Ray request count for this node.
        public var xRayRequestCount: Swift.Int?
        /// The X-Ray request throttle percentage for this node.
        public var xRayThrottlePercent: Swift.Int?

        public init (
            cloudWatchEventDetailType: Swift.String? = nil,
            cloudWatchEventId: Swift.String? = nil,
            cloudWatchEventSource: ApplicationInsightsClientTypes.CloudWatchEventSource? = nil,
            codeDeployApplication: Swift.String? = nil,
            codeDeployDeploymentGroup: Swift.String? = nil,
            codeDeployDeploymentId: Swift.String? = nil,
            codeDeployInstanceGroupId: Swift.String? = nil,
            codeDeployState: Swift.String? = nil,
            ebsCause: Swift.String? = nil,
            ebsEvent: Swift.String? = nil,
            ebsRequestId: Swift.String? = nil,
            ebsResult: Swift.String? = nil,
            ec2State: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            healthEventArn: Swift.String? = nil,
            healthEventDescription: Swift.String? = nil,
            healthEventTypeCategory: Swift.String? = nil,
            healthEventTypeCode: Swift.String? = nil,
            healthService: Swift.String? = nil,
            id: Swift.String? = nil,
            lineTime: ClientRuntime.Date? = nil,
            logFilter: ApplicationInsightsClientTypes.LogFilter? = nil,
            logGroup: Swift.String? = nil,
            logText: Swift.String? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            rdsEventCategories: Swift.String? = nil,
            rdsEventMessage: Swift.String? = nil,
            s3EventName: Swift.String? = nil,
            sourceARN: Swift.String? = nil,
            sourceType: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            statesArn: Swift.String? = nil,
            statesExecutionArn: Swift.String? = nil,
            statesInput: Swift.String? = nil,
            statesStatus: Swift.String? = nil,
            unit: Swift.String? = nil,
            value: Swift.Double? = nil,
            xRayErrorPercent: Swift.Int? = nil,
            xRayFaultPercent: Swift.Int? = nil,
            xRayNodeName: Swift.String? = nil,
            xRayNodeType: Swift.String? = nil,
            xRayRequestAverageLatency: Swift.Int? = nil,
            xRayRequestCount: Swift.Int? = nil,
            xRayThrottlePercent: Swift.Int? = nil
        )
        {
            self.cloudWatchEventDetailType = cloudWatchEventDetailType
            self.cloudWatchEventId = cloudWatchEventId
            self.cloudWatchEventSource = cloudWatchEventSource
            self.codeDeployApplication = codeDeployApplication
            self.codeDeployDeploymentGroup = codeDeployDeploymentGroup
            self.codeDeployDeploymentId = codeDeployDeploymentId
            self.codeDeployInstanceGroupId = codeDeployInstanceGroupId
            self.codeDeployState = codeDeployState
            self.ebsCause = ebsCause
            self.ebsEvent = ebsEvent
            self.ebsRequestId = ebsRequestId
            self.ebsResult = ebsResult
            self.ec2State = ec2State
            self.endTime = endTime
            self.healthEventArn = healthEventArn
            self.healthEventDescription = healthEventDescription
            self.healthEventTypeCategory = healthEventTypeCategory
            self.healthEventTypeCode = healthEventTypeCode
            self.healthService = healthService
            self.id = id
            self.lineTime = lineTime
            self.logFilter = logFilter
            self.logGroup = logGroup
            self.logText = logText
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.rdsEventCategories = rdsEventCategories
            self.rdsEventMessage = rdsEventMessage
            self.s3EventName = s3EventName
            self.sourceARN = sourceARN
            self.sourceType = sourceType
            self.startTime = startTime
            self.statesArn = statesArn
            self.statesExecutionArn = statesExecutionArn
            self.statesInput = statesInput
            self.statesStatus = statesStatus
            self.unit = unit
            self.value = value
            self.xRayErrorPercent = xRayErrorPercent
            self.xRayFaultPercent = xRayFaultPercent
            self.xRayNodeName = xRayNodeName
            self.xRayNodeType = xRayNodeType
            self.xRayRequestAverageLatency = xRayRequestAverageLatency
            self.xRayRequestCount = xRayRequestCount
            self.xRayThrottlePercent = xRayThrottlePercent
        }
    }

}

extension ApplicationInsightsClientTypes {
    public enum OsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OsType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OsType(rawValue: rawValue) ?? OsType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.Problem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affectedResource = "AffectedResource"
        case endTime = "EndTime"
        case feedback = "Feedback"
        case id = "Id"
        case insights = "Insights"
        case lastRecurrenceTime = "LastRecurrenceTime"
        case recurringCount = "RecurringCount"
        case resourceGroupName = "ResourceGroupName"
        case severityLevel = "SeverityLevel"
        case startTime = "StartTime"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affectedResource = self.affectedResource {
            try encodeContainer.encode(affectedResource, forKey: .affectedResource)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let feedback = feedback {
            var feedbackContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .feedback)
            for (dictKey0, feedback0) in feedback {
                try feedbackContainer.encode(feedback0.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insights = self.insights {
            try encodeContainer.encode(insights, forKey: .insights)
        }
        if let lastRecurrenceTime = self.lastRecurrenceTime {
            try encodeContainer.encodeTimestamp(lastRecurrenceTime, format: .epochSeconds, forKey: .lastRecurrenceTime)
        }
        if let recurringCount = self.recurringCount {
            try encodeContainer.encode(recurringCount, forKey: .recurringCount)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let severityLevel = self.severityLevel {
            try encodeContainer.encode(severityLevel.rawValue, forKey: .severityLevel)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let insightsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insights)
        insights = insightsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let affectedResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .affectedResource)
        affectedResource = affectedResourceDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let severityLevelDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.SeverityLevel.self, forKey: .severityLevel)
        severityLevel = severityLevelDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let feedbackContainer = try containerValues.decodeIfPresent([Swift.String: ApplicationInsightsClientTypes.FeedbackValue?].self, forKey: .feedback)
        var feedbackDecoded0: [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]? = nil
        if let feedbackContainer = feedbackContainer {
            feedbackDecoded0 = [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]()
            for (key0, feedbackvalue0) in feedbackContainer {
                if let feedbackvalue0 = feedbackvalue0 {
                    feedbackDecoded0?[key0] = feedbackvalue0
                }
            }
        }
        feedback = feedbackDecoded0
        let recurringCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurringCount)
        recurringCount = recurringCountDecoded
        let lastRecurrenceTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRecurrenceTime)
        lastRecurrenceTime = lastRecurrenceTimeDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes a problem that is detected by correlating observations.
    public struct Problem: Swift.Equatable {
        /// The resource affected by the problem.
        public var affectedResource: Swift.String?
        /// The time when the problem ended, in epoch seconds.
        public var endTime: ClientRuntime.Date?
        /// Feedback provided by the user about the problem.
        public var feedback: [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]?
        /// The ID of the problem.
        public var id: Swift.String?
        /// A detailed analysis of the problem using machine learning.
        public var insights: Swift.String?
        /// The last time that the problem reoccurred after its last resolution.
        public var lastRecurrenceTime: ClientRuntime.Date?
        /// The number of times that the same problem reoccurred after the first time it was resolved.
        public var recurringCount: Swift.Int?
        /// The name of the resource group affected by the problem.
        public var resourceGroupName: Swift.String?
        /// A measure of the level of impact of the problem.
        public var severityLevel: ApplicationInsightsClientTypes.SeverityLevel?
        /// The time when the problem started, in epoch seconds.
        public var startTime: ClientRuntime.Date?
        /// The status of the problem.
        public var status: ApplicationInsightsClientTypes.Status?
        /// The name of the problem.
        public var title: Swift.String?

        public init (
            affectedResource: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            feedback: [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]? = nil,
            id: Swift.String? = nil,
            insights: Swift.String? = nil,
            lastRecurrenceTime: ClientRuntime.Date? = nil,
            recurringCount: Swift.Int? = nil,
            resourceGroupName: Swift.String? = nil,
            severityLevel: ApplicationInsightsClientTypes.SeverityLevel? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ApplicationInsightsClientTypes.Status? = nil,
            title: Swift.String? = nil
        )
        {
            self.affectedResource = affectedResource
            self.endTime = endTime
            self.feedback = feedback
            self.id = id
            self.insights = insights
            self.lastRecurrenceTime = lastRecurrenceTime
            self.recurringCount = recurringCount
            self.resourceGroupName = resourceGroupName
            self.severityLevel = severityLevel
            self.startTime = startTime
            self.status = status
            self.title = title
        }
    }

}

extension ApplicationInsightsClientTypes.RelatedObservations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observationList = "ObservationList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observationList = observationList {
            var observationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .observationList)
            for observation0 in observationList {
                try observationListContainer.encode(observation0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Observation?].self, forKey: .observationList)
        var observationListDecoded0:[ApplicationInsightsClientTypes.Observation]? = nil
        if let observationListContainer = observationListContainer {
            observationListDecoded0 = [ApplicationInsightsClientTypes.Observation]()
            for structure0 in observationListContainer {
                if let structure0 = structure0 {
                    observationListDecoded0?.append(structure0)
                }
            }
        }
        observationList = observationListDecoded0
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes observations related to the problem.
    public struct RelatedObservations: Swift.Equatable {
        /// The list of observations related to the problem.
        public var observationList: [ApplicationInsightsClientTypes.Observation]?

        public init (
            observationList: [ApplicationInsightsClientTypes.Observation]? = nil
        )
        {
            self.observationList = observationList
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is already created or in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource does not exist in the customer account.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum SeverityLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case informative
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityLevel] {
            return [
                .high,
                .informative,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .informative: return "Informative"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SeverityLevel(rawValue: rawValue) ?? SeverityLevel.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ignore
        case pending
        case recurring
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .ignore,
                .pending,
                .recurring,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ignore: return "IGNORE"
            case .pending: return "PENDING"
            case .recurring: return "RECURRING"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// An object that defines the tags associated with an application. A tag is a label that you optionally define and associate with an application. Tags can help you categorize and manage resources in different ways, such as by purpose, owner, environment, or other criteria. Each tag consists of a required tag key and an associated tag value, both of which you define. A tag key is a general label that acts as a category for a more specific tag value. A tag value acts as a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag value can contain as many as 256 characters. The characters can be Unicode letters, digits, white space, or one of the following symbols: _ . : / = + -. The following additional restrictions apply to tags:
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * For each associated resource, each tag key must be unique and it can have only one value.
    ///
    /// * The aws: prefix is reserved for use by AWS; you can’t use it in any tag keys or values that you define. In addition, you can't edit or remove tag keys or values that use this prefix.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that defines a tag. The maximum length of a tag key is 128 characters. The minimum length is 1 character.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that defines a tag. The maximum length of a tag value is 256 characters. The minimum length is 0 characters. If you don't want an application to have a specific tag value, don't specify a value for this parameter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application that you want to add one or more tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags that to add to the application. A tag consists of a required tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    /// This member is required.
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ApplicationInsightsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationInsightsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationInsightsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagsAlreadyExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagsAlreadyExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Tags are already registered for the specified application ARN.
public struct TagsAlreadyExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagsAlreadyExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsAlreadyExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum Tier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectory
        case custom
        case `default`
        case dotNetCore
        case dotNetWeb
        case dotNetWebTier
        case dotNetWorker
        case javaJmx
        case mysql
        case oracle
        case postgresql
        case sapHanaHighAvailability
        case sapHanaMultiNode
        case sapHanaSingleNode
        case sharepoint
        case sqlServer
        case sqlServerAlwaysonAvailabilityGroup
        case sqlServerFailoverClusterInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [Tier] {
            return [
                .activeDirectory,
                .custom,
                .default,
                .dotNetCore,
                .dotNetWeb,
                .dotNetWebTier,
                .dotNetWorker,
                .javaJmx,
                .mysql,
                .oracle,
                .postgresql,
                .sapHanaHighAvailability,
                .sapHanaMultiNode,
                .sapHanaSingleNode,
                .sharepoint,
                .sqlServer,
                .sqlServerAlwaysonAvailabilityGroup,
                .sqlServerFailoverClusterInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case .dotNetCore: return "DOT_NET_CORE"
            case .dotNetWeb: return "DOT_NET_WEB"
            case .dotNetWebTier: return "DOT_NET_WEB_TIER"
            case .dotNetWorker: return "DOT_NET_WORKER"
            case .javaJmx: return "JAVA_JMX"
            case .mysql: return "MYSQL"
            case .oracle: return "ORACLE"
            case .postgresql: return "POSTGRESQL"
            case .sapHanaHighAvailability: return "SAP_HANA_HIGH_AVAILABILITY"
            case .sapHanaMultiNode: return "SAP_HANA_MULTI_NODE"
            case .sapHanaSingleNode: return "SAP_HANA_SINGLE_NODE"
            case .sharepoint: return "SHAREPOINT"
            case .sqlServer: return "SQL_SERVER"
            case .sqlServerAlwaysonAvailabilityGroup: return "SQL_SERVER_ALWAYSON_AVAILABILITY_GROUP"
            case .sqlServerFailoverClusterInstance: return "SQL_SERVER_FAILOVER_CLUSTER_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tier(rawValue: rawValue) ?? Tier.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of the provided tags is beyond the limit, or the number of total tags you are trying to attach to the specified resource exceeds the limit.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The name of the resource with too many tags.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application that you want to remove one or more tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags (tag keys) that you want to remove from the resource. When you specify a tag key, the action removes both that key and its associated tag value. To remove more than one tag from the application, append the TagKeys parameter and argument for each additional tag to remove, separated by an ampersand.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case removeSNSTopic = "RemoveSNSTopic"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let cweMonitorEnabled = self.cweMonitorEnabled {
            try encodeContainer.encode(cweMonitorEnabled, forKey: .cweMonitorEnabled)
        }
        if let opsCenterEnabled = self.opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = self.opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let removeSNSTopic = self.removeSNSTopic {
            try encodeContainer.encode(removeSNSTopic, forKey: .removeSNSTopic)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Turns auto-configuration on or off.
    public var autoConfigEnabled: Swift.Bool?
    /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
    public var cweMonitorEnabled: Swift.Bool?
    /// When set to true, creates opsItems for any problems detected on an application.
    public var opsCenterEnabled: Swift.Bool?
    /// The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
    public var opsItemSNSTopicArn: Swift.String?
    /// Disassociates the SNS topic from the opsItem created for detected problems.
    public var removeSNSTopic: Swift.Bool?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        autoConfigEnabled: Swift.Bool? = nil,
        cweMonitorEnabled: Swift.Bool? = nil,
        opsCenterEnabled: Swift.Bool? = nil,
        opsItemSNSTopicArn: Swift.String? = nil,
        removeSNSTopic: Swift.Bool? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.cweMonitorEnabled = cweMonitorEnabled
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.removeSNSTopic = removeSNSTopic
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let opsCenterEnabled: Swift.Bool?
    let cweMonitorEnabled: Swift.Bool?
    let opsItemSNSTopicArn: Swift.String?
    let removeSNSTopic: Swift.Bool?
    let autoConfigEnabled: Swift.Bool?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case removeSNSTopic = "RemoveSNSTopic"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cweMonitorEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cweMonitorEnabled)
        cweMonitorEnabled = cweMonitorEnabledDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let removeSNSTopicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeSNSTopic)
        removeSNSTopic = removeSNSTopicDecoded
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init (
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    let applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

extension UpdateComponentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case componentConfiguration = "ComponentConfiguration"
        case componentName = "ComponentName"
        case monitor = "Monitor"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let componentConfiguration = self.componentConfiguration {
            try encodeContainer.encode(componentConfiguration, forKey: .componentConfiguration)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let monitor = self.monitor {
            try encodeContainer.encode(monitor, forKey: .monitor)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension UpdateComponentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateComponentConfigurationInput: Swift.Equatable {
    /// Automatically configures the component by applying the recommended configurations.
    public var autoConfigEnabled: Swift.Bool?
    /// The configuration settings of the component. The value is the escaped JSON of the configuration. For more information about the JSON format, see [Working with JSON](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/working-with-json.html). You can send a request to DescribeComponentConfigurationRecommendation to see the recommended configuration for a component. For the complete format of the component configuration file, see [Component Configuration](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/component-config.html).
    public var componentConfiguration: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// Indicates whether the application component is monitored.
    public var monitor: Swift.Bool?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The tier of the application component.
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init (
        autoConfigEnabled: Swift.Bool? = nil,
        componentConfiguration: Swift.String? = nil,
        componentName: Swift.String? = nil,
        monitor: Swift.Bool? = nil,
        resourceGroupName: Swift.String? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.componentConfiguration = componentConfiguration
        self.componentName = componentName
        self.monitor = monitor
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

struct UpdateComponentConfigurationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let monitor: Swift.Bool?
    let tier: ApplicationInsightsClientTypes.Tier?
    let componentConfiguration: Swift.String?
    let autoConfigEnabled: Swift.Bool?
}

extension UpdateComponentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case componentConfiguration = "ComponentConfiguration"
        case componentName = "ComponentName"
        case monitor = "Monitor"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let monitorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
    }
}

extension UpdateComponentConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateComponentConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateComponentConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case newComponentName = "NewComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let newComponentName = self.newComponentName {
            try encodeContainer.encode(newComponentName, forKey: .newComponentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceList = resourceList {
            var resourceListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceList)
            for resourcearn0 in resourceList {
                try resourceListContainer.encode(resourcearn0)
            }
        }
    }
}

extension UpdateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The new name of the component.
    public var newComponentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The list of resource ARNs that belong to the component.
    public var resourceList: [Swift.String]?

    public init (
        componentName: Swift.String? = nil,
        newComponentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.componentName = componentName
        self.newComponentName = newComponentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

struct UpdateComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let newComponentName: Swift.String?
    let resourceList: [Swift.String]?
}

extension UpdateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case newComponentName = "NewComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let newComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newComponentName)
        newComponentName = newComponentNameDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceList)
        var resourceListDecoded0:[Swift.String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [Swift.String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension UpdateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateComponentOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension UpdateLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLogPatternInput: Swift.Equatable {
    /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
    public var pattern: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
    public var rank: Swift.Int
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init (
        pattern: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        rank: Swift.Int = 0,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
    let pattern: Swift.String?
    let rank: Swift.Int
}

extension UpdateLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank) ?? 0
        rank = rankDecoded
    }
}

extension UpdateLogPatternOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLogPatternOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLogPatternOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLogPatternOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLogPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct UpdateLogPatternOutputResponse: Swift.Equatable {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init (
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateLogPatternOutputResponseBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let logPattern: ApplicationInsightsClientTypes.LogPattern?
}

extension UpdateLogPatternOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
