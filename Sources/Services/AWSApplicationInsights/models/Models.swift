// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadConfiguration = "WorkloadConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let workloadConfiguration = self.workloadConfiguration {
            try encodeContainer.encode(workloadConfiguration, forKey: .workloadConfiguration)
        }
    }
}

extension AddWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddWorkloadInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    /// This member is required.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadConfiguration = workloadConfiguration
    }
}

struct AddWorkloadInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
}

extension AddWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadConfiguration = "WorkloadConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let workloadConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.WorkloadConfiguration.self, forKey: .workloadConfiguration)
        workloadConfiguration = workloadConfigurationDecoded
    }
}

extension AddWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workloadConfiguration = output.workloadConfiguration
            self.workloadId = output.workloadId
        } else {
            self.workloadConfiguration = nil
            self.workloadId = nil
        }
    }
}

public struct AddWorkloadOutput: Swift.Equatable {
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?

    public init(
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
    }
}

struct AddWorkloadOutputBody: Swift.Equatable {
    let workloadId: Swift.String?
    let workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
}

extension AddWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadConfiguration = "WorkloadConfiguration"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.WorkloadConfiguration.self, forKey: .workloadConfiguration)
        workloadConfiguration = workloadConfigurationDecoded
    }
}

enum AddWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationInsightsClientTypes.ApplicationComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case componentRemarks = "ComponentRemarks"
        case detectedWorkload = "DetectedWorkload"
        case monitor = "Monitor"
        case osType = "OsType"
        case resourceType = "ResourceType"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentRemarks = self.componentRemarks {
            try encodeContainer.encode(componentRemarks, forKey: .componentRemarks)
        }
        if let detectedWorkload = detectedWorkload {
            var detectedWorkloadContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .detectedWorkload)
            for (dictKey0, detectedWorkload0) in detectedWorkload {
                var detectedWorkload0Container = detectedWorkloadContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, workloadMetaData1) in detectedWorkload0 {
                    try detectedWorkload0Container.encode(workloadMetaData1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let monitor = self.monitor {
            try encodeContainer.encode(monitor, forKey: .monitor)
        }
        if let osType = self.osType {
            try encodeContainer.encode(osType.rawValue, forKey: .osType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentRemarksDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRemarks)
        componentRemarks = componentRemarksDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let osTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.OsType.self, forKey: .osType)
        osType = osTypeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let monitorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let detectedWorkloadContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .detectedWorkload)
        var detectedWorkloadDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let detectedWorkloadContainer = detectedWorkloadContainer {
            detectedWorkloadDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, workloadmetadata0) in detectedWorkloadContainer {
                var workloadmetadata0Decoded0: [Swift.String: Swift.String]? = nil
                if let workloadmetadata0 = workloadmetadata0 {
                    workloadmetadata0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, metadatavalue1) in workloadmetadata0 {
                        if let metadatavalue1 = metadatavalue1 {
                            workloadmetadata0Decoded0?[key1] = metadatavalue1
                        }
                    }
                }
                detectedWorkloadDecoded0?[key0] = workloadmetadata0Decoded0
            }
        }
        detectedWorkload = detectedWorkloadDecoded0
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes a standalone resource or similarly grouped resources that the application is made up of.
    public struct ApplicationComponent: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// If logging is supported for the resource type, indicates whether the component has configured logs to be monitored.
        public var componentRemarks: Swift.String?
        /// Workloads detected in the application component.
        public var detectedWorkload: [Swift.String:[Swift.String:Swift.String]]?
        /// Indicates whether the application component is monitored.
        public var monitor: Swift.Bool?
        /// The operating system of the component.
        public var osType: ApplicationInsightsClientTypes.OsType?
        /// The resource type. Supported resource types include EC2 instances, Auto Scaling group, Classic ELB, Application ELB, and SQS Queue.
        public var resourceType: Swift.String?
        /// The stack tier of the application component.
        public var tier: ApplicationInsightsClientTypes.Tier?

        public init(
            componentName: Swift.String? = nil,
            componentRemarks: Swift.String? = nil,
            detectedWorkload: [Swift.String:[Swift.String:Swift.String]]? = nil,
            monitor: Swift.Bool? = nil,
            osType: ApplicationInsightsClientTypes.OsType? = nil,
            resourceType: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil
        )
        {
            self.componentName = componentName
            self.componentRemarks = componentRemarks
            self.detectedWorkload = detectedWorkload
            self.monitor = monitor
            self.osType = osType
            self.resourceType = resourceType
            self.tier = tier
        }
    }

}

extension ApplicationInsightsClientTypes.ApplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case autoConfigEnabled = "AutoConfigEnabled"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case discoveryType = "DiscoveryType"
        case lifeCycle = "LifeCycle"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case remarks = "Remarks"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let cweMonitorEnabled = self.cweMonitorEnabled {
            try encodeContainer.encode(cweMonitorEnabled, forKey: .cweMonitorEnabled)
        }
        if let discoveryType = self.discoveryType {
            try encodeContainer.encode(discoveryType.rawValue, forKey: .discoveryType)
        }
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let opsCenterEnabled = self.opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = self.opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let remarks = self.remarks {
            try encodeContainer.encode(remarks, forKey: .remarks)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cweMonitorEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cweMonitorEnabled)
        cweMonitorEnabled = cweMonitorEnabledDecoded
        let remarksDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remarks)
        remarks = remarksDecoded
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
        let discoveryTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.DiscoveryType.self, forKey: .discoveryType)
        discoveryType = discoveryTypeDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes the status of the application.
    public struct ApplicationInfo: Swift.Equatable {
        /// The AWS account ID for the owner of the application.
        public var accountId: Swift.String?
        /// Indicates whether auto-configuration is turned on for this application.
        public var autoConfigEnabled: Swift.Bool?
        /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
        public var cweMonitorEnabled: Swift.Bool?
        /// The method used by Application Insights to onboard your resources.
        public var discoveryType: ApplicationInsightsClientTypes.DiscoveryType?
        /// The lifecycle of the application.
        public var lifeCycle: Swift.String?
        /// Indicates whether Application Insights will create opsItems for any problem detected by Application Insights for an application.
        public var opsCenterEnabled: Swift.Bool?
        /// The SNS topic provided to Application Insights that is associated to the created opsItems to receive SNS notifications for opsItem updates.
        public var opsItemSNSTopicArn: Swift.String?
        /// The issues on the user side that block Application Insights from successfully monitoring an application. Example remarks include:
        ///
        /// * “Configuring application, detected 1 Errors, 3 Warnings”
        ///
        /// * “Configuring application, detected 1 Unconfigured Components”
        public var remarks: Swift.String?
        /// The name of the resource group used for the application.
        public var resourceGroupName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            autoConfigEnabled: Swift.Bool? = nil,
            cweMonitorEnabled: Swift.Bool? = nil,
            discoveryType: ApplicationInsightsClientTypes.DiscoveryType? = nil,
            lifeCycle: Swift.String? = nil,
            opsCenterEnabled: Swift.Bool? = nil,
            opsItemSNSTopicArn: Swift.String? = nil,
            remarks: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.autoConfigEnabled = autoConfigEnabled
            self.cweMonitorEnabled = cweMonitorEnabled
            self.discoveryType = discoveryType
            self.lifeCycle = lifeCycle
            self.opsCenterEnabled = opsCenterEnabled
            self.opsItemSNSTopicArn = opsItemSNSTopicArn
            self.remarks = remarks
            self.resourceGroupName = resourceGroupName
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not understood by the server.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum CloudWatchEventSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codeDeploy
        case ec2
        case health
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchEventSource] {
            return [
                .codeDeploy,
                .ec2,
                .health,
                .rds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codeDeploy: return "CODE_DEPLOY"
            case .ec2: return "EC2"
            case .health: return "HEALTH"
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchEventSource(rawValue: rawValue) ?? CloudWatchEventSource.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.ConfigurationEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case eventDetail = "EventDetail"
        case eventResourceName = "EventResourceName"
        case eventResourceType = "EventResourceType"
        case eventStatus = "EventStatus"
        case eventTime = "EventTime"
        case monitoredResourceARN = "MonitoredResourceARN"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let eventDetail = self.eventDetail {
            try encodeContainer.encode(eventDetail, forKey: .eventDetail)
        }
        if let eventResourceName = self.eventResourceName {
            try encodeContainer.encode(eventResourceName, forKey: .eventResourceName)
        }
        if let eventResourceType = self.eventResourceType {
            try encodeContainer.encode(eventResourceType.rawValue, forKey: .eventResourceType)
        }
        if let eventStatus = self.eventStatus {
            try encodeContainer.encode(eventStatus.rawValue, forKey: .eventStatus)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let monitoredResourceARN = self.monitoredResourceARN {
            try encodeContainer.encode(monitoredResourceARN, forKey: .monitoredResourceARN)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let monitoredResourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoredResourceARN)
        monitoredResourceARN = monitoredResourceARNDecoded
        let eventStatusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ConfigurationEventStatus.self, forKey: .eventStatus)
        eventStatus = eventStatusDecoded
        let eventResourceTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ConfigurationEventResourceType.self, forKey: .eventResourceType)
        eventResourceType = eventResourceTypeDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDetail)
        eventDetail = eventDetailDecoded
        let eventResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventResourceName)
        eventResourceName = eventResourceNameDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// The event information.
    public struct ConfigurationEvent: Swift.Equatable {
        /// The AWS account ID for the owner of the application to which the configuration event belongs.
        public var accountId: Swift.String?
        /// The details of the event in plain text.
        public var eventDetail: Swift.String?
        /// The name of the resource Application Insights attempted to configure.
        public var eventResourceName: Swift.String?
        /// The resource type that Application Insights attempted to configure, for example, CLOUDWATCH_ALARM.
        public var eventResourceType: ApplicationInsightsClientTypes.ConfigurationEventResourceType?
        /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
        public var eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
        /// The timestamp of the event.
        public var eventTime: ClientRuntime.Date?
        /// The resource monitored by Application Insights.
        public var monitoredResourceARN: Swift.String?
        /// The name of the resource group of the application to which the configuration event belongs.
        public var resourceGroupName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            eventDetail: Swift.String? = nil,
            eventResourceName: Swift.String? = nil,
            eventResourceType: ApplicationInsightsClientTypes.ConfigurationEventResourceType? = nil,
            eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus? = nil,
            eventTime: ClientRuntime.Date? = nil,
            monitoredResourceARN: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.eventDetail = eventDetail
            self.eventResourceName = eventResourceName
            self.eventResourceType = eventResourceType
            self.eventStatus = eventStatus
            self.eventTime = eventTime
            self.monitoredResourceARN = monitoredResourceARN
            self.resourceGroupName = resourceGroupName
        }
    }

}

extension ApplicationInsightsClientTypes {
    public enum ConfigurationEventResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudformation
        case cloudwatchAlarm
        case cloudwatchLog
        case ssmAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationEventResourceType] {
            return [
                .cloudformation,
                .cloudwatchAlarm,
                .cloudwatchLog,
                .ssmAssociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
            case .cloudwatchLog: return "CLOUDWATCH_LOG"
            case .ssmAssociation: return "SSM_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationEventResourceType(rawValue: rawValue) ?? ConfigurationEventResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum ConfigurationEventStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationEventStatus] {
            return [
                .error,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationEventStatus(rawValue: rawValue) ?? ConfigurationEventStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case autoCreate = "AutoCreate"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case groupingType = "GroupingType"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case resourceGroupName = "ResourceGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let autoCreate = self.autoCreate {
            try encodeContainer.encode(autoCreate, forKey: .autoCreate)
        }
        if let cweMonitorEnabled = self.cweMonitorEnabled {
            try encodeContainer.encode(cweMonitorEnabled, forKey: .cweMonitorEnabled)
        }
        if let groupingType = self.groupingType {
            try encodeContainer.encode(groupingType.rawValue, forKey: .groupingType)
        }
        if let opsCenterEnabled = self.opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = self.opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Indicates whether Application Insights automatically configures unmonitored resources in the resource group.
    public var autoConfigEnabled: Swift.Bool?
    /// Configures all of the resources in the resource group by applying the recommended configurations.
    public var autoCreate: Swift.Bool?
    /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
    public var cweMonitorEnabled: Swift.Bool?
    /// Application Insights can create applications based on a resource group or on an account. To create an account-based application using all of the resources in the account, set this parameter to ACCOUNT_BASED.
    public var groupingType: ApplicationInsightsClientTypes.GroupingType?
    /// When set to true, creates opsItems for any problems detected on an application.
    public var opsCenterEnabled: Swift.Bool?
    /// The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
    public var opsItemSNSTopicArn: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?
    /// List of tags to add to the application. tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init(
        autoConfigEnabled: Swift.Bool? = nil,
        autoCreate: Swift.Bool? = nil,
        cweMonitorEnabled: Swift.Bool? = nil,
        groupingType: ApplicationInsightsClientTypes.GroupingType? = nil,
        opsCenterEnabled: Swift.Bool? = nil,
        opsItemSNSTopicArn: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.autoCreate = autoCreate
        self.cweMonitorEnabled = cweMonitorEnabled
        self.groupingType = groupingType
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.resourceGroupName = resourceGroupName
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let opsCenterEnabled: Swift.Bool?
    let cweMonitorEnabled: Swift.Bool?
    let opsItemSNSTopicArn: Swift.String?
    let tags: [ApplicationInsightsClientTypes.Tag]?
    let autoConfigEnabled: Swift.Bool?
    let autoCreate: Swift.Bool?
    let groupingType: ApplicationInsightsClientTypes.GroupingType?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case autoCreate = "AutoCreate"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case groupingType = "GroupingType"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case resourceGroupName = "ResourceGroupName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cweMonitorEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cweMonitorEnabled)
        cweMonitorEnabled = cweMonitorEnabledDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationInsightsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationInsightsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
        let autoCreateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCreate)
        autoCreate = autoCreateDecoded
        let groupingTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.GroupingType.self, forKey: .groupingType)
        groupingType = groupingTypeDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init(
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsAlreadyExistException": return try await TagsAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceList = resourceList {
            var resourceListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceList)
            for resourcearn0 in resourceList {
                try resourceListContainer.encode(resourcearn0)
            }
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The list of resource ARNs that belong to the component.
    /// This member is required.
    public var resourceList: [Swift.String]?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let resourceList: [Swift.String]?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceList)
        var resourceListDecoded0:[Swift.String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [Swift.String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension CreateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateComponentOutput: Swift.Equatable {

    public init() { }
}

enum CreateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let rank = self.rank {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension CreateLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLogPatternInput: Swift.Equatable {
    /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
    /// This member is required.
    public var pattern: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
    /// This member is required.
    public var rank: Swift.Int?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        pattern: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        rank: Swift.Int? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

struct CreateLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
    let pattern: Swift.String?
    let rank: Swift.Int?
}

extension CreateLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension CreateLogPatternOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLogPatternOutputBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct CreateLogPatternOutput: Swift.Equatable {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct CreateLogPatternOutputBody: Swift.Equatable {
    let logPattern: ApplicationInsightsClientTypes.LogPattern?
    let resourceGroupName: Swift.String?
}

extension CreateLogPatternOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logPatternDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

enum CreateLogPatternOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        resourceGroupName: Swift.String? = nil
    )
    {
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
}

extension DeleteComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DeleteComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteComponentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DeleteLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLogPatternInput: Swift.Equatable {
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
}

extension DeleteLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
    }
}

extension DeleteLogPatternOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLogPatternOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLogPatternOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let accountId: Swift.String?
}

extension DescribeApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct DescribeApplicationOutput: Swift.Equatable {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init(
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct DescribeApplicationOutputBody: Swift.Equatable {
    let applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?
}

extension DescribeApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

enum DescribeApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeComponentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeComponentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeComponentConfigurationInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeComponentConfigurationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let accountId: Swift.String?
}

extension DescribeComponentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeComponentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeComponentConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentConfiguration = output.componentConfiguration
            self.monitor = output.monitor
            self.tier = output.tier
        } else {
            self.componentConfiguration = nil
            self.monitor = nil
            self.tier = nil
        }
    }
}

public struct DescribeComponentConfigurationOutput: Swift.Equatable {
    /// The configuration settings of the component. The value is the escaped JSON of the configuration.
    public var componentConfiguration: Swift.String?
    /// Indicates whether the application component is monitored.
    public var monitor: Swift.Bool?
    /// The tier of the application component. Supported tiers include DOT_NET_CORE, DOT_NET_WORKER, DOT_NET_WEB, SQL_SERVER, and DEFAULT
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init(
        componentConfiguration: Swift.String? = nil,
        monitor: Swift.Bool? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
        self.monitor = monitor
        self.tier = tier
    }
}

struct DescribeComponentConfigurationOutputBody: Swift.Equatable {
    let monitor: Swift.Bool?
    let tier: ApplicationInsightsClientTypes.Tier?
    let componentConfiguration: Swift.String?
}

extension DescribeComponentConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentConfiguration = "ComponentConfiguration"
        case monitor = "Monitor"
        case tier = "Tier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

enum DescribeComponentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeComponentConfigurationRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case recommendationType = "RecommendationType"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let recommendationType = self.recommendationType {
            try encodeContainer.encode(recommendationType.rawValue, forKey: .recommendationType)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension DescribeComponentConfigurationRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeComponentConfigurationRecommendationInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The recommended configuration type.
    public var recommendationType: ApplicationInsightsClientTypes.RecommendationType?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The tier of the application component.
    /// This member is required.
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init(
        componentName: Swift.String? = nil,
        recommendationType: ApplicationInsightsClientTypes.RecommendationType? = nil,
        resourceGroupName: Swift.String? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.componentName = componentName
        self.recommendationType = recommendationType
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

struct DescribeComponentConfigurationRecommendationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let tier: ApplicationInsightsClientTypes.Tier?
    let recommendationType: ApplicationInsightsClientTypes.RecommendationType?
}

extension DescribeComponentConfigurationRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case recommendationType = "RecommendationType"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let recommendationTypeDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.RecommendationType.self, forKey: .recommendationType)
        recommendationType = recommendationTypeDecoded
    }
}

extension DescribeComponentConfigurationRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeComponentConfigurationRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentConfiguration = output.componentConfiguration
        } else {
            self.componentConfiguration = nil
        }
    }
}

public struct DescribeComponentConfigurationRecommendationOutput: Swift.Equatable {
    /// The recommended configuration settings of the component. The value is the escaped JSON of the configuration.
    public var componentConfiguration: Swift.String?

    public init(
        componentConfiguration: Swift.String? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
    }
}

struct DescribeComponentConfigurationRecommendationOutputBody: Swift.Equatable {
    let componentConfiguration: Swift.String?
}

extension DescribeComponentConfigurationRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentConfiguration = "ComponentConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

enum DescribeComponentConfigurationRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeComponentInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let accountId: Swift.String?
}

extension DescribeComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponent = output.applicationComponent
            self.resourceList = output.resourceList
        } else {
            self.applicationComponent = nil
            self.resourceList = nil
        }
    }
}

public struct DescribeComponentOutput: Swift.Equatable {
    /// Describes a standalone resource or similarly grouped resources that the application is made up of.
    public var applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent?
    /// The list of resource ARNs that belong to the component.
    public var resourceList: [Swift.String]?

    public init(
        applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.applicationComponent = applicationComponent
        self.resourceList = resourceList
    }
}

struct DescribeComponentOutputBody: Swift.Equatable {
    let applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent?
    let resourceList: [Swift.String]?
}

extension DescribeComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponent = "ApplicationComponent"
        case resourceList = "ResourceList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationComponent.self, forKey: .applicationComponent)
        applicationComponent = applicationComponentDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceList)
        var resourceListDecoded0:[Swift.String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [Swift.String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

enum DescribeComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension DescribeLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLogPatternInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
    let accountId: Swift.String?
}

extension DescribeLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeLogPatternOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLogPatternOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.accountId = nil
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct DescribeLogPatternOutput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeLogPatternOutputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let accountId: Swift.String?
    let logPattern: ApplicationInsightsClientTypes.LogPattern?
}

extension DescribeLogPatternOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let logPatternDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
    }
}

enum DescribeLogPatternOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeObservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case observationId = "ObservationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let observationId = self.observationId {
            try encodeContainer.encode(observationId, forKey: .observationId)
        }
    }
}

extension DescribeObservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeObservationInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The ID of the observation.
    /// This member is required.
    public var observationId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        observationId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.observationId = observationId
    }
}

struct DescribeObservationInputBody: Swift.Equatable {
    let observationId: Swift.String?
    let accountId: Swift.String?
}

extension DescribeObservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case observationId = "ObservationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observationId)
        observationId = observationIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeObservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeObservationOutputBody = try responseDecoder.decode(responseBody: data)
            self.observation = output.observation
        } else {
            self.observation = nil
        }
    }
}

public struct DescribeObservationOutput: Swift.Equatable {
    /// Information about the observation.
    public var observation: ApplicationInsightsClientTypes.Observation?

    public init(
        observation: ApplicationInsightsClientTypes.Observation? = nil
    )
    {
        self.observation = observation
    }
}

struct DescribeObservationOutputBody: Swift.Equatable {
    let observation: ApplicationInsightsClientTypes.Observation?
}

extension DescribeObservationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observation = "Observation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Observation.self, forKey: .observation)
        observation = observationDecoded
    }
}

enum DescribeObservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProblemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case problemId = "ProblemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let problemId = self.problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
    }
}

extension DescribeProblemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProblemInput: Swift.Equatable {
    /// The AWS account ID for the owner of the resource group affected by the problem.
    public var accountId: Swift.String?
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        problemId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.problemId = problemId
    }
}

struct DescribeProblemInputBody: Swift.Equatable {
    let problemId: Swift.String?
    let accountId: Swift.String?
}

extension DescribeProblemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case problemId = "ProblemId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .problemId)
        problemId = problemIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeProblemObservationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case problemId = "ProblemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let problemId = self.problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
    }
}

extension DescribeProblemObservationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProblemObservationsInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        problemId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.problemId = problemId
    }
}

struct DescribeProblemObservationsInputBody: Swift.Equatable {
    let problemId: Swift.String?
    let accountId: Swift.String?
}

extension DescribeProblemObservationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case problemId = "ProblemId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .problemId)
        problemId = problemIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeProblemObservationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProblemObservationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.relatedObservations = output.relatedObservations
        } else {
            self.relatedObservations = nil
        }
    }
}

public struct DescribeProblemObservationsOutput: Swift.Equatable {
    /// Observations related to the problem.
    public var relatedObservations: ApplicationInsightsClientTypes.RelatedObservations?

    public init(
        relatedObservations: ApplicationInsightsClientTypes.RelatedObservations? = nil
    )
    {
        self.relatedObservations = relatedObservations
    }
}

struct DescribeProblemObservationsOutputBody: Swift.Equatable {
    let relatedObservations: ApplicationInsightsClientTypes.RelatedObservations?
}

extension DescribeProblemObservationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relatedObservations = "RelatedObservations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedObservationsDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.RelatedObservations.self, forKey: .relatedObservations)
        relatedObservations = relatedObservationsDecoded
    }
}

enum DescribeProblemObservationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProblemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProblemOutputBody = try responseDecoder.decode(responseBody: data)
            self.problem = output.problem
        } else {
            self.problem = nil
        }
    }
}

public struct DescribeProblemOutput: Swift.Equatable {
    /// Information about the problem.
    public var problem: ApplicationInsightsClientTypes.Problem?

    public init(
        problem: ApplicationInsightsClientTypes.Problem? = nil
    )
    {
        self.problem = problem
    }
}

struct DescribeProblemOutputBody: Swift.Equatable {
    let problem: ApplicationInsightsClientTypes.Problem?
}

extension DescribeProblemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problem = "Problem"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Problem.self, forKey: .problem)
        problem = problemDecoded
    }
}

enum DescribeProblemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

extension DescribeWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkloadInput: Swift.Equatable {
    /// The AWS account ID for the workload owner.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The ID of the workload.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadId = workloadId
    }
}

struct DescribeWorkloadInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let workloadId: Swift.String?
    let accountId: Swift.String?
}

extension DescribeWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DescribeWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workloadConfiguration = output.workloadConfiguration
            self.workloadId = output.workloadId
            self.workloadRemarks = output.workloadRemarks
        } else {
            self.workloadConfiguration = nil
            self.workloadId = nil
            self.workloadRemarks = nil
        }
    }
}

public struct DescribeWorkloadOutput: Swift.Equatable {
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?
    /// If logging is supported for the resource type, shows whether the component has configured logs to be monitored.
    public var workloadRemarks: Swift.String?

    public init(
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil,
        workloadRemarks: Swift.String? = nil
    )
    {
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
        self.workloadRemarks = workloadRemarks
    }
}

struct DescribeWorkloadOutputBody: Swift.Equatable {
    let workloadId: Swift.String?
    let workloadRemarks: Swift.String?
    let workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
}

extension DescribeWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadConfiguration = "WorkloadConfiguration"
        case workloadId = "WorkloadId"
        case workloadRemarks = "WorkloadRemarks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadRemarksDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadRemarks)
        workloadRemarks = workloadRemarksDecoded
        let workloadConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.WorkloadConfiguration.self, forKey: .workloadConfiguration)
        workloadConfiguration = workloadConfigurationDecoded
    }
}

enum DescribeWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum DiscoveryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountBased
        case resourceGroupBased
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryType] {
            return [
                .accountBased,
                .resourceGroupBased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountBased: return "ACCOUNT_BASED"
            case .resourceGroupBased: return "RESOURCE_GROUP_BASED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiscoveryType(rawValue: rawValue) ?? DiscoveryType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum FeedbackKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insightsFeedback
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackKey] {
            return [
                .insightsFeedback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insightsFeedback: return "INSIGHTS_FEEDBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeedbackKey(rawValue: rawValue) ?? FeedbackKey.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum FeedbackValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notSpecified
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackValue] {
            return [
                .notSpecified,
                .notUseful,
                .useful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notSpecified: return "NOT_SPECIFIED"
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeedbackValue(rawValue: rawValue) ?? FeedbackValue.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum GroupingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountBased
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupingType] {
            return [
                .accountBased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountBased: return "ACCOUNT_BASED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupingType(rawValue: rawValue) ?? GroupingType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfoList = output.applicationInfoList
            self.nextToken = output.nextToken
        } else {
            self.applicationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// The list of applications.
    public var applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInfoList = applicationInfoList
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfoList = "ApplicationInfoList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.ApplicationInfo?].self, forKey: .applicationInfoList)
        var applicationInfoListDecoded0:[ApplicationInsightsClientTypes.ApplicationInfo]? = nil
        if let applicationInfoListContainer = applicationInfoListContainer {
            applicationInfoListDecoded0 = [ApplicationInsightsClientTypes.ApplicationInfo]()
            for structure0 in applicationInfoListContainer {
                if let structure0 = structure0 {
                    applicationInfoListDecoded0?.append(structure0)
                }
            }
        }
        applicationInfoList = applicationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentList = output.applicationComponentList
            self.nextToken = output.nextToken
        } else {
            self.applicationComponentList = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// The list of application components.
    public var applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationComponentList = applicationComponentList
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentList = "ApplicationComponentList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.ApplicationComponent?].self, forKey: .applicationComponentList)
        var applicationComponentListDecoded0:[ApplicationInsightsClientTypes.ApplicationComponent]? = nil
        if let applicationComponentListContainer = applicationComponentListContainer {
            applicationComponentListDecoded0 = [ApplicationInsightsClientTypes.ApplicationComponent]()
            for structure0 in applicationComponentListContainer {
                if let structure0 = structure0 {
                    applicationComponentListDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentList = applicationComponentListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfigurationHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case endTime = "EndTime"
        case eventStatus = "EventStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventStatus = self.eventStatus {
            try encodeContainer.encode(eventStatus.rawValue, forKey: .eventStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListConfigurationHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConfigurationHistoryInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The end time of the event.
    public var endTime: ClientRuntime.Date?
    /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
    public var eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
    /// The maximum number of results returned by ListConfigurationHistory in paginated output. When this parameter is used, ListConfigurationHistory returns only MaxResults in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another ListConfigurationHistory request with the returned NextToken value. If this parameter is not used, then ListConfigurationHistory returns all results.
    public var maxResults: Swift.Int?
    /// The NextToken value returned from a previous paginated ListConfigurationHistory request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Resource group to which the application belongs.
    public var resourceGroupName: Swift.String?
    /// The start time of the event.
    public var startTime: ClientRuntime.Date?

    public init(
        accountId: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.accountId = accountId
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
    }
}

struct ListConfigurationHistoryInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListConfigurationHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case endTime = "EndTime"
        case eventStatus = "EventStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let eventStatusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ConfigurationEventStatus.self, forKey: .eventStatus)
        eventStatus = eventStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListConfigurationHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventList = output.eventList
            self.nextToken = output.nextToken
        } else {
            self.eventList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationHistoryOutput: Swift.Equatable {
    /// The list of configuration events and their corresponding details.
    public var eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]?
    /// The NextToken value to include in a future ListConfigurationHistory request. When the results of a ListConfigurationHistory request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventList = eventList
        self.nextToken = nextToken
    }
}

struct ListConfigurationHistoryOutputBody: Swift.Equatable {
    let eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]?
    let nextToken: Swift.String?
}

extension ListConfigurationHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventList = "EventList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.ConfigurationEvent?].self, forKey: .eventList)
        var eventListDecoded0:[ApplicationInsightsClientTypes.ConfigurationEvent]? = nil
        if let eventListContainer = eventListContainer {
            eventListDecoded0 = [ApplicationInsightsClientTypes.ConfigurationEvent]()
            for structure0 in eventListContainer {
                if let structure0 = structure0 {
                    eventListDecoded0?.append(structure0)
                }
            }
        }
        eventList = eventListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfigurationHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLogPatternSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListLogPatternSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLogPatternSetsInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternSetsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListLogPatternSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListLogPatternSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLogPatternSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.logPatternSets = output.logPatternSets
            self.nextToken = output.nextToken
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.accountId = nil
            self.logPatternSets = nil
            self.nextToken = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListLogPatternSetsOutput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The list of log pattern sets.
    public var logPatternSets: [Swift.String]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        logPatternSets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.logPatternSets = logPatternSets
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternSetsOutputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let accountId: Swift.String?
    let logPatternSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListLogPatternSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case logPatternSets = "LogPatternSets"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let logPatternSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logPatternSets)
        var logPatternSetsDecoded0:[Swift.String]? = nil
        if let logPatternSetsContainer = logPatternSetsContainer {
            logPatternSetsDecoded0 = [Swift.String]()
            for string0 in logPatternSetsContainer {
                if let string0 = string0 {
                    logPatternSetsDecoded0?.append(string0)
                }
            }
        }
        logPatternSets = logPatternSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLogPatternSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLogPatternsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListLogPatternsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLogPatternsInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the log pattern set.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListLogPatternsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListLogPatternsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLogPatternsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.logPatterns = output.logPatterns
            self.nextToken = output.nextToken
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.accountId = nil
            self.logPatterns = nil
            self.nextToken = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListLogPatternsOutput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The list of log patterns.
    public var logPatterns: [ApplicationInsightsClientTypes.LogPattern]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        logPatterns: [ApplicationInsightsClientTypes.LogPattern]? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.logPatterns = logPatterns
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternsOutputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let accountId: Swift.String?
    let logPatterns: [ApplicationInsightsClientTypes.LogPattern]?
    let nextToken: Swift.String?
}

extension ListLogPatternsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case logPatterns = "LogPatterns"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let logPatternsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.LogPattern?].self, forKey: .logPatterns)
        var logPatternsDecoded0:[ApplicationInsightsClientTypes.LogPattern]? = nil
        if let logPatternsContainer = logPatternsContainer {
            logPatternsDecoded0 = [ApplicationInsightsClientTypes.LogPattern]()
            for structure0 in logPatternsContainer {
                if let structure0 = structure0 {
                    logPatternsDecoded0?.append(structure0)
                }
            }
        }
        logPatterns = logPatternsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLogPatternsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProblemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }
}

extension ListProblemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProblemsInput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the component.
    public var componentName: Swift.String?
    /// The time when the problem ended, in epoch seconds. If not specified, problems within the past seven days are returned.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?
    /// The time when the problem was detected, in epoch seconds. If you don't specify a time frame for the request, problems within the past seven days are returned.
    public var startTime: ClientRuntime.Date?
    /// Specifies whether or not you can view the problem. If not specified, visible and ignored problems are returned.
    public var visibility: ApplicationInsightsClientTypes.Visibility?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        visibility: ApplicationInsightsClientTypes.Visibility? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
        self.visibility = visibility
    }
}

struct ListProblemsInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let resourceGroupName: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let componentName: Swift.String?
    let visibility: ApplicationInsightsClientTypes.Visibility?
}

extension ListProblemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
        case visibility = "Visibility"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension ListProblemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProblemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.nextToken = output.nextToken
            self.problemList = output.problemList
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.accountId = nil
            self.nextToken = nil
            self.problemList = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListProblemsOutput: Swift.Equatable {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of problems.
    public var problemList: [ApplicationInsightsClientTypes.Problem]?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        problemList: [ApplicationInsightsClientTypes.Problem]? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
        self.problemList = problemList
        self.resourceGroupName = resourceGroupName
    }
}

struct ListProblemsOutputBody: Swift.Equatable {
    let problemList: [ApplicationInsightsClientTypes.Problem]?
    let nextToken: Swift.String?
    let resourceGroupName: Swift.String?
    let accountId: Swift.String?
}

extension ListProblemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case nextToken = "NextToken"
        case problemList = "ProblemList"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Problem?].self, forKey: .problemList)
        var problemListDecoded0:[ApplicationInsightsClientTypes.Problem]? = nil
        if let problemListContainer = problemListContainer {
            problemListDecoded0 = [ApplicationInsightsClientTypes.Problem]()
            for structure0 in problemListContainer {
                if let structure0 = structure0 {
                    problemListDecoded0?.append(structure0)
                }
            }
        }
        problemList = problemListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

enum ListProblemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application that you want to retrieve tag information for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// An array that lists all the tags that are associated with the application. Each tag consists of a required tag key (Key) and an associated tag value (Value).
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init(
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ApplicationInsightsClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationInsightsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationInsightsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkloadsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension ListWorkloadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkloadsInput: Swift.Equatable {
    /// The AWS account ID of the owner of the workload.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListWorkloadsInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListWorkloadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case componentName = "ComponentName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListWorkloadsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkloadsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadList = output.workloadList
        } else {
            self.nextToken = nil
            self.workloadList = nil
        }
    }
}

public struct ListWorkloadsOutput: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The list of workloads.
    public var workloadList: [ApplicationInsightsClientTypes.Workload]?

    public init(
        nextToken: Swift.String? = nil,
        workloadList: [ApplicationInsightsClientTypes.Workload]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadList = workloadList
    }
}

struct ListWorkloadsOutputBody: Swift.Equatable {
    let workloadList: [ApplicationInsightsClientTypes.Workload]?
    let nextToken: Swift.String?
}

extension ListWorkloadsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadList = "WorkloadList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Workload?].self, forKey: .workloadList)
        var workloadListDecoded0:[ApplicationInsightsClientTypes.Workload]? = nil
        if let workloadListContainer = workloadListContainer {
            workloadListDecoded0 = [ApplicationInsightsClientTypes.Workload]()
            for structure0 in workloadListContainer {
                if let structure0 = structure0 {
                    workloadListDecoded0?.append(structure0)
                }
            }
        }
        workloadList = workloadListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkloadsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum LogFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogFilter] {
            return [
                .error,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogFilter(rawValue: rawValue) ?? LogFilter.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.LogPattern: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank) ?? 0
        rank = rankDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// An object that defines the log patterns that belongs to a LogPatternSet.
    public struct LogPattern: Swift.Equatable {
        /// A regular expression that defines the log pattern. A log pattern can contain as many as 50 characters, and it cannot be empty. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
        public var pattern: Swift.String?
        /// The name of the log pattern. A log pattern name can contain as many as 50 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public var patternName: Swift.String?
        /// The name of the log pattern. A log pattern name can contain as many as 30 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public var patternSetName: Swift.String?
        /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
        public var rank: Swift.Int

        public init(
            pattern: Swift.String? = nil,
            patternName: Swift.String? = nil,
            patternSetName: Swift.String? = nil,
            rank: Swift.Int = 0
        )
        {
            self.pattern = pattern
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.rank = rank
        }
    }

}

extension ApplicationInsightsClientTypes.Observation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchEventDetailType = "CloudWatchEventDetailType"
        case cloudWatchEventId = "CloudWatchEventId"
        case cloudWatchEventSource = "CloudWatchEventSource"
        case codeDeployApplication = "CodeDeployApplication"
        case codeDeployDeploymentGroup = "CodeDeployDeploymentGroup"
        case codeDeployDeploymentId = "CodeDeployDeploymentId"
        case codeDeployInstanceGroupId = "CodeDeployInstanceGroupId"
        case codeDeployState = "CodeDeployState"
        case ebsCause = "EbsCause"
        case ebsEvent = "EbsEvent"
        case ebsRequestId = "EbsRequestId"
        case ebsResult = "EbsResult"
        case ec2State = "Ec2State"
        case endTime = "EndTime"
        case healthEventArn = "HealthEventArn"
        case healthEventDescription = "HealthEventDescription"
        case healthEventTypeCategory = "HealthEventTypeCategory"
        case healthEventTypeCode = "HealthEventTypeCode"
        case healthService = "HealthService"
        case id = "Id"
        case lineTime = "LineTime"
        case logFilter = "LogFilter"
        case logGroup = "LogGroup"
        case logText = "LogText"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case rdsEventCategories = "RdsEventCategories"
        case rdsEventMessage = "RdsEventMessage"
        case s3EventName = "S3EventName"
        case sourceARN = "SourceARN"
        case sourceType = "SourceType"
        case startTime = "StartTime"
        case statesArn = "StatesArn"
        case statesExecutionArn = "StatesExecutionArn"
        case statesInput = "StatesInput"
        case statesStatus = "StatesStatus"
        case unit = "Unit"
        case value = "Value"
        case xRayErrorPercent = "XRayErrorPercent"
        case xRayFaultPercent = "XRayFaultPercent"
        case xRayNodeName = "XRayNodeName"
        case xRayNodeType = "XRayNodeType"
        case xRayRequestAverageLatency = "XRayRequestAverageLatency"
        case xRayRequestCount = "XRayRequestCount"
        case xRayThrottlePercent = "XRayThrottlePercent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchEventDetailType = self.cloudWatchEventDetailType {
            try encodeContainer.encode(cloudWatchEventDetailType, forKey: .cloudWatchEventDetailType)
        }
        if let cloudWatchEventId = self.cloudWatchEventId {
            try encodeContainer.encode(cloudWatchEventId, forKey: .cloudWatchEventId)
        }
        if let cloudWatchEventSource = self.cloudWatchEventSource {
            try encodeContainer.encode(cloudWatchEventSource.rawValue, forKey: .cloudWatchEventSource)
        }
        if let codeDeployApplication = self.codeDeployApplication {
            try encodeContainer.encode(codeDeployApplication, forKey: .codeDeployApplication)
        }
        if let codeDeployDeploymentGroup = self.codeDeployDeploymentGroup {
            try encodeContainer.encode(codeDeployDeploymentGroup, forKey: .codeDeployDeploymentGroup)
        }
        if let codeDeployDeploymentId = self.codeDeployDeploymentId {
            try encodeContainer.encode(codeDeployDeploymentId, forKey: .codeDeployDeploymentId)
        }
        if let codeDeployInstanceGroupId = self.codeDeployInstanceGroupId {
            try encodeContainer.encode(codeDeployInstanceGroupId, forKey: .codeDeployInstanceGroupId)
        }
        if let codeDeployState = self.codeDeployState {
            try encodeContainer.encode(codeDeployState, forKey: .codeDeployState)
        }
        if let ebsCause = self.ebsCause {
            try encodeContainer.encode(ebsCause, forKey: .ebsCause)
        }
        if let ebsEvent = self.ebsEvent {
            try encodeContainer.encode(ebsEvent, forKey: .ebsEvent)
        }
        if let ebsRequestId = self.ebsRequestId {
            try encodeContainer.encode(ebsRequestId, forKey: .ebsRequestId)
        }
        if let ebsResult = self.ebsResult {
            try encodeContainer.encode(ebsResult, forKey: .ebsResult)
        }
        if let ec2State = self.ec2State {
            try encodeContainer.encode(ec2State, forKey: .ec2State)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let healthEventArn = self.healthEventArn {
            try encodeContainer.encode(healthEventArn, forKey: .healthEventArn)
        }
        if let healthEventDescription = self.healthEventDescription {
            try encodeContainer.encode(healthEventDescription, forKey: .healthEventDescription)
        }
        if let healthEventTypeCategory = self.healthEventTypeCategory {
            try encodeContainer.encode(healthEventTypeCategory, forKey: .healthEventTypeCategory)
        }
        if let healthEventTypeCode = self.healthEventTypeCode {
            try encodeContainer.encode(healthEventTypeCode, forKey: .healthEventTypeCode)
        }
        if let healthService = self.healthService {
            try encodeContainer.encode(healthService, forKey: .healthService)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lineTime = self.lineTime {
            try encodeContainer.encodeTimestamp(lineTime, format: .epochSeconds, forKey: .lineTime)
        }
        if let logFilter = self.logFilter {
            try encodeContainer.encode(logFilter.rawValue, forKey: .logFilter)
        }
        if let logGroup = self.logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let logText = self.logText {
            try encodeContainer.encode(logText, forKey: .logText)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = self.metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let rdsEventCategories = self.rdsEventCategories {
            try encodeContainer.encode(rdsEventCategories, forKey: .rdsEventCategories)
        }
        if let rdsEventMessage = self.rdsEventMessage {
            try encodeContainer.encode(rdsEventMessage, forKey: .rdsEventMessage)
        }
        if let s3EventName = self.s3EventName {
            try encodeContainer.encode(s3EventName, forKey: .s3EventName)
        }
        if let sourceARN = self.sourceARN {
            try encodeContainer.encode(sourceARN, forKey: .sourceARN)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statesArn = self.statesArn {
            try encodeContainer.encode(statesArn, forKey: .statesArn)
        }
        if let statesExecutionArn = self.statesExecutionArn {
            try encodeContainer.encode(statesExecutionArn, forKey: .statesExecutionArn)
        }
        if let statesInput = self.statesInput {
            try encodeContainer.encode(statesInput, forKey: .statesInput)
        }
        if let statesStatus = self.statesStatus {
            try encodeContainer.encode(statesStatus, forKey: .statesStatus)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let xRayErrorPercent = self.xRayErrorPercent {
            try encodeContainer.encode(xRayErrorPercent, forKey: .xRayErrorPercent)
        }
        if let xRayFaultPercent = self.xRayFaultPercent {
            try encodeContainer.encode(xRayFaultPercent, forKey: .xRayFaultPercent)
        }
        if let xRayNodeName = self.xRayNodeName {
            try encodeContainer.encode(xRayNodeName, forKey: .xRayNodeName)
        }
        if let xRayNodeType = self.xRayNodeType {
            try encodeContainer.encode(xRayNodeType, forKey: .xRayNodeType)
        }
        if let xRayRequestAverageLatency = self.xRayRequestAverageLatency {
            try encodeContainer.encode(xRayRequestAverageLatency, forKey: .xRayRequestAverageLatency)
        }
        if let xRayRequestCount = self.xRayRequestCount {
            try encodeContainer.encode(xRayRequestCount, forKey: .xRayRequestCount)
        }
        if let xRayThrottlePercent = self.xRayThrottlePercent {
            try encodeContainer.encode(xRayThrottlePercent, forKey: .xRayThrottlePercent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceARN)
        sourceARN = sourceARNDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
        let lineTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lineTime)
        lineTime = lineTimeDecoded
        let logTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logText)
        logText = logTextDecoded
        let logFilterDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogFilter.self, forKey: .logFilter)
        logFilter = logFilterDecoded
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let cloudWatchEventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchEventId)
        cloudWatchEventId = cloudWatchEventIdDecoded
        let cloudWatchEventSourceDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.CloudWatchEventSource.self, forKey: .cloudWatchEventSource)
        cloudWatchEventSource = cloudWatchEventSourceDecoded
        let cloudWatchEventDetailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchEventDetailType)
        cloudWatchEventDetailType = cloudWatchEventDetailTypeDecoded
        let healthEventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventArn)
        healthEventArn = healthEventArnDecoded
        let healthServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthService)
        healthService = healthServiceDecoded
        let healthEventTypeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventTypeCode)
        healthEventTypeCode = healthEventTypeCodeDecoded
        let healthEventTypeCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventTypeCategory)
        healthEventTypeCategory = healthEventTypeCategoryDecoded
        let healthEventDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthEventDescription)
        healthEventDescription = healthEventDescriptionDecoded
        let codeDeployDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployDeploymentId)
        codeDeployDeploymentId = codeDeployDeploymentIdDecoded
        let codeDeployDeploymentGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployDeploymentGroup)
        codeDeployDeploymentGroup = codeDeployDeploymentGroupDecoded
        let codeDeployStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployState)
        codeDeployState = codeDeployStateDecoded
        let codeDeployApplicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployApplication)
        codeDeployApplication = codeDeployApplicationDecoded
        let codeDeployInstanceGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeDeployInstanceGroupId)
        codeDeployInstanceGroupId = codeDeployInstanceGroupIdDecoded
        let ec2StateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2State)
        ec2State = ec2StateDecoded
        let rdsEventCategoriesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsEventCategories)
        rdsEventCategories = rdsEventCategoriesDecoded
        let rdsEventMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsEventMessage)
        rdsEventMessage = rdsEventMessageDecoded
        let s3EventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3EventName)
        s3EventName = s3EventNameDecoded
        let statesExecutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesExecutionArn)
        statesExecutionArn = statesExecutionArnDecoded
        let statesArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesArn)
        statesArn = statesArnDecoded
        let statesStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesStatus)
        statesStatus = statesStatusDecoded
        let statesInputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statesInput)
        statesInput = statesInputDecoded
        let ebsEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEvent)
        ebsEvent = ebsEventDecoded
        let ebsResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsResult)
        ebsResult = ebsResultDecoded
        let ebsCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsCause)
        ebsCause = ebsCauseDecoded
        let ebsRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsRequestId)
        ebsRequestId = ebsRequestIdDecoded
        let xRayFaultPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayFaultPercent)
        xRayFaultPercent = xRayFaultPercentDecoded
        let xRayThrottlePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayThrottlePercent)
        xRayThrottlePercent = xRayThrottlePercentDecoded
        let xRayErrorPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayErrorPercent)
        xRayErrorPercent = xRayErrorPercentDecoded
        let xRayRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayRequestCount)
        xRayRequestCount = xRayRequestCountDecoded
        let xRayRequestAverageLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .xRayRequestAverageLatency)
        xRayRequestAverageLatency = xRayRequestAverageLatencyDecoded
        let xRayNodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xRayNodeName)
        xRayNodeName = xRayNodeNameDecoded
        let xRayNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xRayNodeType)
        xRayNodeType = xRayNodeTypeDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes an anomaly or error with the application.
    public struct Observation: Swift.Equatable {
        /// The detail type of the CloudWatch Event-based observation, for example, EC2 Instance State-change Notification.
        public var cloudWatchEventDetailType: Swift.String?
        /// The ID of the CloudWatch Event-based observation related to the detected problem.
        public var cloudWatchEventId: Swift.String?
        /// The source of the CloudWatch Event.
        public var cloudWatchEventSource: ApplicationInsightsClientTypes.CloudWatchEventSource?
        /// The CodeDeploy application to which the deployment belongs.
        public var codeDeployApplication: Swift.String?
        /// The deployment group to which the CodeDeploy deployment belongs.
        public var codeDeployDeploymentGroup: Swift.String?
        /// The deployment ID of the CodeDeploy-based observation related to the detected problem.
        public var codeDeployDeploymentId: Swift.String?
        /// The instance group to which the CodeDeploy instance belongs.
        public var codeDeployInstanceGroupId: Swift.String?
        /// The status of the CodeDeploy deployment, for example SUCCESS or  FAILURE.
        public var codeDeployState: Swift.String?
        /// The cause of an EBS CloudWatch event.
        public var ebsCause: Swift.String?
        /// The type of EBS CloudWatch event, such as createVolume, deleteVolume or attachVolume.
        public var ebsEvent: Swift.String?
        /// The request ID of an EBS CloudWatch event.
        public var ebsRequestId: Swift.String?
        /// The result of an EBS CloudWatch event, such as failed or succeeded.
        public var ebsResult: Swift.String?
        /// The state of the instance, such as STOPPING or TERMINATING.
        public var ec2State: Swift.String?
        /// The time when the observation ended, in epoch seconds.
        public var endTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the AWS Health Event-based observation.
        public var healthEventArn: Swift.String?
        /// The description of the AWS Health event provided by the service, such as Amazon EC2.
        public var healthEventDescription: Swift.String?
        /// The category of the AWS Health event, such as issue.
        public var healthEventTypeCategory: Swift.String?
        /// The type of the AWS Health event, for example, AWS_EC2_POWER_CONNECTIVITY_ISSUE.
        public var healthEventTypeCode: Swift.String?
        /// The service to which the AWS Health Event belongs, such as EC2.
        public var healthService: Swift.String?
        /// The ID of the observation type.
        public var id: Swift.String?
        /// The timestamp in the CloudWatch Logs that specifies when the matched line occurred.
        public var lineTime: ClientRuntime.Date?
        /// The log filter of the observation.
        public var logFilter: ApplicationInsightsClientTypes.LogFilter?
        /// The log group name.
        public var logGroup: Swift.String?
        /// The log text of the observation.
        public var logText: Swift.String?
        /// The name of the observation metric.
        public var metricName: Swift.String?
        /// The namespace of the observation metric.
        public var metricNamespace: Swift.String?
        /// The category of an RDS event.
        public var rdsEventCategories: Swift.String?
        /// The message of an RDS event.
        public var rdsEventMessage: Swift.String?
        /// The name of the S3 CloudWatch Event-based observation.
        public var s3EventName: Swift.String?
        /// The source resource ARN of the observation.
        public var sourceARN: Swift.String?
        /// The source type of the observation.
        public var sourceType: Swift.String?
        /// The time when the observation was first detected, in epoch seconds.
        public var startTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the step function-based observation.
        public var statesArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the step function execution-based observation.
        public var statesExecutionArn: Swift.String?
        /// The input to the step function-based observation.
        public var statesInput: Swift.String?
        /// The status of the step function-related observation.
        public var statesStatus: Swift.String?
        /// The unit of the source observation metric.
        public var unit: Swift.String?
        /// The value of the source observation metric.
        public var value: Swift.Double?
        /// The X-Ray request error percentage for this node.
        public var xRayErrorPercent: Swift.Int?
        /// The X-Ray request fault percentage for this node.
        public var xRayFaultPercent: Swift.Int?
        /// The name of the X-Ray node.
        public var xRayNodeName: Swift.String?
        /// The type of the X-Ray node.
        public var xRayNodeType: Swift.String?
        /// The X-Ray node request average latency for this node.
        public var xRayRequestAverageLatency: Swift.Int?
        /// The X-Ray request count for this node.
        public var xRayRequestCount: Swift.Int?
        /// The X-Ray request throttle percentage for this node.
        public var xRayThrottlePercent: Swift.Int?

        public init(
            cloudWatchEventDetailType: Swift.String? = nil,
            cloudWatchEventId: Swift.String? = nil,
            cloudWatchEventSource: ApplicationInsightsClientTypes.CloudWatchEventSource? = nil,
            codeDeployApplication: Swift.String? = nil,
            codeDeployDeploymentGroup: Swift.String? = nil,
            codeDeployDeploymentId: Swift.String? = nil,
            codeDeployInstanceGroupId: Swift.String? = nil,
            codeDeployState: Swift.String? = nil,
            ebsCause: Swift.String? = nil,
            ebsEvent: Swift.String? = nil,
            ebsRequestId: Swift.String? = nil,
            ebsResult: Swift.String? = nil,
            ec2State: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            healthEventArn: Swift.String? = nil,
            healthEventDescription: Swift.String? = nil,
            healthEventTypeCategory: Swift.String? = nil,
            healthEventTypeCode: Swift.String? = nil,
            healthService: Swift.String? = nil,
            id: Swift.String? = nil,
            lineTime: ClientRuntime.Date? = nil,
            logFilter: ApplicationInsightsClientTypes.LogFilter? = nil,
            logGroup: Swift.String? = nil,
            logText: Swift.String? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            rdsEventCategories: Swift.String? = nil,
            rdsEventMessage: Swift.String? = nil,
            s3EventName: Swift.String? = nil,
            sourceARN: Swift.String? = nil,
            sourceType: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            statesArn: Swift.String? = nil,
            statesExecutionArn: Swift.String? = nil,
            statesInput: Swift.String? = nil,
            statesStatus: Swift.String? = nil,
            unit: Swift.String? = nil,
            value: Swift.Double? = nil,
            xRayErrorPercent: Swift.Int? = nil,
            xRayFaultPercent: Swift.Int? = nil,
            xRayNodeName: Swift.String? = nil,
            xRayNodeType: Swift.String? = nil,
            xRayRequestAverageLatency: Swift.Int? = nil,
            xRayRequestCount: Swift.Int? = nil,
            xRayThrottlePercent: Swift.Int? = nil
        )
        {
            self.cloudWatchEventDetailType = cloudWatchEventDetailType
            self.cloudWatchEventId = cloudWatchEventId
            self.cloudWatchEventSource = cloudWatchEventSource
            self.codeDeployApplication = codeDeployApplication
            self.codeDeployDeploymentGroup = codeDeployDeploymentGroup
            self.codeDeployDeploymentId = codeDeployDeploymentId
            self.codeDeployInstanceGroupId = codeDeployInstanceGroupId
            self.codeDeployState = codeDeployState
            self.ebsCause = ebsCause
            self.ebsEvent = ebsEvent
            self.ebsRequestId = ebsRequestId
            self.ebsResult = ebsResult
            self.ec2State = ec2State
            self.endTime = endTime
            self.healthEventArn = healthEventArn
            self.healthEventDescription = healthEventDescription
            self.healthEventTypeCategory = healthEventTypeCategory
            self.healthEventTypeCode = healthEventTypeCode
            self.healthService = healthService
            self.id = id
            self.lineTime = lineTime
            self.logFilter = logFilter
            self.logGroup = logGroup
            self.logText = logText
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.rdsEventCategories = rdsEventCategories
            self.rdsEventMessage = rdsEventMessage
            self.s3EventName = s3EventName
            self.sourceARN = sourceARN
            self.sourceType = sourceType
            self.startTime = startTime
            self.statesArn = statesArn
            self.statesExecutionArn = statesExecutionArn
            self.statesInput = statesInput
            self.statesStatus = statesStatus
            self.unit = unit
            self.value = value
            self.xRayErrorPercent = xRayErrorPercent
            self.xRayFaultPercent = xRayFaultPercent
            self.xRayNodeName = xRayNodeName
            self.xRayNodeType = xRayNodeType
            self.xRayRequestAverageLatency = xRayRequestAverageLatency
            self.xRayRequestCount = xRayRequestCount
            self.xRayThrottlePercent = xRayThrottlePercent
        }
    }

}

extension ApplicationInsightsClientTypes {
    public enum OsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OsType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OsType(rawValue: rawValue) ?? OsType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.Problem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case affectedResource = "AffectedResource"
        case endTime = "EndTime"
        case feedback = "Feedback"
        case id = "Id"
        case insights = "Insights"
        case lastRecurrenceTime = "LastRecurrenceTime"
        case recurringCount = "RecurringCount"
        case resolutionMethod = "ResolutionMethod"
        case resourceGroupName = "ResourceGroupName"
        case severityLevel = "SeverityLevel"
        case startTime = "StartTime"
        case status = "Status"
        case title = "Title"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let affectedResource = self.affectedResource {
            try encodeContainer.encode(affectedResource, forKey: .affectedResource)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let feedback = feedback {
            var feedbackContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .feedback)
            for (dictKey0, feedback0) in feedback {
                try feedbackContainer.encode(feedback0.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insights = self.insights {
            try encodeContainer.encode(insights, forKey: .insights)
        }
        if let lastRecurrenceTime = self.lastRecurrenceTime {
            try encodeContainer.encodeTimestamp(lastRecurrenceTime, format: .epochSeconds, forKey: .lastRecurrenceTime)
        }
        if let recurringCount = self.recurringCount {
            try encodeContainer.encode(recurringCount, forKey: .recurringCount)
        }
        if let resolutionMethod = self.resolutionMethod {
            try encodeContainer.encode(resolutionMethod.rawValue, forKey: .resolutionMethod)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let severityLevel = self.severityLevel {
            try encodeContainer.encode(severityLevel.rawValue, forKey: .severityLevel)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let insightsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insights)
        insights = insightsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let affectedResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .affectedResource)
        affectedResource = affectedResourceDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let severityLevelDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.SeverityLevel.self, forKey: .severityLevel)
        severityLevel = severityLevelDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let feedbackContainer = try containerValues.decodeIfPresent([Swift.String: ApplicationInsightsClientTypes.FeedbackValue?].self, forKey: .feedback)
        var feedbackDecoded0: [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]? = nil
        if let feedbackContainer = feedbackContainer {
            feedbackDecoded0 = [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]()
            for (key0, feedbackvalue0) in feedbackContainer {
                if let feedbackvalue0 = feedbackvalue0 {
                    feedbackDecoded0?[key0] = feedbackvalue0
                }
            }
        }
        feedback = feedbackDecoded0
        let recurringCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurringCount)
        recurringCount = recurringCountDecoded
        let lastRecurrenceTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRecurrenceTime)
        lastRecurrenceTime = lastRecurrenceTimeDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let resolutionMethodDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ResolutionMethod.self, forKey: .resolutionMethod)
        resolutionMethod = resolutionMethodDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes a problem that is detected by correlating observations.
    public struct Problem: Swift.Equatable {
        /// The AWS account ID for the owner of the resource group affected by the problem.
        public var accountId: Swift.String?
        /// The resource affected by the problem.
        public var affectedResource: Swift.String?
        /// The time when the problem ended, in epoch seconds.
        public var endTime: ClientRuntime.Date?
        /// Feedback provided by the user about the problem.
        public var feedback: [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]?
        /// The ID of the problem.
        public var id: Swift.String?
        /// A detailed analysis of the problem using machine learning.
        public var insights: Swift.String?
        /// The last time that the problem reoccurred after its last resolution.
        public var lastRecurrenceTime: ClientRuntime.Date?
        /// The number of times that the same problem reoccurred after the first time it was resolved.
        public var recurringCount: Swift.Int?
        /// Specifies how the problem was resolved. If the value is AUTOMATIC, the system resolved the problem. If the value is MANUAL, the user resolved the problem. If the value is UNRESOLVED, then the problem is not resolved.
        public var resolutionMethod: ApplicationInsightsClientTypes.ResolutionMethod?
        /// The name of the resource group affected by the problem.
        public var resourceGroupName: Swift.String?
        /// A measure of the level of impact of the problem.
        public var severityLevel: ApplicationInsightsClientTypes.SeverityLevel?
        /// The time when the problem started, in epoch seconds.
        public var startTime: ClientRuntime.Date?
        /// The status of the problem.
        public var status: ApplicationInsightsClientTypes.Status?
        /// The name of the problem.
        public var title: Swift.String?
        /// Specifies whether or not you can view the problem. Updates to ignored problems do not generate notifications.
        public var visibility: ApplicationInsightsClientTypes.Visibility?

        public init(
            accountId: Swift.String? = nil,
            affectedResource: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            feedback: [Swift.String:ApplicationInsightsClientTypes.FeedbackValue]? = nil,
            id: Swift.String? = nil,
            insights: Swift.String? = nil,
            lastRecurrenceTime: ClientRuntime.Date? = nil,
            recurringCount: Swift.Int? = nil,
            resolutionMethod: ApplicationInsightsClientTypes.ResolutionMethod? = nil,
            resourceGroupName: Swift.String? = nil,
            severityLevel: ApplicationInsightsClientTypes.SeverityLevel? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ApplicationInsightsClientTypes.Status? = nil,
            title: Swift.String? = nil,
            visibility: ApplicationInsightsClientTypes.Visibility? = nil
        )
        {
            self.accountId = accountId
            self.affectedResource = affectedResource
            self.endTime = endTime
            self.feedback = feedback
            self.id = id
            self.insights = insights
            self.lastRecurrenceTime = lastRecurrenceTime
            self.recurringCount = recurringCount
            self.resolutionMethod = resolutionMethod
            self.resourceGroupName = resourceGroupName
            self.severityLevel = severityLevel
            self.startTime = startTime
            self.status = status
            self.title = title
            self.visibility = visibility
        }
    }

}

extension ApplicationInsightsClientTypes {
    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case infraOnly
        case workloadOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .all,
                .infraOnly,
                .workloadOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .infraOnly: return "INFRA_ONLY"
            case .workloadOnly: return "WORKLOAD_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationType(rawValue: rawValue) ?? RecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.RelatedObservations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observationList = "ObservationList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observationList = observationList {
            var observationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .observationList)
            for observation0 in observationList {
                try observationListContainer.encode(observation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationListContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Observation?].self, forKey: .observationList)
        var observationListDecoded0:[ApplicationInsightsClientTypes.Observation]? = nil
        if let observationListContainer = observationListContainer {
            observationListDecoded0 = [ApplicationInsightsClientTypes.Observation]()
            for structure0 in observationListContainer {
                if let structure0 = structure0 {
                    observationListDecoded0?.append(structure0)
                }
            }
        }
        observationList = observationListDecoded0
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes observations related to the problem.
    public struct RelatedObservations: Swift.Equatable {
        /// The list of observations related to the problem.
        public var observationList: [ApplicationInsightsClientTypes.Observation]?

        public init(
            observationList: [ApplicationInsightsClientTypes.Observation]? = nil
        )
        {
            self.observationList = observationList
        }
    }

}

extension RemoveWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

extension RemoveWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveWorkloadInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The ID of the workload.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadId = workloadId
    }
}

struct RemoveWorkloadInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let workloadId: Swift.String?
}

extension RemoveWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension RemoveWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveWorkloadOutput: Swift.Equatable {

    public init() { }
}

enum RemoveWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum ResolutionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case manual
        case unresolved
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionMethod] {
            return [
                .automatic,
                .manual,
                .unresolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case .unresolved: return "UNRESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionMethod(rawValue: rawValue) ?? ResolutionMethod.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is already created or in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource does not exist in the customer account.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum SeverityLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case informative
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityLevel] {
            return [
                .high,
                .informative,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .informative: return "Informative"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SeverityLevel(rawValue: rawValue) ?? SeverityLevel.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ignore
        case pending
        case recovering
        case recurring
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .ignore,
                .pending,
                .recovering,
                .recurring,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ignore: return "IGNORE"
            case .pending: return "PENDING"
            case .recovering: return "RECOVERING"
            case .recurring: return "RECURRING"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// An object that defines the tags associated with an application. A tag is a label that you optionally define and associate with an application. Tags can help you categorize and manage resources in different ways, such as by purpose, owner, environment, or other criteria. Each tag consists of a required tag key and an associated tag value, both of which you define. A tag key is a general label that acts as a category for a more specific tag value. A tag value acts as a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag value can contain as many as 256 characters. The characters can be Unicode letters, digits, white space, or one of the following symbols: _ . : / = + -. The following additional restrictions apply to tags:
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * For each associated resource, each tag key must be unique and it can have only one value.
    ///
    /// * The aws: prefix is reserved for use by AWS; you can’t use it in any tag keys or values that you define. In addition, you can't edit or remove tag keys or values that use this prefix.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that defines a tag. The maximum length of a tag key is 128 characters. The minimum length is 1 character.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that defines a tag. The maximum length of a tag value is 256 characters. The minimum length is 0 characters. If you don't want an application to have a specific tag value, don't specify a value for this parameter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application that you want to add one or more tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags that to add to the application. A tag consists of a required tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    /// This member is required.
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ApplicationInsightsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationInsightsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationInsightsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationInsightsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagsAlreadyExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagsAlreadyExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Tags are already registered for the specified application ARN.
public struct TagsAlreadyExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsAlreadyExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagsAlreadyExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsAlreadyExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum Tier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectory
        case custom
        case `default`
        case dotNetCore
        case dotNetWeb
        case dotNetWebTier
        case dotNetWorker
        case javaJmx
        case mysql
        case oracle
        case postgresql
        case sapHanaHighAvailability
        case sapHanaMultiNode
        case sapHanaSingleNode
        case sapNetweaverDistributed
        case sapNetweaverHighAvailability
        case sapNetweaverStandard
        case sharepoint
        case sqlServer
        case sqlServerAlwaysonAvailabilityGroup
        case sqlServerFailoverClusterInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [Tier] {
            return [
                .activeDirectory,
                .custom,
                .default,
                .dotNetCore,
                .dotNetWeb,
                .dotNetWebTier,
                .dotNetWorker,
                .javaJmx,
                .mysql,
                .oracle,
                .postgresql,
                .sapHanaHighAvailability,
                .sapHanaMultiNode,
                .sapHanaSingleNode,
                .sapNetweaverDistributed,
                .sapNetweaverHighAvailability,
                .sapNetweaverStandard,
                .sharepoint,
                .sqlServer,
                .sqlServerAlwaysonAvailabilityGroup,
                .sqlServerFailoverClusterInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case .dotNetCore: return "DOT_NET_CORE"
            case .dotNetWeb: return "DOT_NET_WEB"
            case .dotNetWebTier: return "DOT_NET_WEB_TIER"
            case .dotNetWorker: return "DOT_NET_WORKER"
            case .javaJmx: return "JAVA_JMX"
            case .mysql: return "MYSQL"
            case .oracle: return "ORACLE"
            case .postgresql: return "POSTGRESQL"
            case .sapHanaHighAvailability: return "SAP_HANA_HIGH_AVAILABILITY"
            case .sapHanaMultiNode: return "SAP_HANA_MULTI_NODE"
            case .sapHanaSingleNode: return "SAP_HANA_SINGLE_NODE"
            case .sapNetweaverDistributed: return "SAP_NETWEAVER_DISTRIBUTED"
            case .sapNetweaverHighAvailability: return "SAP_NETWEAVER_HIGH_AVAILABILITY"
            case .sapNetweaverStandard: return "SAP_NETWEAVER_STANDARD"
            case .sharepoint: return "SHAREPOINT"
            case .sqlServer: return "SQL_SERVER"
            case .sqlServerAlwaysonAvailabilityGroup: return "SQL_SERVER_ALWAYSON_AVAILABILITY_GROUP"
            case .sqlServerFailoverClusterInstance: return "SQL_SERVER_FAILOVER_CLUSTER_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tier(rawValue: rawValue) ?? Tier.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of the provided tags is beyond the limit, or the number of total tags you are trying to attach to the specified resource exceeds the limit.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application that you want to remove one or more tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags (tag keys) that you want to remove from the resource. When you specify a tag key, the action removes both that key and its associated tag value. To remove more than one tag from the application, append the TagKeys parameter and argument for each additional tag to remove, separated by an ampersand.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case removeSNSTopic = "RemoveSNSTopic"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let cweMonitorEnabled = self.cweMonitorEnabled {
            try encodeContainer.encode(cweMonitorEnabled, forKey: .cweMonitorEnabled)
        }
        if let opsCenterEnabled = self.opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = self.opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let removeSNSTopic = self.removeSNSTopic {
            try encodeContainer.encode(removeSNSTopic, forKey: .removeSNSTopic)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Turns auto-configuration on or off.
    public var autoConfigEnabled: Swift.Bool?
    /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
    public var cweMonitorEnabled: Swift.Bool?
    /// When set to true, creates opsItems for any problems detected on an application.
    public var opsCenterEnabled: Swift.Bool?
    /// The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
    public var opsItemSNSTopicArn: Swift.String?
    /// Disassociates the SNS topic from the opsItem created for detected problems.
    public var removeSNSTopic: Swift.Bool?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        autoConfigEnabled: Swift.Bool? = nil,
        cweMonitorEnabled: Swift.Bool? = nil,
        opsCenterEnabled: Swift.Bool? = nil,
        opsItemSNSTopicArn: Swift.String? = nil,
        removeSNSTopic: Swift.Bool? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.cweMonitorEnabled = cweMonitorEnabled
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.removeSNSTopic = removeSNSTopic
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let opsCenterEnabled: Swift.Bool?
    let cweMonitorEnabled: Swift.Bool?
    let opsItemSNSTopicArn: Swift.String?
    let removeSNSTopic: Swift.Bool?
    let autoConfigEnabled: Swift.Bool?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case cweMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case removeSNSTopic = "RemoveSNSTopic"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cweMonitorEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cweMonitorEnabled)
        cweMonitorEnabled = cweMonitorEnabledDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let removeSNSTopicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeSNSTopic)
        removeSNSTopic = removeSNSTopicDecoded
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init(
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateComponentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case componentConfiguration = "ComponentConfiguration"
        case componentName = "ComponentName"
        case monitor = "Monitor"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoConfigEnabled = self.autoConfigEnabled {
            try encodeContainer.encode(autoConfigEnabled, forKey: .autoConfigEnabled)
        }
        if let componentConfiguration = self.componentConfiguration {
            try encodeContainer.encode(componentConfiguration, forKey: .componentConfiguration)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let monitor = self.monitor {
            try encodeContainer.encode(monitor, forKey: .monitor)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension UpdateComponentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateComponentConfigurationInput: Swift.Equatable {
    /// Automatically configures the component by applying the recommended configurations.
    public var autoConfigEnabled: Swift.Bool?
    /// The configuration settings of the component. The value is the escaped JSON of the configuration. For more information about the JSON format, see [Working with JSON](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/working-with-json.html). You can send a request to DescribeComponentConfigurationRecommendation to see the recommended configuration for a component. For the complete format of the component configuration file, see [Component Configuration](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/component-config.html).
    public var componentConfiguration: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// Indicates whether the application component is monitored.
    public var monitor: Swift.Bool?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The tier of the application component.
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init(
        autoConfigEnabled: Swift.Bool? = nil,
        componentConfiguration: Swift.String? = nil,
        componentName: Swift.String? = nil,
        monitor: Swift.Bool? = nil,
        resourceGroupName: Swift.String? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.componentConfiguration = componentConfiguration
        self.componentName = componentName
        self.monitor = monitor
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

struct UpdateComponentConfigurationInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let monitor: Swift.Bool?
    let tier: ApplicationInsightsClientTypes.Tier?
    let componentConfiguration: Swift.String?
    let autoConfigEnabled: Swift.Bool?
}

extension UpdateComponentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoConfigEnabled = "AutoConfigEnabled"
        case componentConfiguration = "ComponentConfiguration"
        case componentName = "ComponentName"
        case monitor = "Monitor"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let monitorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
        let autoConfigEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoConfigEnabled)
        autoConfigEnabled = autoConfigEnabledDecoded
    }
}

extension UpdateComponentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateComponentConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateComponentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case newComponentName = "NewComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let newComponentName = self.newComponentName {
            try encodeContainer.encode(newComponentName, forKey: .newComponentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceList = resourceList {
            var resourceListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceList)
            for resourcearn0 in resourceList {
                try resourceListContainer.encode(resourcearn0)
            }
        }
    }
}

extension UpdateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateComponentInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The new name of the component.
    public var newComponentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The list of resource ARNs that belong to the component.
    public var resourceList: [Swift.String]?

    public init(
        componentName: Swift.String? = nil,
        newComponentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.componentName = componentName
        self.newComponentName = newComponentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

struct UpdateComponentInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let newComponentName: Swift.String?
    let resourceList: [Swift.String]?
}

extension UpdateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case newComponentName = "NewComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let newComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newComponentName)
        newComponentName = newComponentNameDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceList)
        var resourceListDecoded0:[Swift.String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [Swift.String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension UpdateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateComponentOutput: Swift.Equatable {

    public init() { }
}

enum UpdateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLogPatternInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = self.patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let rank = self.rank {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

extension UpdateLogPatternInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLogPatternInput: Swift.Equatable {
    /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
    public var pattern: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
    public var rank: Swift.Int?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        pattern: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        rank: Swift.Int? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateLogPatternInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let patternSetName: Swift.String?
    let patternName: Swift.String?
    let pattern: Swift.String?
    let rank: Swift.Int?
}

extension UpdateLogPatternInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension UpdateLogPatternOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLogPatternOutputBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct UpdateLogPatternOutput: Swift.Equatable {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateLogPatternOutputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let logPattern: ApplicationInsightsClientTypes.LogPattern?
}

extension UpdateLogPatternOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
    }
}

enum UpdateLogPatternOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProblemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problemId = "ProblemId"
        case updateStatus = "UpdateStatus"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let problemId = self.problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }
}

extension UpdateProblemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProblemInput: Swift.Equatable {
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?
    /// The status of the problem. Arguments can be passed for only problems that show a status of RECOVERING.
    public var updateStatus: ApplicationInsightsClientTypes.UpdateStatus?
    /// The visibility of a problem. When you pass a value of IGNORED, the problem is removed from the default view, and all notifications for the problem are suspended. When VISIBLE is passed, the IGNORED action is reversed.
    public var visibility: ApplicationInsightsClientTypes.Visibility?

    public init(
        problemId: Swift.String? = nil,
        updateStatus: ApplicationInsightsClientTypes.UpdateStatus? = nil,
        visibility: ApplicationInsightsClientTypes.Visibility? = nil
    )
    {
        self.problemId = problemId
        self.updateStatus = updateStatus
        self.visibility = visibility
    }
}

struct UpdateProblemInputBody: Swift.Equatable {
    let problemId: Swift.String?
    let updateStatus: ApplicationInsightsClientTypes.UpdateStatus?
    let visibility: ApplicationInsightsClientTypes.Visibility?
}

extension UpdateProblemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problemId = "ProblemId"
        case updateStatus = "UpdateStatus"
        case visibility = "Visibility"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .problemId)
        problemId = problemIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.UpdateStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension UpdateProblemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProblemOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProblemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationInsightsClientTypes {
    public enum UpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateStatus] {
            return [
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateStatus(rawValue: rawValue) ?? UpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension UpdateWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadConfiguration = "WorkloadConfiguration"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let workloadConfiguration = self.workloadConfiguration {
            try encodeContainer.encode(workloadConfiguration, forKey: .workloadConfiguration)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

extension UpdateWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkloadInput: Swift.Equatable {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    /// This member is required.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
    }
}

struct UpdateWorkloadInputBody: Swift.Equatable {
    let resourceGroupName: Swift.String?
    let componentName: Swift.String?
    let workloadId: Swift.String?
    let workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
}

extension UpdateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case workloadConfiguration = "WorkloadConfiguration"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.WorkloadConfiguration.self, forKey: .workloadConfiguration)
        workloadConfiguration = workloadConfigurationDecoded
    }
}

extension UpdateWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workloadConfiguration = output.workloadConfiguration
            self.workloadId = output.workloadId
        } else {
            self.workloadConfiguration = nil
            self.workloadId = nil
        }
    }
}

public struct UpdateWorkloadOutput: Swift.Equatable {
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?

    public init(
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
    }
}

struct UpdateWorkloadOutputBody: Swift.Equatable {
    let workloadId: Swift.String?
    let workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
}

extension UpdateWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadConfiguration = "WorkloadConfiguration"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.WorkloadConfiguration.self, forKey: .workloadConfiguration)
        workloadConfiguration = workloadConfigurationDecoded
    }
}

enum UpdateWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationInsightsClientTypes {
    public enum Visibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ignored
        case visible
        case sdkUnknown(Swift.String)

        public static var allCases: [Visibility] {
            return [
                .ignored,
                .visible,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ignored: return "IGNORED"
            case .visible: return "VISIBLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Visibility(rawValue: rawValue) ?? Visibility.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationInsightsClientTypes.Workload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName = "ComponentName"
        case tier = "Tier"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
        case workloadRemarks = "WorkloadRemarks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
        if let workloadRemarks = self.workloadRemarks {
            try encodeContainer.encode(workloadRemarks, forKey: .workloadRemarks)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let workloadRemarksDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadRemarks)
        workloadRemarks = workloadRemarksDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes the workloads on a component.
    public struct Workload: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The tier of the workload.
        public var tier: ApplicationInsightsClientTypes.Tier?
        /// The ID of the workload.
        public var workloadId: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?
        /// If logging is supported for the resource type, shows whether the component has configured logs to be monitored.
        public var workloadRemarks: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil,
            workloadRemarks: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.tier = tier
            self.workloadId = workloadId
            self.workloadName = workloadName
            self.workloadRemarks = workloadRemarks
        }
    }

}

extension ApplicationInsightsClientTypes.WorkloadConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case tier = "Tier"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ApplicationInsightsClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension ApplicationInsightsClientTypes {
    /// The configuration of the workload.
    public struct WorkloadConfiguration: Swift.Equatable {
        /// The configuration settings of the workload.
        public var configuration: Swift.String?
        /// The configuration of the workload tier.
        public var tier: ApplicationInsightsClientTypes.Tier?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            configuration: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.tier = tier
            self.workloadName = workloadName
        }
    }

}
