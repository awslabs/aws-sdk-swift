//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox

/// User does not have permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource is already created or in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource does not exist in the customer account.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ApplicationInsightsClientTypes {

    public enum Tier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeDirectory
        case custom
        case `default`
        case dotNetCore
        case dotNetWeb
        case dotNetWebTier
        case dotNetWorker
        case javaJmx
        case mysql
        case oracle
        case postgresql
        case sapHanaHighAvailability
        case sapHanaMultiNode
        case sapHanaSingleNode
        case sapNetweaverDistributed
        case sapNetweaverHighAvailability
        case sapNetweaverStandard
        case sharepoint
        case sqlServer
        case sqlServerAlwaysonAvailabilityGroup
        case sqlServerFailoverClusterInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [Tier] {
            return [
                .activeDirectory,
                .custom,
                .default,
                .dotNetCore,
                .dotNetWeb,
                .dotNetWebTier,
                .dotNetWorker,
                .javaJmx,
                .mysql,
                .oracle,
                .postgresql,
                .sapHanaHighAvailability,
                .sapHanaMultiNode,
                .sapHanaSingleNode,
                .sapNetweaverDistributed,
                .sapNetweaverHighAvailability,
                .sapNetweaverStandard,
                .sharepoint,
                .sqlServer,
                .sqlServerAlwaysonAvailabilityGroup,
                .sqlServerFailoverClusterInstance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case .dotNetCore: return "DOT_NET_CORE"
            case .dotNetWeb: return "DOT_NET_WEB"
            case .dotNetWebTier: return "DOT_NET_WEB_TIER"
            case .dotNetWorker: return "DOT_NET_WORKER"
            case .javaJmx: return "JAVA_JMX"
            case .mysql: return "MYSQL"
            case .oracle: return "ORACLE"
            case .postgresql: return "POSTGRESQL"
            case .sapHanaHighAvailability: return "SAP_HANA_HIGH_AVAILABILITY"
            case .sapHanaMultiNode: return "SAP_HANA_MULTI_NODE"
            case .sapHanaSingleNode: return "SAP_HANA_SINGLE_NODE"
            case .sapNetweaverDistributed: return "SAP_NETWEAVER_DISTRIBUTED"
            case .sapNetweaverHighAvailability: return "SAP_NETWEAVER_HIGH_AVAILABILITY"
            case .sapNetweaverStandard: return "SAP_NETWEAVER_STANDARD"
            case .sharepoint: return "SHAREPOINT"
            case .sqlServer: return "SQL_SERVER"
            case .sqlServerAlwaysonAvailabilityGroup: return "SQL_SERVER_ALWAYSON_AVAILABILITY_GROUP"
            case .sqlServerFailoverClusterInstance: return "SQL_SERVER_FAILOVER_CLUSTER_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// The configuration of the workload.
    public struct WorkloadConfiguration {
        /// The configuration settings of the workload.
        public var configuration: Swift.String?
        /// The configuration of the workload tier.
        public var tier: ApplicationInsightsClientTypes.Tier?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            configuration: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.tier = tier
            self.workloadName = workloadName
        }
    }

}

public struct AddWorkloadInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    /// This member is required.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadConfiguration = workloadConfiguration
    }
}

public struct AddWorkloadOutput {
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?

    public init(
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
    }
}

extension ApplicationInsightsClientTypes {

    public enum OsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OsType] {
            return [
                .linux,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes a standalone resource or similarly grouped resources that the application is made up of.
    public struct ApplicationComponent {
        /// The name of the component.
        public var componentName: Swift.String?
        /// If logging is supported for the resource type, indicates whether the component has configured logs to be monitored.
        public var componentRemarks: Swift.String?
        /// Workloads detected in the application component.
        public var detectedWorkload: [Swift.String: [Swift.String: Swift.String]]?
        /// Indicates whether the application component is monitored.
        public var monitor: Swift.Bool?
        /// The operating system of the component.
        public var osType: ApplicationInsightsClientTypes.OsType?
        /// The resource type. Supported resource types include EC2 instances, Auto Scaling group, Classic ELB, Application ELB, and SQS Queue.
        public var resourceType: Swift.String?
        /// The stack tier of the application component.
        public var tier: ApplicationInsightsClientTypes.Tier?

        public init(
            componentName: Swift.String? = nil,
            componentRemarks: Swift.String? = nil,
            detectedWorkload: [Swift.String: [Swift.String: Swift.String]]? = nil,
            monitor: Swift.Bool? = nil,
            osType: ApplicationInsightsClientTypes.OsType? = nil,
            resourceType: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil
        )
        {
            self.componentName = componentName
            self.componentRemarks = componentRemarks
            self.detectedWorkload = detectedWorkload
            self.monitor = monitor
            self.osType = osType
            self.resourceType = resourceType
            self.tier = tier
        }
    }

}

extension ApplicationInsightsClientTypes {

    public enum DiscoveryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountBased
        case resourceGroupBased
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryType] {
            return [
                .accountBased,
                .resourceGroupBased
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountBased: return "ACCOUNT_BASED"
            case .resourceGroupBased: return "RESOURCE_GROUP_BASED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes the status of the application.
    public struct ApplicationInfo {
        /// The AWS account ID for the owner of the application.
        public var accountId: Swift.String?
        /// If set to true, the managed policies for SSM and CW will be attached to the instance roles if they are missing.
        public var attachMissingPermission: Swift.Bool?
        /// Indicates whether auto-configuration is turned on for this application.
        public var autoConfigEnabled: Swift.Bool?
        /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
        public var cweMonitorEnabled: Swift.Bool?
        /// The method used by Application Insights to onboard your resources.
        public var discoveryType: ApplicationInsightsClientTypes.DiscoveryType?
        /// The lifecycle of the application.
        public var lifeCycle: Swift.String?
        /// Indicates whether Application Insights will create opsItems for any problem detected by Application Insights for an application.
        public var opsCenterEnabled: Swift.Bool?
        /// The SNS topic provided to Application Insights that is associated to the created opsItems to receive SNS notifications for opsItem updates.
        public var opsItemSNSTopicArn: Swift.String?
        /// The issues on the user side that block Application Insights from successfully monitoring an application. Example remarks include:
        ///
        /// * “Configuring application, detected 1 Errors, 3 Warnings”
        ///
        /// * “Configuring application, detected 1 Unconfigured Components”
        public var remarks: Swift.String?
        /// The name of the resource group used for the application.
        public var resourceGroupName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            attachMissingPermission: Swift.Bool? = nil,
            autoConfigEnabled: Swift.Bool? = nil,
            cweMonitorEnabled: Swift.Bool? = nil,
            discoveryType: ApplicationInsightsClientTypes.DiscoveryType? = nil,
            lifeCycle: Swift.String? = nil,
            opsCenterEnabled: Swift.Bool? = nil,
            opsItemSNSTopicArn: Swift.String? = nil,
            remarks: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.attachMissingPermission = attachMissingPermission
            self.autoConfigEnabled = autoConfigEnabled
            self.cweMonitorEnabled = cweMonitorEnabled
            self.discoveryType = discoveryType
            self.lifeCycle = lifeCycle
            self.opsCenterEnabled = opsCenterEnabled
            self.opsItemSNSTopicArn = opsItemSNSTopicArn
            self.remarks = remarks
            self.resourceGroupName = resourceGroupName
        }
    }

}

/// The request is not understood by the server.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ApplicationInsightsClientTypes {

    public enum CloudWatchEventSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case codeDeploy
        case ec2
        case health
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchEventSource] {
            return [
                .codeDeploy,
                .ec2,
                .health,
                .rds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .codeDeploy: return "CODE_DEPLOY"
            case .ec2: return "EC2"
            case .health: return "HEALTH"
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum ConfigurationEventResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudformation
        case cloudwatchAlarm
        case cloudwatchLog
        case ssmAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationEventResourceType] {
            return [
                .cloudformation,
                .cloudwatchAlarm,
                .cloudwatchLog,
                .ssmAssociation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
            case .cloudwatchLog: return "CLOUDWATCH_LOG"
            case .ssmAssociation: return "SSM_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum ConfigurationEventStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationEventStatus] {
            return [
                .error,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// The event information.
    public struct ConfigurationEvent {
        /// The AWS account ID for the owner of the application to which the configuration event belongs.
        public var accountId: Swift.String?
        /// The details of the event in plain text.
        public var eventDetail: Swift.String?
        /// The name of the resource Application Insights attempted to configure.
        public var eventResourceName: Swift.String?
        /// The resource type that Application Insights attempted to configure, for example, CLOUDWATCH_ALARM.
        public var eventResourceType: ApplicationInsightsClientTypes.ConfigurationEventResourceType?
        /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
        public var eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
        /// The timestamp of the event.
        public var eventTime: Foundation.Date?
        /// The resource monitored by Application Insights.
        public var monitoredResourceARN: Swift.String?
        /// The name of the resource group of the application to which the configuration event belongs.
        public var resourceGroupName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            eventDetail: Swift.String? = nil,
            eventResourceName: Swift.String? = nil,
            eventResourceType: ApplicationInsightsClientTypes.ConfigurationEventResourceType? = nil,
            eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus? = nil,
            eventTime: Foundation.Date? = nil,
            monitoredResourceARN: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.eventDetail = eventDetail
            self.eventResourceName = eventResourceName
            self.eventResourceType = eventResourceType
            self.eventStatus = eventStatus
            self.eventTime = eventTime
            self.monitoredResourceARN = monitoredResourceARN
            self.resourceGroupName = resourceGroupName
        }
    }

}

/// Tags are already registered for the specified application ARN.
public struct TagsAlreadyExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsAlreadyExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ApplicationInsightsClientTypes {

    public enum GroupingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountBased
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupingType] {
            return [
                .accountBased
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountBased: return "ACCOUNT_BASED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// An object that defines the tags associated with an application. A tag is a label that you optionally define and associate with an application. Tags can help you categorize and manage resources in different ways, such as by purpose, owner, environment, or other criteria. Each tag consists of a required tag key and an associated tag value, both of which you define. A tag key is a general label that acts as a category for a more specific tag value. A tag value acts as a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag value can contain as many as 256 characters. The characters can be Unicode letters, digits, white space, or one of the following symbols: _ . : / = + -. The following additional restrictions apply to tags:
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * For each associated resource, each tag key must be unique and it can have only one value.
    ///
    /// * The aws: prefix is reserved for use by AWS; you can’t use it in any tag keys or values that you define. In addition, you can't edit or remove tag keys or values that use this prefix.
    public struct Tag {
        /// One part of a key-value pair that defines a tag. The maximum length of a tag key is 128 characters. The minimum length is 1 character.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that defines a tag. The maximum length of a tag value is 256 characters. The minimum length is 0 characters. If you don't want an application to have a specific tag value, don't specify a value for this parameter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateApplicationInput {
    /// If set to true, the managed policies for SSM and CW will be attached to the instance roles if they are missing.
    public var attachMissingPermission: Swift.Bool?
    /// Indicates whether Application Insights automatically configures unmonitored resources in the resource group.
    public var autoConfigEnabled: Swift.Bool?
    /// Configures all of the resources in the resource group by applying the recommended configurations.
    public var autoCreate: Swift.Bool?
    /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
    public var cweMonitorEnabled: Swift.Bool?
    /// Application Insights can create applications based on a resource group or on an account. To create an account-based application using all of the resources in the account, set this parameter to ACCOUNT_BASED.
    public var groupingType: ApplicationInsightsClientTypes.GroupingType?
    /// When set to true, creates opsItems for any problems detected on an application.
    public var opsCenterEnabled: Swift.Bool?
    /// The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
    public var opsItemSNSTopicArn: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?
    /// List of tags to add to the application. tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init(
        attachMissingPermission: Swift.Bool? = nil,
        autoConfigEnabled: Swift.Bool? = nil,
        autoCreate: Swift.Bool? = nil,
        cweMonitorEnabled: Swift.Bool? = nil,
        groupingType: ApplicationInsightsClientTypes.GroupingType? = nil,
        opsCenterEnabled: Swift.Bool? = nil,
        opsItemSNSTopicArn: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.attachMissingPermission = attachMissingPermission
        self.autoConfigEnabled = autoConfigEnabled
        self.autoCreate = autoCreate
        self.cweMonitorEnabled = cweMonitorEnabled
        self.groupingType = groupingType
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.resourceGroupName = resourceGroupName
        self.tags = tags
    }
}

public struct CreateApplicationOutput {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init(
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

public struct CreateComponentInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The list of resource ARNs that belong to the component.
    /// This member is required.
    public var resourceList: [Swift.String]?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

public struct CreateComponentOutput {

    public init() { }
}

public struct CreateLogPatternInput {
    /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
    /// This member is required.
    public var pattern: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
    /// This member is required.
    public var rank: Swift.Int?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        pattern: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        rank: Swift.Int? = 0,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

extension ApplicationInsightsClientTypes {
    /// An object that defines the log patterns that belongs to a LogPatternSet.
    public struct LogPattern {
        /// A regular expression that defines the log pattern. A log pattern can contain as many as 50 characters, and it cannot be empty. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
        public var pattern: Swift.String?
        /// The name of the log pattern. A log pattern name can contain as many as 50 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public var patternName: Swift.String?
        /// The name of the log pattern. A log pattern name can contain as many as 30 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public var patternSetName: Swift.String?
        /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
        public var rank: Swift.Int

        public init(
            pattern: Swift.String? = nil,
            patternName: Swift.String? = nil,
            patternSetName: Swift.String? = nil,
            rank: Swift.Int = 0
        )
        {
            self.pattern = pattern
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.rank = rank
        }
    }

}

public struct CreateLogPatternOutput {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

public struct DeleteApplicationInput {
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        resourceGroupName: Swift.String? = nil
    )
    {
        self.resourceGroupName = resourceGroupName
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

public struct DeleteComponentInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

public struct DeleteComponentOutput {

    public init() { }
}

public struct DeleteLogPatternInput {
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

public struct DeleteLogPatternOutput {

    public init() { }
}

public struct DescribeApplicationInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.resourceGroupName = resourceGroupName
    }
}

public struct DescribeApplicationOutput {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init(
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

public struct DescribeComponentInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

public struct DescribeComponentOutput {
    /// Describes a standalone resource or similarly grouped resources that the application is made up of.
    public var applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent?
    /// The list of resource ARNs that belong to the component.
    public var resourceList: [Swift.String]?

    public init(
        applicationComponent: ApplicationInsightsClientTypes.ApplicationComponent? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.applicationComponent = applicationComponent
        self.resourceList = resourceList
    }
}

public struct DescribeComponentConfigurationInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

public struct DescribeComponentConfigurationOutput {
    /// The configuration settings of the component. The value is the escaped JSON of the configuration.
    public var componentConfiguration: Swift.String?
    /// Indicates whether the application component is monitored.
    public var monitor: Swift.Bool?
    /// The tier of the application component. Supported tiers include DOT_NET_CORE, DOT_NET_WORKER, DOT_NET_WEB, SQL_SERVER, and DEFAULT
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init(
        componentConfiguration: Swift.String? = nil,
        monitor: Swift.Bool? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
        self.monitor = monitor
        self.tier = tier
    }
}

extension ApplicationInsightsClientTypes {

    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case infraOnly
        case workloadOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .all,
                .infraOnly,
                .workloadOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .infraOnly: return "INFRA_ONLY"
            case .workloadOnly: return "WORKLOAD_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeComponentConfigurationRecommendationInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The recommended configuration type.
    public var recommendationType: ApplicationInsightsClientTypes.RecommendationType?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The tier of the application component.
    /// This member is required.
    public var tier: ApplicationInsightsClientTypes.Tier?
    /// The name of the workload.
    public var workloadName: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        recommendationType: ApplicationInsightsClientTypes.RecommendationType? = nil,
        resourceGroupName: Swift.String? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.recommendationType = recommendationType
        self.resourceGroupName = resourceGroupName
        self.tier = tier
        self.workloadName = workloadName
    }
}

public struct DescribeComponentConfigurationRecommendationOutput {
    /// The recommended configuration settings of the component. The value is the escaped JSON of the configuration.
    public var componentConfiguration: Swift.String?

    public init(
        componentConfiguration: Swift.String? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
    }
}

public struct DescribeLogPatternInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

public struct DescribeLogPatternOutput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

public struct DescribeObservationInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The ID of the observation.
    /// This member is required.
    public var observationId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        observationId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.observationId = observationId
    }
}

extension ApplicationInsightsClientTypes {

    public enum LogFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogFilter] {
            return [
                .error,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes an anomaly or error with the application.
    public struct Observation {
        /// The detail type of the CloudWatch Event-based observation, for example, EC2 Instance State-change Notification.
        public var cloudWatchEventDetailType: Swift.String?
        /// The ID of the CloudWatch Event-based observation related to the detected problem.
        public var cloudWatchEventId: Swift.String?
        /// The source of the CloudWatch Event.
        public var cloudWatchEventSource: ApplicationInsightsClientTypes.CloudWatchEventSource?
        /// The CodeDeploy application to which the deployment belongs.
        public var codeDeployApplication: Swift.String?
        /// The deployment group to which the CodeDeploy deployment belongs.
        public var codeDeployDeploymentGroup: Swift.String?
        /// The deployment ID of the CodeDeploy-based observation related to the detected problem.
        public var codeDeployDeploymentId: Swift.String?
        /// The instance group to which the CodeDeploy instance belongs.
        public var codeDeployInstanceGroupId: Swift.String?
        /// The status of the CodeDeploy deployment, for example SUCCESS or  FAILURE.
        public var codeDeployState: Swift.String?
        /// The cause of an EBS CloudWatch event.
        public var ebsCause: Swift.String?
        /// The type of EBS CloudWatch event, such as createVolume, deleteVolume or attachVolume.
        public var ebsEvent: Swift.String?
        /// The request ID of an EBS CloudWatch event.
        public var ebsRequestId: Swift.String?
        /// The result of an EBS CloudWatch event, such as failed or succeeded.
        public var ebsResult: Swift.String?
        /// The state of the instance, such as STOPPING or TERMINATING.
        public var ec2State: Swift.String?
        /// The time when the observation ended, in epoch seconds.
        public var endTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the AWS Health Event-based observation.
        public var healthEventArn: Swift.String?
        /// The description of the AWS Health event provided by the service, such as Amazon EC2.
        public var healthEventDescription: Swift.String?
        /// The category of the AWS Health event, such as issue.
        public var healthEventTypeCategory: Swift.String?
        /// The type of the AWS Health event, for example, AWS_EC2_POWER_CONNECTIVITY_ISSUE.
        public var healthEventTypeCode: Swift.String?
        /// The service to which the AWS Health Event belongs, such as EC2.
        public var healthService: Swift.String?
        /// The ID of the observation type.
        public var id: Swift.String?
        /// The timestamp in the CloudWatch Logs that specifies when the matched line occurred.
        public var lineTime: Foundation.Date?
        /// The log filter of the observation.
        public var logFilter: ApplicationInsightsClientTypes.LogFilter?
        /// The log group name.
        public var logGroup: Swift.String?
        /// The log text of the observation.
        public var logText: Swift.String?
        /// The name of the observation metric.
        public var metricName: Swift.String?
        /// The namespace of the observation metric.
        public var metricNamespace: Swift.String?
        /// The category of an RDS event.
        public var rdsEventCategories: Swift.String?
        /// The message of an RDS event.
        public var rdsEventMessage: Swift.String?
        /// The name of the S3 CloudWatch Event-based observation.
        public var s3EventName: Swift.String?
        /// The source resource ARN of the observation.
        public var sourceARN: Swift.String?
        /// The source type of the observation.
        public var sourceType: Swift.String?
        /// The time when the observation was first detected, in epoch seconds.
        public var startTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the step function-based observation.
        public var statesArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the step function execution-based observation.
        public var statesExecutionArn: Swift.String?
        /// The input to the step function-based observation.
        public var statesInput: Swift.String?
        /// The status of the step function-related observation.
        public var statesStatus: Swift.String?
        /// The unit of the source observation metric.
        public var unit: Swift.String?
        /// The value of the source observation metric.
        public var value: Swift.Double?
        /// The X-Ray request error percentage for this node.
        public var xRayErrorPercent: Swift.Int?
        /// The X-Ray request fault percentage for this node.
        public var xRayFaultPercent: Swift.Int?
        /// The name of the X-Ray node.
        public var xRayNodeName: Swift.String?
        /// The type of the X-Ray node.
        public var xRayNodeType: Swift.String?
        /// The X-Ray node request average latency for this node.
        public var xRayRequestAverageLatency: Swift.Int?
        /// The X-Ray request count for this node.
        public var xRayRequestCount: Swift.Int?
        /// The X-Ray request throttle percentage for this node.
        public var xRayThrottlePercent: Swift.Int?

        public init(
            cloudWatchEventDetailType: Swift.String? = nil,
            cloudWatchEventId: Swift.String? = nil,
            cloudWatchEventSource: ApplicationInsightsClientTypes.CloudWatchEventSource? = nil,
            codeDeployApplication: Swift.String? = nil,
            codeDeployDeploymentGroup: Swift.String? = nil,
            codeDeployDeploymentId: Swift.String? = nil,
            codeDeployInstanceGroupId: Swift.String? = nil,
            codeDeployState: Swift.String? = nil,
            ebsCause: Swift.String? = nil,
            ebsEvent: Swift.String? = nil,
            ebsRequestId: Swift.String? = nil,
            ebsResult: Swift.String? = nil,
            ec2State: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            healthEventArn: Swift.String? = nil,
            healthEventDescription: Swift.String? = nil,
            healthEventTypeCategory: Swift.String? = nil,
            healthEventTypeCode: Swift.String? = nil,
            healthService: Swift.String? = nil,
            id: Swift.String? = nil,
            lineTime: Foundation.Date? = nil,
            logFilter: ApplicationInsightsClientTypes.LogFilter? = nil,
            logGroup: Swift.String? = nil,
            logText: Swift.String? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            rdsEventCategories: Swift.String? = nil,
            rdsEventMessage: Swift.String? = nil,
            s3EventName: Swift.String? = nil,
            sourceARN: Swift.String? = nil,
            sourceType: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            statesArn: Swift.String? = nil,
            statesExecutionArn: Swift.String? = nil,
            statesInput: Swift.String? = nil,
            statesStatus: Swift.String? = nil,
            unit: Swift.String? = nil,
            value: Swift.Double? = nil,
            xRayErrorPercent: Swift.Int? = nil,
            xRayFaultPercent: Swift.Int? = nil,
            xRayNodeName: Swift.String? = nil,
            xRayNodeType: Swift.String? = nil,
            xRayRequestAverageLatency: Swift.Int? = nil,
            xRayRequestCount: Swift.Int? = nil,
            xRayThrottlePercent: Swift.Int? = nil
        )
        {
            self.cloudWatchEventDetailType = cloudWatchEventDetailType
            self.cloudWatchEventId = cloudWatchEventId
            self.cloudWatchEventSource = cloudWatchEventSource
            self.codeDeployApplication = codeDeployApplication
            self.codeDeployDeploymentGroup = codeDeployDeploymentGroup
            self.codeDeployDeploymentId = codeDeployDeploymentId
            self.codeDeployInstanceGroupId = codeDeployInstanceGroupId
            self.codeDeployState = codeDeployState
            self.ebsCause = ebsCause
            self.ebsEvent = ebsEvent
            self.ebsRequestId = ebsRequestId
            self.ebsResult = ebsResult
            self.ec2State = ec2State
            self.endTime = endTime
            self.healthEventArn = healthEventArn
            self.healthEventDescription = healthEventDescription
            self.healthEventTypeCategory = healthEventTypeCategory
            self.healthEventTypeCode = healthEventTypeCode
            self.healthService = healthService
            self.id = id
            self.lineTime = lineTime
            self.logFilter = logFilter
            self.logGroup = logGroup
            self.logText = logText
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.rdsEventCategories = rdsEventCategories
            self.rdsEventMessage = rdsEventMessage
            self.s3EventName = s3EventName
            self.sourceARN = sourceARN
            self.sourceType = sourceType
            self.startTime = startTime
            self.statesArn = statesArn
            self.statesExecutionArn = statesExecutionArn
            self.statesInput = statesInput
            self.statesStatus = statesStatus
            self.unit = unit
            self.value = value
            self.xRayErrorPercent = xRayErrorPercent
            self.xRayFaultPercent = xRayFaultPercent
            self.xRayNodeName = xRayNodeName
            self.xRayNodeType = xRayNodeType
            self.xRayRequestAverageLatency = xRayRequestAverageLatency
            self.xRayRequestCount = xRayRequestCount
            self.xRayThrottlePercent = xRayThrottlePercent
        }
    }

}

public struct DescribeObservationOutput {
    /// Information about the observation.
    public var observation: ApplicationInsightsClientTypes.Observation?

    public init(
        observation: ApplicationInsightsClientTypes.Observation? = nil
    )
    {
        self.observation = observation
    }
}

public struct DescribeProblemInput {
    /// The AWS account ID for the owner of the resource group affected by the problem.
    public var accountId: Swift.String?
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        problemId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.problemId = problemId
    }
}

extension ApplicationInsightsClientTypes {

    public enum FeedbackKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insightsFeedback
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackKey] {
            return [
                .insightsFeedback
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insightsFeedback: return "INSIGHTS_FEEDBACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum FeedbackValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notSpecified
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackValue] {
            return [
                .notSpecified,
                .notUseful,
                .useful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notSpecified: return "NOT_SPECIFIED"
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum ResolutionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case manual
        case unresolved
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionMethod] {
            return [
                .automatic,
                .manual,
                .unresolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case .unresolved: return "UNRESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum SeverityLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case informative
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityLevel] {
            return [
                .high,
                .informative,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .informative: return "Informative"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ignore
        case pending
        case recovering
        case recurring
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .ignore,
                .pending,
                .recovering,
                .recurring,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ignore: return "IGNORE"
            case .pending: return "PENDING"
            case .recovering: return "RECOVERING"
            case .recurring: return "RECURRING"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {

    public enum Visibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ignored
        case visible
        case sdkUnknown(Swift.String)

        public static var allCases: [Visibility] {
            return [
                .ignored,
                .visible
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ignored: return "IGNORED"
            case .visible: return "VISIBLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes a problem that is detected by correlating observations.
    public struct Problem {
        /// The AWS account ID for the owner of the resource group affected by the problem.
        public var accountId: Swift.String?
        /// The resource affected by the problem.
        public var affectedResource: Swift.String?
        /// The time when the problem ended, in epoch seconds.
        public var endTime: Foundation.Date?
        /// Feedback provided by the user about the problem.
        public var feedback: [Swift.String: ApplicationInsightsClientTypes.FeedbackValue]?
        /// The ID of the problem.
        public var id: Swift.String?
        /// A detailed analysis of the problem using machine learning.
        public var insights: Swift.String?
        /// The last time that the problem reoccurred after its last resolution.
        public var lastRecurrenceTime: Foundation.Date?
        /// The number of times that the same problem reoccurred after the first time it was resolved.
        public var recurringCount: Swift.Int?
        /// Specifies how the problem was resolved. If the value is AUTOMATIC, the system resolved the problem. If the value is MANUAL, the user resolved the problem. If the value is UNRESOLVED, then the problem is not resolved.
        public var resolutionMethod: ApplicationInsightsClientTypes.ResolutionMethod?
        /// The name of the resource group affected by the problem.
        public var resourceGroupName: Swift.String?
        /// A measure of the level of impact of the problem.
        public var severityLevel: ApplicationInsightsClientTypes.SeverityLevel?
        /// The time when the problem started, in epoch seconds.
        public var startTime: Foundation.Date?
        /// The status of the problem.
        public var status: ApplicationInsightsClientTypes.Status?
        /// The name of the problem.
        public var title: Swift.String?
        /// Specifies whether or not you can view the problem. Updates to ignored problems do not generate notifications.
        public var visibility: ApplicationInsightsClientTypes.Visibility?

        public init(
            accountId: Swift.String? = nil,
            affectedResource: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            feedback: [Swift.String: ApplicationInsightsClientTypes.FeedbackValue]? = nil,
            id: Swift.String? = nil,
            insights: Swift.String? = nil,
            lastRecurrenceTime: Foundation.Date? = nil,
            recurringCount: Swift.Int? = nil,
            resolutionMethod: ApplicationInsightsClientTypes.ResolutionMethod? = nil,
            resourceGroupName: Swift.String? = nil,
            severityLevel: ApplicationInsightsClientTypes.SeverityLevel? = nil,
            startTime: Foundation.Date? = nil,
            status: ApplicationInsightsClientTypes.Status? = nil,
            title: Swift.String? = nil,
            visibility: ApplicationInsightsClientTypes.Visibility? = nil
        )
        {
            self.accountId = accountId
            self.affectedResource = affectedResource
            self.endTime = endTime
            self.feedback = feedback
            self.id = id
            self.insights = insights
            self.lastRecurrenceTime = lastRecurrenceTime
            self.recurringCount = recurringCount
            self.resolutionMethod = resolutionMethod
            self.resourceGroupName = resourceGroupName
            self.severityLevel = severityLevel
            self.startTime = startTime
            self.status = status
            self.title = title
            self.visibility = visibility
        }
    }

}

public struct DescribeProblemOutput {
    /// Information about the problem.
    public var problem: ApplicationInsightsClientTypes.Problem?

    public init(
        problem: ApplicationInsightsClientTypes.Problem? = nil
    )
    {
        self.problem = problem
    }
}

public struct DescribeProblemObservationsInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        problemId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.problemId = problemId
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes observations related to the problem.
    public struct RelatedObservations {
        /// The list of observations related to the problem.
        public var observationList: [ApplicationInsightsClientTypes.Observation]?

        public init(
            observationList: [ApplicationInsightsClientTypes.Observation]? = nil
        )
        {
            self.observationList = observationList
        }
    }

}

public struct DescribeProblemObservationsOutput {
    /// Observations related to the problem.
    public var relatedObservations: ApplicationInsightsClientTypes.RelatedObservations?

    public init(
        relatedObservations: ApplicationInsightsClientTypes.RelatedObservations? = nil
    )
    {
        self.relatedObservations = relatedObservations
    }
}

public struct DescribeWorkloadInput {
    /// The AWS account ID for the workload owner.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The ID of the workload.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadId = workloadId
    }
}

public struct DescribeWorkloadOutput {
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?
    /// If logging is supported for the resource type, shows whether the component has configured logs to be monitored.
    public var workloadRemarks: Swift.String?

    public init(
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil,
        workloadRemarks: Swift.String? = nil
    )
    {
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
        self.workloadRemarks = workloadRemarks
    }
}

public struct ListApplicationsInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput {
    /// The list of applications.
    public var applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        applicationInfoList: [ApplicationInsightsClientTypes.ApplicationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInfoList = applicationInfoList
        self.nextToken = nextToken
    }
}

public struct ListComponentsInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

public struct ListComponentsOutput {
    /// The list of application components.
    public var applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationComponentList: [ApplicationInsightsClientTypes.ApplicationComponent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationComponentList = applicationComponentList
        self.nextToken = nextToken
    }
}

public struct ListConfigurationHistoryInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The end time of the event.
    public var endTime: Foundation.Date?
    /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
    public var eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus?
    /// The maximum number of results returned by ListConfigurationHistory in paginated output. When this parameter is used, ListConfigurationHistory returns only MaxResults in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another ListConfigurationHistory request with the returned NextToken value. If this parameter is not used, then ListConfigurationHistory returns all results.
    public var maxResults: Swift.Int?
    /// The NextToken value returned from a previous paginated ListConfigurationHistory request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Resource group to which the application belongs.
    public var resourceGroupName: Swift.String?
    /// The start time of the event.
    public var startTime: Foundation.Date?

    public init(
        accountId: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        eventStatus: ApplicationInsightsClientTypes.ConfigurationEventStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.accountId = accountId
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
    }
}

public struct ListConfigurationHistoryOutput {
    /// The list of configuration events and their corresponding details.
    public var eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]?
    /// The NextToken value to include in a future ListConfigurationHistory request. When the results of a ListConfigurationHistory request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        eventList: [ApplicationInsightsClientTypes.ConfigurationEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventList = eventList
        self.nextToken = nextToken
    }
}

public struct ListLogPatternsInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the log pattern set.
    public var patternSetName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

public struct ListLogPatternsOutput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The list of log patterns.
    public var logPatterns: [ApplicationInsightsClientTypes.LogPattern]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        logPatterns: [ApplicationInsightsClientTypes.LogPattern]? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.logPatterns = logPatterns
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

public struct ListLogPatternSetsInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

public struct ListLogPatternSetsOutput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The list of log pattern sets.
    public var logPatternSets: [Swift.String]?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        logPatternSets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.logPatternSets = logPatternSets
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

public struct ListProblemsInput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The name of the component.
    public var componentName: Swift.String?
    /// The time when the problem ended, in epoch seconds. If not specified, problems within the past seven days are returned.
    public var endTime: Foundation.Date?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?
    /// The time when the problem was detected, in epoch seconds. If you don't specify a time frame for the request, problems within the past seven days are returned.
    public var startTime: Foundation.Date?
    /// Specifies whether or not you can view the problem. If not specified, visible and ignored problems are returned.
    public var visibility: ApplicationInsightsClientTypes.Visibility?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        visibility: ApplicationInsightsClientTypes.Visibility? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
        self.visibility = visibility
    }
}

public struct ListProblemsOutput {
    /// The AWS account ID for the resource group owner.
    public var accountId: Swift.String?
    /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of problems.
    public var problemList: [ApplicationInsightsClientTypes.Problem]?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        problemList: [ApplicationInsightsClientTypes.Problem]? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
        self.problemList = problemList
        self.resourceGroupName = resourceGroupName
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the application that you want to retrieve tag information for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// An array that lists all the tags that are associated with the application. Each tag consists of a required tag key (Key) and an associated tag value (Value).
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init(
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWorkloadsInput {
    /// The AWS account ID of the owner of the workload.
    public var accountId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        componentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.componentName = componentName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

extension ApplicationInsightsClientTypes {
    /// Describes the workloads on a component.
    public struct Workload {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The tier of the workload.
        public var tier: ApplicationInsightsClientTypes.Tier?
        /// The ID of the workload.
        public var workloadId: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?
        /// If logging is supported for the resource type, shows whether the component has configured logs to be monitored.
        public var workloadRemarks: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            tier: ApplicationInsightsClientTypes.Tier? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil,
            workloadRemarks: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.tier = tier
            self.workloadId = workloadId
            self.workloadName = workloadName
            self.workloadRemarks = workloadRemarks
        }
    }

}

public struct ListWorkloadsOutput {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The list of workloads.
    public var workloadList: [ApplicationInsightsClientTypes.Workload]?

    public init(
        nextToken: Swift.String? = nil,
        workloadList: [ApplicationInsightsClientTypes.Workload]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadList = workloadList
    }
}

public struct RemoveWorkloadInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The ID of the workload.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadId = workloadId
    }
}

public struct RemoveWorkloadOutput {

    public init() { }
}

/// The number of the provided tags is beyond the limit, or the number of total tags you are trying to attach to the specified resource exceeds the limit.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the application that you want to add one or more tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags that to add to the application. A tag consists of a required tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
    /// This member is required.
    public var tags: [ApplicationInsightsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ApplicationInsightsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the application that you want to remove one or more tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags (tag keys) that you want to remove from the resource. When you specify a tag key, the action removes both that key and its associated tag value. To remove more than one tag from the application, append the TagKeys parameter and argument for each additional tag to remove, separated by an ampersand.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateApplicationInput {
    /// If set to true, the managed policies for SSM and CW will be attached to the instance roles if they are missing.
    public var attachMissingPermission: Swift.Bool?
    /// Turns auto-configuration on or off.
    public var autoConfigEnabled: Swift.Bool?
    /// Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
    public var cweMonitorEnabled: Swift.Bool?
    /// When set to true, creates opsItems for any problems detected on an application.
    public var opsCenterEnabled: Swift.Bool?
    /// The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
    public var opsItemSNSTopicArn: Swift.String?
    /// Disassociates the SNS topic from the opsItem created for detected problems.
    public var removeSNSTopic: Swift.Bool?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        attachMissingPermission: Swift.Bool? = nil,
        autoConfigEnabled: Swift.Bool? = nil,
        cweMonitorEnabled: Swift.Bool? = nil,
        opsCenterEnabled: Swift.Bool? = nil,
        opsItemSNSTopicArn: Swift.String? = nil,
        removeSNSTopic: Swift.Bool? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.attachMissingPermission = attachMissingPermission
        self.autoConfigEnabled = autoConfigEnabled
        self.cweMonitorEnabled = cweMonitorEnabled
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.removeSNSTopic = removeSNSTopic
        self.resourceGroupName = resourceGroupName
    }
}

public struct UpdateApplicationOutput {
    /// Information about the application.
    public var applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo?

    public init(
        applicationInfo: ApplicationInsightsClientTypes.ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

public struct UpdateComponentInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The new name of the component.
    public var newComponentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The list of resource ARNs that belong to the component.
    public var resourceList: [Swift.String]?

    public init(
        componentName: Swift.String? = nil,
        newComponentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        resourceList: [Swift.String]? = nil
    )
    {
        self.componentName = componentName
        self.newComponentName = newComponentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

public struct UpdateComponentOutput {

    public init() { }
}

public struct UpdateComponentConfigurationInput {
    /// Automatically configures the component by applying the recommended configurations.
    public var autoConfigEnabled: Swift.Bool?
    /// The configuration settings of the component. The value is the escaped JSON of the configuration. For more information about the JSON format, see [Working with JSON](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/working-with-json.html). You can send a request to DescribeComponentConfigurationRecommendation to see the recommended configuration for a component. For the complete format of the component configuration file, see [Component Configuration](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/component-config.html).
    public var componentConfiguration: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// Indicates whether the application component is monitored.
    public var monitor: Swift.Bool?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The tier of the application component.
    public var tier: ApplicationInsightsClientTypes.Tier?

    public init(
        autoConfigEnabled: Swift.Bool? = nil,
        componentConfiguration: Swift.String? = nil,
        componentName: Swift.String? = nil,
        monitor: Swift.Bool? = nil,
        resourceGroupName: Swift.String? = nil,
        tier: ApplicationInsightsClientTypes.Tier? = nil
    )
    {
        self.autoConfigEnabled = autoConfigEnabled
        self.componentConfiguration = componentConfiguration
        self.componentName = componentName
        self.monitor = monitor
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

public struct UpdateComponentConfigurationOutput {

    public init() { }
}

public struct UpdateLogPatternInput {
    /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
    public var pattern: Swift.String?
    /// The name of the log pattern.
    /// This member is required.
    public var patternName: Swift.String?
    /// The name of the log pattern set.
    /// This member is required.
    public var patternSetName: Swift.String?
    /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
    public var rank: Swift.Int?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?

    public init(
        pattern: Swift.String? = nil,
        patternName: Swift.String? = nil,
        patternSetName: Swift.String? = nil,
        rank: Swift.Int? = 0,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

public struct UpdateLogPatternOutput {
    /// The successfully created log pattern.
    public var logPattern: ApplicationInsightsClientTypes.LogPattern?
    /// The name of the resource group.
    public var resourceGroupName: Swift.String?

    public init(
        logPattern: ApplicationInsightsClientTypes.LogPattern? = nil,
        resourceGroupName: Swift.String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

extension ApplicationInsightsClientTypes {

    public enum UpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateStatus] {
            return [
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateProblemInput {
    /// The ID of the problem.
    /// This member is required.
    public var problemId: Swift.String?
    /// The status of the problem. Arguments can be passed for only problems that show a status of RECOVERING.
    public var updateStatus: ApplicationInsightsClientTypes.UpdateStatus?
    /// The visibility of a problem. When you pass a value of IGNORED, the problem is removed from the default view, and all notifications for the problem are suspended. When VISIBLE is passed, the IGNORED action is reversed.
    public var visibility: ApplicationInsightsClientTypes.Visibility?

    public init(
        problemId: Swift.String? = nil,
        updateStatus: ApplicationInsightsClientTypes.UpdateStatus? = nil,
        visibility: ApplicationInsightsClientTypes.Visibility? = nil
    )
    {
        self.problemId = problemId
        self.updateStatus = updateStatus
        self.visibility = visibility
    }
}

public struct UpdateProblemOutput {

    public init() { }
}

public struct UpdateWorkloadInput {
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The name of the resource group.
    /// This member is required.
    public var resourceGroupName: Swift.String?
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    /// This member is required.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        resourceGroupName: Swift.String? = nil,
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
    }
}

public struct UpdateWorkloadOutput {
    /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
    public var workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration?
    /// The ID of the workload.
    public var workloadId: Swift.String?

    public init(
        workloadConfiguration: ApplicationInsightsClientTypes.WorkloadConfiguration? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadConfiguration = workloadConfiguration
        self.workloadId = workloadId
    }
}

extension AddWorkloadInput {

    static func urlPathProvider(_ value: AddWorkloadInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateComponentInput {

    static func urlPathProvider(_ value: CreateComponentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLogPatternInput {

    static func urlPathProvider(_ value: CreateLogPatternInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteComponentInput {

    static func urlPathProvider(_ value: DeleteComponentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLogPatternInput {

    static func urlPathProvider(_ value: DeleteLogPatternInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationInput {

    static func urlPathProvider(_ value: DescribeApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeComponentInput {

    static func urlPathProvider(_ value: DescribeComponentInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeComponentConfigurationInput {

    static func urlPathProvider(_ value: DescribeComponentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeComponentConfigurationRecommendationInput {

    static func urlPathProvider(_ value: DescribeComponentConfigurationRecommendationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLogPatternInput {

    static func urlPathProvider(_ value: DescribeLogPatternInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeObservationInput {

    static func urlPathProvider(_ value: DescribeObservationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProblemInput {

    static func urlPathProvider(_ value: DescribeProblemInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProblemObservationsInput {

    static func urlPathProvider(_ value: DescribeProblemObservationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkloadInput {

    static func urlPathProvider(_ value: DescribeWorkloadInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListComponentsInput {

    static func urlPathProvider(_ value: ListComponentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListConfigurationHistoryInput {

    static func urlPathProvider(_ value: ListConfigurationHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListLogPatternsInput {

    static func urlPathProvider(_ value: ListLogPatternsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLogPatternSetsInput {

    static func urlPathProvider(_ value: ListLogPatternSetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListProblemsInput {

    static func urlPathProvider(_ value: ListProblemsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkloadsInput {

    static func urlPathProvider(_ value: ListWorkloadsInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveWorkloadInput {

    static func urlPathProvider(_ value: RemoveWorkloadInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateComponentInput {

    static func urlPathProvider(_ value: UpdateComponentInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateComponentConfigurationInput {

    static func urlPathProvider(_ value: UpdateComponentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLogPatternInput {

    static func urlPathProvider(_ value: UpdateLogPatternInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProblemInput {

    static func urlPathProvider(_ value: UpdateProblemInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkloadInput {

    static func urlPathProvider(_ value: UpdateWorkloadInput) -> Swift.String? {
        return "/"
    }
}

extension AddWorkloadInput {

    static func write(value: AddWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["WorkloadConfiguration"].write(value.workloadConfiguration, with: ApplicationInsightsClientTypes.WorkloadConfiguration.write(value:to:))
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachMissingPermission"].write(value.attachMissingPermission)
        try writer["AutoConfigEnabled"].write(value.autoConfigEnabled)
        try writer["AutoCreate"].write(value.autoCreate)
        try writer["CWEMonitorEnabled"].write(value.cweMonitorEnabled)
        try writer["GroupingType"].write(value.groupingType)
        try writer["OpsCenterEnabled"].write(value.opsCenterEnabled)
        try writer["OpsItemSNSTopicArn"].write(value.opsItemSNSTopicArn)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ApplicationInsightsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateComponentInput {

    static func write(value: CreateComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["ResourceList"].writeList(value.resourceList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLogPatternInput {

    static func write(value: CreateLogPatternInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Pattern"].write(value.pattern)
        try writer["PatternName"].write(value.patternName)
        try writer["PatternSetName"].write(value.patternSetName)
        try writer["Rank"].write(value.rank)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DeleteApplicationInput {

    static func write(value: DeleteApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DeleteComponentInput {

    static func write(value: DeleteComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DeleteLogPatternInput {

    static func write(value: DeleteLogPatternInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PatternName"].write(value.patternName)
        try writer["PatternSetName"].write(value.patternSetName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DescribeApplicationInput {

    static func write(value: DescribeApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DescribeComponentInput {

    static func write(value: DescribeComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DescribeComponentConfigurationInput {

    static func write(value: DescribeComponentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DescribeComponentConfigurationRecommendationInput {

    static func write(value: DescribeComponentConfigurationRecommendationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["RecommendationType"].write(value.recommendationType)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["Tier"].write(value.tier)
        try writer["WorkloadName"].write(value.workloadName)
    }
}

extension DescribeLogPatternInput {

    static func write(value: DescribeLogPatternInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["PatternName"].write(value.patternName)
        try writer["PatternSetName"].write(value.patternSetName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension DescribeObservationInput {

    static func write(value: DescribeObservationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ObservationId"].write(value.observationId)
    }
}

extension DescribeProblemInput {

    static func write(value: DescribeProblemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ProblemId"].write(value.problemId)
    }
}

extension DescribeProblemObservationsInput {

    static func write(value: DescribeProblemObservationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ProblemId"].write(value.problemId)
    }
}

extension DescribeWorkloadInput {

    static func write(value: DescribeWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["WorkloadId"].write(value.workloadId)
    }
}

extension ListApplicationsInput {

    static func write(value: ListApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListComponentsInput {

    static func write(value: ListComponentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension ListConfigurationHistoryInput {

    static func write(value: ListConfigurationHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["EventStatus"].write(value.eventStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListLogPatternsInput {

    static func write(value: ListLogPatternsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PatternSetName"].write(value.patternSetName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension ListLogPatternSetsInput {

    static func write(value: ListLogPatternSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension ListProblemsInput {

    static func write(value: ListProblemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ComponentName"].write(value.componentName)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Visibility"].write(value.visibility)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ListWorkloadsInput {

    static func write(value: ListWorkloadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ComponentName"].write(value.componentName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension RemoveWorkloadInput {

    static func write(value: RemoveWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["WorkloadId"].write(value.workloadId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ApplicationInsightsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachMissingPermission"].write(value.attachMissingPermission)
        try writer["AutoConfigEnabled"].write(value.autoConfigEnabled)
        try writer["CWEMonitorEnabled"].write(value.cweMonitorEnabled)
        try writer["OpsCenterEnabled"].write(value.opsCenterEnabled)
        try writer["OpsItemSNSTopicArn"].write(value.opsItemSNSTopicArn)
        try writer["RemoveSNSTopic"].write(value.removeSNSTopic)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension UpdateComponentInput {

    static func write(value: UpdateComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["NewComponentName"].write(value.newComponentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["ResourceList"].writeList(value.resourceList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateComponentConfigurationInput {

    static func write(value: UpdateComponentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoConfigEnabled"].write(value.autoConfigEnabled)
        try writer["ComponentConfiguration"].write(value.componentConfiguration)
        try writer["ComponentName"].write(value.componentName)
        try writer["Monitor"].write(value.monitor)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["Tier"].write(value.tier)
    }
}

extension UpdateLogPatternInput {

    static func write(value: UpdateLogPatternInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Pattern"].write(value.pattern)
        try writer["PatternName"].write(value.patternName)
        try writer["PatternSetName"].write(value.patternSetName)
        try writer["Rank"].write(value.rank)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
    }
}

extension UpdateProblemInput {

    static func write(value: UpdateProblemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProblemId"].write(value.problemId)
        try writer["UpdateStatus"].write(value.updateStatus)
        try writer["Visibility"].write(value.visibility)
    }
}

extension UpdateWorkloadInput {

    static func write(value: UpdateWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentName"].write(value.componentName)
        try writer["ResourceGroupName"].write(value.resourceGroupName)
        try writer["WorkloadConfiguration"].write(value.workloadConfiguration, with: ApplicationInsightsClientTypes.WorkloadConfiguration.write(value:to:))
        try writer["WorkloadId"].write(value.workloadId)
    }
}

extension AddWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddWorkloadOutput()
        value.workloadConfiguration = try reader["WorkloadConfiguration"].readIfPresent(with: ApplicationInsightsClientTypes.WorkloadConfiguration.read(from:))
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationInfo = try reader["ApplicationInfo"].readIfPresent(with: ApplicationInsightsClientTypes.ApplicationInfo.read(from:))
        return value
    }
}

extension CreateComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateComponentOutput {
        return CreateComponentOutput()
    }
}

extension CreateLogPatternOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLogPatternOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLogPatternOutput()
        value.logPattern = try reader["LogPattern"].readIfPresent(with: ApplicationInsightsClientTypes.LogPattern.read(from:))
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteComponentOutput {
        return DeleteComponentOutput()
    }
}

extension DeleteLogPatternOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLogPatternOutput {
        return DeleteLogPatternOutput()
    }
}

extension DescribeApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationOutput()
        value.applicationInfo = try reader["ApplicationInfo"].readIfPresent(with: ApplicationInsightsClientTypes.ApplicationInfo.read(from:))
        return value
    }
}

extension DescribeComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeComponentOutput()
        value.applicationComponent = try reader["ApplicationComponent"].readIfPresent(with: ApplicationInsightsClientTypes.ApplicationComponent.read(from:))
        value.resourceList = try reader["ResourceList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeComponentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeComponentConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeComponentConfigurationOutput()
        value.componentConfiguration = try reader["ComponentConfiguration"].readIfPresent()
        value.monitor = try reader["Monitor"].readIfPresent()
        value.tier = try reader["Tier"].readIfPresent()
        return value
    }
}

extension DescribeComponentConfigurationRecommendationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeComponentConfigurationRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeComponentConfigurationRecommendationOutput()
        value.componentConfiguration = try reader["ComponentConfiguration"].readIfPresent()
        return value
    }
}

extension DescribeLogPatternOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLogPatternOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLogPatternOutput()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.logPattern = try reader["LogPattern"].readIfPresent(with: ApplicationInsightsClientTypes.LogPattern.read(from:))
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        return value
    }
}

extension DescribeObservationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeObservationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeObservationOutput()
        value.observation = try reader["Observation"].readIfPresent(with: ApplicationInsightsClientTypes.Observation.read(from:))
        return value
    }
}

extension DescribeProblemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProblemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProblemOutput()
        value.problem = try reader["Problem"].readIfPresent(with: ApplicationInsightsClientTypes.Problem.read(from:))
        return value
    }
}

extension DescribeProblemObservationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProblemObservationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProblemObservationsOutput()
        value.relatedObservations = try reader["RelatedObservations"].readIfPresent(with: ApplicationInsightsClientTypes.RelatedObservations.read(from:))
        return value
    }
}

extension DescribeWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkloadOutput()
        value.workloadConfiguration = try reader["WorkloadConfiguration"].readIfPresent(with: ApplicationInsightsClientTypes.WorkloadConfiguration.read(from:))
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadRemarks = try reader["WorkloadRemarks"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applicationInfoList = try reader["ApplicationInfoList"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.ApplicationInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentsOutput()
        value.applicationComponentList = try reader["ApplicationComponentList"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.ApplicationComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConfigurationHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigurationHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationHistoryOutput()
        value.eventList = try reader["EventList"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.ConfigurationEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLogPatternsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLogPatternsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLogPatternsOutput()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.logPatterns = try reader["LogPatterns"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.LogPattern.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        return value
    }
}

extension ListLogPatternSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLogPatternSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLogPatternSetsOutput()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.logPatternSets = try reader["LogPatternSets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        return value
    }
}

extension ListProblemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProblemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProblemsOutput()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.problemList = try reader["ProblemList"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.Problem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkloadsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadList = try reader["WorkloadList"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.Workload.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RemoveWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveWorkloadOutput {
        return RemoveWorkloadOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.applicationInfo = try reader["ApplicationInfo"].readIfPresent(with: ApplicationInsightsClientTypes.ApplicationInfo.read(from:))
        return value
    }
}

extension UpdateComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateComponentOutput {
        return UpdateComponentOutput()
    }
}

extension UpdateComponentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateComponentConfigurationOutput {
        return UpdateComponentConfigurationOutput()
    }
}

extension UpdateLogPatternOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLogPatternOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLogPatternOutput()
        value.logPattern = try reader["LogPattern"].readIfPresent(with: ApplicationInsightsClientTypes.LogPattern.read(from:))
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        return value
    }
}

extension UpdateProblemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProblemOutput {
        return UpdateProblemOutput()
    }
}

extension UpdateWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkloadOutput()
        value.workloadConfiguration = try reader["WorkloadConfiguration"].readIfPresent(with: ApplicationInsightsClientTypes.WorkloadConfiguration.read(from:))
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

enum AddWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagsAlreadyExistException": return try TagsAlreadyExistException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLogPatternOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLogPatternOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeComponentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeComponentConfigurationRecommendationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLogPatternOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeObservationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProblemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProblemObservationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigurationHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLogPatternsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLogPatternSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProblemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateComponentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLogPatternOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProblemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagsAlreadyExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagsAlreadyExistException {
        let reader = baseError.errorBodyReader
        var value = TagsAlreadyExistException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApplicationInsightsClientTypes.WorkloadConfiguration {

    static func write(value: ApplicationInsightsClientTypes.WorkloadConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration)
        try writer["Tier"].write(value.tier)
        try writer["WorkloadName"].write(value.workloadName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.WorkloadConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.WorkloadConfiguration()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.tier = try reader["Tier"].readIfPresent()
        value.configuration = try reader["Configuration"].readIfPresent()
        return value
    }
}

extension ApplicationInsightsClientTypes.ApplicationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.ApplicationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.ApplicationInfo()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        value.lifeCycle = try reader["LifeCycle"].readIfPresent()
        value.opsItemSNSTopicArn = try reader["OpsItemSNSTopicArn"].readIfPresent()
        value.opsCenterEnabled = try reader["OpsCenterEnabled"].readIfPresent()
        value.cweMonitorEnabled = try reader["CWEMonitorEnabled"].readIfPresent()
        value.remarks = try reader["Remarks"].readIfPresent()
        value.autoConfigEnabled = try reader["AutoConfigEnabled"].readIfPresent()
        value.discoveryType = try reader["DiscoveryType"].readIfPresent()
        value.attachMissingPermission = try reader["AttachMissingPermission"].readIfPresent()
        return value
    }
}

extension ApplicationInsightsClientTypes.LogPattern {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.LogPattern {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.LogPattern()
        value.patternSetName = try reader["PatternSetName"].readIfPresent()
        value.patternName = try reader["PatternName"].readIfPresent()
        value.pattern = try reader["Pattern"].readIfPresent()
        value.rank = try reader["Rank"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationInsightsClientTypes.ApplicationComponent {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.ApplicationComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.ApplicationComponent()
        value.componentName = try reader["ComponentName"].readIfPresent()
        value.componentRemarks = try reader["ComponentRemarks"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.osType = try reader["OsType"].readIfPresent()
        value.tier = try reader["Tier"].readIfPresent()
        value.monitor = try reader["Monitor"].readIfPresent()
        value.detectedWorkload = try reader["DetectedWorkload"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApplicationInsightsClientTypes.Observation {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.Observation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.Observation()
        value.id = try reader["Id"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.sourceARN = try reader["SourceARN"].readIfPresent()
        value.logGroup = try reader["LogGroup"].readIfPresent()
        value.lineTime = try reader["LineTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.logText = try reader["LogText"].readIfPresent()
        value.logFilter = try reader["LogFilter"].readIfPresent()
        value.metricNamespace = try reader["MetricNamespace"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.cloudWatchEventId = try reader["CloudWatchEventId"].readIfPresent()
        value.cloudWatchEventSource = try reader["CloudWatchEventSource"].readIfPresent()
        value.cloudWatchEventDetailType = try reader["CloudWatchEventDetailType"].readIfPresent()
        value.healthEventArn = try reader["HealthEventArn"].readIfPresent()
        value.healthService = try reader["HealthService"].readIfPresent()
        value.healthEventTypeCode = try reader["HealthEventTypeCode"].readIfPresent()
        value.healthEventTypeCategory = try reader["HealthEventTypeCategory"].readIfPresent()
        value.healthEventDescription = try reader["HealthEventDescription"].readIfPresent()
        value.codeDeployDeploymentId = try reader["CodeDeployDeploymentId"].readIfPresent()
        value.codeDeployDeploymentGroup = try reader["CodeDeployDeploymentGroup"].readIfPresent()
        value.codeDeployState = try reader["CodeDeployState"].readIfPresent()
        value.codeDeployApplication = try reader["CodeDeployApplication"].readIfPresent()
        value.codeDeployInstanceGroupId = try reader["CodeDeployInstanceGroupId"].readIfPresent()
        value.ec2State = try reader["Ec2State"].readIfPresent()
        value.rdsEventCategories = try reader["RdsEventCategories"].readIfPresent()
        value.rdsEventMessage = try reader["RdsEventMessage"].readIfPresent()
        value.s3EventName = try reader["S3EventName"].readIfPresent()
        value.statesExecutionArn = try reader["StatesExecutionArn"].readIfPresent()
        value.statesArn = try reader["StatesArn"].readIfPresent()
        value.statesStatus = try reader["StatesStatus"].readIfPresent()
        value.statesInput = try reader["StatesInput"].readIfPresent()
        value.ebsEvent = try reader["EbsEvent"].readIfPresent()
        value.ebsResult = try reader["EbsResult"].readIfPresent()
        value.ebsCause = try reader["EbsCause"].readIfPresent()
        value.ebsRequestId = try reader["EbsRequestId"].readIfPresent()
        value.xRayFaultPercent = try reader["XRayFaultPercent"].readIfPresent()
        value.xRayThrottlePercent = try reader["XRayThrottlePercent"].readIfPresent()
        value.xRayErrorPercent = try reader["XRayErrorPercent"].readIfPresent()
        value.xRayRequestCount = try reader["XRayRequestCount"].readIfPresent()
        value.xRayRequestAverageLatency = try reader["XRayRequestAverageLatency"].readIfPresent()
        value.xRayNodeName = try reader["XRayNodeName"].readIfPresent()
        value.xRayNodeType = try reader["XRayNodeType"].readIfPresent()
        return value
    }
}

extension ApplicationInsightsClientTypes.Problem {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.Problem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.Problem()
        value.id = try reader["Id"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.insights = try reader["Insights"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.affectedResource = try reader["AffectedResource"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.severityLevel = try reader["SeverityLevel"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        value.feedback = try reader["Feedback"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<ApplicationInsightsClientTypes.FeedbackValue>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.recurringCount = try reader["RecurringCount"].readIfPresent()
        value.lastRecurrenceTime = try reader["LastRecurrenceTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.visibility = try reader["Visibility"].readIfPresent()
        value.resolutionMethod = try reader["ResolutionMethod"].readIfPresent()
        return value
    }
}

extension ApplicationInsightsClientTypes.RelatedObservations {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.RelatedObservations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.RelatedObservations()
        value.observationList = try reader["ObservationList"].readListIfPresent(memberReadingClosure: ApplicationInsightsClientTypes.Observation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApplicationInsightsClientTypes.ConfigurationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.ConfigurationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.ConfigurationEvent()
        value.resourceGroupName = try reader["ResourceGroupName"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.monitoredResourceARN = try reader["MonitoredResourceARN"].readIfPresent()
        value.eventStatus = try reader["EventStatus"].readIfPresent()
        value.eventResourceType = try reader["EventResourceType"].readIfPresent()
        value.eventTime = try reader["EventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventDetail = try reader["EventDetail"].readIfPresent()
        value.eventResourceName = try reader["EventResourceName"].readIfPresent()
        return value
    }
}

extension ApplicationInsightsClientTypes.Tag {

    static func write(value: ApplicationInsightsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ApplicationInsightsClientTypes.Workload {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationInsightsClientTypes.Workload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationInsightsClientTypes.Workload()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.componentName = try reader["ComponentName"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.tier = try reader["Tier"].readIfPresent()
        value.workloadRemarks = try reader["WorkloadRemarks"].readIfPresent()
        return value
    }
}

public enum ApplicationInsightsClientTypes {}
