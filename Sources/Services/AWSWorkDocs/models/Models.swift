// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortDocumentVersionUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortDocumentVersionUploadInput(documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension AbortDocumentVersionUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension AbortDocumentVersionUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct AbortDocumentVersionUploadInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the version.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct AbortDocumentVersionUploadInputBody: Swift.Equatable {
}

extension AbortDocumentVersionUploadInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AbortDocumentVersionUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AbortDocumentVersionUploadOutput: Swift.Equatable {

    public init() { }
}

enum AbortDocumentVersionUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ActivateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateUserInput(userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension ActivateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension ActivateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())/activation"
    }
}

public struct ActivateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct ActivateUserInputBody: Swift.Equatable {
}

extension ActivateUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ActivateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ActivateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct ActivateUserOutput: Swift.Equatable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct ActivateUserOutputBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension ActivateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum ActivateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkDocsClientTypes.Activity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentMetadata = "CommentMetadata"
        case initiator = "Initiator"
        case isIndirectActivity = "IsIndirectActivity"
        case organizationId = "OrganizationId"
        case originalParent = "OriginalParent"
        case participants = "Participants"
        case resourceMetadata = "ResourceMetadata"
        case timeStamp = "TimeStamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentMetadata = self.commentMetadata {
            try encodeContainer.encode(commentMetadata, forKey: .commentMetadata)
        }
        if let initiator = self.initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if isIndirectActivity != false {
            try encodeContainer.encode(isIndirectActivity, forKey: .isIndirectActivity)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let originalParent = self.originalParent {
            try encodeContainer.encode(originalParent, forKey: .originalParent)
        }
        if let participants = self.participants {
            try encodeContainer.encode(participants, forKey: .participants)
        }
        if let resourceMetadata = self.resourceMetadata {
            try encodeContainer.encode(resourceMetadata, forKey: .resourceMetadata)
        }
        if let timeStamp = self.timeStamp {
            try encodeContainer.encodeTimestamp(timeStamp, format: .epochSeconds, forKey: .timeStamp)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ActivityType.self, forKey: .type)
        type = typeDecoded
        let timeStampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeStamp)
        timeStamp = timeStampDecoded
        let isIndirectActivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIndirectActivity) ?? false
        isIndirectActivity = isIndirectActivityDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserMetadata.self, forKey: .initiator)
        initiator = initiatorDecoded
        let participantsDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Participants.self, forKey: .participants)
        participants = participantsDecoded
        let resourceMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceMetadata.self, forKey: .resourceMetadata)
        resourceMetadata = resourceMetadataDecoded
        let originalParentDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceMetadata.self, forKey: .originalParent)
        originalParent = originalParentDecoded
        let commentMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentMetadata.self, forKey: .commentMetadata)
        commentMetadata = commentMetadataDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the activity information.
    public struct Activity: Swift.Equatable {
        /// Metadata of the commenting activity. This is an optional field and is filled for commenting activities.
        public var commentMetadata: WorkDocsClientTypes.CommentMetadata?
        /// The user who performed the action.
        public var initiator: WorkDocsClientTypes.UserMetadata?
        /// Indicates whether an activity is indirect or direct. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
        public var isIndirectActivity: Swift.Bool
        /// The ID of the organization.
        public var organizationId: Swift.String?
        /// The original parent of the resource. This is an optional field and is filled for move activities.
        public var originalParent: WorkDocsClientTypes.ResourceMetadata?
        /// The list of users or groups impacted by this action. This is an optional field and is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED, DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.
        public var participants: WorkDocsClientTypes.Participants?
        /// The metadata of the resource involved in the user action.
        public var resourceMetadata: WorkDocsClientTypes.ResourceMetadata?
        /// The timestamp when the action was performed.
        public var timeStamp: ClientRuntime.Date?
        /// The activity type.
        public var type: WorkDocsClientTypes.ActivityType?

        public init(
            commentMetadata: WorkDocsClientTypes.CommentMetadata? = nil,
            initiator: WorkDocsClientTypes.UserMetadata? = nil,
            isIndirectActivity: Swift.Bool = false,
            organizationId: Swift.String? = nil,
            originalParent: WorkDocsClientTypes.ResourceMetadata? = nil,
            participants: WorkDocsClientTypes.Participants? = nil,
            resourceMetadata: WorkDocsClientTypes.ResourceMetadata? = nil,
            timeStamp: ClientRuntime.Date? = nil,
            type: WorkDocsClientTypes.ActivityType? = nil
        )
        {
            self.commentMetadata = commentMetadata
            self.initiator = initiator
            self.isIndirectActivity = isIndirectActivity
            self.organizationId = organizationId
            self.originalParent = originalParent
            self.participants = participants
            self.resourceMetadata = resourceMetadata
            self.timeStamp = timeStamp
            self.type = type
        }
    }

}

extension WorkDocsClientTypes {
    public enum ActivityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documentAnnotationAdded
        case documentAnnotationDeleted
        case documentCheckedIn
        case documentCheckedOut
        case documentCommentAdded
        case documentCommentDeleted
        case documentMoved
        case documentRecycled
        case documentRenamed
        case documentRestored
        case documentReverted
        case documentShareableLinkCreated
        case documentShareableLinkPermissionChanged
        case documentShareableLinkRemoved
        case documentShared
        case documentSharePermissionChanged
        case documentUnshared
        case documentVersionDeleted
        case documentVersionDownloaded
        case documentVersionUploaded
        case documentVersionViewed
        case folderCreated
        case folderDeleted
        case folderMoved
        case folderRecycled
        case folderRenamed
        case folderRestored
        case folderShareableLinkCreated
        case folderShareableLinkPermissionChanged
        case folderShareableLinkRemoved
        case folderShared
        case folderSharePermissionChanged
        case folderUnshared
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityType] {
            return [
                .documentAnnotationAdded,
                .documentAnnotationDeleted,
                .documentCheckedIn,
                .documentCheckedOut,
                .documentCommentAdded,
                .documentCommentDeleted,
                .documentMoved,
                .documentRecycled,
                .documentRenamed,
                .documentRestored,
                .documentReverted,
                .documentShareableLinkCreated,
                .documentShareableLinkPermissionChanged,
                .documentShareableLinkRemoved,
                .documentShared,
                .documentSharePermissionChanged,
                .documentUnshared,
                .documentVersionDeleted,
                .documentVersionDownloaded,
                .documentVersionUploaded,
                .documentVersionViewed,
                .folderCreated,
                .folderDeleted,
                .folderMoved,
                .folderRecycled,
                .folderRenamed,
                .folderRestored,
                .folderShareableLinkCreated,
                .folderShareableLinkPermissionChanged,
                .folderShareableLinkRemoved,
                .folderShared,
                .folderSharePermissionChanged,
                .folderUnshared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documentAnnotationAdded: return "DOCUMENT_ANNOTATION_ADDED"
            case .documentAnnotationDeleted: return "DOCUMENT_ANNOTATION_DELETED"
            case .documentCheckedIn: return "DOCUMENT_CHECKED_IN"
            case .documentCheckedOut: return "DOCUMENT_CHECKED_OUT"
            case .documentCommentAdded: return "DOCUMENT_COMMENT_ADDED"
            case .documentCommentDeleted: return "DOCUMENT_COMMENT_DELETED"
            case .documentMoved: return "DOCUMENT_MOVED"
            case .documentRecycled: return "DOCUMENT_RECYCLED"
            case .documentRenamed: return "DOCUMENT_RENAMED"
            case .documentRestored: return "DOCUMENT_RESTORED"
            case .documentReverted: return "DOCUMENT_REVERTED"
            case .documentShareableLinkCreated: return "DOCUMENT_SHAREABLE_LINK_CREATED"
            case .documentShareableLinkPermissionChanged: return "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED"
            case .documentShareableLinkRemoved: return "DOCUMENT_SHAREABLE_LINK_REMOVED"
            case .documentShared: return "DOCUMENT_SHARED"
            case .documentSharePermissionChanged: return "DOCUMENT_SHARE_PERMISSION_CHANGED"
            case .documentUnshared: return "DOCUMENT_UNSHARED"
            case .documentVersionDeleted: return "DOCUMENT_VERSION_DELETED"
            case .documentVersionDownloaded: return "DOCUMENT_VERSION_DOWNLOADED"
            case .documentVersionUploaded: return "DOCUMENT_VERSION_UPLOADED"
            case .documentVersionViewed: return "DOCUMENT_VERSION_VIEWED"
            case .folderCreated: return "FOLDER_CREATED"
            case .folderDeleted: return "FOLDER_DELETED"
            case .folderMoved: return "FOLDER_MOVED"
            case .folderRecycled: return "FOLDER_RECYCLED"
            case .folderRenamed: return "FOLDER_RENAMED"
            case .folderRestored: return "FOLDER_RESTORED"
            case .folderShareableLinkCreated: return "FOLDER_SHAREABLE_LINK_CREATED"
            case .folderShareableLinkPermissionChanged: return "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED"
            case .folderShareableLinkRemoved: return "FOLDER_SHAREABLE_LINK_REMOVED"
            case .folderShared: return "FOLDER_SHARED"
            case .folderSharePermissionChanged: return "FOLDER_SHARE_PERMISSION_CHANGED"
            case .folderUnshared: return "FOLDER_UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivityType(rawValue: rawValue) ?? ActivityType.sdkUnknown(rawValue)
        }
    }
}

extension AddResourcePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddResourcePermissionsInput(notificationOptions: \(Swift.String(describing: notificationOptions)), principals: \(Swift.String(describing: principals)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension AddResourcePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationOptions = "NotificationOptions"
        case principals = "Principals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationOptions = self.notificationOptions {
            try encodeContainer.encode(notificationOptions, forKey: .notificationOptions)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for shareprincipal0 in principals {
                try principalsContainer.encode(shareprincipal0)
            }
        }
    }
}

extension AddResourcePermissionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension AddResourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

public struct AddResourcePermissionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The notification options.
    public var notificationOptions: WorkDocsClientTypes.NotificationOptions?
    /// The users, groups, or organization being granted permission.
    /// This member is required.
    public var principals: [WorkDocsClientTypes.SharePrincipal]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        notificationOptions: WorkDocsClientTypes.NotificationOptions? = nil,
        principals: [WorkDocsClientTypes.SharePrincipal]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.notificationOptions = notificationOptions
        self.principals = principals
        self.resourceId = resourceId
    }
}

struct AddResourcePermissionsInputBody: Swift.Equatable {
    let principals: [WorkDocsClientTypes.SharePrincipal]?
    let notificationOptions: WorkDocsClientTypes.NotificationOptions?
}

extension AddResourcePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationOptions = "NotificationOptions"
        case principals = "Principals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SharePrincipal?].self, forKey: .principals)
        var principalsDecoded0:[WorkDocsClientTypes.SharePrincipal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [WorkDocsClientTypes.SharePrincipal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let notificationOptionsDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.NotificationOptions.self, forKey: .notificationOptions)
        notificationOptions = notificationOptionsDecoded
    }
}

extension AddResourcePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddResourcePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.shareResults = output.shareResults
        } else {
            self.shareResults = nil
        }
    }
}

public struct AddResourcePermissionsOutput: Swift.Equatable {
    /// The share results.
    public var shareResults: [WorkDocsClientTypes.ShareResult]?

    public init(
        shareResults: [WorkDocsClientTypes.ShareResult]? = nil
    )
    {
        self.shareResults = shareResults
    }
}

struct AddResourcePermissionsOutputBody: Swift.Equatable {
    let shareResults: [WorkDocsClientTypes.ShareResult]?
}

extension AddResourcePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareResults = "ShareResults"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareResultsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.ShareResult?].self, forKey: .shareResults)
        var shareResultsDecoded0:[WorkDocsClientTypes.ShareResult]? = nil
        if let shareResultsContainer = shareResultsContainer {
            shareResultsDecoded0 = [WorkDocsClientTypes.ShareResult]()
            for structure0 in shareResultsContainer {
                if let structure0 = structure0 {
                    shareResultsDecoded0?.append(structure0)
                }
            }
        }
        shareResults = shareResultsDecoded0
    }
}

enum AddResourcePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkDocsClientTypes {
    public enum AdditionalResponseFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case weburl
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalResponseFieldType] {
            return [
                .weburl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .weburl: return "WEBURL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalResponseFieldType(rawValue: rawValue) ?? AdditionalResponseFieldType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum BooleanEnumType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [BooleanEnumType] {
            return [
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BooleanEnumType(rawValue: rawValue) ?? BooleanEnumType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.Comment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId = "CommentId"
        case contributor = "Contributor"
        case createdTimestamp = "CreatedTimestamp"
        case parentId = "ParentId"
        case recipientId = "RecipientId"
        case status = "Status"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let contributor = self.contributor {
            try encodeContainer.encode(contributor, forKey: .contributor)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let parentId = self.parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let recipientId = self.recipientId {
            try encodeContainer.encode(recipientId, forKey: .recipientId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let threadId = self.threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let threadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let contributorDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .contributor)
        contributor = contributorDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentStatusType.self, forKey: .status)
        status = statusDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentVisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let recipientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipientId)
        recipientId = recipientIdDecoded
    }
}

extension WorkDocsClientTypes.Comment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Comment(commentId: \(Swift.String(describing: commentId)), contributor: \(Swift.String(describing: contributor)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), parentId: \(Swift.String(describing: parentId)), recipientId: \(Swift.String(describing: recipientId)), status: \(Swift.String(describing: status)), threadId: \(Swift.String(describing: threadId)), visibility: \(Swift.String(describing: visibility)), text: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes a comment.
    public struct Comment: Swift.Equatable {
        /// The ID of the comment.
        /// This member is required.
        public var commentId: Swift.String?
        /// The details of the user who made the comment.
        public var contributor: WorkDocsClientTypes.User?
        /// The time that the comment was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the parent comment.
        public var parentId: Swift.String?
        /// If the comment is a reply to another user's comment, this field contains the user ID of the user being replied to.
        public var recipientId: Swift.String?
        /// The status of the comment.
        public var status: WorkDocsClientTypes.CommentStatusType?
        /// The text of the comment.
        public var text: Swift.String?
        /// The ID of the root comment in the thread.
        public var threadId: Swift.String?
        /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
        public var visibility: WorkDocsClientTypes.CommentVisibilityType?

        public init(
            commentId: Swift.String? = nil,
            contributor: WorkDocsClientTypes.User? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            parentId: Swift.String? = nil,
            recipientId: Swift.String? = nil,
            status: WorkDocsClientTypes.CommentStatusType? = nil,
            text: Swift.String? = nil,
            threadId: Swift.String? = nil,
            visibility: WorkDocsClientTypes.CommentVisibilityType? = nil
        )
        {
            self.commentId = commentId
            self.contributor = contributor
            self.createdTimestamp = createdTimestamp
            self.parentId = parentId
            self.recipientId = recipientId
            self.status = status
            self.text = text
            self.threadId = threadId
            self.visibility = visibility
        }
    }

}

extension WorkDocsClientTypes.CommentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId = "CommentId"
        case commentStatus = "CommentStatus"
        case contributor = "Contributor"
        case contributorId = "ContributorId"
        case createdTimestamp = "CreatedTimestamp"
        case recipientId = "RecipientId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let commentStatus = self.commentStatus {
            try encodeContainer.encode(commentStatus.rawValue, forKey: .commentStatus)
        }
        if let contributor = self.contributor {
            try encodeContainer.encode(contributor, forKey: .contributor)
        }
        if let contributorId = self.contributorId {
            try encodeContainer.encode(contributorId, forKey: .contributorId)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let recipientId = self.recipientId {
            try encodeContainer.encode(recipientId, forKey: .recipientId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contributorDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .contributor)
        contributor = contributorDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let commentStatusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentStatusType.self, forKey: .commentStatus)
        commentStatus = commentStatusDecoded
        let recipientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipientId)
        recipientId = recipientIdDecoded
        let contributorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contributorId)
        contributorId = contributorIdDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the metadata of a comment.
    public struct CommentMetadata: Swift.Equatable {
        /// The ID of the comment.
        public var commentId: Swift.String?
        /// The status of the comment.
        public var commentStatus: WorkDocsClientTypes.CommentStatusType?
        /// The user who made the comment.
        public var contributor: WorkDocsClientTypes.User?
        /// The ID of the user who made the comment.
        public var contributorId: Swift.String?
        /// The timestamp that the comment was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the user being replied to.
        public var recipientId: Swift.String?

        public init(
            commentId: Swift.String? = nil,
            commentStatus: WorkDocsClientTypes.CommentStatusType? = nil,
            contributor: WorkDocsClientTypes.User? = nil,
            contributorId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            recipientId: Swift.String? = nil
        )
        {
            self.commentId = commentId
            self.commentStatus = commentStatus
            self.contributor = contributor
            self.contributorId = contributorId
            self.createdTimestamp = createdTimestamp
            self.recipientId = recipientId
        }
    }

}

extension WorkDocsClientTypes {
    public enum CommentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentStatusType] {
            return [
                .deleted,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommentStatusType(rawValue: rawValue) ?? CommentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum CommentVisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentVisibilityType] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommentVisibilityType(rawValue: rawValue) ?? CommentVisibilityType.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource hierarchy is changing.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictingOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Another operation is in progress on the resource that conflicts with the current operation.
public struct ConflictingOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictingOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictingOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictingOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum ContentCategoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audio
        case document
        case image
        case other
        case pdf
        case presentation
        case sourceCode
        case spreadsheet
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentCategoryType] {
            return [
                .audio,
                .document,
                .image,
                .other,
                .pdf,
                .presentation,
                .sourceCode,
                .spreadsheet,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .document: return "DOCUMENT"
            case .image: return "IMAGE"
            case .other: return "OTHER"
            case .pdf: return "PDF"
            case .presentation: return "PRESENTATION"
            case .sourceCode: return "SOURCE_CODE"
            case .spreadsheet: return "SPREADSHEET"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentCategoryType(rawValue: rawValue) ?? ContentCategoryType.sdkUnknown(rawValue)
        }
    }
}

extension CreateCommentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCommentInput(documentId: \(Swift.String(describing: documentId)), notifyCollaborators: \(Swift.String(describing: notifyCollaborators)), parentId: \(Swift.String(describing: parentId)), threadId: \(Swift.String(describing: threadId)), versionId: \(Swift.String(describing: versionId)), visibility: \(Swift.String(describing: visibility)), authenticationToken: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension CreateCommentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifyCollaborators = "NotifyCollaborators"
        case parentId = "ParentId"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notifyCollaborators = self.notifyCollaborators {
            try encodeContainer.encode(notifyCollaborators, forKey: .notifyCollaborators)
        }
        if let parentId = self.parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let threadId = self.threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }
}

extension CreateCommentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comment"
    }
}

public struct CreateCommentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
    public var notifyCollaborators: Swift.Bool?
    /// The ID of the parent comment.
    public var parentId: Swift.String?
    /// The text of the comment.
    /// This member is required.
    public var text: Swift.String?
    /// The ID of the root comment in the thread.
    public var threadId: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?
    /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
    public var visibility: WorkDocsClientTypes.CommentVisibilityType?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        notifyCollaborators: Swift.Bool? = nil,
        parentId: Swift.String? = nil,
        text: Swift.String? = nil,
        threadId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        visibility: WorkDocsClientTypes.CommentVisibilityType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.notifyCollaborators = notifyCollaborators
        self.parentId = parentId
        self.text = text
        self.threadId = threadId
        self.versionId = versionId
        self.visibility = visibility
    }
}

struct CreateCommentInputBody: Swift.Equatable {
    let parentId: Swift.String?
    let threadId: Swift.String?
    let text: Swift.String?
    let visibility: WorkDocsClientTypes.CommentVisibilityType?
    let notifyCollaborators: Swift.Bool?
}

extension CreateCommentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifyCollaborators = "NotifyCollaborators"
        case parentId = "ParentId"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let threadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentVisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let notifyCollaboratorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyCollaborators)
        notifyCollaborators = notifyCollaboratorsDecoded
    }
}

extension CreateCommentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCommentOutputBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct CreateCommentOutput: Swift.Equatable {
    /// The comment that has been created.
    public var comment: WorkDocsClientTypes.Comment?

    public init(
        comment: WorkDocsClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct CreateCommentOutputBody: Swift.Equatable {
    let comment: WorkDocsClientTypes.Comment?
}

extension CreateCommentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum CreateCommentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DocumentLockedForCommentsException": return try await DocumentLockedForCommentsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentOperationException": return try await InvalidCommentOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomMetadataInput(customMetadata: \(Swift.String(describing: customMetadata)), resourceId: \(Swift.String(describing: resourceId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension CreateCustomMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customMetadata = customMetadata {
            var customMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .customMetadata)
            for (dictKey0, customMetadataMap0) in customMetadata {
                try customMetadataContainer.encode(customMetadataMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCustomMetadataInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCustomMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionId = versionId {
                let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionid".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
                items.append(versionIdQueryItem)
            }
            return items
        }
    }
}

extension CreateCustomMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/customMetadata"
    }
}

public struct CreateCustomMetadataInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Custom metadata in the form of name-value pairs.
    /// This member is required.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The ID of the version, if the custom metadata is being added to a document version.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        customMetadata: [Swift.String:Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.customMetadata = customMetadata
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

struct CreateCustomMetadataInputBody: Swift.Equatable {
    let customMetadata: [Swift.String:Swift.String]?
}

extension CreateCustomMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension CreateCustomMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateCustomMetadataOutput: Swift.Equatable {

    public init() { }
}

enum CreateCustomMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CustomMetadataLimitExceededException": return try await CustomMetadataLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFolderInput(parentFolderId: \(Swift.String(describing: parentFolderId)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = self.parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
    }
}

extension CreateFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/folders"
    }
}

public struct CreateFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The name of the new folder.
    public var name: Swift.String?
    /// The ID of the parent folder.
    /// This member is required.
    public var parentFolderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

struct CreateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentFolderId: Swift.String?
}

extension CreateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
    }
}

extension CreateFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFolderOutputBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
        } else {
            self.metadata = nil
        }
    }
}

public struct CreateFolderOutput: Swift.Equatable {
    /// The metadata of the folder.
    public var metadata: WorkDocsClientTypes.FolderMetadata?

    public init(
        metadata: WorkDocsClientTypes.FolderMetadata? = nil
    )
    {
        self.metadata = metadata
    }
}

struct CreateFolderOutputBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.FolderMetadata?
}

extension CreateFolderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.FolderMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

enum CreateFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLabelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLabelsInput(labels: \(Swift.String(describing: labels)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension CreateLabelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabel0 in labels {
                try labelsContainer.encode(sharedlabel0)
            }
        }
    }
}

extension CreateLabelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateLabelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/labels"
    }
}

public struct CreateLabelsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// List of labels to add to the resource.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.labels = labels
        self.resourceId = resourceId
    }
}

struct CreateLabelsInputBody: Swift.Equatable {
    let labels: [Swift.String]?
}

extension CreateLabelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension CreateLabelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateLabelsOutput: Swift.Equatable {

    public init() { }
}

enum CreateLabelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyLabelsException": return try await TooManyLabelsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNotificationSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let subscriptionType = self.subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }
}

extension CreateNotificationSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationId = organizationId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions"
    }
}

public struct CreateNotificationSubscriptionInput: Swift.Equatable {
    /// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with https.
    /// This member is required.
    public var endpoint: Swift.String?
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The protocol to use. The supported value is https, which delivers JSON-encoded messages using HTTPS POST.
    /// This member is required.
    public var `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
    /// The notification type.
    /// This member is required.
    public var subscriptionType: WorkDocsClientTypes.SubscriptionType?

    public init(
        endpoint: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        `protocol`: WorkDocsClientTypes.SubscriptionProtocolType? = nil,
        subscriptionType: WorkDocsClientTypes.SubscriptionType? = nil
    )
    {
        self.endpoint = endpoint
        self.organizationId = organizationId
        self.`protocol` = `protocol`
        self.subscriptionType = subscriptionType
    }
}

struct CreateNotificationSubscriptionInputBody: Swift.Equatable {
    let endpoint: Swift.String?
    let `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
    let subscriptionType: WorkDocsClientTypes.SubscriptionType?
}

extension CreateNotificationSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case subscriptionType = "SubscriptionType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SubscriptionProtocolType.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
    }
}

extension CreateNotificationSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNotificationSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscription = output.subscription
        } else {
            self.subscription = nil
        }
    }
}

public struct CreateNotificationSubscriptionOutput: Swift.Equatable {
    /// The subscription.
    public var subscription: WorkDocsClientTypes.Subscription?

    public init(
        subscription: WorkDocsClientTypes.Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

struct CreateNotificationSubscriptionOutputBody: Swift.Equatable {
    let subscription: WorkDocsClientTypes.Subscription?
}

extension CreateNotificationSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscription = "Subscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Subscription.self, forKey: .subscription)
        subscription = subscriptionDecoded
    }
}

enum CreateNotificationSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManySubscriptionsException": return try await TooManySubscriptionsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(organizationId: \(Swift.String(describing: organizationId)), storageRule: \(Swift.String(describing: storageRule)), timeZoneId: \(Swift.String(describing: timeZoneId)), authenticationToken: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case organizationId = "OrganizationId"
        case password = "Password"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = self.givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let storageRule = self.storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let surname = self.surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/users"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The email address of the user.
    public var emailAddress: Swift.String?
    /// The given name of the user.
    /// This member is required.
    public var givenName: Swift.String?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// The password of the user.
    /// This member is required.
    public var password: Swift.String?
    /// The amount of storage for the user.
    public var storageRule: WorkDocsClientTypes.StorageRuleType?
    /// The surname of the user.
    /// This member is required.
    public var surname: Swift.String?
    /// The time zone ID of the user.
    public var timeZoneId: Swift.String?
    /// The login name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        givenName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
        surname: Swift.String? = nil,
        timeZoneId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.emailAddress = emailAddress
        self.givenName = givenName
        self.organizationId = organizationId
        self.password = password
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let username: Swift.String?
    let emailAddress: Swift.String?
    let givenName: Swift.String?
    let surname: Swift.String?
    let password: Swift.String?
    let timeZoneId: Swift.String?
    let storageRule: WorkDocsClientTypes.StorageRuleType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case organizationId = "OrganizationId"
        case password = "Password"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomMetadataLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CustomMetadataLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit has been reached on the number of custom properties for the specified resource.
public struct CustomMetadataLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomMetadataLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CustomMetadataLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomMetadataLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.DateRangeType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endValue = "EndValue"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endValue = self.endValue {
            try encodeContainer.encodeTimestamp(endValue, format: .epochSeconds, forKey: .endValue)
        }
        if let startValue = self.startValue {
            try encodeContainer.encodeTimestamp(startValue, format: .epochSeconds, forKey: .startValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startValueDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startValue)
        startValue = startValueDecoded
        let endValueDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension WorkDocsClientTypes {
    /// Filters results based on timestamp range (in epochs).
    public struct DateRangeType: Swift.Equatable {
        /// Timestamp range end value (in epochs).
        public var endValue: ClientRuntime.Date?
        /// Timestamp range start value (in epochs)
        public var startValue: ClientRuntime.Date?

        public init(
            endValue: ClientRuntime.Date? = nil,
            startValue: ClientRuntime.Date? = nil
        )
        {
            self.endValue = endValue
            self.startValue = startValue
        }
    }

}

extension DeactivateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeactivateUserInput(userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeactivateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeactivateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())/activation"
    }
}

public struct DeactivateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct DeactivateUserInputBody: Swift.Equatable {
}

extension DeactivateUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeactivateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeactivateUserOutput: Swift.Equatable {

    public init() { }
}

enum DeactivateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeactivatingLastSystemUserException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeactivatingLastSystemUserExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The last user in the organization is being deactivated.
public struct DeactivatingLastSystemUserException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeactivatingLastSystemUserException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct DeactivatingLastSystemUserExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension DeactivatingLastSystemUserExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DeleteCommentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCommentInput(commentId: \(Swift.String(describing: commentId)), documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteCommentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        guard let commentId = commentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comment/\(commentId.urlPercentEncoding())"
    }
}

public struct DeleteCommentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the comment.
    /// This member is required.
    public var commentId: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        commentId: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.commentId = commentId
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct DeleteCommentInputBody: Swift.Equatable {
}

extension DeleteCommentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCommentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCommentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCommentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DocumentLockedForCommentsException": return try await DocumentLockedForCommentsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomMetadataInput(deleteAll: \(Swift.String(describing: deleteAll)), keys: \(Swift.String(describing: keys)), resourceId: \(Swift.String(describing: resourceId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteCustomMetadataInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCustomMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionId = versionId {
                let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
                items.append(versionIdQueryItem)
            }
            if let deleteAll = deleteAll {
                let deleteAllQueryItem = ClientRuntime.URLQueryItem(name: "deleteAll".urlPercentEncoding(), value: Swift.String(deleteAll).urlPercentEncoding())
                items.append(deleteAllQueryItem)
            }
            if let keys = keys {
                keys.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "keys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension DeleteCustomMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/customMetadata"
    }
}

public struct DeleteCustomMetadataInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Flag to indicate removal of all custom metadata properties from the specified resource.
    public var deleteAll: Swift.Bool?
    /// List of properties to remove.
    public var keys: [Swift.String]?
    /// The ID of the resource, either a document or folder.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The ID of the version, if the custom metadata is being deleted from a document version.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        deleteAll: Swift.Bool? = nil,
        keys: [Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.keys = keys
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

struct DeleteCustomMetadataInputBody: Swift.Equatable {
}

extension DeleteCustomMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomMetadataOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDocumentInput(documentId: \(Swift.String(describing: documentId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteDocumentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

public struct DeleteDocumentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
    }
}

struct DeleteDocumentInputBody: Swift.Equatable {
}

extension DeleteDocumentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDocumentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDocumentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDocumentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDocumentVersionInput(deletePriorVersions: \(Swift.String(describing: deletePriorVersions)), documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteDocumentVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteDocumentVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let deletePriorVersions = deletePriorVersions else {
                let message = "Creating a URL Query Item failed. deletePriorVersions is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let deletePriorVersionsQueryItem = ClientRuntime.URLQueryItem(name: "deletePriorVersions".urlPercentEncoding(), value: Swift.String(deletePriorVersions).urlPercentEncoding())
            items.append(deletePriorVersionsQueryItem)
            return items
        }
    }
}

extension DeleteDocumentVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documentVersions/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct DeleteDocumentVersionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Deletes all versions of a document prior to the current version.
    /// This member is required.
    public var deletePriorVersions: Swift.Bool?
    /// The ID of the document associated with the version being deleted.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the version being deleted.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        deletePriorVersions: Swift.Bool? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deletePriorVersions = deletePriorVersions
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct DeleteDocumentVersionInputBody: Swift.Equatable {
}

extension DeleteDocumentVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDocumentVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDocumentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFolderContentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFolderContentsInput(folderId: \(Swift.String(describing: folderId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteFolderContentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteFolderContentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/contents"
    }
}

public struct DeleteFolderContentsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

struct DeleteFolderContentsInputBody: Swift.Equatable {
}

extension DeleteFolderContentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderContentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFolderContentsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFolderContentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFolderInput(folderId: \(Swift.String(describing: folderId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct DeleteFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

struct DeleteFolderInputBody: Swift.Equatable {
}

extension DeleteFolderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFolderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLabelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLabelsInput(deleteAll: \(Swift.String(describing: deleteAll)), labels: \(Swift.String(describing: labels)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteLabelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteLabelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deleteAll = deleteAll {
                let deleteAllQueryItem = ClientRuntime.URLQueryItem(name: "deleteAll".urlPercentEncoding(), value: Swift.String(deleteAll).urlPercentEncoding())
                items.append(deleteAllQueryItem)
            }
            if let labels = labels {
                labels.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "labels".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension DeleteLabelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/labels"
    }
}

public struct DeleteLabelsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Flag to request removal of all labels from the specified resource.
    public var deleteAll: Swift.Bool?
    /// List of labels to delete from the resource.
    public var labels: [Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        deleteAll: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.labels = labels
        self.resourceId = resourceId
    }
}

struct DeleteLabelsInputBody: Swift.Equatable {
}

extension DeleteLabelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLabelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLabelsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLabelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNotificationSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationId = organizationId else {
            return nil
        }
        guard let subscriptionId = subscriptionId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions/\(subscriptionId.urlPercentEncoding())"
    }
}

public struct DeleteNotificationSubscriptionInput: Swift.Equatable {
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        subscriptionId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.subscriptionId = subscriptionId
    }
}

struct DeleteNotificationSubscriptionInputBody: Swift.Equatable {
}

extension DeleteNotificationSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNotificationSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNotificationSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNotificationSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DeleteUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Do not set this field when using administrative API actions, as in accessing the API using Amazon Web Services credentials.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeActivitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeActivitiesInput(activityTypes: \(Swift.String(describing: activityTypes)), endTime: \(Swift.String(describing: endTime)), includeIndirectActivities: \(Swift.String(describing: includeIndirectActivities)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)), startTime: \(Swift.String(describing: startTime)), userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DescribeActivitiesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeActivitiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let endTime = endTime {
                let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
                items.append(endTimeQueryItem)
            }
            if let resourceId = resourceId {
                let resourceIdQueryItem = ClientRuntime.URLQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
                items.append(resourceIdQueryItem)
            }
            if let userId = userId {
                let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
                items.append(userIdQueryItem)
            }
            if let startTime = startTime {
                let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
                items.append(startTimeQueryItem)
            }
            if let includeIndirectActivities = includeIndirectActivities {
                let includeIndirectActivitiesQueryItem = ClientRuntime.URLQueryItem(name: "includeIndirectActivities".urlPercentEncoding(), value: Swift.String(includeIndirectActivities).urlPercentEncoding())
                items.append(includeIndirectActivitiesQueryItem)
            }
            if let organizationId = organizationId {
                let organizationIdQueryItem = ClientRuntime.URLQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
                items.append(organizationIdQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let activityTypes = activityTypes {
                let activityTypesQueryItem = ClientRuntime.URLQueryItem(name: "activityTypes".urlPercentEncoding(), value: Swift.String(activityTypes).urlPercentEncoding())
                items.append(activityTypesQueryItem)
            }
            return items
        }
    }
}

extension DescribeActivitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/activities"
    }
}

public struct DescribeActivitiesInput: Swift.Equatable {
    /// Specifies which activity types to include in the response. If this field is left empty, all activity types are returned.
    public var activityTypes: Swift.String?
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The timestamp that determines the end time of the activities. The response includes the activities performed before the specified timestamp.
    public var endTime: ClientRuntime.Date?
    /// Includes indirect activities. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
    public var includeIndirectActivities: Swift.Bool?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The ID of the organization. This is a mandatory parameter when using administrative API (SigV4) requests.
    public var organizationId: Swift.String?
    /// The document or folder ID for which to describe activity types.
    public var resourceId: Swift.String?
    /// The timestamp that determines the starting time of the activities. The response includes the activities performed after the specified timestamp.
    public var startTime: ClientRuntime.Date?
    /// The ID of the user who performed the action. The response includes activities pertaining to this user. This is an optional parameter and is only applicable for administrative API (SigV4) requests.
    public var userId: Swift.String?

    public init(
        activityTypes: Swift.String? = nil,
        authenticationToken: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        includeIndirectActivities: Swift.Bool? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        userId: Swift.String? = nil
    )
    {
        self.activityTypes = activityTypes
        self.authenticationToken = authenticationToken
        self.endTime = endTime
        self.includeIndirectActivities = includeIndirectActivities
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.resourceId = resourceId
        self.startTime = startTime
        self.userId = userId
    }
}

struct DescribeActivitiesInputBody: Swift.Equatable {
}

extension DescribeActivitiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeActivitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeActivitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.userActivities = output.userActivities
        } else {
            self.marker = nil
            self.userActivities = nil
        }
    }
}

public struct DescribeActivitiesOutput: Swift.Equatable {
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The list of activities for the specified user and time period.
    public var userActivities: [WorkDocsClientTypes.Activity]?

    public init(
        marker: Swift.String? = nil,
        userActivities: [WorkDocsClientTypes.Activity]? = nil
    )
    {
        self.marker = marker
        self.userActivities = userActivities
    }
}

struct DescribeActivitiesOutputBody: Swift.Equatable {
    let userActivities: [WorkDocsClientTypes.Activity]?
    let marker: Swift.String?
}

extension DescribeActivitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case userActivities = "UserActivities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userActivitiesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Activity?].self, forKey: .userActivities)
        var userActivitiesDecoded0:[WorkDocsClientTypes.Activity]? = nil
        if let userActivitiesContainer = userActivitiesContainer {
            userActivitiesDecoded0 = [WorkDocsClientTypes.Activity]()
            for structure0 in userActivitiesContainer {
                if let structure0 = structure0 {
                    userActivitiesDecoded0?.append(structure0)
                }
            }
        }
        userActivities = userActivitiesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeActivitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCommentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommentsInput(documentId: \(Swift.String(describing: documentId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DescribeCommentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeCommentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension DescribeCommentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comments"
    }
}

public struct DescribeCommentsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.limit = limit
        self.marker = marker
        self.versionId = versionId
    }
}

struct DescribeCommentsInputBody: Swift.Equatable {
}

extension DescribeCommentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCommentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCommentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.comments = output.comments
            self.marker = output.marker
        } else {
            self.comments = nil
            self.marker = nil
        }
    }
}

public struct DescribeCommentsOutput: Swift.Equatable {
    /// The list of comments for the specified document version.
    public var comments: [WorkDocsClientTypes.Comment]?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?

    public init(
        comments: [WorkDocsClientTypes.Comment]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.comments = comments
        self.marker = marker
    }
}

struct DescribeCommentsOutputBody: Swift.Equatable {
    let comments: [WorkDocsClientTypes.Comment]?
    let marker: Swift.String?
}

extension DescribeCommentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "Comments"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Comment?].self, forKey: .comments)
        var commentsDecoded0:[WorkDocsClientTypes.Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [WorkDocsClientTypes.Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeCommentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDocumentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDocumentVersionsInput(documentId: \(Swift.String(describing: documentId)), fields: \(Swift.String(describing: fields)), include: \(Swift.String(describing: include)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DescribeDocumentVersionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeDocumentVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fields = fields {
                let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
                items.append(fieldsQueryItem)
            }
            if let include = include {
                let includeQueryItem = ClientRuntime.URLQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include).urlPercentEncoding())
                items.append(includeQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension DescribeDocumentVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions"
    }
}

public struct DescribeDocumentVersionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Specify "SOURCE" to include initialized versions and a URL for the source document.
    public var fields: Swift.String?
    /// A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.
    public var include: Swift.String?
    /// The maximum number of versions to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        include: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeDocumentVersionsInputBody: Swift.Equatable {
}

extension DescribeDocumentVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDocumentVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDocumentVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.documentVersions = output.documentVersions
            self.marker = output.marker
        } else {
            self.documentVersions = nil
            self.marker = nil
        }
    }
}

public struct DescribeDocumentVersionsOutput: Swift.Equatable {
    /// The document versions.
    public var documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.marker = marker
    }
}

struct DescribeDocumentVersionsOutputBody: Swift.Equatable {
    let documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]?
    let marker: Swift.String?
}

extension DescribeDocumentVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersions = "DocumentVersions"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.DocumentVersionMetadata?].self, forKey: .documentVersions)
        var documentVersionsDecoded0:[WorkDocsClientTypes.DocumentVersionMetadata]? = nil
        if let documentVersionsContainer = documentVersionsContainer {
            documentVersionsDecoded0 = [WorkDocsClientTypes.DocumentVersionMetadata]()
            for structure0 in documentVersionsContainer {
                if let structure0 = structure0 {
                    documentVersionsDecoded0?.append(structure0)
                }
            }
        }
        documentVersions = documentVersionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeDocumentVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFolderContentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFolderContentsInput(folderId: \(Swift.String(describing: folderId)), include: \(Swift.String(describing: include)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), order: \(Swift.String(describing: order)), sort: \(Swift.String(describing: sort)), type: \(Swift.String(describing: type)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DescribeFolderContentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeFolderContentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let order = order {
                let orderQueryItem = ClientRuntime.URLQueryItem(name: "order".urlPercentEncoding(), value: Swift.String(order.rawValue).urlPercentEncoding())
                items.append(orderQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let sort = sort {
                let sortQueryItem = ClientRuntime.URLQueryItem(name: "sort".urlPercentEncoding(), value: Swift.String(sort.rawValue).urlPercentEncoding())
                items.append(sortQueryItem)
            }
            if let include = include {
                let includeQueryItem = ClientRuntime.URLQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include).urlPercentEncoding())
                items.append(includeQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension DescribeFolderContentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/contents"
    }
}

public struct DescribeFolderContentsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The contents to include. Specify "INITIALIZED" to include initialized documents.
    public var include: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The order for the contents of the folder.
    public var order: WorkDocsClientTypes.OrderType?
    /// The sorting criteria.
    public var sort: WorkDocsClientTypes.ResourceSortType?
    /// The type of items.
    public var type: WorkDocsClientTypes.FolderContentType?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        include: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        order: WorkDocsClientTypes.OrderType? = nil,
        sort: WorkDocsClientTypes.ResourceSortType? = nil,
        type: WorkDocsClientTypes.FolderContentType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.sort = sort
        self.type = type
    }
}

struct DescribeFolderContentsInputBody: Swift.Equatable {
}

extension DescribeFolderContentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderContentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFolderContentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.documents = output.documents
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.documents = nil
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct DescribeFolderContentsOutput: Swift.Equatable {
    /// The documents in the specified folder.
    public var documents: [WorkDocsClientTypes.DocumentMetadata]?
    /// The subfolders in the specified folder.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        documents: [WorkDocsClientTypes.DocumentMetadata]? = nil,
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

struct DescribeFolderContentsOutputBody: Swift.Equatable {
    let folders: [WorkDocsClientTypes.FolderMetadata]?
    let documents: [WorkDocsClientTypes.DocumentMetadata]?
    let marker: Swift.String?
}

extension DescribeFolderContentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents = "Documents"
        case folders = "Folders"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[WorkDocsClientTypes.FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [WorkDocsClientTypes.FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let documentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.DocumentMetadata?].self, forKey: .documents)
        var documentsDecoded0:[WorkDocsClientTypes.DocumentMetadata]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [WorkDocsClientTypes.DocumentMetadata]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeFolderContentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupsInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), organizationId: \(Swift.String(describing: organizationId)), authenticationToken: \"CONTENT_REDACTED\", searchQuery: \"CONTENT_REDACTED\")"}
}

extension DescribeGroupsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let searchQuery = searchQuery else {
                let message = "Creating a URL Query Item failed. searchQuery is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let searchQueryQueryItem = ClientRuntime.URLQueryItem(name: "searchQuery".urlPercentEncoding(), value: Swift.String(searchQuery).urlPercentEncoding())
            items.append(searchQueryQueryItem)
            if let organizationId = organizationId {
                let organizationIdQueryItem = ClientRuntime.URLQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
                items.append(organizationIdQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension DescribeGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/groups"
    }
}

public struct DescribeGroupsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// A query to describe groups by group name.
    /// This member is required.
    public var searchQuery: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        searchQuery: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.searchQuery = searchQuery
    }
}

struct DescribeGroupsInputBody: Swift.Equatable {
}

extension DescribeGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.marker = output.marker
        } else {
            self.groups = nil
            self.marker = nil
        }
    }
}

public struct DescribeGroupsOutput: Swift.Equatable {
    /// The list of groups.
    public var groups: [WorkDocsClientTypes.GroupMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        groups: [WorkDocsClientTypes.GroupMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.marker = marker
    }
}

struct DescribeGroupsOutputBody: Swift.Equatable {
    let groups: [WorkDocsClientTypes.GroupMetadata]?
    let marker: Swift.String?
}

extension DescribeGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.GroupMetadata?].self, forKey: .groups)
        var groupsDecoded0:[WorkDocsClientTypes.GroupMetadata]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkDocsClientTypes.GroupMetadata]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNotificationSubscriptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension DescribeNotificationSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationId = organizationId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions"
    }
}

public struct DescribeNotificationSubscriptionsInput: Swift.Equatable {
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
    }
}

struct DescribeNotificationSubscriptionsInputBody: Swift.Equatable {
}

extension DescribeNotificationSubscriptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNotificationSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNotificationSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.subscriptions = output.subscriptions
        } else {
            self.marker = nil
            self.subscriptions = nil
        }
    }
}

public struct DescribeNotificationSubscriptionsOutput: Swift.Equatable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The subscriptions.
    public var subscriptions: [WorkDocsClientTypes.Subscription]?

    public init(
        marker: Swift.String? = nil,
        subscriptions: [WorkDocsClientTypes.Subscription]? = nil
    )
    {
        self.marker = marker
        self.subscriptions = subscriptions
    }
}

struct DescribeNotificationSubscriptionsOutputBody: Swift.Equatable {
    let subscriptions: [WorkDocsClientTypes.Subscription]?
    let marker: Swift.String?
}

extension DescribeNotificationSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case subscriptions = "Subscriptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[WorkDocsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [WorkDocsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeNotificationSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResourcePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResourcePermissionsInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), principalId: \(Swift.String(describing: principalId)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DescribeResourcePermissionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeResourcePermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let principalId = principalId {
                let principalIdQueryItem = ClientRuntime.URLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
                items.append(principalIdQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension DescribeResourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeResourcePermissionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call)
    public var marker: Swift.String?
    /// The ID of the principal to filter permissions by.
    public var principalId: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        principalId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.principalId = principalId
        self.resourceId = resourceId
    }
}

struct DescribeResourcePermissionsInputBody: Swift.Equatable {
}

extension DescribeResourcePermissionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeResourcePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResourcePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.principals = output.principals
        } else {
            self.marker = nil
            self.principals = nil
        }
    }
}

public struct DescribeResourcePermissionsOutput: Swift.Equatable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The principals.
    public var principals: [WorkDocsClientTypes.Principal]?

    public init(
        marker: Swift.String? = nil,
        principals: [WorkDocsClientTypes.Principal]? = nil
    )
    {
        self.marker = marker
        self.principals = principals
    }
}

struct DescribeResourcePermissionsOutputBody: Swift.Equatable {
    let principals: [WorkDocsClientTypes.Principal]?
    let marker: Swift.String?
}

extension DescribeResourcePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case principals = "Principals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[WorkDocsClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [WorkDocsClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeResourcePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRootFoldersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRootFoldersInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension DescribeRootFoldersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeRootFoldersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension DescribeRootFoldersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/me/root"
    }
}

public struct DescribeRootFoldersInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token.
    /// This member is required.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeRootFoldersInputBody: Swift.Equatable {
}

extension DescribeRootFoldersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRootFoldersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRootFoldersOutputBody = try responseDecoder.decode(responseBody: data)
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct DescribeRootFoldersOutput: Swift.Equatable {
    /// The user's special folders.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker for the next set of results.
    public var marker: Swift.String?

    public init(
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.folders = folders
        self.marker = marker
    }
}

struct DescribeRootFoldersOutputBody: Swift.Equatable {
    let folders: [WorkDocsClientTypes.FolderMetadata]?
    let marker: Swift.String?
}

extension DescribeRootFoldersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folders = "Folders"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[WorkDocsClientTypes.FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [WorkDocsClientTypes.FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeRootFoldersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsersInput(fields: \(Swift.String(describing: fields)), include: \(Swift.String(describing: include)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), order: \(Swift.String(describing: order)), organizationId: \(Swift.String(describing: organizationId)), sort: \(Swift.String(describing: sort)), userIds: \(Swift.String(describing: userIds)), authenticationToken: \"CONTENT_REDACTED\", query: \"CONTENT_REDACTED\")"}
}

extension DescribeUsersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let order = order {
                let orderQueryItem = ClientRuntime.URLQueryItem(name: "order".urlPercentEncoding(), value: Swift.String(order.rawValue).urlPercentEncoding())
                items.append(orderQueryItem)
            }
            if let fields = fields {
                let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
                items.append(fieldsQueryItem)
            }
            if let query = query {
                let queryQueryItem = ClientRuntime.URLQueryItem(name: "query".urlPercentEncoding(), value: Swift.String(query).urlPercentEncoding())
                items.append(queryQueryItem)
            }
            if let include = include {
                let includeQueryItem = ClientRuntime.URLQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include.rawValue).urlPercentEncoding())
                items.append(includeQueryItem)
            }
            if let sort = sort {
                let sortQueryItem = ClientRuntime.URLQueryItem(name: "sort".urlPercentEncoding(), value: Swift.String(sort.rawValue).urlPercentEncoding())
                items.append(sortQueryItem)
            }
            if let organizationId = organizationId {
                let organizationIdQueryItem = ClientRuntime.URLQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
                items.append(organizationIdQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let userIds = userIds {
                let userIdsQueryItem = ClientRuntime.URLQueryItem(name: "userIds".urlPercentEncoding(), value: Swift.String(userIds).urlPercentEncoding())
                items.append(userIdsQueryItem)
            }
            return items
        }
    }
}

extension DescribeUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/users"
    }
}

public struct DescribeUsersInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.
    public var fields: Swift.String?
    /// The state of the users. Specify "ALL" to include inactive users.
    public var include: WorkDocsClientTypes.UserFilterType?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The order for the results.
    public var order: WorkDocsClientTypes.OrderType?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// A query to filter users by user name. Remember the following about the Userids and Query parameters:
    ///
    /// * If you don't use either parameter, the API returns a paginated list of all users on the site.
    ///
    /// * If you use both parameters, the API ignores the Query parameter.
    ///
    /// * The Userid parameter only returns user names that match a corresponding user ID.
    ///
    /// * The Query parameter runs a "prefix" search for users by the GivenName, SurName, or UserName fields included in a [CreateUser](https://docs.aws.amazon.com/workdocs/latest/APIReference/API_CreateUser.html) API call. For example, querying on Ma returns Mrcia Oliveira, Mara Garca, and Mateo Jackson. If you use multiple characters, the API only returns data that matches all characters. For example, querying on Ma J only returns Mateo Jackson.
    public var query: Swift.String?
    /// The sorting criteria.
    public var sort: WorkDocsClientTypes.UserSortType?
    /// The IDs of the users.
    public var userIds: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        fields: Swift.String? = nil,
        include: WorkDocsClientTypes.UserFilterType? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        order: WorkDocsClientTypes.OrderType? = nil,
        organizationId: Swift.String? = nil,
        query: Swift.String? = nil,
        sort: WorkDocsClientTypes.UserSortType? = nil,
        userIds: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.organizationId = organizationId
        self.query = query
        self.sort = sort
        self.userIds = userIds
    }
}

struct DescribeUsersInputBody: Swift.Equatable {
}

extension DescribeUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.totalNumberOfUsers = output.totalNumberOfUsers
            self.users = output.users
        } else {
            self.marker = nil
            self.totalNumberOfUsers = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutput: Swift.Equatable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The total number of users included in the results.
    @available(*, deprecated)
    public var totalNumberOfUsers: Swift.Int?
    /// The users.
    public var users: [WorkDocsClientTypes.User]?

    public init(
        marker: Swift.String? = nil,
        totalNumberOfUsers: Swift.Int? = nil,
        users: [WorkDocsClientTypes.User]? = nil
    )
    {
        self.marker = marker
        self.totalNumberOfUsers = totalNumberOfUsers
        self.users = users
    }
}

struct DescribeUsersOutputBody: Swift.Equatable {
    let users: [WorkDocsClientTypes.User]?
    let totalNumberOfUsers: Swift.Int?
    let marker: Swift.String?
}

extension DescribeUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case totalNumberOfUsers = "TotalNumberOfUsers"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[WorkDocsClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkDocsClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let totalNumberOfUsersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfUsers)
        totalNumberOfUsers = totalNumberOfUsersDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestedEntityTooLargeException": return try await RequestedEntityTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DocumentLockedForCommentsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DocumentLockedForCommentsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.
public struct DocumentLockedForCommentsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DocumentLockedForCommentsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DocumentLockedForCommentsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DocumentLockedForCommentsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.DocumentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case labels = "Labels"
        case latestVersionMetadata = "LatestVersionMetadata"
        case modifiedTimestamp = "ModifiedTimestamp"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let creatorId = self.creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabel0 in labels {
                try labelsContainer.encode(sharedlabel0)
            }
        }
        if let latestVersionMetadata = self.latestVersionMetadata {
            try encodeContainer.encode(latestVersionMetadata, forKey: .latestVersionMetadata)
        }
        if let modifiedTimestamp = self.modifiedTimestamp {
            try encodeContainer.encodeTimestamp(modifiedTimestamp, format: .epochSeconds, forKey: .modifiedTimestamp)
        }
        if let parentFolderId = self.parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = self.resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let latestVersionMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionMetadata.self, forKey: .latestVersionMetadata)
        latestVersionMetadata = latestVersionMetadataDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the document.
    public struct DocumentMetadata: Swift.Equatable {
        /// The time when the document was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the document.
        public var id: Swift.String?
        /// List of labels on the document.
        public var labels: [Swift.String]?
        /// The latest version of the document.
        public var latestVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata?
        /// The time when the document was updated.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The ID of the parent folder.
        public var parentFolderId: Swift.String?
        /// The resource state.
        public var resourceState: WorkDocsClientTypes.ResourceStateType?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            latestVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            parentFolderId: Swift.String? = nil,
            resourceState: WorkDocsClientTypes.ResourceStateType? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionMetadata = latestVersionMetadata
            self.modifiedTimestamp = modifiedTimestamp
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
        }
    }

}

extension WorkDocsClientTypes {
    public enum DocumentSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case original
        case withComments
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentSourceType] {
            return [
                .original,
                .withComments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .withComments: return "WITH_COMMENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentSourceType(rawValue: rawValue) ?? DocumentSourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum DocumentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case initialized
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatusType] {
            return [
                .active,
                .initialized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .initialized: return "INITIALIZED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentStatusType(rawValue: rawValue) ?? DocumentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum DocumentThumbnailType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case small
        case smallHq
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentThumbnailType] {
            return [
                .large,
                .small,
                .smallHq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .small: return "SMALL"
            case .smallHq: return "SMALL_HQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentThumbnailType(rawValue: rawValue) ?? DocumentThumbnailType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.DocumentVersionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case modifiedTimestamp = "ModifiedTimestamp"
        case name = "Name"
        case signature = "Signature"
        case size = "Size"
        case source = "Source"
        case status = "Status"
        case thumbnail = "Thumbnail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentCreatedTimestamp = self.contentCreatedTimestamp {
            try encodeContainer.encodeTimestamp(contentCreatedTimestamp, format: .epochSeconds, forKey: .contentCreatedTimestamp)
        }
        if let contentModifiedTimestamp = self.contentModifiedTimestamp {
            try encodeContainer.encodeTimestamp(contentModifiedTimestamp, format: .epochSeconds, forKey: .contentModifiedTimestamp)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let creatorId = self.creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedTimestamp = self.modifiedTimestamp {
            try encodeContainer.encodeTimestamp(modifiedTimestamp, format: .epochSeconds, forKey: .modifiedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let source = source {
            var sourceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .source)
            for (dictKey0, documentSourceUrlMap0) in source {
                try sourceContainer.encode(documentSourceUrlMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let thumbnail = thumbnail {
            var thumbnailContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .thumbnail)
            for (dictKey0, documentThumbnailUrlMap0) in thumbnail {
                try thumbnailContainer.encode(documentThumbnailUrlMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentStatusType.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let contentCreatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .contentCreatedTimestamp)
        contentCreatedTimestamp = contentCreatedTimestampDecoded
        let contentModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .contentModifiedTimestamp)
        contentModifiedTimestamp = contentModifiedTimestampDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let thumbnailContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .thumbnail)
        var thumbnailDecoded0: [Swift.String:Swift.String]? = nil
        if let thumbnailContainer = thumbnailContainer {
            thumbnailDecoded0 = [Swift.String:Swift.String]()
            for (key0, urltype0) in thumbnailContainer {
                if let urltype0 = urltype0 {
                    thumbnailDecoded0?[key0] = urltype0
                }
            }
        }
        thumbnail = thumbnailDecoded0
        let sourceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .source)
        var sourceDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [Swift.String:Swift.String]()
            for (key0, urltype0) in sourceContainer {
                if let urltype0 = urltype0 {
                    sourceDecoded0?[key0] = urltype0
                }
            }
        }
        source = sourceDecoded0
    }
}

extension WorkDocsClientTypes.DocumentVersionMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentVersionMetadata(contentCreatedTimestamp: \(Swift.String(describing: contentCreatedTimestamp)), contentModifiedTimestamp: \(Swift.String(describing: contentModifiedTimestamp)), contentType: \(Swift.String(describing: contentType)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), creatorId: \(Swift.String(describing: creatorId)), id: \(Swift.String(describing: id)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), signature: \(Swift.String(describing: signature)), size: \(Swift.String(describing: size)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), thumbnail: \(Swift.String(describing: thumbnail)), name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes a version of a document.
    public struct DocumentVersionMetadata: Swift.Equatable {
        /// The timestamp when the content of the document was originally created.
        public var contentCreatedTimestamp: ClientRuntime.Date?
        /// The timestamp when the content of the document was modified.
        public var contentModifiedTimestamp: ClientRuntime.Date?
        /// The content type of the document.
        public var contentType: Swift.String?
        /// The timestamp when the document was first uploaded.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the version.
        public var id: Swift.String?
        /// The timestamp when the document was last uploaded.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The name of the version.
        public var name: Swift.String?
        /// The signature of the document.
        public var signature: Swift.String?
        /// The size of the document, in bytes.
        public var size: Swift.Int?
        /// The source of the document.
        public var source: [Swift.String:Swift.String]?
        /// The status of the document.
        public var status: WorkDocsClientTypes.DocumentStatusType?
        /// The thumbnail of the document.
        public var thumbnail: [Swift.String:Swift.String]?

        public init(
            contentCreatedTimestamp: ClientRuntime.Date? = nil,
            contentModifiedTimestamp: ClientRuntime.Date? = nil,
            contentType: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            signature: Swift.String? = nil,
            size: Swift.Int? = nil,
            source: [Swift.String:Swift.String]? = nil,
            status: WorkDocsClientTypes.DocumentStatusType? = nil,
            thumbnail: [Swift.String:Swift.String]? = nil
        )
        {
            self.contentCreatedTimestamp = contentCreatedTimestamp
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.signature = signature
            self.size = size
            self.source = source
            self.status = status
            self.thumbnail = thumbnail
        }
    }

}

extension WorkDocsClientTypes {
    public enum DocumentVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentVersionStatus] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentVersionStatus(rawValue: rawValue) ?? DocumentVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DraftUploadOutOfSyncException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DraftUploadOutOfSyncExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.
public struct DraftUploadOutOfSyncException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DraftUploadOutOfSyncException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DraftUploadOutOfSyncExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DraftUploadOutOfSyncExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists.
public struct EntityAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityNotExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.entityIds = output.entityIds
            self.properties.message = output.message
        } else {
            self.properties.entityIds = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource does not exist.
public struct EntityNotExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The IDs of the non-existent resources.
        public internal(set) var entityIds: [Swift.String]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        entityIds: [Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.entityIds = entityIds
        self.properties.message = message
    }
}

struct EntityNotExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let entityIds: [Swift.String]?
}

extension EntityNotExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityIds = "EntityIds"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let entityIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityIds)
        var entityIdsDecoded0:[Swift.String]? = nil
        if let entityIdsContainer = entityIdsContainer {
            entityIdsDecoded0 = [Swift.String]()
            for string0 in entityIdsContainer {
                if let string0 = string0 {
                    entityIdsDecoded0?.append(string0)
                }
            }
        }
        entityIds = entityIdsDecoded0
    }
}

extension FailedDependencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FailedDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.
public struct FailedDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FailedDependencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FailedDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FailedDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.Filters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ancestorIds = "AncestorIds"
        case contentCategories = "ContentCategories"
        case createdRange = "CreatedRange"
        case labels = "Labels"
        case modifiedRange = "ModifiedRange"
        case principals = "Principals"
        case resourceTypes = "ResourceTypes"
        case searchCollectionTypes = "SearchCollectionTypes"
        case sizeRange = "SizeRange"
        case textLocales = "TextLocales"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ancestorIds = ancestorIds {
            var ancestorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ancestorIds)
            for searchancestorid0 in ancestorIds {
                try ancestorIdsContainer.encode(searchancestorid0)
            }
        }
        if let contentCategories = contentCategories {
            var contentCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentCategories)
            for contentcategorytype0 in contentCategories {
                try contentCategoriesContainer.encode(contentcategorytype0.rawValue)
            }
        }
        if let createdRange = self.createdRange {
            try encodeContainer.encode(createdRange, forKey: .createdRange)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for searchlabel0 in labels {
                try labelsContainer.encode(searchlabel0)
            }
        }
        if let modifiedRange = self.modifiedRange {
            try encodeContainer.encode(modifiedRange, forKey: .modifiedRange)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for searchprincipaltype0 in principals {
                try principalsContainer.encode(searchprincipaltype0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for searchresourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(searchresourcetype0.rawValue)
            }
        }
        if let searchCollectionTypes = searchCollectionTypes {
            var searchCollectionTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .searchCollectionTypes)
            for searchcollectiontype0 in searchCollectionTypes {
                try searchCollectionTypesContainer.encode(searchcollectiontype0.rawValue)
            }
        }
        if let sizeRange = self.sizeRange {
            try encodeContainer.encode(sizeRange, forKey: .sizeRange)
        }
        if let textLocales = textLocales {
            var textLocalesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textLocales)
            for languagecodetype0 in textLocales {
                try textLocalesContainer.encode(languagecodetype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textLocalesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.LanguageCodeType?].self, forKey: .textLocales)
        var textLocalesDecoded0:[WorkDocsClientTypes.LanguageCodeType]? = nil
        if let textLocalesContainer = textLocalesContainer {
            textLocalesDecoded0 = [WorkDocsClientTypes.LanguageCodeType]()
            for enum0 in textLocalesContainer {
                if let enum0 = enum0 {
                    textLocalesDecoded0?.append(enum0)
                }
            }
        }
        textLocales = textLocalesDecoded0
        let contentCategoriesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.ContentCategoryType?].self, forKey: .contentCategories)
        var contentCategoriesDecoded0:[WorkDocsClientTypes.ContentCategoryType]? = nil
        if let contentCategoriesContainer = contentCategoriesContainer {
            contentCategoriesDecoded0 = [WorkDocsClientTypes.ContentCategoryType]()
            for enum0 in contentCategoriesContainer {
                if let enum0 = enum0 {
                    contentCategoriesDecoded0?.append(enum0)
                }
            }
        }
        contentCategories = contentCategoriesDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SearchResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[WorkDocsClientTypes.SearchResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [WorkDocsClientTypes.SearchResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SearchPrincipalType?].self, forKey: .principals)
        var principalsDecoded0:[WorkDocsClientTypes.SearchPrincipalType]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [WorkDocsClientTypes.SearchPrincipalType]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let ancestorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ancestorIds)
        var ancestorIdsDecoded0:[Swift.String]? = nil
        if let ancestorIdsContainer = ancestorIdsContainer {
            ancestorIdsDecoded0 = [Swift.String]()
            for string0 in ancestorIdsContainer {
                if let string0 = string0 {
                    ancestorIdsDecoded0?.append(string0)
                }
            }
        }
        ancestorIds = ancestorIdsDecoded0
        let searchCollectionTypesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SearchCollectionType?].self, forKey: .searchCollectionTypes)
        var searchCollectionTypesDecoded0:[WorkDocsClientTypes.SearchCollectionType]? = nil
        if let searchCollectionTypesContainer = searchCollectionTypesContainer {
            searchCollectionTypesDecoded0 = [WorkDocsClientTypes.SearchCollectionType]()
            for enum0 in searchCollectionTypesContainer {
                if let enum0 = enum0 {
                    searchCollectionTypesDecoded0?.append(enum0)
                }
            }
        }
        searchCollectionTypes = searchCollectionTypesDecoded0
        let sizeRangeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.LongRangeType.self, forKey: .sizeRange)
        sizeRange = sizeRangeDecoded
        let createdRangeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DateRangeType.self, forKey: .createdRange)
        createdRange = createdRangeDecoded
        let modifiedRangeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DateRangeType.self, forKey: .modifiedRange)
        modifiedRange = modifiedRangeDecoded
    }
}

extension WorkDocsClientTypes {
    /// Filters results based on entity metadata.
    public struct Filters: Swift.Equatable {
        /// Filter based on resources path.
        public var ancestorIds: [Swift.String]?
        /// Filters by content category.
        public var contentCategories: [WorkDocsClientTypes.ContentCategoryType]?
        /// Filter based on resources creation timestamp.
        public var createdRange: WorkDocsClientTypes.DateRangeType?
        /// Filter by labels using exact match.
        public var labels: [Swift.String]?
        /// Filter based on resources modified timestamp.
        public var modifiedRange: WorkDocsClientTypes.DateRangeType?
        /// Filter based on UserIds or GroupIds.
        public var principals: [WorkDocsClientTypes.SearchPrincipalType]?
        /// Filters based on entity type.
        public var resourceTypes: [WorkDocsClientTypes.SearchResourceType]?
        /// Filter based on file groupings.
        public var searchCollectionTypes: [WorkDocsClientTypes.SearchCollectionType]?
        /// Filter based on size (in bytes).
        public var sizeRange: WorkDocsClientTypes.LongRangeType?
        /// Filters by the locale of the content or comment.
        public var textLocales: [WorkDocsClientTypes.LanguageCodeType]?

        public init(
            ancestorIds: [Swift.String]? = nil,
            contentCategories: [WorkDocsClientTypes.ContentCategoryType]? = nil,
            createdRange: WorkDocsClientTypes.DateRangeType? = nil,
            labels: [Swift.String]? = nil,
            modifiedRange: WorkDocsClientTypes.DateRangeType? = nil,
            principals: [WorkDocsClientTypes.SearchPrincipalType]? = nil,
            resourceTypes: [WorkDocsClientTypes.SearchResourceType]? = nil,
            searchCollectionTypes: [WorkDocsClientTypes.SearchCollectionType]? = nil,
            sizeRange: WorkDocsClientTypes.LongRangeType? = nil,
            textLocales: [WorkDocsClientTypes.LanguageCodeType]? = nil
        )
        {
            self.ancestorIds = ancestorIds
            self.contentCategories = contentCategories
            self.createdRange = createdRange
            self.labels = labels
            self.modifiedRange = modifiedRange
            self.principals = principals
            self.resourceTypes = resourceTypes
            self.searchCollectionTypes = searchCollectionTypes
            self.sizeRange = sizeRange
            self.textLocales = textLocales
        }
    }

}

extension WorkDocsClientTypes {
    public enum FolderContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case document
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderContentType] {
            return [
                .all,
                .document,
                .folder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .document: return "DOCUMENT"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderContentType(rawValue: rawValue) ?? FolderContentType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.FolderMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case labels = "Labels"
        case latestVersionSize = "LatestVersionSize"
        case modifiedTimestamp = "ModifiedTimestamp"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
        case signature = "Signature"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let creatorId = self.creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabel0 in labels {
                try labelsContainer.encode(sharedlabel0)
            }
        }
        if let latestVersionSize = self.latestVersionSize {
            try encodeContainer.encode(latestVersionSize, forKey: .latestVersionSize)
        }
        if let modifiedTimestamp = self.modifiedTimestamp {
            try encodeContainer.encodeTimestamp(modifiedTimestamp, format: .epochSeconds, forKey: .modifiedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = self.parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = self.resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let latestVersionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionSize)
        latestVersionSize = latestVersionSizeDecoded
    }
}

extension WorkDocsClientTypes.FolderMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FolderMetadata(createdTimestamp: \(Swift.String(describing: createdTimestamp)), creatorId: \(Swift.String(describing: creatorId)), id: \(Swift.String(describing: id)), labels: \(Swift.String(describing: labels)), latestVersionSize: \(Swift.String(describing: latestVersionSize)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), parentFolderId: \(Swift.String(describing: parentFolderId)), resourceState: \(Swift.String(describing: resourceState)), signature: \(Swift.String(describing: signature)), size: \(Swift.String(describing: size)), name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes a folder.
    public struct FolderMetadata: Swift.Equatable {
        /// The time when the folder was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the folder.
        public var id: Swift.String?
        /// List of labels on the folder.
        public var labels: [Swift.String]?
        /// The size of the latest version of the folder metadata.
        public var latestVersionSize: Swift.Int?
        /// The time when the folder was updated.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The name of the folder.
        public var name: Swift.String?
        /// The ID of the parent folder.
        public var parentFolderId: Swift.String?
        /// The resource state of the folder.
        public var resourceState: WorkDocsClientTypes.ResourceStateType?
        /// The unique identifier created from the subfolders and documents of the folder.
        public var signature: Swift.String?
        /// The size of the folder metadata.
        public var size: Swift.Int?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            latestVersionSize: Swift.Int? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            parentFolderId: Swift.String? = nil,
            resourceState: WorkDocsClientTypes.ResourceStateType? = nil,
            signature: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionSize = latestVersionSize
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
            self.signature = signature
            self.size = size
        }
    }

}

extension GetCurrentUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCurrentUserInput(authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetCurrentUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetCurrentUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/me"
    }
}

public struct GetCurrentUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token.
    /// This member is required.
    public var authenticationToken: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
    }
}

struct GetCurrentUserInputBody: Swift.Equatable {
}

extension GetCurrentUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCurrentUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCurrentUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct GetCurrentUserOutput: Swift.Equatable {
    /// Metadata of the user.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct GetCurrentUserOutputBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension GetCurrentUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum GetCurrentUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentInput(documentId: \(Swift.String(describing: documentId)), includeCustomMetadata: \(Swift.String(describing: includeCustomMetadata)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetDocumentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeCustomMetadata = includeCustomMetadata {
                let includeCustomMetadataQueryItem = ClientRuntime.URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
                items.append(includeCustomMetadataQueryItem)
            }
            return items
        }
    }
}

extension GetDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

public struct GetDocumentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Set this to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

struct GetDocumentInputBody: Swift.Equatable {
}

extension GetDocumentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentOutputBody = try responseDecoder.decode(responseBody: data)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetDocumentOutput: Swift.Equatable {
    /// The custom metadata on the document.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The metadata details of the document.
    public var metadata: WorkDocsClientTypes.DocumentMetadata?

    public init(
        customMetadata: [Swift.String:Swift.String]? = nil,
        metadata: WorkDocsClientTypes.DocumentMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetDocumentOutputBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.DocumentMetadata?
    let customMetadata: [Swift.String:Swift.String]?
}

extension GetDocumentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

enum GetDocumentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentPathInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentPathInput(documentId: \(Swift.String(describing: documentId)), fields: \(Swift.String(describing: fields)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetDocumentPathInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentPathInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fields = fields {
                let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
                items.append(fieldsQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension GetDocumentPathInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/path"
    }
}

public struct GetDocumentPathInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// A comma-separated list of values. Specify NAME to include the names of the parent folders.
    public var fields: Swift.String?
    /// The maximum number of levels in the hierarchy to return.
    public var limit: Swift.Int?
    /// This value is not supported.
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.limit = limit
        self.marker = marker
    }
}

struct GetDocumentPathInputBody: Swift.Equatable {
}

extension GetDocumentPathInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentPathOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentPathOutputBody = try responseDecoder.decode(responseBody: data)
            self.path = output.path
        } else {
            self.path = nil
        }
    }
}

public struct GetDocumentPathOutput: Swift.Equatable {
    /// The path information.
    public var path: WorkDocsClientTypes.ResourcePath?

    public init(
        path: WorkDocsClientTypes.ResourcePath? = nil
    )
    {
        self.path = path
    }
}

struct GetDocumentPathOutputBody: Swift.Equatable {
    let path: WorkDocsClientTypes.ResourcePath?
}

extension GetDocumentPathOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourcePath.self, forKey: .path)
        path = pathDecoded
    }
}

enum GetDocumentPathOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentVersionInput(documentId: \(Swift.String(describing: documentId)), fields: \(Swift.String(describing: fields)), includeCustomMetadata: \(Swift.String(describing: includeCustomMetadata)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetDocumentVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fields = fields {
                let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
                items.append(fieldsQueryItem)
            }
            if let includeCustomMetadata = includeCustomMetadata {
                let includeCustomMetadataQueryItem = ClientRuntime.URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
                items.append(includeCustomMetadataQueryItem)
            }
            return items
        }
    }
}

extension GetDocumentVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct GetDocumentVersionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.
    public var fields: Swift.String?
    /// Set this to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool?
    /// The version ID of the document.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.includeCustomMetadata = includeCustomMetadata
        self.versionId = versionId
    }
}

struct GetDocumentVersionInputBody: Swift.Equatable {
}

extension GetDocumentVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetDocumentVersionOutput: Swift.Equatable {
    /// The custom metadata on the document version.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The version metadata.
    public var metadata: WorkDocsClientTypes.DocumentVersionMetadata?

    public init(
        customMetadata: [Swift.String:Swift.String]? = nil,
        metadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetDocumentVersionOutputBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.DocumentVersionMetadata?
    let customMetadata: [Swift.String:Swift.String]?
}

extension GetDocumentVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

enum GetDocumentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFolderInput(folderId: \(Swift.String(describing: folderId)), includeCustomMetadata: \(Swift.String(describing: includeCustomMetadata)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetFolderInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeCustomMetadata = includeCustomMetadata {
                let includeCustomMetadataQueryItem = ClientRuntime.URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
                items.append(includeCustomMetadataQueryItem)
            }
            return items
        }
    }
}

extension GetFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct GetFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// Set to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

struct GetFolderInputBody: Swift.Equatable {
}

extension GetFolderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFolderOutputBody = try responseDecoder.decode(responseBody: data)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetFolderOutput: Swift.Equatable {
    /// The custom metadata on the folder.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The metadata of the folder.
    public var metadata: WorkDocsClientTypes.FolderMetadata?

    public init(
        customMetadata: [Swift.String:Swift.String]? = nil,
        metadata: WorkDocsClientTypes.FolderMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetFolderOutputBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.FolderMetadata?
    let customMetadata: [Swift.String:Swift.String]?
}

extension GetFolderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.FolderMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

enum GetFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFolderPathInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFolderPathInput(fields: \(Swift.String(describing: fields)), folderId: \(Swift.String(describing: folderId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetFolderPathInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetFolderPathInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fields = fields {
                let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
                items.append(fieldsQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension GetFolderPathInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/path"
    }
}

public struct GetFolderPathInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
    public var fields: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of levels in the hierarchy to return.
    public var limit: Swift.Int?
    /// This value is not supported.
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        fields: Swift.String? = nil,
        folderId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.folderId = folderId
        self.limit = limit
        self.marker = marker
    }
}

struct GetFolderPathInputBody: Swift.Equatable {
}

extension GetFolderPathInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFolderPathOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFolderPathOutputBody = try responseDecoder.decode(responseBody: data)
            self.path = output.path
        } else {
            self.path = nil
        }
    }
}

public struct GetFolderPathOutput: Swift.Equatable {
    /// The path information.
    public var path: WorkDocsClientTypes.ResourcePath?

    public init(
        path: WorkDocsClientTypes.ResourcePath? = nil
    )
    {
        self.path = path
    }
}

struct GetFolderPathOutputBody: Swift.Equatable {
    let path: WorkDocsClientTypes.ResourcePath?
}

extension GetFolderPathOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourcePath.self, forKey: .path)
        path = pathDecoded
    }
}

enum GetFolderPathOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcesInput(collectionType: \(Swift.String(describing: collectionType)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension GetResourcesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let userId = userId {
                let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
                items.append(userIdQueryItem)
            }
            if let collectionType = collectionType {
                let collectionTypeQueryItem = ClientRuntime.URLQueryItem(name: "collectionType".urlPercentEncoding(), value: Swift.String(collectionType.rawValue).urlPercentEncoding())
                items.append(collectionTypeQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension GetResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/resources"
    }
}

public struct GetResourcesInput: Swift.Equatable {
    /// The Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The collection type.
    public var collectionType: WorkDocsClientTypes.ResourceCollectionType?
    /// The maximum number of resources to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The user ID for the resource collection. This is a required field for accessing the API operation using IAM credentials.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        collectionType: WorkDocsClientTypes.ResourceCollectionType? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.collectionType = collectionType
        self.limit = limit
        self.marker = marker
        self.userId = userId
    }
}

struct GetResourcesInputBody: Swift.Equatable {
}

extension GetResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.documents = output.documents
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.documents = nil
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct GetResourcesOutput: Swift.Equatable {
    /// The documents in the specified collection.
    public var documents: [WorkDocsClientTypes.DocumentMetadata]?
    /// The folders in the specified folder.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        documents: [WorkDocsClientTypes.DocumentMetadata]? = nil,
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

struct GetResourcesOutputBody: Swift.Equatable {
    let folders: [WorkDocsClientTypes.FolderMetadata]?
    let documents: [WorkDocsClientTypes.DocumentMetadata]?
    let marker: Swift.String?
}

extension GetResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents = "Documents"
        case folders = "Folders"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[WorkDocsClientTypes.FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [WorkDocsClientTypes.FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let documentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.DocumentMetadata?].self, forKey: .documents)
        var documentsDecoded0:[WorkDocsClientTypes.DocumentMetadata]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [WorkDocsClientTypes.DocumentMetadata]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum GetResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkDocsClientTypes.GroupMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the metadata of a user group.
    public struct GroupMetadata: Swift.Equatable {
        /// The ID of the user group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension IllegalUserStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IllegalUserStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user is undergoing transfer of ownership.
public struct IllegalUserStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalUserStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalUserStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalUserStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InitiateDocumentVersionUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateDocumentVersionUploadInput(contentCreatedTimestamp: \(Swift.String(describing: contentCreatedTimestamp)), contentModifiedTimestamp: \(Swift.String(describing: contentModifiedTimestamp)), contentType: \(Swift.String(describing: contentType)), documentSizeInBytes: \(Swift.String(describing: documentSizeInBytes)), id: \(Swift.String(describing: id)), parentFolderId: \(Swift.String(describing: parentFolderId)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension InitiateDocumentVersionUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case documentSizeInBytes = "DocumentSizeInBytes"
        case id = "Id"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentCreatedTimestamp = self.contentCreatedTimestamp {
            try encodeContainer.encodeTimestamp(contentCreatedTimestamp, format: .epochSeconds, forKey: .contentCreatedTimestamp)
        }
        if let contentModifiedTimestamp = self.contentModifiedTimestamp {
            try encodeContainer.encodeTimestamp(contentModifiedTimestamp, format: .epochSeconds, forKey: .contentModifiedTimestamp)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let documentSizeInBytes = self.documentSizeInBytes {
            try encodeContainer.encode(documentSizeInBytes, forKey: .documentSizeInBytes)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = self.parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
    }
}

extension InitiateDocumentVersionUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension InitiateDocumentVersionUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/documents"
    }
}

public struct InitiateDocumentVersionUploadInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The timestamp when the content of the document was originally created.
    public var contentCreatedTimestamp: ClientRuntime.Date?
    /// The timestamp when the content of the document was modified.
    public var contentModifiedTimestamp: ClientRuntime.Date?
    /// The content type of the document.
    public var contentType: Swift.String?
    /// The size of the document, in bytes.
    public var documentSizeInBytes: Swift.Int?
    /// The ID of the document.
    public var id: Swift.String?
    /// The name of the document.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        contentCreatedTimestamp: ClientRuntime.Date? = nil,
        contentModifiedTimestamp: ClientRuntime.Date? = nil,
        contentType: Swift.String? = nil,
        documentSizeInBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.contentCreatedTimestamp = contentCreatedTimestamp
        self.contentModifiedTimestamp = contentModifiedTimestamp
        self.contentType = contentType
        self.documentSizeInBytes = documentSizeInBytes
        self.id = id
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

struct InitiateDocumentVersionUploadInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let contentCreatedTimestamp: ClientRuntime.Date?
    let contentModifiedTimestamp: ClientRuntime.Date?
    let contentType: Swift.String?
    let documentSizeInBytes: Swift.Int?
    let parentFolderId: Swift.String?
}

extension InitiateDocumentVersionUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case documentSizeInBytes = "DocumentSizeInBytes"
        case id = "Id"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentCreatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .contentCreatedTimestamp)
        contentCreatedTimestamp = contentCreatedTimestampDecoded
        let contentModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .contentModifiedTimestamp)
        contentModifiedTimestamp = contentModifiedTimestampDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let documentSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .documentSizeInBytes)
        documentSizeInBytes = documentSizeInBytesDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
    }
}

extension InitiateDocumentVersionUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InitiateDocumentVersionUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.metadata = nil
            self.uploadMetadata = nil
        }
    }
}

public struct InitiateDocumentVersionUploadOutput: Swift.Equatable {
    /// The document metadata.
    public var metadata: WorkDocsClientTypes.DocumentMetadata?
    /// The upload metadata.
    public var uploadMetadata: WorkDocsClientTypes.UploadMetadata?

    public init(
        metadata: WorkDocsClientTypes.DocumentMetadata? = nil,
        uploadMetadata: WorkDocsClientTypes.UploadMetadata? = nil
    )
    {
        self.metadata = metadata
        self.uploadMetadata = uploadMetadata
    }
}

struct InitiateDocumentVersionUploadOutputBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.DocumentMetadata?
    let uploadMetadata: WorkDocsClientTypes.UploadMetadata?
}

extension InitiateDocumentVersionUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case uploadMetadata = "UploadMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

enum InitiateDocumentVersionUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DraftUploadOutOfSyncException": return try await DraftUploadOutOfSyncException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyCheckedOutException": return try await ResourceAlreadyCheckedOutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StorageLimitExceededException": return try await StorageLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StorageLimitWillExceedException": return try await StorageLimitWillExceedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pagination marker or limit fields are not valid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommentOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCommentOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation is not allowed on the specified comment object.
public struct InvalidCommentOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommentOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCommentOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommentOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation is invalid.
public struct InvalidOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The password is invalid.
public struct InvalidPasswordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPasswordException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPasswordExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPasswordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum LanguageCodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ar
        case bg
        case bn
        case cs
        case da
        case de
        case `default`
        case el
        case en
        case es
        case fa
        case fi
        case fr
        case hi
        case hu
        case id
        case it
        case ja
        case ko
        case lt
        case lv
        case nl
        case no
        case pt
        case ro
        case ru
        case sv
        case sw
        case th
        case tr
        case zh
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCodeType] {
            return [
                .ar,
                .bg,
                .bn,
                .cs,
                .da,
                .de,
                .default,
                .el,
                .en,
                .es,
                .fa,
                .fi,
                .fr,
                .hi,
                .hu,
                .id,
                .it,
                .ja,
                .ko,
                .lt,
                .lv,
                .nl,
                .no,
                .pt,
                .ro,
                .ru,
                .sv,
                .sw,
                .th,
                .tr,
                .zh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ar: return "AR"
            case .bg: return "BG"
            case .bn: return "BN"
            case .cs: return "CS"
            case .da: return "DA"
            case .de: return "DE"
            case .default: return "DEFAULT"
            case .el: return "EL"
            case .en: return "EN"
            case .es: return "ES"
            case .fa: return "FA"
            case .fi: return "FI"
            case .fr: return "FR"
            case .hi: return "HI"
            case .hu: return "HU"
            case .id: return "ID"
            case .it: return "IT"
            case .ja: return "JA"
            case .ko: return "KO"
            case .lt: return "LT"
            case .lv: return "LV"
            case .nl: return "NL"
            case .no: return "NO"
            case .pt: return "PT"
            case .ro: return "RO"
            case .ru: return "RU"
            case .sv: return "SV"
            case .sw: return "SW"
            case .th: return "TH"
            case .tr: return "TR"
            case .zh: return "ZH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCodeType(rawValue: rawValue) ?? LanguageCodeType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum of 100,000 files and folders under the parent folder has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum LocaleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case de
        case `default`
        case en
        case es
        case fr
        case ja
        case ko
        case ptBr
        case ru
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LocaleType] {
            return [
                .de,
                .default,
                .en,
                .es,
                .fr,
                .ja,
                .ko,
                .ptBr,
                .ru,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .de: return "de"
            case .default: return "default"
            case .en: return "en"
            case .es: return "es"
            case .fr: return "fr"
            case .ja: return "ja"
            case .ko: return "ko"
            case .ptBr: return "pt_BR"
            case .ru: return "ru"
            case .zhCn: return "zh_CN"
            case .zhTw: return "zh_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocaleType(rawValue: rawValue) ?? LocaleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.LongRangeType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endValue = "EndValue"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endValue = self.endValue {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let startValue = self.startValue {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startValue)
        startValue = startValueDecoded
        let endValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension WorkDocsClientTypes {
    /// Filter based on size (in bytes).
    public struct LongRangeType: Swift.Equatable {
        /// The size end range (in bytes).
        public var endValue: Swift.Int?
        /// The size start range (in bytes).
        public var startValue: Swift.Int?

        public init(
            endValue: Swift.Int? = nil,
            startValue: Swift.Int? = nil
        )
        {
            self.endValue = endValue
            self.startValue = startValue
        }
    }

}

extension WorkDocsClientTypes.NotificationOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailMessage = "EmailMessage"
        case sendEmail = "SendEmail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = self.emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if sendEmail != false {
            try encodeContainer.encode(sendEmail, forKey: .sendEmail)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendEmailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sendEmail) ?? false
        sendEmail = sendEmailDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
    }
}

extension WorkDocsClientTypes.NotificationOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationOptions(sendEmail: \(Swift.String(describing: sendEmail)), emailMessage: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Set of options which defines notification preferences of given action.
    public struct NotificationOptions: Swift.Equatable {
        /// Text value to be included in the email body.
        public var emailMessage: Swift.String?
        /// Boolean value to indicate an email notification should be sent to the recipients.
        public var sendEmail: Swift.Bool

        public init(
            emailMessage: Swift.String? = nil,
            sendEmail: Swift.Bool = false
        )
        {
            self.emailMessage = emailMessage
            self.sendEmail = sendEmail
        }
    }

}

extension WorkDocsClientTypes {
    public enum OrderByFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdTimestamp
        case modifiedTimestamp
        case name
        case relevance
        case size
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderByFieldType] {
            return [
                .createdTimestamp,
                .modifiedTimestamp,
                .name,
                .relevance,
                .size,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdTimestamp: return "CREATED_TIMESTAMP"
            case .modifiedTimestamp: return "MODIFIED_TIMESTAMP"
            case .name: return "NAME"
            case .relevance: return "RELEVANCE"
            case .size: return "SIZE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderByFieldType(rawValue: rawValue) ?? OrderByFieldType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum OrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderType] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderType(rawValue: rawValue) ?? OrderType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.Participants: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupmetadata0 in groups {
                try groupsContainer.encode(groupmetadata0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for usermetadata0 in users {
                try usersContainer.encode(usermetadata0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.UserMetadata?].self, forKey: .users)
        var usersDecoded0:[WorkDocsClientTypes.UserMetadata]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkDocsClientTypes.UserMetadata]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.GroupMetadata?].self, forKey: .groups)
        var groupsDecoded0:[WorkDocsClientTypes.GroupMetadata]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkDocsClientTypes.GroupMetadata]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the users or user groups.
    public struct Participants: Swift.Equatable {
        /// The list of user groups.
        public var groups: [WorkDocsClientTypes.GroupMetadata]?
        /// The list of users.
        public var users: [WorkDocsClientTypes.UserMetadata]?

        public init(
            groups: [WorkDocsClientTypes.GroupMetadata]? = nil,
            users: [WorkDocsClientTypes.UserMetadata]? = nil
        )
        {
            self.groups = groups
            self.users = users
        }
    }

}

extension WorkDocsClientTypes.PermissionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RoleType.self, forKey: .role)
        role = roleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RolePermissionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the permissions.
    public struct PermissionInfo: Swift.Equatable {
        /// The role of the user.
        public var role: WorkDocsClientTypes.RoleType?
        /// The type of permissions.
        public var type: WorkDocsClientTypes.RolePermissionType?

        public init(
            role: WorkDocsClientTypes.RoleType? = nil,
            type: WorkDocsClientTypes.RolePermissionType? = nil
        )
        {
            self.role = role
            self.type = type
        }
    }

}

extension WorkDocsClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case roles = "Roles"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for permissioninfo0 in roles {
                try rolesContainer.encode(permissioninfo0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.PrincipalType.self, forKey: .type)
        type = typeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.PermissionInfo?].self, forKey: .roles)
        var rolesDecoded0:[WorkDocsClientTypes.PermissionInfo]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [WorkDocsClientTypes.PermissionInfo]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes a resource.
    public struct Principal: Swift.Equatable {
        /// The ID of the resource.
        public var id: Swift.String?
        /// The permission information for the resource.
        public var roles: [WorkDocsClientTypes.PermissionInfo]?
        /// The type of resource.
        public var type: WorkDocsClientTypes.PrincipalType?

        public init(
            id: Swift.String? = nil,
            roles: [WorkDocsClientTypes.PermissionInfo]? = nil,
            type: WorkDocsClientTypes.PrincipalType? = nil
        )
        {
            self.id = id
            self.roles = roles
            self.type = type
        }
    }

}

extension WorkDocsClientTypes {
    public enum PrincipalRoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case coowner
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalRoleType] {
            return [
                .contributor,
                .coowner,
                .owner,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .coowner: return "COOWNER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalRoleType(rawValue: rawValue) ?? PrincipalRoleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anonymous
        case group
        case invite
        case organization
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .anonymous,
                .group,
                .invite,
                .organization,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anonymous: return "ANONYMOUS"
            case .group: return "GROUP"
            case .invite: return "INVITE"
            case .organization: return "ORGANIZATION"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ProhibitedStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProhibitedStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified document version is not in the INITIALIZED state.
public struct ProhibitedStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProhibitedStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ProhibitedStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProhibitedStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RemoveAllResourcePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAllResourcePermissionsInput(resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension RemoveAllResourcePermissionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveAllResourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

public struct RemoveAllResourcePermissionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.resourceId = resourceId
    }
}

struct RemoveAllResourcePermissionsInputBody: Swift.Equatable {
}

extension RemoveAllResourcePermissionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveAllResourcePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveAllResourcePermissionsOutput: Swift.Equatable {

    public init() { }
}

enum RemoveAllResourcePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveResourcePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveResourcePermissionInput(principalId: \(Swift.String(describing: principalId)), principalType: \(Swift.String(describing: principalType)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension RemoveResourcePermissionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveResourcePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let principalType = principalType {
                let principalTypeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(principalType.rawValue).urlPercentEncoding())
                items.append(principalTypeQueryItem)
            }
            return items
        }
    }
}

extension RemoveResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions/\(principalId.urlPercentEncoding())"
    }
}

public struct RemoveResourcePermissionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The principal ID of the resource.
    /// This member is required.
    public var principalId: Swift.String?
    /// The principal type of the resource.
    public var principalType: WorkDocsClientTypes.PrincipalType?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: WorkDocsClientTypes.PrincipalType? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.principalId = principalId
        self.principalType = principalType
        self.resourceId = resourceId
    }
}

struct RemoveResourcePermissionInputBody: Swift.Equatable {
}

extension RemoveResourcePermissionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveResourcePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveResourcePermissionOutput: Swift.Equatable {

    public init() { }
}

enum RemoveResourcePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestedEntityTooLargeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestedEntityTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The response is too large to return. The request must include a filter to reduce the size of the response.
public struct RequestedEntityTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestedEntityTooLargeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestedEntityTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestedEntityTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyCheckedOutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyCheckedOutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is already checked out.
public struct ResourceAlreadyCheckedOutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyCheckedOutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyCheckedOutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyCheckedOutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum ResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sharedWithMe
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCollectionType] {
            return [
                .sharedWithMe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sharedWithMe: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceCollectionType(rawValue: rawValue) ?? ResourceCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.ResourceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case originalName = "OriginalName"
        case owner = "Owner"
        case parentId = "ParentId"
        case type = "Type"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let originalName = self.originalName {
            try encodeContainer.encode(originalName, forKey: .originalName)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentId = self.parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalName)
        originalName = originalNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserMetadata.self, forKey: .owner)
        owner = ownerDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
    }
}

extension WorkDocsClientTypes.ResourceMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceMetadata(id: \(Swift.String(describing: id)), owner: \(Swift.String(describing: owner)), parentId: \(Swift.String(describing: parentId)), type: \(Swift.String(describing: type)), versionId: \(Swift.String(describing: versionId)), name: \"CONTENT_REDACTED\", originalName: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes the metadata of a resource.
    public struct ResourceMetadata: Swift.Equatable {
        /// The ID of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The original name of the resource before a rename operation.
        public var originalName: Swift.String?
        /// The owner of the resource.
        public var owner: WorkDocsClientTypes.UserMetadata?
        /// The parent ID of the resource before a rename operation.
        public var parentId: Swift.String?
        /// The type of resource.
        public var type: WorkDocsClientTypes.ResourceType?
        /// The version ID of the resource. This is an optional field and is filled for action on document version.
        public var versionId: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            originalName: Swift.String? = nil,
            owner: WorkDocsClientTypes.UserMetadata? = nil,
            parentId: Swift.String? = nil,
            type: WorkDocsClientTypes.ResourceType? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.originalName = originalName
            self.owner = owner
            self.parentId = parentId
            self.type = type
            self.versionId = versionId
        }
    }

}

extension WorkDocsClientTypes.ResourcePath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components = "Components"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for resourcepathcomponent0 in components {
                try componentsContainer.encode(resourcepathcomponent0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.ResourcePathComponent?].self, forKey: .components)
        var componentsDecoded0:[WorkDocsClientTypes.ResourcePathComponent]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [WorkDocsClientTypes.ResourcePathComponent]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the path information of a resource.
    public struct ResourcePath: Swift.Equatable {
        /// The components of the resource path.
        public var components: [WorkDocsClientTypes.ResourcePathComponent]?

        public init(
            components: [WorkDocsClientTypes.ResourcePathComponent]? = nil
        )
        {
            self.components = components
        }
    }

}

extension WorkDocsClientTypes.ResourcePathComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkDocsClientTypes.ResourcePathComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePathComponent(id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes the resource path.
    public struct ResourcePathComponent: Swift.Equatable {
        /// The ID of the resource path.
        public var id: Swift.String?
        /// The name of the resource path.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension WorkDocsClientTypes {
    public enum ResourceSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSortType] {
            return [
                .date,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSortType(rawValue: rawValue) ?? ResourceSortType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum ResourceStateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case recycled
        case recycling
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStateType] {
            return [
                .active,
                .recycled,
                .recycling,
                .restoring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .recycled: return "RECYCLED"
            case .recycling: return "RECYCLING"
            case .restoring: return "RESTORING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStateType(rawValue: rawValue) ?? ResourceStateType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .document,
                .folder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.ResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentMetadata = "CommentMetadata"
        case documentMetadata = "DocumentMetadata"
        case documentVersionMetadata = "DocumentVersionMetadata"
        case folderMetadata = "FolderMetadata"
        case resourceType = "ResourceType"
        case webUrl = "WebUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentMetadata = self.commentMetadata {
            try encodeContainer.encode(commentMetadata, forKey: .commentMetadata)
        }
        if let documentMetadata = self.documentMetadata {
            try encodeContainer.encode(documentMetadata, forKey: .documentMetadata)
        }
        if let documentVersionMetadata = self.documentVersionMetadata {
            try encodeContainer.encode(documentVersionMetadata, forKey: .documentVersionMetadata)
        }
        if let folderMetadata = self.folderMetadata {
            try encodeContainer.encode(folderMetadata, forKey: .folderMetadata)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let webUrl = self.webUrl {
            try encodeContainer.encode(webUrl, forKey: .webUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResponseItemType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let webUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webUrl)
        webUrl = webUrlDecoded
        let documentMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentMetadata.self, forKey: .documentMetadata)
        documentMetadata = documentMetadataDecoded
        let folderMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.FolderMetadata.self, forKey: .folderMetadata)
        folderMetadata = folderMetadataDecoded
        let commentMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentMetadata.self, forKey: .commentMetadata)
        commentMetadata = commentMetadataDecoded
        let documentVersionMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionMetadata.self, forKey: .documentVersionMetadata)
        documentVersionMetadata = documentVersionMetadataDecoded
    }
}

extension WorkDocsClientTypes.ResponseItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseItem(commentMetadata: \(Swift.String(describing: commentMetadata)), documentMetadata: \(Swift.String(describing: documentMetadata)), documentVersionMetadata: \(Swift.String(describing: documentVersionMetadata)), folderMetadata: \(Swift.String(describing: folderMetadata)), resourceType: \(Swift.String(describing: resourceType)), webUrl: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// List of Documents, Folders, Comments, and Document Versions matching the query.
    public struct ResponseItem: Swift.Equatable {
        /// The comment that matches the query.
        public var commentMetadata: WorkDocsClientTypes.CommentMetadata?
        /// The document that matches the query.
        public var documentMetadata: WorkDocsClientTypes.DocumentMetadata?
        /// The document version that matches the metadata.
        public var documentVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata?
        /// The folder that matches the query.
        public var folderMetadata: WorkDocsClientTypes.FolderMetadata?
        /// The type of item being returned.
        public var resourceType: WorkDocsClientTypes.ResponseItemType?
        /// The webUrl of the item being returned.
        public var webUrl: Swift.String?

        public init(
            commentMetadata: WorkDocsClientTypes.CommentMetadata? = nil,
            documentMetadata: WorkDocsClientTypes.DocumentMetadata? = nil,
            documentVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil,
            folderMetadata: WorkDocsClientTypes.FolderMetadata? = nil,
            resourceType: WorkDocsClientTypes.ResponseItemType? = nil,
            webUrl: Swift.String? = nil
        )
        {
            self.commentMetadata = commentMetadata
            self.documentMetadata = documentMetadata
            self.documentVersionMetadata = documentVersionMetadata
            self.folderMetadata = folderMetadata
            self.resourceType = resourceType
            self.webUrl = webUrl
        }
    }

}

extension WorkDocsClientTypes {
    public enum ResponseItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comment
        case document
        case documentVersion
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseItemType] {
            return [
                .comment,
                .document,
                .documentVersion,
                .folder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comment: return "COMMENT"
            case .document: return "DOCUMENT"
            case .documentVersion: return "DOCUMENT_VERSION"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseItemType(rawValue: rawValue) ?? ResponseItemType.sdkUnknown(rawValue)
        }
    }
}

extension RestoreDocumentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDocumentVersionsInput(documentId: \(Swift.String(describing: documentId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension RestoreDocumentVersionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RestoreDocumentVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documentVersions/restore/\(documentId.urlPercentEncoding())"
    }
}

public struct RestoreDocumentVersionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
    }
}

struct RestoreDocumentVersionsInputBody: Swift.Equatable {
}

extension RestoreDocumentVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RestoreDocumentVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RestoreDocumentVersionsOutput: Swift.Equatable {

    public init() { }
}

enum RestoreDocumentVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkDocsClientTypes {
    public enum RolePermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case direct
        case inherited
        case sdkUnknown(Swift.String)

        public static var allCases: [RolePermissionType] {
            return [
                .direct,
                .inherited,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .direct: return "DIRECT"
            case .inherited: return "INHERITED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RolePermissionType(rawValue: rawValue) ?? RolePermissionType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum RoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case coowner
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleType] {
            return [
                .contributor,
                .coowner,
                .owner,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .coowner: return "COOWNER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleType(rawValue: rawValue) ?? RoleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum SearchCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case owned
        case sharedWithMe
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchCollectionType] {
            return [
                .owned,
                .sharedWithMe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .owned: return "OWNED"
            case .sharedWithMe: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchCollectionType(rawValue: rawValue) ?? SearchCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.SearchPrincipalType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case roles = "Roles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for principalroletype0 in roles {
                try rolesContainer.encode(principalroletype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let rolesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.PrincipalRoleType?].self, forKey: .roles)
        var rolesDecoded0:[WorkDocsClientTypes.PrincipalRoleType]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [WorkDocsClientTypes.PrincipalRoleType]()
            for enum0 in rolesContainer {
                if let enum0 = enum0 {
                    rolesDecoded0?.append(enum0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Filter based on UserIds or GroupIds.
    public struct SearchPrincipalType: Swift.Equatable {
        /// UserIds or GroupIds.
        /// This member is required.
        public var id: Swift.String?
        /// The Role of a User or Group.
        public var roles: [WorkDocsClientTypes.PrincipalRoleType]?

        public init(
            id: Swift.String? = nil,
            roles: [WorkDocsClientTypes.PrincipalRoleType]? = nil
        )
        {
            self.id = id
            self.roles = roles
        }
    }

}

extension WorkDocsClientTypes {
    public enum SearchQueryScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case content
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchQueryScopeType] {
            return [
                .content,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .content: return "CONTENT"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchQueryScopeType(rawValue: rawValue) ?? SearchQueryScopeType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum SearchResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comment
        case document
        case documentVersion
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchResourceType] {
            return [
                .comment,
                .document,
                .documentVersion,
                .folder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comment: return "COMMENT"
            case .document: return "DOCUMENT"
            case .documentVersion: return "DOCUMENT_VERSION"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchResourceType(rawValue: rawValue) ?? SearchResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SearchResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchResourcesInput(additionalResponseFields: \(Swift.String(describing: additionalResponseFields)), filters: \(Swift.String(describing: filters)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), orderBy: \(Swift.String(describing: orderBy)), organizationId: \(Swift.String(describing: organizationId)), queryScopes: \(Swift.String(describing: queryScopes)), authenticationToken: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension SearchResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalResponseFields = "AdditionalResponseFields"
        case filters = "Filters"
        case limit = "Limit"
        case marker = "Marker"
        case orderBy = "OrderBy"
        case organizationId = "OrganizationId"
        case queryScopes = "QueryScopes"
        case queryText = "QueryText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalResponseFields = additionalResponseFields {
            var additionalResponseFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalResponseFields)
            for additionalresponsefieldtype0 in additionalResponseFields {
                try additionalResponseFieldsContainer.encode(additionalresponsefieldtype0.rawValue)
            }
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let orderBy = orderBy {
            var orderByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderBy)
            for searchsortresult0 in orderBy {
                try orderByContainer.encode(searchsortresult0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let queryScopes = queryScopes {
            var queryScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryScopes)
            for searchqueryscopetype0 in queryScopes {
                try queryScopesContainer.encode(searchqueryscopetype0.rawValue)
            }
        }
        if let queryText = self.queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
    }
}

extension SearchResourcesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension SearchResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/search"
    }
}

public struct SearchResourcesInput: Swift.Equatable {
    /// A list of attributes to include in the response. Used to request fields that are not normally returned in a standard response.
    public var additionalResponseFields: [WorkDocsClientTypes.AdditionalResponseFieldType]?
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Filters results based on entity metadata.
    public var filters: WorkDocsClientTypes.Filters?
    /// Max results count per page.
    public var limit: Swift.Int?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// Order by results in one or more categories.
    public var orderBy: [WorkDocsClientTypes.SearchSortResult]?
    /// Filters based on the resource owner OrgId. This is a mandatory parameter when using Admin SigV4 credentials.
    public var organizationId: Swift.String?
    /// Filter based on the text field type. A Folder has only a name and no content. A Comment has only content and no name. A Document or Document Version has a name and content
    public var queryScopes: [WorkDocsClientTypes.SearchQueryScopeType]?
    /// The String to search for. Searches across different text fields based on request parameters. Use double quotes around the query string for exact phrase matches.
    public var queryText: Swift.String?

    public init(
        additionalResponseFields: [WorkDocsClientTypes.AdditionalResponseFieldType]? = nil,
        authenticationToken: Swift.String? = nil,
        filters: WorkDocsClientTypes.Filters? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        orderBy: [WorkDocsClientTypes.SearchSortResult]? = nil,
        organizationId: Swift.String? = nil,
        queryScopes: [WorkDocsClientTypes.SearchQueryScopeType]? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalResponseFields = additionalResponseFields
        self.authenticationToken = authenticationToken
        self.filters = filters
        self.limit = limit
        self.marker = marker
        self.orderBy = orderBy
        self.organizationId = organizationId
        self.queryScopes = queryScopes
        self.queryText = queryText
    }
}

struct SearchResourcesInputBody: Swift.Equatable {
    let queryText: Swift.String?
    let queryScopes: [WorkDocsClientTypes.SearchQueryScopeType]?
    let organizationId: Swift.String?
    let additionalResponseFields: [WorkDocsClientTypes.AdditionalResponseFieldType]?
    let filters: WorkDocsClientTypes.Filters?
    let orderBy: [WorkDocsClientTypes.SearchSortResult]?
    let limit: Swift.Int?
    let marker: Swift.String?
}

extension SearchResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalResponseFields = "AdditionalResponseFields"
        case filters = "Filters"
        case limit = "Limit"
        case marker = "Marker"
        case orderBy = "OrderBy"
        case organizationId = "OrganizationId"
        case queryScopes = "QueryScopes"
        case queryText = "QueryText"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let queryScopesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SearchQueryScopeType?].self, forKey: .queryScopes)
        var queryScopesDecoded0:[WorkDocsClientTypes.SearchQueryScopeType]? = nil
        if let queryScopesContainer = queryScopesContainer {
            queryScopesDecoded0 = [WorkDocsClientTypes.SearchQueryScopeType]()
            for enum0 in queryScopesContainer {
                if let enum0 = enum0 {
                    queryScopesDecoded0?.append(enum0)
                }
            }
        }
        queryScopes = queryScopesDecoded0
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let additionalResponseFieldsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.AdditionalResponseFieldType?].self, forKey: .additionalResponseFields)
        var additionalResponseFieldsDecoded0:[WorkDocsClientTypes.AdditionalResponseFieldType]? = nil
        if let additionalResponseFieldsContainer = additionalResponseFieldsContainer {
            additionalResponseFieldsDecoded0 = [WorkDocsClientTypes.AdditionalResponseFieldType]()
            for enum0 in additionalResponseFieldsContainer {
                if let enum0 = enum0 {
                    additionalResponseFieldsDecoded0?.append(enum0)
                }
            }
        }
        additionalResponseFields = additionalResponseFieldsDecoded0
        let filtersDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Filters.self, forKey: .filters)
        filters = filtersDecoded
        let orderByContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SearchSortResult?].self, forKey: .orderBy)
        var orderByDecoded0:[WorkDocsClientTypes.SearchSortResult]? = nil
        if let orderByContainer = orderByContainer {
            orderByDecoded0 = [WorkDocsClientTypes.SearchSortResult]()
            for structure0 in orderByContainer {
                if let structure0 = structure0 {
                    orderByDecoded0?.append(structure0)
                }
            }
        }
        orderBy = orderByDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension SearchResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.marker = output.marker
        } else {
            self.items = nil
            self.marker = nil
        }
    }
}

public struct SearchResourcesOutput: Swift.Equatable {
    /// List of Documents, Folders, Comments, and Document Versions matching the query.
    public var items: [WorkDocsClientTypes.ResponseItem]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        items: [WorkDocsClientTypes.ResponseItem]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.items = items
        self.marker = marker
    }
}

struct SearchResourcesOutputBody: Swift.Equatable {
    let items: [WorkDocsClientTypes.ResponseItem]?
    let marker: Swift.String?
}

extension SearchResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.ResponseItem?].self, forKey: .items)
        var itemsDecoded0:[WorkDocsClientTypes.ResponseItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [WorkDocsClientTypes.ResponseItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum SearchResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkDocsClientTypes.SearchSortResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field = "Field"
        case order = "Order"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.OrderByFieldType.self, forKey: .field)
        field = fieldDecoded
        let orderDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension WorkDocsClientTypes {
    /// The result of the sort operation.
    public struct SearchSortResult: Swift.Equatable {
        /// Sort search results based on this field name.
        public var field: WorkDocsClientTypes.OrderByFieldType?
        /// Sort direction.
        public var order: WorkDocsClientTypes.SortOrder?

        public init(
            field: WorkDocsClientTypes.OrderByFieldType? = nil,
            order: WorkDocsClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.order = order
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the dependencies is unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.SharePrincipal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case role = "Role"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.PrincipalType.self, forKey: .type)
        type = typeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RoleType.self, forKey: .role)
        role = roleDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the recipient type and ID, if available.
    public struct SharePrincipal: Swift.Equatable {
        /// The ID of the recipient.
        /// This member is required.
        public var id: Swift.String?
        /// The role of the recipient.
        /// This member is required.
        public var role: WorkDocsClientTypes.RoleType?
        /// The type of the recipient.
        /// This member is required.
        public var type: WorkDocsClientTypes.PrincipalType?

        public init(
            id: Swift.String? = nil,
            role: WorkDocsClientTypes.RoleType? = nil,
            type: WorkDocsClientTypes.PrincipalType? = nil
        )
        {
            self.id = id
            self.role = role
            self.type = type
        }
    }

}

extension WorkDocsClientTypes.ShareResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inviteePrincipalId = "InviteePrincipalId"
        case principalId = "PrincipalId"
        case role = "Role"
        case shareId = "ShareId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inviteePrincipalId = self.inviteePrincipalId {
            try encodeContainer.encode(inviteePrincipalId, forKey: .inviteePrincipalId)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let inviteePrincipalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inviteePrincipalId)
        inviteePrincipalId = inviteePrincipalIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RoleType.self, forKey: .role)
        role = roleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ShareStatusType.self, forKey: .status)
        status = statusDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WorkDocsClientTypes.ShareResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareResult(inviteePrincipalId: \(Swift.String(describing: inviteePrincipalId)), principalId: \(Swift.String(describing: principalId)), role: \(Swift.String(describing: role)), shareId: \(Swift.String(describing: shareId)), status: \(Swift.String(describing: status)), statusMessage: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes the share results of a resource.
    public struct ShareResult: Swift.Equatable {
        /// The ID of the invited user.
        public var inviteePrincipalId: Swift.String?
        /// The ID of the principal.
        public var principalId: Swift.String?
        /// The role.
        public var role: WorkDocsClientTypes.RoleType?
        /// The ID of the resource that was shared.
        public var shareId: Swift.String?
        /// The status.
        public var status: WorkDocsClientTypes.ShareStatusType?
        /// The status message.
        public var statusMessage: Swift.String?

        public init(
            inviteePrincipalId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            role: WorkDocsClientTypes.RoleType? = nil,
            shareId: Swift.String? = nil,
            status: WorkDocsClientTypes.ShareStatusType? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.inviteePrincipalId = inviteePrincipalId
            self.principalId = principalId
            self.role = role
            self.shareId = shareId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension WorkDocsClientTypes {
    public enum ShareStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatusType] {
            return [
                .failure,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatusType(rawValue: rawValue) ?? ShareStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StorageLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StorageLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The storage limit has been exceeded.
public struct StorageLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StorageLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StorageLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageLimitWillExceedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StorageLimitWillExceedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The storage limit will be exceeded.
public struct StorageLimitWillExceedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StorageLimitWillExceedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StorageLimitWillExceedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageLimitWillExceedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.StorageRuleType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageAllocatedInBytes = "StorageAllocatedInBytes"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageAllocatedInBytes = self.storageAllocatedInBytes {
            try encodeContainer.encode(storageAllocatedInBytes, forKey: .storageAllocatedInBytes)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageAllocatedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageAllocatedInBytes)
        storageAllocatedInBytes = storageAllocatedInBytesDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the storage for a user.
    public struct StorageRuleType: Swift.Equatable {
        /// The amount of storage allocated, in bytes.
        public var storageAllocatedInBytes: Swift.Int?
        /// The type of storage.
        public var storageType: WorkDocsClientTypes.StorageType?

        public init(
            storageAllocatedInBytes: Swift.Int? = nil,
            storageType: WorkDocsClientTypes.StorageType? = nil
        )
        {
            self.storageAllocatedInBytes = storageAllocatedInBytes
            self.storageType = storageType
        }
    }

}

extension WorkDocsClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quota
        case unlimited
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .quota,
                .unlimited,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quota: return "QUOTA"
            case .unlimited: return "UNLIMITED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoint = "EndPoint"
        case `protocol` = "Protocol"
        case subscriptionId = "SubscriptionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endPoint = self.endPoint {
            try encodeContainer.encode(endPoint, forKey: .endPoint)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let subscriptionId = self.subscriptionId {
            try encodeContainer.encode(subscriptionId, forKey: .subscriptionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
        let endPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endPoint)
        endPoint = endPointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SubscriptionProtocolType.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes a subscription.
    public struct Subscription: Swift.Equatable {
        /// The endpoint of the subscription.
        public var endPoint: Swift.String?
        /// The protocol of the subscription.
        public var `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
        /// The ID of the subscription.
        public var subscriptionId: Swift.String?

        public init(
            endPoint: Swift.String? = nil,
            `protocol`: WorkDocsClientTypes.SubscriptionProtocolType? = nil,
            subscriptionId: Swift.String? = nil
        )
        {
            self.endPoint = endPoint
            self.`protocol` = `protocol`
            self.subscriptionId = subscriptionId
        }
    }

}

extension WorkDocsClientTypes {
    public enum SubscriptionProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionProtocolType] {
            return [
                .https,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionProtocolType(rawValue: rawValue) ?? SubscriptionProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension TooManyLabelsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyLabelsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit has been reached on the number of labels for the specified resource.
public struct TooManyLabelsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLabelsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyLabelsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyLabelsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManySubscriptionsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManySubscriptionsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've reached the limit on the number of subscriptions for the WorkDocs instance.
public struct TooManySubscriptionsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManySubscriptionsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManySubscriptionsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManySubscriptionsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation is not permitted.
public struct UnauthorizedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnauthorizedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension UnauthorizedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UnauthorizedResourceAccessException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedResourceAccessExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The caller does not have access to perform the action on the resource.
public struct UnauthorizedResourceAccessException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedResourceAccessException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedResourceAccessExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedResourceAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentInput(documentId: \(Swift.String(describing: documentId)), parentFolderId: \(Swift.String(describing: parentFolderId)), resourceState: \(Swift.String(describing: resourceState)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = self.parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = self.resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }
}

extension UpdateDocumentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

public struct UpdateDocumentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The name of the document.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?
    /// The resource state of the document. Only ACTIVE and RECYCLED are supported.
    public var resourceState: WorkDocsClientTypes.ResourceStateType?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil,
        resourceState: WorkDocsClientTypes.ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

struct UpdateDocumentInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentFolderId: Swift.String?
    let resourceState: WorkDocsClientTypes.ResourceStateType?
}

extension UpdateDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension UpdateDocumentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDocumentOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDocumentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDocumentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentVersionInput(documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), versionStatus: \(Swift.String(describing: versionStatus)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension UpdateDocumentVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionStatus = "VersionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionStatus = self.versionStatus {
            try encodeContainer.encode(versionStatus.rawValue, forKey: .versionStatus)
        }
    }
}

extension UpdateDocumentVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateDocumentVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct UpdateDocumentVersionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The version ID of the document.
    /// This member is required.
    public var versionId: Swift.String?
    /// The status of the version.
    public var versionStatus: WorkDocsClientTypes.DocumentVersionStatus?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStatus: WorkDocsClientTypes.DocumentVersionStatus? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
        self.versionStatus = versionStatus
    }
}

struct UpdateDocumentVersionInputBody: Swift.Equatable {
    let versionStatus: WorkDocsClientTypes.DocumentVersionStatus?
}

extension UpdateDocumentVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionStatus = "VersionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionStatusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionStatus.self, forKey: .versionStatus)
        versionStatus = versionStatusDecoded
    }
}

extension UpdateDocumentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDocumentVersionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDocumentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFolderInput(folderId: \(Swift.String(describing: folderId)), parentFolderId: \(Swift.String(describing: parentFolderId)), resourceState: \(Swift.String(describing: resourceState)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = self.parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = self.resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }
}

extension UpdateFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct UpdateFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The name of the folder.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?
    /// The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from the API.
    public var resourceState: WorkDocsClientTypes.ResourceStateType?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil,
        resourceState: WorkDocsClientTypes.ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

struct UpdateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentFolderId: Swift.String?
    let resourceState: WorkDocsClientTypes.ResourceStateType?
}

extension UpdateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension UpdateFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFolderOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(grantPoweruserPrivileges: \(Swift.String(describing: grantPoweruserPrivileges)), locale: \(Swift.String(describing: locale)), storageRule: \(Swift.String(describing: storageRule)), timeZoneId: \(Swift.String(describing: timeZoneId)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\")"}
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case givenName = "GivenName"
        case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
        case locale = "Locale"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let givenName = self.givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let grantPoweruserPrivileges = self.grantPoweruserPrivileges {
            try encodeContainer.encode(grantPoweruserPrivileges.rawValue, forKey: .grantPoweruserPrivileges)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let storageRule = self.storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let surname = self.surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The given name of the user.
    public var givenName: Swift.String?
    /// Boolean value to determine whether the user is granted Power user privileges.
    public var grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType?
    /// The locale of the user.
    public var locale: WorkDocsClientTypes.LocaleType?
    /// The amount of storage for the user.
    public var storageRule: WorkDocsClientTypes.StorageRuleType?
    /// The surname of the user.
    public var surname: Swift.String?
    /// The time zone ID of the user.
    public var timeZoneId: Swift.String?
    /// The type of the user.
    public var type: WorkDocsClientTypes.UserType?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        givenName: Swift.String? = nil,
        grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType? = nil,
        locale: WorkDocsClientTypes.LocaleType? = nil,
        storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
        surname: Swift.String? = nil,
        timeZoneId: Swift.String? = nil,
        type: WorkDocsClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.givenName = givenName
        self.grantPoweruserPrivileges = grantPoweruserPrivileges
        self.locale = locale
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.type = type
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let givenName: Swift.String?
    let surname: Swift.String?
    let type: WorkDocsClientTypes.UserType?
    let storageRule: WorkDocsClientTypes.StorageRuleType?
    let timeZoneId: Swift.String?
    let locale: WorkDocsClientTypes.LocaleType?
    let grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case givenName = "GivenName"
        case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
        case locale = "Locale"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let localeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.LocaleType.self, forKey: .locale)
        locale = localeDecoded
        let grantPoweruserPrivilegesDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.BooleanEnumType.self, forKey: .grantPoweruserPrivileges)
        grantPoweruserPrivileges = grantPoweruserPrivilegesDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct UpdateUserOutput: Swift.Equatable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct UpdateUserOutputBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension UpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeactivatingLastSystemUserException": return try await DeactivatingLastSystemUserException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotExistsException": return try await EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependencyException": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalUserStateException": return try await IllegalUserStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProhibitedStateException": return try await ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperationException": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedResourceAccessException": return try await UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkDocsClientTypes.UploadMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signedHeaders = "SignedHeaders"
        case uploadUrl = "UploadUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signedHeaders = signedHeaders {
            var signedHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signedHeaders)
            for (dictKey0, signedHeaderMap0) in signedHeaders {
                try signedHeadersContainer.encode(signedHeaderMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uploadUrl = self.uploadUrl {
            try encodeContainer.encode(uploadUrl, forKey: .uploadUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadUrl)
        uploadUrl = uploadUrlDecoded
        let signedHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signedHeaders)
        var signedHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let signedHeadersContainer = signedHeadersContainer {
            signedHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, headervaluetype0) in signedHeadersContainer {
                if let headervaluetype0 = headervaluetype0 {
                    signedHeadersDecoded0?[key0] = headervaluetype0
                }
            }
        }
        signedHeaders = signedHeadersDecoded0
    }
}

extension WorkDocsClientTypes.UploadMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadMetadata(signedHeaders: \(Swift.String(describing: signedHeaders)), uploadUrl: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes the upload.
    public struct UploadMetadata: Swift.Equatable {
        /// The signed headers.
        public var signedHeaders: [Swift.String:Swift.String]?
        /// The URL of the upload.
        public var uploadUrl: Swift.String?

        public init(
            signedHeaders: [Swift.String:Swift.String]? = nil,
            uploadUrl: Swift.String? = nil
        )
        {
            self.signedHeaders = signedHeaders
            self.uploadUrl = uploadUrl
        }
    }

}

extension WorkDocsClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case id = "Id"
        case locale = "Locale"
        case modifiedTimestamp = "ModifiedTimestamp"
        case organizationId = "OrganizationId"
        case recycleBinFolderId = "RecycleBinFolderId"
        case rootFolderId = "RootFolderId"
        case status = "Status"
        case storage = "Storage"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = self.givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let modifiedTimestamp = self.modifiedTimestamp {
            try encodeContainer.encodeTimestamp(modifiedTimestamp, format: .epochSeconds, forKey: .modifiedTimestamp)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let recycleBinFolderId = self.recycleBinFolderId {
            try encodeContainer.encode(recycleBinFolderId, forKey: .recycleBinFolderId)
        }
        if let rootFolderId = self.rootFolderId {
            try encodeContainer.encode(rootFolderId, forKey: .rootFolderId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = self.storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
        if let surname = self.surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let rootFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootFolderId)
        rootFolderId = rootFolderIdDecoded
        let recycleBinFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recycleBinFolderId)
        recycleBinFolderId = recycleBinFolderIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserStatusType.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let localeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.LocaleType.self, forKey: .locale)
        locale = localeDecoded
        let storageDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserStorageMetadata.self, forKey: .storage)
        storage = storageDecoded
    }
}

extension WorkDocsClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(createdTimestamp: \(Swift.String(describing: createdTimestamp)), id: \(Swift.String(describing: id)), locale: \(Swift.String(describing: locale)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), organizationId: \(Swift.String(describing: organizationId)), recycleBinFolderId: \(Swift.String(describing: recycleBinFolderId)), rootFolderId: \(Swift.String(describing: rootFolderId)), status: \(Swift.String(describing: status)), storage: \(Swift.String(describing: storage)), timeZoneId: \(Swift.String(describing: timeZoneId)), type: \(Swift.String(describing: type)), emailAddress: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes a user.
    public struct User: Swift.Equatable {
        /// The time when the user was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The email address of the user.
        public var emailAddress: Swift.String?
        /// The given name of the user.
        public var givenName: Swift.String?
        /// The ID of the user.
        public var id: Swift.String?
        /// The locale of the user.
        public var locale: WorkDocsClientTypes.LocaleType?
        /// The time when the user was modified.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The ID of the organization.
        public var organizationId: Swift.String?
        /// The ID of the recycle bin folder.
        public var recycleBinFolderId: Swift.String?
        /// The ID of the root folder.
        public var rootFolderId: Swift.String?
        /// The status of the user.
        public var status: WorkDocsClientTypes.UserStatusType?
        /// The storage for the user.
        public var storage: WorkDocsClientTypes.UserStorageMetadata?
        /// The surname of the user.
        public var surname: Swift.String?
        /// The time zone ID of the user.
        public var timeZoneId: Swift.String?
        /// The type of user.
        public var type: WorkDocsClientTypes.UserType?
        /// The login name of the user.
        public var username: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            emailAddress: Swift.String? = nil,
            givenName: Swift.String? = nil,
            id: Swift.String? = nil,
            locale: WorkDocsClientTypes.LocaleType? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            organizationId: Swift.String? = nil,
            recycleBinFolderId: Swift.String? = nil,
            rootFolderId: Swift.String? = nil,
            status: WorkDocsClientTypes.UserStatusType? = nil,
            storage: WorkDocsClientTypes.UserStorageMetadata? = nil,
            surname: Swift.String? = nil,
            timeZoneId: Swift.String? = nil,
            type: WorkDocsClientTypes.UserType? = nil,
            username: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.locale = locale
            self.modifiedTimestamp = modifiedTimestamp
            self.organizationId = organizationId
            self.recycleBinFolderId = recycleBinFolderId
            self.rootFolderId = rootFolderId
            self.status = status
            self.storage = storage
            self.surname = surname
            self.timeZoneId = timeZoneId
            self.type = type
            self.username = username
        }
    }

}

extension WorkDocsClientTypes {
    public enum UserFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activePending
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [UserFilterType] {
            return [
                .activePending,
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activePending: return "ACTIVE_PENDING"
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserFilterType(rawValue: rawValue) ?? UserFilterType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.UserMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case id = "Id"
        case surname = "Surname"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = self.givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let surname = self.surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension WorkDocsClientTypes.UserMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserMetadata(id: \(Swift.String(describing: id)), emailAddress: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {
    /// Describes the metadata of the user.
    public struct UserMetadata: Swift.Equatable {
        /// The email address of the user.
        public var emailAddress: Swift.String?
        /// The given name of the user before a rename operation.
        public var givenName: Swift.String?
        /// The ID of the user.
        public var id: Swift.String?
        /// The surname of the user.
        public var surname: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            emailAddress: Swift.String? = nil,
            givenName: Swift.String? = nil,
            id: Swift.String? = nil,
            surname: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.surname = surname
            self.username = username
        }
    }

}

extension WorkDocsClientTypes {
    public enum UserSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullName
        case storageLimit
        case storageUsed
        case userName
        case userStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSortType] {
            return [
                .fullName,
                .storageLimit,
                .storageUsed,
                .userName,
                .userStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullName: return "FULL_NAME"
            case .storageLimit: return "STORAGE_LIMIT"
            case .storageUsed: return "STORAGE_USED"
            case .userName: return "USER_NAME"
            case .userStatus: return "USER_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserSortType(rawValue: rawValue) ?? UserSortType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum UserStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStatusType] {
            return [
                .active,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStatusType(rawValue: rawValue) ?? UserStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.UserStorageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageRule = "StorageRule"
        case storageUtilizedInBytes = "StorageUtilizedInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageRule = self.storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let storageUtilizedInBytes = self.storageUtilizedInBytes {
            try encodeContainer.encode(storageUtilizedInBytes, forKey: .storageUtilizedInBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageUtilizedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageUtilizedInBytes)
        storageUtilizedInBytes = storageUtilizedInBytesDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the storage for a user.
    public struct UserStorageMetadata: Swift.Equatable {
        /// The storage for a user.
        public var storageRule: WorkDocsClientTypes.StorageRuleType?
        /// The amount of storage used, in bytes.
        public var storageUtilizedInBytes: Swift.Int?

        public init(
            storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
            storageUtilizedInBytes: Swift.Int? = nil
        )
        {
            self.storageRule = storageRule
            self.storageUtilizedInBytes = storageUtilizedInBytes
        }
    }

}

extension WorkDocsClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case minimaluser
        case poweruser
        case user
        case workspacesuser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .admin,
                .minimaluser,
                .poweruser,
                .user,
                .workspacesuser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .minimaluser: return "MINIMALUSER"
            case .poweruser: return "POWERUSER"
            case .user: return "USER"
            case .workspacesuser: return "WORKSPACESUSER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}
