// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DeadlineClientTypes.AcceleratorCountRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension DeadlineClientTypes {
    /// The range for the GPU fleet acceleration.
    public struct AcceleratorCountRange: Swift.Equatable {
        /// The maximum GPU for the accelerator.
        public var max: Swift.Int?
        /// The minimum GPU for the accelerator.
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension DeadlineClientTypes.AcceleratorTotalMemoryMiBRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension DeadlineClientTypes {
    /// The range for memory, in MiB, to use for the accelerator.
    public struct AcceleratorTotalMemoryMiBRange: Swift.Equatable {
        /// The maximum amount of memory to use for the accelerator, measured in MiB.
        public var max: Swift.Int?
        /// The minimum amount of memory to use for the accelerator, measured in MiB.
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension DeadlineClientTypes {
    public enum AcceleratorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// GPU accelerator type.
        case gpu
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceleratorType] {
            return [
                .gpu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gpu: return "gpu"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceleratorType(rawValue: rawValue) ?? AcceleratorType.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permission to perform the action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let context: [Swift.String:Swift.String]?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
    }
}

extension DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The assigned starting environment for a worker during session.
    public struct AssignedEnvironmentEnterSessionActionDefinition: Swift.Equatable {
        /// The environment ID of the assigned environment at the start of a session.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }

}

extension DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The assigned environment when a worker exits a session.
    public struct AssignedEnvironmentExitSessionActionDefinition: Swift.Equatable {
        /// The environment ID of the assigned environment when exiting a session.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }

}

extension DeadlineClientTypes.AssignedSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case logConfiguration
        case queueId
        case sessionActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let sessionActions = sessionActions {
            var sessionActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sessionActions)
            for assignedsessionaction0 in sessionActions {
                try sessionActionsContainer.encode(assignedsessionaction0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sessionActionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.AssignedSessionAction?].self, forKey: .sessionActions)
        var sessionActionsDecoded0:[DeadlineClientTypes.AssignedSessionAction]? = nil
        if let sessionActionsContainer = sessionActionsContainer {
            sessionActionsDecoded0 = [DeadlineClientTypes.AssignedSessionAction]()
            for structure0 in sessionActionsContainer {
                if let structure0 = structure0 {
                    sessionActionsDecoded0?.append(structure0)
                }
            }
        }
        sessionActions = sessionActionsDecoded0
        let logConfigurationDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
    }
}

extension DeadlineClientTypes {
    /// The assigned session for the worker.
    public struct AssignedSession: Swift.Equatable {
        /// The job ID for the assigned session.
        /// This member is required.
        public var jobId: Swift.String?
        /// The log configuration for the worker's assigned session.
        /// This member is required.
        public var logConfiguration: DeadlineClientTypes.LogConfiguration?
        /// The queue ID of the assigned session.
        /// This member is required.
        public var queueId: Swift.String?
        /// The session actions to apply to the assigned session.
        /// This member is required.
        public var sessionActions: [DeadlineClientTypes.AssignedSessionAction]?

        public init(
            jobId: Swift.String? = nil,
            logConfiguration: DeadlineClientTypes.LogConfiguration? = nil,
            queueId: Swift.String? = nil,
            sessionActions: [DeadlineClientTypes.AssignedSessionAction]? = nil
        )
        {
            self.jobId = jobId
            self.logConfiguration = logConfiguration
            self.queueId = queueId
            self.sessionActions = sessionActions
        }
    }

}

extension DeadlineClientTypes.AssignedSessionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case sessionActionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let sessionActionId = self.sessionActionId {
            try encodeContainer.encode(sessionActionId, forKey: .sessionActionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionActionId)
        sessionActionId = sessionActionIdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AssignedSessionActionDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension DeadlineClientTypes {
    /// The action for a session defined by the session action ID.
    public struct AssignedSessionAction: Swift.Equatable {
        /// The definition of the assigned session action.
        /// This member is required.
        public var definition: DeadlineClientTypes.AssignedSessionActionDefinition?
        /// The session action ID for the assigned session.
        /// This member is required.
        public var sessionActionId: Swift.String?

        public init(
            definition: DeadlineClientTypes.AssignedSessionActionDefinition? = nil,
            sessionActionId: Swift.String? = nil
        )
        {
            self.definition = definition
            self.sessionActionId = sessionActionId
        }
    }

}

extension DeadlineClientTypes.AssignedSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enventer = "envEnter"
        case envexit = "envExit"
        case sdkUnknown
        case syncinputjobattachments = "syncInputJobAttachments"
        case taskrun = "taskRun"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .enventer(enventer):
                try container.encode(enventer, forKey: .enventer)
            case let .envexit(envexit):
                try container.encode(envexit, forKey: .envexit)
            case let .syncinputjobattachments(syncinputjobattachments):
                try container.encode(syncinputjobattachments, forKey: .syncinputjobattachments)
            case let .taskrun(taskrun):
                try container.encode(taskrun, forKey: .taskrun)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let enventerDecoded = try values.decodeIfPresent(DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition.self, forKey: .enventer)
        if let enventer = enventerDecoded {
            self = .enventer(enventer)
            return
        }
        let envexitDecoded = try values.decodeIfPresent(DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition.self, forKey: .envexit)
        if let envexit = envexitDecoded {
            self = .envexit(envexit)
            return
        }
        let taskrunDecoded = try values.decodeIfPresent(DeadlineClientTypes.AssignedTaskRunSessionActionDefinition.self, forKey: .taskrun)
        if let taskrun = taskrunDecoded {
            self = .taskrun(taskrun)
            return
        }
        let syncinputjobattachmentsDecoded = try values.decodeIfPresent(DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition.self, forKey: .syncinputjobattachments)
        if let syncinputjobattachments = syncinputjobattachmentsDecoded {
            self = .syncinputjobattachments(syncinputjobattachments)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The definition of the assigned session action.
    public enum AssignedSessionActionDefinition: Swift.Equatable {
        /// The environment a session starts on.
        case enventer(DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition)
        /// The environment a session exits from.
        case envexit(DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition)
        /// The task run.
        case taskrun(DeadlineClientTypes.AssignedTaskRunSessionActionDefinition)
        /// The job attachment to sync with an assigned session action.
        case syncinputjobattachments(DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The details for an assigned session action as it relates to a job attachment.
    public struct AssignedSyncInputJobAttachmentsSessionActionDefinition: Swift.Equatable {
        /// The step ID.
        public var stepId: Swift.String?

        public init(
            stepId: Swift.String? = nil
        )
        {
            self.stepId = stepId
        }
    }

}

extension DeadlineClientTypes.AssignedTaskRunSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
        case stepId
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, taskParameters0) in parameters {
                try parametersContainer.encode(taskParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.TaskParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.TaskParameterValue]()
            for (key0, taskparametervalue0) in parametersContainer {
                if let taskparametervalue0 = taskparametervalue0 {
                    parametersDecoded0?[key0] = taskparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DeadlineClientTypes.AssignedTaskRunSessionActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignedTaskRunSessionActionDefinition(stepId: \(Swift.String(describing: stepId)), taskId: \(Swift.String(describing: taskId)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The specific task, step, and parameters to include.
    public struct AssignedTaskRunSessionActionDefinition: Swift.Equatable {
        /// The parameters to include.
        /// This member is required.
        public var parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil,
            stepId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.stepId = stepId
            self.taskId = taskId
        }
    }

}

extension AssociateMemberToFarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension AssociateMemberToFarmInput {

    static func urlPathProvider(_ value: AssociateMemberToFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct AssociateMemberToFarmInput: Swift.Equatable {
    /// The ID of the farm to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The identity store ID of the member to associate with the farm.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The principal's membership level for the associated farm.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with the farm.
    /// This member is required.
    public var principalId: Swift.String?
    /// The principal type of the member to associate with the farm.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

    public init(
        farmId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
    )
    {
        self.farmId = farmId
        self.identityStoreId = identityStoreId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct AssociateMemberToFarmInputBody: Swift.Equatable {
    let principalType: DeadlineClientTypes.DeadlinePrincipalType?
    let identityStoreId: Swift.String?
    let membershipLevel: DeadlineClientTypes.MembershipLevel?
}

extension AssociateMemberToFarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension AssociateMemberToFarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMemberToFarmOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMemberToFarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateMemberToFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension AssociateMemberToFleetInput {

    static func urlPathProvider(_ value: AssociateMemberToFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct AssociateMemberToFleetInput: Swift.Equatable {
    /// The farm ID of the fleet to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The ID of the fleet to associate with a member.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The member's identity store ID to associate with the fleet.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The principal's membership level for the associated fleet.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with a fleet.
    /// This member is required.
    public var principalId: Swift.String?
    /// The member's principal type to associate with the fleet.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.identityStoreId = identityStoreId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct AssociateMemberToFleetInputBody: Swift.Equatable {
    let principalType: DeadlineClientTypes.DeadlinePrincipalType?
    let identityStoreId: Swift.String?
    let membershipLevel: DeadlineClientTypes.MembershipLevel?
}

extension AssociateMemberToFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension AssociateMemberToFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMemberToFleetOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMemberToFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateMemberToJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension AssociateMemberToJobInput {

    static func urlPathProvider(_ value: AssociateMemberToJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct AssociateMemberToJobInput: Swift.Equatable {
    /// The farm ID of the job to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The member's identity store ID to associate with the job.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The job ID to associate with the member.
    /// This member is required.
    public var jobId: Swift.String?
    /// The principal's membership level for the associated job.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with the job.
    /// This member is required.
    public var principalId: Swift.String?
    /// The member's principal type to associate with the job.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
    /// The queue ID to associate to the member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.identityStoreId = identityStoreId
        self.jobId = jobId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
        self.queueId = queueId
    }
}

struct AssociateMemberToJobInputBody: Swift.Equatable {
    let principalType: DeadlineClientTypes.DeadlinePrincipalType?
    let identityStoreId: Swift.String?
    let membershipLevel: DeadlineClientTypes.MembershipLevel?
}

extension AssociateMemberToJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension AssociateMemberToJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMemberToJobOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMemberToJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateMemberToQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension AssociateMemberToQueueInput {

    static func urlPathProvider(_ value: AssociateMemberToQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct AssociateMemberToQueueInput: Swift.Equatable {
    /// The farm ID of the queue to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The member's identity store ID to associate with the queue.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The principal's membership level for the associated queue.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with the queue.
    /// This member is required.
    public var principalId: Swift.String?
    /// The member's principal type to associate with the queue.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
    /// The ID of the queue to associate to the member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.identityStoreId = identityStoreId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
        self.queueId = queueId
    }
}

struct AssociateMemberToQueueInputBody: Swift.Equatable {
    let principalType: DeadlineClientTypes.DeadlinePrincipalType?
    let identityStoreId: Swift.String?
    let membershipLevel: DeadlineClientTypes.MembershipLevel?
}

extension AssociateMemberToQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case membershipLevel
        case principalType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension AssociateMemberToQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMemberToQueueOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMemberToQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssumeFleetRoleForReadInput {

    static func urlPathProvider(_ value: AssumeFleetRoleForReadInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/read-roles"
    }
}

public struct AssumeFleetRoleForReadInput: Swift.Equatable {
    /// The farm ID for the fleet's farm.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
    }
}

struct AssumeFleetRoleForReadInputBody: Swift.Equatable {
}

extension AssumeFleetRoleForReadInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssumeFleetRoleForReadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AssumeFleetRoleForReadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeFleetRoleForReadOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct AssumeFleetRoleForReadOutput: Swift.Equatable {
    /// The credentials for the fleet role.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct AssumeFleetRoleForReadOutputBody: Swift.Equatable {
    let credentials: DeadlineClientTypes.AwsCredentials?
}

extension AssumeFleetRoleForReadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

enum AssumeFleetRoleForReadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssumeFleetRoleForWorkerInput {

    static func urlPathProvider(_ value: AssumeFleetRoleForWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/fleet-roles"
    }
}

public struct AssumeFleetRoleForWorkerInput: Swift.Equatable {
    /// The farm ID for the fleet's farm.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID that contains the worker.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The ID of the worker assuming the fleet role.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.workerId = workerId
    }
}

struct AssumeFleetRoleForWorkerInputBody: Swift.Equatable {
}

extension AssumeFleetRoleForWorkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssumeFleetRoleForWorkerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AssumeFleetRoleForWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeFleetRoleForWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct AssumeFleetRoleForWorkerOutput: Swift.Equatable {
    /// The credentials for the worker.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct AssumeFleetRoleForWorkerOutputBody: Swift.Equatable {
    let credentials: DeadlineClientTypes.AwsCredentials?
}

extension AssumeFleetRoleForWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

enum AssumeFleetRoleForWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssumeQueueRoleForReadInput {

    static func urlPathProvider(_ value: AssumeQueueRoleForReadInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/read-roles"
    }
}

public struct AssumeQueueRoleForReadInput: Swift.Equatable {
    /// The farm ID of the farm containing the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

struct AssumeQueueRoleForReadInputBody: Swift.Equatable {
}

extension AssumeQueueRoleForReadInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssumeQueueRoleForReadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AssumeQueueRoleForReadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeQueueRoleForReadOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct AssumeQueueRoleForReadOutput: Swift.Equatable {
    /// The credentials for the queue role.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct AssumeQueueRoleForReadOutputBody: Swift.Equatable {
    let credentials: DeadlineClientTypes.AwsCredentials?
}

extension AssumeQueueRoleForReadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

enum AssumeQueueRoleForReadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssumeQueueRoleForUserInput {

    static func urlPathProvider(_ value: AssumeQueueRoleForUserInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/user-roles"
    }
}

public struct AssumeQueueRoleForUserInput: Swift.Equatable {
    /// The farm ID of the queue that the user assumes the role for.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID of the queue that the user assumes the role for.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

struct AssumeQueueRoleForUserInputBody: Swift.Equatable {
}

extension AssumeQueueRoleForUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssumeQueueRoleForUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AssumeQueueRoleForUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeQueueRoleForUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct AssumeQueueRoleForUserOutput: Swift.Equatable {
    /// The credentials for the queue role that a user has access to.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct AssumeQueueRoleForUserOutputBody: Swift.Equatable {
    let credentials: DeadlineClientTypes.AwsCredentials?
}

extension AssumeQueueRoleForUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

enum AssumeQueueRoleForUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssumeQueueRoleForWorkerInput {

    static func queryItemProvider(_ value: AssumeQueueRoleForWorkerInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let queueId = value.queueId else {
            let message = "Creating a URL Query Item failed. queueId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let queueIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "queueId".urlPercentEncoding(), value: Swift.String(queueId).urlPercentEncoding())
        items.append(queueIdQueryItem)
        return items
    }
}

extension AssumeQueueRoleForWorkerInput {

    static func urlPathProvider(_ value: AssumeQueueRoleForWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/queue-roles"
    }
}

public struct AssumeQueueRoleForWorkerInput: Swift.Equatable {
    /// The farm ID of the worker assuming the queue role.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker assuming the queue role.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID of the worker assuming the queue role.
    /// This member is required.
    public var queueId: Swift.String?
    /// The worker ID of the worker assuming the queue role.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
        self.workerId = workerId
    }
}

struct AssumeQueueRoleForWorkerInputBody: Swift.Equatable {
}

extension AssumeQueueRoleForWorkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssumeQueueRoleForWorkerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AssumeQueueRoleForWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeQueueRoleForWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct AssumeQueueRoleForWorkerOutput: Swift.Equatable {
    /// The Amazon Web Services credentials for the role that the worker is assuming.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct AssumeQueueRoleForWorkerOutputBody: Swift.Equatable {
    let credentials: DeadlineClientTypes.AwsCredentials?
}

extension AssumeQueueRoleForWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

enum AssumeQueueRoleForWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.Attachments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystem
        case manifests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystem = self.fileSystem {
            try encodeContainer.encode(fileSystem.rawValue, forKey: .fileSystem)
        }
        if let manifests = manifests {
            var manifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .manifests)
            for manifestproperties0 in manifests {
                try manifestsContainer.encode(manifestproperties0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.ManifestProperties?].self, forKey: .manifests)
        var manifestsDecoded0:[DeadlineClientTypes.ManifestProperties]? = nil
        if let manifestsContainer = manifestsContainer {
            manifestsDecoded0 = [DeadlineClientTypes.ManifestProperties]()
            for structure0 in manifestsContainer {
                if let structure0 = structure0 {
                    manifestsDecoded0?.append(structure0)
                }
            }
        }
        manifests = manifestsDecoded0
        let fileSystemDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobAttachmentsFileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

extension DeadlineClientTypes {
    /// The attachments for jobs.
    public struct Attachments: Swift.Equatable {
        /// The file system.
        public var fileSystem: DeadlineClientTypes.JobAttachmentsFileSystem?
        /// A list of manifests which describe job attachment configurations.
        /// This member is required.
        public var manifests: [DeadlineClientTypes.ManifestProperties]?

        public init(
            fileSystem: DeadlineClientTypes.JobAttachmentsFileSystem? = nil,
            manifests: [DeadlineClientTypes.ManifestProperties]? = nil
        )
        {
            self.fileSystem = fileSystem
            self.manifests = manifests
        }
    }

}

extension DeadlineClientTypes {
    public enum AutoScalingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventBasedAutoScaling
        case noScaling
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingMode] {
            return [
                .eventBasedAutoScaling,
                .noScaling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventBasedAutoScaling: return "EVENT_BASED_AUTO_SCALING"
            case .noScaling: return "NO_SCALING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingMode(rawValue: rawValue) ?? AutoScalingMode.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum AutoScalingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case growing
        case shrinking
        case steady
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingStatus] {
            return [
                .growing,
                .shrinking,
                .steady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .growing: return "GROWING"
            case .shrinking: return "SHRINKING"
            case .steady: return "STEADY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingStatus(rawValue: rawValue) ?? AutoScalingStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.AwsCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case expiration
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let expiration = self.expiration {
            try encodeContainer.encodeTimestamp(expiration, format: .dateTime, forKey: .expiration)
        }
        if let secretAccessKey = self.secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension DeadlineClientTypes.AwsCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {
    /// The Identity and Access Management credentials.
    public struct AwsCredentials: Swift.Equatable {
        /// The IAM access key ID.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The expiration date and time of the IAM credentials.
        /// This member is required.
        public var expiration: ClientRuntime.Date?
        /// The IAM secret access key.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The IAM session token
        /// This member is required.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension BatchGetJobEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for jobentityidentifiersunion0 in identifiers {
                try identifiersContainer.encode(jobentityidentifiersunion0)
            }
        }
    }
}

extension BatchGetJobEntityInput {

    static func urlPathProvider(_ value: BatchGetJobEntityInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/batchGetJobEntity"
    }
}

public struct BatchGetJobEntityInput: Swift.Equatable {
    /// The farm ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The job identifiers to include within the job entity batch details.
    /// This member is required.
    public var identifiers: [DeadlineClientTypes.JobEntityIdentifiersUnion]?
    /// The worker ID of the worker containing the job details to get.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        identifiers: [DeadlineClientTypes.JobEntityIdentifiersUnion]? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.identifiers = identifiers
        self.workerId = workerId
    }
}

struct BatchGetJobEntityInputBody: Swift.Equatable {
    let identifiers: [DeadlineClientTypes.JobEntityIdentifiersUnion]?
}

extension BatchGetJobEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifiersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.JobEntityIdentifiersUnion?].self, forKey: .identifiers)
        var identifiersDecoded0:[DeadlineClientTypes.JobEntityIdentifiersUnion]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [DeadlineClientTypes.JobEntityIdentifiersUnion]()
            for union0 in identifiersContainer {
                if let union0 = union0 {
                    identifiersDecoded0?.append(union0)
                }
            }
        }
        identifiers = identifiersDecoded0
    }
}

extension BatchGetJobEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetJobEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.errors = output.errors
        } else {
            self.entities = nil
            self.errors = nil
        }
    }
}

public struct BatchGetJobEntityOutput: Swift.Equatable {
    /// A list of the job entities, or details, in the batch.
    /// This member is required.
    public var entities: [DeadlineClientTypes.JobEntity]?
    /// A list of errors from the job error logs for the batch.
    /// This member is required.
    public var errors: [DeadlineClientTypes.GetJobEntityError]?

    public init(
        entities: [DeadlineClientTypes.JobEntity]? = nil,
        errors: [DeadlineClientTypes.GetJobEntityError]? = nil
    )
    {
        self.entities = entities
        self.errors = errors
    }
}

struct BatchGetJobEntityOutputBody: Swift.Equatable {
    let entities: [DeadlineClientTypes.JobEntity]?
    let errors: [DeadlineClientTypes.GetJobEntityError]?
}

extension BatchGetJobEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.JobEntity?].self, forKey: .entities)
        var entitiesDecoded0:[DeadlineClientTypes.JobEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [DeadlineClientTypes.JobEntity]()
            for union0 in entitiesContainer {
                if let union0 = union0 {
                    entitiesDecoded0?.append(union0)
                }
            }
        }
        entities = entitiesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.GetJobEntityError?].self, forKey: .errors)
        var errorsDecoded0:[DeadlineClientTypes.GetJobEntityError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DeadlineClientTypes.GetJobEntityError]()
            for union0 in errorsContainer {
                if let union0 = union0 {
                    errorsDecoded0?.append(union0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetJobEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.BudgetActionToAdd: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case thresholdPercentage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let thresholdPercentage = self.thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetActionType.self, forKey: .type)
        type = typeDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DeadlineClientTypes.BudgetActionToAdd: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetActionToAdd(thresholdPercentage: \(Swift.String(describing: thresholdPercentage)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The budget action to add.
    public struct BudgetActionToAdd: Swift.Equatable {
        /// A description for the budget action to add.
        public var description: Swift.String?
        /// The percentage threshold for the budget action to add.
        /// This member is required.
        public var thresholdPercentage: Swift.Float?
        /// The type of budget action to add.
        /// This member is required.
        public var type: DeadlineClientTypes.BudgetActionType?

        public init(
            description: Swift.String? = nil,
            thresholdPercentage: Swift.Float? = nil,
            type: DeadlineClientTypes.BudgetActionType? = nil
        )
        {
            self.description = description
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }
    }

}

extension DeadlineClientTypes.BudgetActionToRemove: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thresholdPercentage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thresholdPercentage = self.thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetActionType.self, forKey: .type)
        type = typeDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
    }
}

extension DeadlineClientTypes {
    /// The budget action to remove.
    public struct BudgetActionToRemove: Swift.Equatable {
        /// The percentage threshold for the budget action to remove.
        /// This member is required.
        public var thresholdPercentage: Swift.Float?
        /// The type of budget action to remove.
        /// This member is required.
        public var type: DeadlineClientTypes.BudgetActionType?

        public init(
            thresholdPercentage: Swift.Float? = nil,
            type: DeadlineClientTypes.BudgetActionType? = nil
        )
        {
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }
    }

}

extension DeadlineClientTypes {
    public enum BudgetActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetActionType] {
            return [
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BudgetActionType(rawValue: rawValue) ?? BudgetActionType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.BudgetSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fixed
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fixed(fixed):
                try container.encode(fixed, forKey: .fixed)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fixedDecoded = try values.decodeIfPresent(DeadlineClientTypes.FixedBudgetSchedule.self, forKey: .fixed)
        if let fixed = fixedDecoded {
            self = .fixed(fixed)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The start and end time of the budget.
    public enum BudgetSchedule: Swift.Equatable {
        /// The fixed start and end time of the budget's schedule.
        case fixed(DeadlineClientTypes.FixedBudgetSchedule)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes {
    public enum BudgetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BudgetStatus(rawValue: rawValue) ?? BudgetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.BudgetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateDollarLimit
        case budgetId
        case createdAt
        case createdBy
        case description
        case displayName
        case status
        case updatedAt
        case updatedBy
        case usageTrackingResource
        case usages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateDollarLimit = self.approximateDollarLimit {
            try encodeContainer.encode(approximateDollarLimit, forKey: .approximateDollarLimit)
        }
        if let budgetId = self.budgetId {
            try encodeContainer.encode(budgetId, forKey: .budgetId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let usageTrackingResource = self.usageTrackingResource {
            try encodeContainer.encode(usageTrackingResource, forKey: .usageTrackingResource)
        }
        if let usages = self.usages {
            try encodeContainer.encode(usages, forKey: .usages)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetId)
        budgetId = budgetIdDecoded
        let usageTrackingResourceDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UsageTrackingResource.self, forKey: .usageTrackingResource)
        usageTrackingResource = usageTrackingResourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetStatus.self, forKey: .status)
        status = statusDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let approximateDollarLimitDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .approximateDollarLimit)
        approximateDollarLimit = approximateDollarLimitDecoded
        let usagesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ConsumedUsages.self, forKey: .usages)
        usages = usagesDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DeadlineClientTypes.BudgetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetSummary(approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), budgetId: \(Swift.String(describing: budgetId)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), usageTrackingResource: \(Swift.String(describing: usageTrackingResource)), usages: \(Swift.String(describing: usages)), description: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The budget summary.
    public struct BudgetSummary: Swift.Equatable {
        /// The approximate dollar limit of the budget.
        /// This member is required.
        public var approximateDollarLimit: Swift.Float?
        /// The budget ID.
        /// This member is required.
        public var budgetId: Swift.String?
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the budget summary.
        public var description: Swift.String?
        /// The display name of the budget summary to update.
        /// This member is required.
        public var displayName: Swift.String?
        /// The status of the budget.
        ///
        /// * ACTIVEThe budget is being evaluated.
        ///
        /// * INACTIVEThe budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
        /// This member is required.
        public var status: DeadlineClientTypes.BudgetStatus?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The resource used to track expenditure in the budget.
        /// This member is required.
        public var usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?
        /// The consumed usage for the budget.
        /// This member is required.
        public var usages: DeadlineClientTypes.ConsumedUsages?

        public init(
            approximateDollarLimit: Swift.Float? = nil,
            budgetId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: DeadlineClientTypes.BudgetStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            usageTrackingResource: DeadlineClientTypes.UsageTrackingResource? = nil,
            usages: DeadlineClientTypes.ConsumedUsages? = nil
        )
        {
            self.approximateDollarLimit = approximateDollarLimit
            self.budgetId = budgetId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.displayName = displayName
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.usageTrackingResource = usageTrackingResource
            self.usages = usages
        }
    }

}

extension DeadlineClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greaterThan
        case greaterThanEqualTo
        case lessThan
        case lessThanEqualTo
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greaterThan,
                .greaterThanEqualTo,
                .lessThan,
                .lessThanEqualTo,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanEqualTo: return "GREATER_THAN_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanEqualTo: return "LESS_THAN_EQUAL_TO"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum CompletedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case interrupted
        case neverAttempted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CompletedStatus] {
            return [
                .canceled,
                .failed,
                .interrupted,
                .neverAttempted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .neverAttempted: return "NEVER_ATTEMPTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompletedStatus(rawValue: rawValue) ?? CompletedStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.context = nil
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A description of the error.
        /// This member is required.
        public internal(set) var reason: DeadlineClientTypes.ConflictExceptionReason? = nil
        /// The identifier of the resource in use.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource in use.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil,
        reason: DeadlineClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: DeadlineClientTypes.ConflictExceptionReason?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let context: [Swift.String:Swift.String]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case message
        case reason
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
    }
}

extension DeadlineClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentModification
        case conflictException
        case resourceAlreadyExists
        case resourceInUse
        case statusConflict
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification,
                .conflictException,
                .resourceAlreadyExists,
                .resourceInUse,
                .statusConflict,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case .conflictException: return "CONFLICT_EXCEPTION"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceInUse: return "RESOURCE_IN_USE"
            case .statusConflict: return "STATUS_CONFLICT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.ConsumedUsages: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateDollarUsage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateDollarUsage = self.approximateDollarUsage {
            try encodeContainer.encode(approximateDollarUsage, forKey: .approximateDollarUsage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateDollarUsageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .approximateDollarUsage)
        approximateDollarUsage = approximateDollarUsageDecoded
    }
}

extension DeadlineClientTypes {
    /// The consumed usage for the resource.
    public struct ConsumedUsages: Swift.Equatable {
        /// The amount of the budget consumed.
        /// This member is required.
        public var approximateDollarUsage: Swift.Float?

        public init(
            approximateDollarUsage: Swift.Float? = nil
        )
        {
            self.approximateDollarUsage = approximateDollarUsage
        }
    }

}

extension CopyJobTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetS3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetS3Location = self.targetS3Location {
            try encodeContainer.encode(targetS3Location, forKey: .targetS3Location)
        }
    }
}

extension CopyJobTemplateInput {

    static func urlPathProvider(_ value: CopyJobTemplateInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/template"
    }
}

public struct CopyJobTemplateInput: Swift.Equatable {
    /// The farm ID to copy.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to copy.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to copy.
    /// This member is required.
    public var queueId: Swift.String?
    /// The Amazon S3 bucket name and key where you would like to add a copy of the job template.
    /// This member is required.
    public var targetS3Location: DeadlineClientTypes.S3Location?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        targetS3Location: DeadlineClientTypes.S3Location? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.targetS3Location = targetS3Location
    }
}

struct CopyJobTemplateInputBody: Swift.Equatable {
    let targetS3Location: DeadlineClientTypes.S3Location?
}

extension CopyJobTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetS3Location
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetS3LocationDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.S3Location.self, forKey: .targetS3Location)
        targetS3Location = targetS3LocationDecoded
    }
}

extension CopyJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateType = output.templateType
        } else {
            self.templateType = nil
        }
    }
}

public struct CopyJobTemplateOutput: Swift.Equatable {
    /// The format of the job template, either JSON or YAML.
    /// This member is required.
    public var templateType: DeadlineClientTypes.JobTemplateType?

    public init(
        templateType: DeadlineClientTypes.JobTemplateType? = nil
    )
    {
        self.templateType = templateType
    }
}

struct CopyJobTemplateOutputBody: Swift.Equatable {
    let templateType: DeadlineClientTypes.JobTemplateType?
}

extension CopyJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobTemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
    }
}

enum CopyJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes {
    public enum CpuArchitectureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [CpuArchitectureType] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CpuArchitectureType(rawValue: rawValue) ?? CpuArchitectureType.sdkUnknown(rawValue)
        }
    }
}

extension CreateBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBudgetInput(actions: \(Swift.String(describing: actions)), approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), schedule: \(Swift.String(describing: schedule)), usageTrackingResource: \(Swift.String(describing: usageTrackingResource)), description: \"CONTENT_REDACTED\")"}
}

extension CreateBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case approximateDollarLimit
        case description
        case displayName
        case schedule
        case usageTrackingResource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for budgetactiontoadd0 in actions {
                try actionsContainer.encode(budgetactiontoadd0)
            }
        }
        if let approximateDollarLimit = self.approximateDollarLimit {
            try encodeContainer.encode(approximateDollarLimit, forKey: .approximateDollarLimit)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let usageTrackingResource = self.usageTrackingResource {
            try encodeContainer.encode(usageTrackingResource, forKey: .usageTrackingResource)
        }
    }
}

extension CreateBudgetInput {

    static func headerProvider(_ value: CreateBudgetInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateBudgetInput {

    static func urlPathProvider(_ value: CreateBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets"
    }
}

public struct CreateBudgetInput: Swift.Equatable {
    /// The budget actions to specify what happens when the budget runs out.
    /// This member is required.
    public var actions: [DeadlineClientTypes.BudgetActionToAdd]?
    /// The dollar limit based on consumed usage.
    /// This member is required.
    public var approximateDollarLimit: Swift.Float?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The description of the budget.
    public var description: Swift.String?
    /// The display name of the budget.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID to include in this budget.
    /// This member is required.
    public var farmId: Swift.String?
    /// The schedule to associate with this budget.
    /// This member is required.
    public var schedule: DeadlineClientTypes.BudgetSchedule?
    /// The queue ID provided to this budget to track usage.
    /// This member is required.
    public var usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?

    public init(
        actions: [DeadlineClientTypes.BudgetActionToAdd]? = nil,
        approximateDollarLimit: Swift.Float? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        schedule: DeadlineClientTypes.BudgetSchedule? = nil,
        usageTrackingResource: DeadlineClientTypes.UsageTrackingResource? = nil
    )
    {
        self.actions = actions
        self.approximateDollarLimit = approximateDollarLimit
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.schedule = schedule
        self.usageTrackingResource = usageTrackingResource
    }
}

struct CreateBudgetInputBody: Swift.Equatable {
    let usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?
    let displayName: Swift.String?
    let description: Swift.String?
    let approximateDollarLimit: Swift.Float?
    let actions: [DeadlineClientTypes.BudgetActionToAdd]?
    let schedule: DeadlineClientTypes.BudgetSchedule?
}

extension CreateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case approximateDollarLimit
        case description
        case displayName
        case schedule
        case usageTrackingResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageTrackingResourceDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UsageTrackingResource.self, forKey: .usageTrackingResource)
        usageTrackingResource = usageTrackingResourceDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let approximateDollarLimitDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .approximateDollarLimit)
        approximateDollarLimit = approximateDollarLimitDecoded
        let actionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.BudgetActionToAdd?].self, forKey: .actions)
        var actionsDecoded0:[DeadlineClientTypes.BudgetActionToAdd]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DeadlineClientTypes.BudgetActionToAdd]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension CreateBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBudgetOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgetId = output.budgetId
        } else {
            self.budgetId = nil
        }
    }
}

public struct CreateBudgetOutput: Swift.Equatable {
    /// The budget ID.
    /// This member is required.
    public var budgetId: Swift.String?

    public init(
        budgetId: Swift.String? = nil
    )
    {
        self.budgetId = budgetId
    }
}

struct CreateBudgetOutputBody: Swift.Equatable {
    let budgetId: Swift.String?
}

extension CreateBudgetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetId)
        budgetId = budgetIdDecoded
    }
}

enum CreateBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFarmInput(clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension CreateFarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case kmsKeyArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFarmInput {

    static func headerProvider(_ value: CreateFarmInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateFarmInput {

    static func urlPathProvider(_ value: CreateFarmInput) -> Swift.String? {
        return "/2023-10-12/farms"
    }
}

public struct CreateFarmInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The description of the farm.
    public var description: Swift.String?
    /// The display name of the farm.
    /// This member is required.
    public var displayName: Swift.String?
    /// The ARN of the KMS key to use on the farm.
    public var kmsKeyArn: Swift.String?
    /// The tags to add to your farm. Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

struct CreateFarmInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let kmsKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case kmsKeyArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.farmId = output.farmId
        } else {
            self.farmId = nil
        }
    }
}

public struct CreateFarmOutput: Swift.Equatable {
    /// The farm ID.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        farmId: Swift.String? = nil
    )
    {
        self.farmId = farmId
    }
}

struct CreateFarmOutputBody: Swift.Equatable {
    let farmId: Swift.String?
}

extension CreateFarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case farmId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
    }
}

enum CreateFarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), maxWorkerCount: \(Swift.String(describing: maxWorkerCount)), minWorkerCount: \(Swift.String(describing: minWorkerCount)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case displayName
        case maxWorkerCount
        case minWorkerCount
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let maxWorkerCount = self.maxWorkerCount {
            try encodeContainer.encode(maxWorkerCount, forKey: .maxWorkerCount)
        }
        if let minWorkerCount = self.minWorkerCount {
            try encodeContainer.encode(minWorkerCount, forKey: .minWorkerCount)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFleetInput {

    static func headerProvider(_ value: CreateFleetInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateFleetInput {

    static func urlPathProvider(_ value: CreateFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The configuration settings for the fleet. Customer managed fleets are self-managed. Service managed Amazon EC2 fleets are managed by Deadline Cloud.
    /// This member is required.
    public var configuration: DeadlineClientTypes.FleetConfiguration?
    /// The description of the fleet.
    public var description: Swift.String?
    /// The display name of the fleet.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to connect to the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of workers for the fleet.
    /// This member is required.
    public var maxWorkerCount: Swift.Int?
    /// The minimum number of workers for the fleet.
    public var minWorkerCount: Swift.Int?
    /// The IAM role ARN for the role that the fleet's workers will use.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        configuration: DeadlineClientTypes.FleetConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxWorkerCount: Swift.Int? = nil,
        minWorkerCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.maxWorkerCount = maxWorkerCount
        self.minWorkerCount = minWorkerCount
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let minWorkerCount: Swift.Int?
    let maxWorkerCount: Swift.Int?
    let configuration: DeadlineClientTypes.FleetConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case displayName
        case maxWorkerCount
        case minWorkerCount
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let minWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let maxWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetId = output.fleetId
        } else {
            self.fleetId = nil
        }
    }
}

public struct CreateFleetOutput: Swift.Equatable {
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

struct CreateFleetOutputBody: Swift.Equatable {
    let fleetId: Swift.String?
}

extension CreateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
    }
}

enum CreateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobInput(attachments: \(Swift.String(describing: attachments)), clientToken: \(Swift.String(describing: clientToken)), farmId: \(Swift.String(describing: farmId)), maxFailedTasksCount: \(Swift.String(describing: maxFailedTasksCount)), maxRetriesPerTask: \(Swift.String(describing: maxRetriesPerTask)), priority: \(Swift.String(describing: priority)), queueId: \(Swift.String(describing: queueId)), storageProfileId: \(Swift.String(describing: storageProfileId)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), templateType: \(Swift.String(describing: templateType)), parameters: \"CONTENT_REDACTED\", template: \"CONTENT_REDACTED\")"}
}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments
        case maxFailedTasksCount
        case maxRetriesPerTask
        case parameters
        case priority
        case storageProfileId
        case targetTaskRunStatus
        case template
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = self.attachments {
            try encodeContainer.encode(attachments, forKey: .attachments)
        }
        if let maxFailedTasksCount = self.maxFailedTasksCount {
            try encodeContainer.encode(maxFailedTasksCount, forKey: .maxFailedTasksCount)
        }
        if let maxRetriesPerTask = self.maxRetriesPerTask {
            try encodeContainer.encode(maxRetriesPerTask, forKey: .maxRetriesPerTask)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, jobParameters0) in parameters {
                try parametersContainer.encode(jobParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let storageProfileId = self.storageProfileId {
            try encodeContainer.encode(storageProfileId, forKey: .storageProfileId)
        }
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension CreateJobInput {

    static func headerProvider(_ value: CreateJobInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// The attachments for the job. Attach files required for the job to run to a render job.
    public var attachments: DeadlineClientTypes.Attachments?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to connect to the job.
    /// This member is required.
    public var farmId: Swift.String?
    /// The number of task failures before the job stops running and is marked as FAILED.
    public var maxFailedTasksCount: Swift.Int?
    /// The maximum number of retries for a job.
    public var maxRetriesPerTask: Swift.Int?
    /// The parameters for the job.
    public var parameters: [Swift.String:DeadlineClientTypes.JobParameter]?
    /// The priority of the job on a scale of 1 to 100. The highest priority is 1.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID of the queue that the job is submitted to.
    /// This member is required.
    public var queueId: Swift.String?
    /// The storage profile ID for the storage profile to connect to the job.
    public var storageProfileId: Swift.String?
    /// The initial status of the job's tasks when they are created. Tasks that are created with a SUSPENDED status will not run until you update their status.
    public var targetTaskRunStatus: DeadlineClientTypes.CreateJobTargetTaskRunStatus?
    /// The job template to use for this job.
    /// This member is required.
    public var template: Swift.String?
    /// The file type for the job template.
    /// This member is required.
    public var templateType: DeadlineClientTypes.JobTemplateType?

    public init(
        attachments: DeadlineClientTypes.Attachments? = nil,
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxFailedTasksCount: Swift.Int? = nil,
        maxRetriesPerTask: Swift.Int? = nil,
        parameters: [Swift.String:DeadlineClientTypes.JobParameter]? = nil,
        priority: Swift.Int? = nil,
        queueId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.CreateJobTargetTaskRunStatus? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.JobTemplateType? = nil
    )
    {
        self.attachments = attachments
        self.clientToken = clientToken
        self.farmId = farmId
        self.maxFailedTasksCount = maxFailedTasksCount
        self.maxRetriesPerTask = maxRetriesPerTask
        self.parameters = parameters
        self.priority = priority
        self.queueId = queueId
        self.storageProfileId = storageProfileId
        self.targetTaskRunStatus = targetTaskRunStatus
        self.template = template
        self.templateType = templateType
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let template: Swift.String?
    let templateType: DeadlineClientTypes.JobTemplateType?
    let priority: Swift.Int?
    let parameters: [Swift.String:DeadlineClientTypes.JobParameter]?
    let attachments: DeadlineClientTypes.Attachments?
    let storageProfileId: Swift.String?
    let targetTaskRunStatus: DeadlineClientTypes.CreateJobTargetTaskRunStatus?
    let maxFailedTasksCount: Swift.Int?
    let maxRetriesPerTask: Swift.Int?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments
        case maxFailedTasksCount
        case maxRetriesPerTask
        case parameters
        case priority
        case storageProfileId
        case targetTaskRunStatus
        case template
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobTemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.JobParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.JobParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.JobParameter]()
            for (key0, jobparameter0) in parametersContainer {
                if let jobparameter0 = jobparameter0 {
                    parametersDecoded0?[key0] = jobparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let attachmentsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Attachments.self, forKey: .attachments)
        attachments = attachmentsDecoded
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.CreateJobTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let maxFailedTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFailedTasksCount)
        maxFailedTasksCount = maxFailedTasksCountDecoded
        let maxRetriesPerTaskDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetriesPerTask)
        maxRetriesPerTask = maxRetriesPerTaskDecoded
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes {
    public enum CreateJobTargetTaskRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [CreateJobTargetTaskRunStatus] {
            return [
                .ready,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreateJobTargetTaskRunStatus(rawValue: rawValue) ?? CreateJobTargetTaskRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateLicenseEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateLicenseEndpointInput {

    static func headerProvider(_ value: CreateLicenseEndpointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateLicenseEndpointInput {

    static func urlPathProvider(_ value: CreateLicenseEndpointInput) -> Swift.String? {
        return "/2023-10-12/license-endpoints"
    }
}

public struct CreateLicenseEndpointInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The security group IDs.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnet IDs.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC (virtual private cloud) ID to use with the license endpoint.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateLicenseEndpointInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLicenseEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLicenseEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLicenseEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseEndpointId = output.licenseEndpointId
        } else {
            self.licenseEndpointId = nil
        }
    }
}

public struct CreateLicenseEndpointOutput: Swift.Equatable {
    /// The license endpoint ID.
    /// This member is required.
    public var licenseEndpointId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
    }
}

struct CreateLicenseEndpointOutputBody: Swift.Equatable {
    let licenseEndpointId: Swift.String?
}

extension CreateLicenseEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseEndpointId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseEndpointId)
        licenseEndpointId = licenseEndpointIdDecoded
    }
}

enum CreateLicenseEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case identityCenterInstanceArn
        case roleArn
        case subdomain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let identityCenterInstanceArn = self.identityCenterInstanceArn {
            try encodeContainer.encode(identityCenterInstanceArn, forKey: .identityCenterInstanceArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let subdomain = self.subdomain {
            try encodeContainer.encode(subdomain, forKey: .subdomain)
        }
    }
}

extension CreateMonitorInput {

    static func headerProvider(_ value: CreateMonitorInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateMonitorInput {

    static func urlPathProvider(_ value: CreateMonitorInput) -> Swift.String? {
        return "/2023-10-12/monitors"
    }
}

public struct CreateMonitorInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The name that you give the monitor that is displayed in the Deadline Cloud console.
    /// This member is required.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Identity Center instance that authenticates monitor users.
    /// This member is required.
    public var identityCenterInstanceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that the monitor uses to connect to Deadline Cloud. Every user that signs in to the monitor using IAM Identity Center uses this role to access Deadline Cloud resources.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The subdomain to use when creating the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    /// This member is required.
    public var subdomain: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityCenterInstanceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.displayName = displayName
        self.identityCenterInstanceArn = identityCenterInstanceArn
        self.roleArn = roleArn
        self.subdomain = subdomain
    }
}

struct CreateMonitorInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let identityCenterInstanceArn: Swift.String?
    let subdomain: Swift.String?
    let roleArn: Swift.String?
}

extension CreateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case identityCenterInstanceArn
        case roleArn
        case subdomain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let identityCenterInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterInstanceArn)
        identityCenterInstanceArn = identityCenterInstanceArnDecoded
        let subdomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdomain)
        subdomain = subdomainDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityCenterApplicationArn = output.identityCenterApplicationArn
            self.monitorId = output.monitorId
        } else {
            self.identityCenterApplicationArn = nil
            self.monitorId = nil
        }
    }
}

public struct CreateMonitorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that IAM Identity Center assigns to the monitor.
    /// This member is required.
    public var identityCenterApplicationArn: Swift.String?
    /// The unique identifier of the monitor.
    /// This member is required.
    public var monitorId: Swift.String?

    public init(
        identityCenterApplicationArn: Swift.String? = nil,
        monitorId: Swift.String? = nil
    )
    {
        self.identityCenterApplicationArn = identityCenterApplicationArn
        self.monitorId = monitorId
    }
}

struct CreateMonitorOutputBody: Swift.Equatable {
    let monitorId: Swift.String?
    let identityCenterApplicationArn: Swift.String?
}

extension CreateMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityCenterApplicationArn
        case monitorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorId)
        monitorId = monitorIdDecoded
        let identityCenterApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterApplicationArn)
        identityCenterApplicationArn = identityCenterApplicationArnDecoded
    }
}

enum CreateMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQueueEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQueueEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), farmId: \(Swift.String(describing: farmId)), priority: \(Swift.String(describing: priority)), queueId: \(Swift.String(describing: queueId)), templateType: \(Swift.String(describing: templateType)), template: \"CONTENT_REDACTED\")"}
}

extension CreateQueueEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority
        case template
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension CreateQueueEnvironmentInput {

    static func headerProvider(_ value: CreateQueueEnvironmentInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateQueueEnvironmentInput {

    static func urlPathProvider(_ value: CreateQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments"
    }
}

public struct CreateQueueEnvironmentInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to connect to the environment.
    /// This member is required.
    public var farmId: Swift.String?
    /// Sets the priority of the environments in the queue from 0 to 10,000, where 0 is the highest priority. If two environments share the same priority value, the environment created first takes higher priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The queue ID to connect the queue and environment.
    /// This member is required.
    public var queueId: Swift.String?
    /// The environment template to use in the queue.
    /// This member is required.
    public var template: Swift.String?
    /// The template's file type, JSON or YAML.
    /// This member is required.
    public var templateType: DeadlineClientTypes.EnvironmentTemplateType?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queueId: Swift.String? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.EnvironmentTemplateType? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.priority = priority
        self.queueId = queueId
        self.template = template
        self.templateType = templateType
    }
}

struct CreateQueueEnvironmentInputBody: Swift.Equatable {
    let priority: Swift.Int?
    let templateType: DeadlineClientTypes.EnvironmentTemplateType?
    let template: Swift.String?
}

extension CreateQueueEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority
        case template
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.EnvironmentTemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension CreateQueueEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateQueueEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.queueEnvironmentId = output.queueEnvironmentId
        } else {
            self.queueEnvironmentId = nil
        }
    }
}

public struct CreateQueueEnvironmentOutput: Swift.Equatable {
    /// The queue environment ID.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?

    public init(
        queueEnvironmentId: Swift.String? = nil
    )
    {
        self.queueEnvironmentId = queueEnvironmentId
    }
}

struct CreateQueueEnvironmentOutputBody: Swift.Equatable {
    let queueEnvironmentId: Swift.String?
}

extension CreateQueueEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueEnvironmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueEnvironmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueEnvironmentId)
        queueEnvironmentId = queueEnvironmentIdDecoded
    }
}

enum CreateQueueEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQueueFleetAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
        case queueId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }
}

extension CreateQueueFleetAssociationInput {

    static func urlPathProvider(_ value: CreateQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations"
    }
}

public struct CreateQueueFleetAssociationInput: Swift.Equatable {
    /// The ID of the farm that the queue and fleet belong to.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
    }
}

struct CreateQueueFleetAssociationInputBody: Swift.Equatable {
    let queueId: Swift.String?
    let fleetId: Swift.String?
}

extension CreateQueueFleetAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
        case queueId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
    }
}

extension CreateQueueFleetAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateQueueFleetAssociationOutput: Swift.Equatable {

    public init() { }
}

enum CreateQueueFleetAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQueueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQueueInput(allowedStorageProfileIds: \(Swift.String(describing: allowedStorageProfileIds)), clientToken: \(Swift.String(describing: clientToken)), defaultBudgetAction: \(Swift.String(describing: defaultBudgetAction)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), requiredFileSystemLocationNames: \(Swift.String(describing: requiredFileSystemLocationNames)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension CreateQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedStorageProfileIds
        case defaultBudgetAction
        case description
        case displayName
        case jobAttachmentSettings
        case jobRunAsUser
        case requiredFileSystemLocationNames
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedStorageProfileIds = allowedStorageProfileIds {
            var allowedStorageProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedStorageProfileIds)
            for storageprofileid0 in allowedStorageProfileIds {
                try allowedStorageProfileIdsContainer.encode(storageprofileid0)
            }
        }
        if let defaultBudgetAction = self.defaultBudgetAction {
            try encodeContainer.encode(defaultBudgetAction.rawValue, forKey: .defaultBudgetAction)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let jobAttachmentSettings = self.jobAttachmentSettings {
            try encodeContainer.encode(jobAttachmentSettings, forKey: .jobAttachmentSettings)
        }
        if let jobRunAsUser = self.jobRunAsUser {
            try encodeContainer.encode(jobRunAsUser, forKey: .jobRunAsUser)
        }
        if let requiredFileSystemLocationNames = requiredFileSystemLocationNames {
            var requiredFileSystemLocationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFileSystemLocationNames)
            for filesystemlocationname0 in requiredFileSystemLocationNames {
                try requiredFileSystemLocationNamesContainer.encode(filesystemlocationname0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQueueInput {

    static func headerProvider(_ value: CreateQueueInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateQueueInput {

    static func urlPathProvider(_ value: CreateQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues"
    }
}

public struct CreateQueueInput: Swift.Equatable {
    /// The storage profile IDs to include in the queue.
    public var allowedStorageProfileIds: [Swift.String]?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The default action to take on a queue if a budget isn't configured.
    public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    /// The description of the queue.
    public var description: Swift.String?
    /// The display name of the queue.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to connect to the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job attachment settings for the queue. These are the Amazon S3 bucket name and the Amazon S3 prefix.
    public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    /// The jobs in the queue run as the specified POSIX user.
    public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    /// The file system location name to include in the queue.
    public var requiredFileSystemLocationNames: [Swift.String]?
    /// The IAM role ARN that workers will use while running jobs for this queue.
    public var roleArn: Swift.String?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String:Swift.String]?

    public init(
        allowedStorageProfileIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
        jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
        requiredFileSystemLocationNames: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowedStorageProfileIds = allowedStorageProfileIds
        self.clientToken = clientToken
        self.defaultBudgetAction = defaultBudgetAction
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.jobAttachmentSettings = jobAttachmentSettings
        self.jobRunAsUser = jobRunAsUser
        self.requiredFileSystemLocationNames = requiredFileSystemLocationNames
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateQueueInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    let jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    let roleArn: Swift.String?
    let jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    let requiredFileSystemLocationNames: [Swift.String]?
    let allowedStorageProfileIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedStorageProfileIds
        case defaultBudgetAction
        case description
        case displayName
        case jobAttachmentSettings
        case jobRunAsUser
        case requiredFileSystemLocationNames
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultBudgetActionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DefaultQueueBudgetAction.self, forKey: .defaultBudgetAction)
        defaultBudgetAction = defaultBudgetActionDecoded
        let jobAttachmentSettingsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobAttachmentSettings.self, forKey: .jobAttachmentSettings)
        jobAttachmentSettings = jobAttachmentSettingsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let jobRunAsUserDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobRunAsUser.self, forKey: .jobRunAsUser)
        jobRunAsUser = jobRunAsUserDecoded
        let requiredFileSystemLocationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredFileSystemLocationNames)
        var requiredFileSystemLocationNamesDecoded0:[Swift.String]? = nil
        if let requiredFileSystemLocationNamesContainer = requiredFileSystemLocationNamesContainer {
            requiredFileSystemLocationNamesDecoded0 = [Swift.String]()
            for string0 in requiredFileSystemLocationNamesContainer {
                if let string0 = string0 {
                    requiredFileSystemLocationNamesDecoded0?.append(string0)
                }
            }
        }
        requiredFileSystemLocationNames = requiredFileSystemLocationNamesDecoded0
        let allowedStorageProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedStorageProfileIds)
        var allowedStorageProfileIdsDecoded0:[Swift.String]? = nil
        if let allowedStorageProfileIdsContainer = allowedStorageProfileIdsContainer {
            allowedStorageProfileIdsDecoded0 = [Swift.String]()
            for string0 in allowedStorageProfileIdsContainer {
                if let string0 = string0 {
                    allowedStorageProfileIdsDecoded0?.append(string0)
                }
            }
        }
        allowedStorageProfileIds = allowedStorageProfileIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateQueueOutputBody = try responseDecoder.decode(responseBody: data)
            self.queueId = output.queueId
        } else {
            self.queueId = nil
        }
    }
}

public struct CreateQueueOutput: Swift.Equatable {
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        queueId: Swift.String? = nil
    )
    {
        self.queueId = queueId
    }
}

struct CreateQueueOutputBody: Swift.Equatable {
    let queueId: Swift.String?
}

extension CreateQueueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
    }
}

enum CreateQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStorageProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case fileSystemLocations
        case osFamily
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for filesystemlocation0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(filesystemlocation0)
            }
        }
        if let osFamily = self.osFamily {
            try encodeContainer.encode(osFamily.rawValue, forKey: .osFamily)
        }
    }
}

extension CreateStorageProfileInput {

    static func headerProvider(_ value: CreateStorageProfileInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStorageProfileInput {

    static func urlPathProvider(_ value: CreateStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles"
    }
}

public struct CreateStorageProfileInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The display name of the storage profile.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to connect to the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// File system paths to include in the storage profile.
    public var fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
    /// The type of operating system (OS) for the storage profile.
    /// This member is required.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil
    )
    {
        self.clientToken = clientToken
        self.displayName = displayName
        self.farmId = farmId
        self.fileSystemLocations = fileSystemLocations
        self.osFamily = osFamily
    }
}

struct CreateStorageProfileInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    let fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
}

extension CreateStorageProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case fileSystemLocations
        case osFamily
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StorageProfileOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[DeadlineClientTypes.FileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [DeadlineClientTypes.FileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
    }
}

extension CreateStorageProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStorageProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.storageProfileId = output.storageProfileId
        } else {
            self.storageProfileId = nil
        }
    }
}

public struct CreateStorageProfileOutput: Swift.Equatable {
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        storageProfileId: Swift.String? = nil
    )
    {
        self.storageProfileId = storageProfileId
    }
}

struct CreateStorageProfileOutputBody: Swift.Equatable {
    let storageProfileId: Swift.String?
}

extension CreateStorageProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageProfileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
    }
}

enum CreateStorageProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostProperties = self.hostProperties {
            try encodeContainer.encode(hostProperties, forKey: .hostProperties)
        }
    }
}

extension CreateWorkerInput {

    static func headerProvider(_ value: CreateWorkerInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateWorkerInput {

    static func urlPathProvider(_ value: CreateWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers"
    }
}

public struct CreateWorkerInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to connect to the worker.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to connect to the worker.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The IP address and host name of the worker.
    public var hostProperties: DeadlineClientTypes.HostPropertiesRequest?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesRequest? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.fleetId = fleetId
        self.hostProperties = hostProperties
    }
}

struct CreateWorkerInputBody: Swift.Equatable {
    let hostProperties: DeadlineClientTypes.HostPropertiesRequest?
}

extension CreateWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.HostPropertiesRequest.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
    }
}

extension CreateWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.workerId = output.workerId
        } else {
            self.workerId = nil
        }
    }
}

public struct CreateWorkerOutput: Swift.Equatable {
    /// The worker ID.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        workerId: Swift.String? = nil
    )
    {
        self.workerId = workerId
    }
}

struct CreateWorkerOutputBody: Swift.Equatable {
    let workerId: Swift.String?
}

extension CreateWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
    }
}

enum CreateWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.CustomerManagedFleetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
        case storageProfileId
        case workerCapabilities
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let storageProfileId = self.storageProfileId {
            try encodeContainer.encode(storageProfileId, forKey: .storageProfileId)
        }
        if let workerCapabilities = self.workerCapabilities {
            try encodeContainer.encode(workerCapabilities, forKey: .workerCapabilities)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AutoScalingMode.self, forKey: .mode)
        mode = modeDecoded
        let workerCapabilitiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.CustomerManagedWorkerCapabilities.self, forKey: .workerCapabilities)
        workerCapabilities = workerCapabilitiesDecoded
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a customer managed fleet configuration.
    public struct CustomerManagedFleetConfiguration: Swift.Equatable {
        /// The Auto Scaling mode for the customer managed fleet configuration.
        /// This member is required.
        public var mode: DeadlineClientTypes.AutoScalingMode?
        /// The storage profile ID.
        public var storageProfileId: Swift.String?
        /// The worker capabilities for a customer managed fleet configuration.
        /// This member is required.
        public var workerCapabilities: DeadlineClientTypes.CustomerManagedWorkerCapabilities?

        public init(
            mode: DeadlineClientTypes.AutoScalingMode? = nil,
            storageProfileId: Swift.String? = nil,
            workerCapabilities: DeadlineClientTypes.CustomerManagedWorkerCapabilities? = nil
        )
        {
            self.mode = mode
            self.storageProfileId = storageProfileId
            self.workerCapabilities = workerCapabilities
        }
    }

}

extension DeadlineClientTypes {
    public enum CustomerManagedFleetOperatingSystemFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerManagedFleetOperatingSystemFamily] {
            return [
                .linux,
                .macos,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .macos: return "MACOS"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerManagedFleetOperatingSystemFamily(rawValue: rawValue) ?? CustomerManagedFleetOperatingSystemFamily.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.CustomerManagedWorkerCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorCount
        case acceleratorTotalMemoryMiB
        case acceleratorTypes
        case cpuArchitectureType
        case customAmounts
        case customAttributes
        case memoryMiB
        case osFamily
        case vCpuCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorCount = self.acceleratorCount {
            try encodeContainer.encode(acceleratorCount, forKey: .acceleratorCount)
        }
        if let acceleratorTotalMemoryMiB = self.acceleratorTotalMemoryMiB {
            try encodeContainer.encode(acceleratorTotalMemoryMiB, forKey: .acceleratorTotalMemoryMiB)
        }
        if let acceleratorTypes = acceleratorTypes {
            var acceleratorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorTypes)
            for acceleratortype0 in acceleratorTypes {
                try acceleratorTypesContainer.encode(acceleratortype0.rawValue)
            }
        }
        if let cpuArchitectureType = self.cpuArchitectureType {
            try encodeContainer.encode(cpuArchitectureType.rawValue, forKey: .cpuArchitectureType)
        }
        if let customAmounts = customAmounts {
            var customAmountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customAmounts)
            for fleetamountcapability0 in customAmounts {
                try customAmountsContainer.encode(fleetamountcapability0)
            }
        }
        if let customAttributes = customAttributes {
            var customAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customAttributes)
            for fleetattributecapability0 in customAttributes {
                try customAttributesContainer.encode(fleetattributecapability0)
            }
        }
        if let memoryMiB = self.memoryMiB {
            try encodeContainer.encode(memoryMiB, forKey: .memoryMiB)
        }
        if let osFamily = self.osFamily {
            try encodeContainer.encode(osFamily.rawValue, forKey: .osFamily)
        }
        if let vCpuCount = self.vCpuCount {
            try encodeContainer.encode(vCpuCount, forKey: .vCpuCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCpuCountDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.VCpuCountRange.self, forKey: .vCpuCount)
        vCpuCount = vCpuCountDecoded
        let memoryMiBDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MemoryMiBRange.self, forKey: .memoryMiB)
        memoryMiB = memoryMiBDecoded
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.AcceleratorType?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[DeadlineClientTypes.AcceleratorType]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [DeadlineClientTypes.AcceleratorType]()
            for enum0 in acceleratorTypesContainer {
                if let enum0 = enum0 {
                    acceleratorTypesDecoded0?.append(enum0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
        let acceleratorCountDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AcceleratorCountRange.self, forKey: .acceleratorCount)
        acceleratorCount = acceleratorCountDecoded
        let acceleratorTotalMemoryMiBDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AcceleratorTotalMemoryMiBRange.self, forKey: .acceleratorTotalMemoryMiB)
        acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiBDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.CustomerManagedFleetOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
        let cpuArchitectureTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.CpuArchitectureType.self, forKey: .cpuArchitectureType)
        cpuArchitectureType = cpuArchitectureTypeDecoded
        let customAmountsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetAmountCapability?].self, forKey: .customAmounts)
        var customAmountsDecoded0:[DeadlineClientTypes.FleetAmountCapability]? = nil
        if let customAmountsContainer = customAmountsContainer {
            customAmountsDecoded0 = [DeadlineClientTypes.FleetAmountCapability]()
            for structure0 in customAmountsContainer {
                if let structure0 = structure0 {
                    customAmountsDecoded0?.append(structure0)
                }
            }
        }
        customAmounts = customAmountsDecoded0
        let customAttributesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetAttributeCapability?].self, forKey: .customAttributes)
        var customAttributesDecoded0:[DeadlineClientTypes.FleetAttributeCapability]? = nil
        if let customAttributesContainer = customAttributesContainer {
            customAttributesDecoded0 = [DeadlineClientTypes.FleetAttributeCapability]()
            for structure0 in customAttributesContainer {
                if let structure0 = structure0 {
                    customAttributesDecoded0?.append(structure0)
                }
            }
        }
        customAttributes = customAttributesDecoded0
    }
}

extension DeadlineClientTypes {
    /// The worker capabilities for a customer managed workflow.
    public struct CustomerManagedWorkerCapabilities: Swift.Equatable {
        /// The range of the accelerator.
        public var acceleratorCount: DeadlineClientTypes.AcceleratorCountRange?
        /// The total memory (MiB) for the customer managed worker capabilities.
        public var acceleratorTotalMemoryMiB: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange?
        /// The accelerator types for the customer managed worker capabilities.
        public var acceleratorTypes: [DeadlineClientTypes.AcceleratorType]?
        /// The CPU architecture type for the customer managed worker capabilities.
        /// This member is required.
        public var cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType?
        /// Custom requirement ranges for customer managed worker capabilities.
        public var customAmounts: [DeadlineClientTypes.FleetAmountCapability]?
        /// Custom attributes for the customer manged worker capabilities.
        public var customAttributes: [DeadlineClientTypes.FleetAttributeCapability]?
        /// The memory (MiB).
        /// This member is required.
        public var memoryMiB: DeadlineClientTypes.MemoryMiBRange?
        /// The operating system (OS) family.
        /// This member is required.
        public var osFamily: DeadlineClientTypes.CustomerManagedFleetOperatingSystemFamily?
        /// The vCPU count for the customer manged worker capabilities.
        /// This member is required.
        public var vCpuCount: DeadlineClientTypes.VCpuCountRange?

        public init(
            acceleratorCount: DeadlineClientTypes.AcceleratorCountRange? = nil,
            acceleratorTotalMemoryMiB: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange? = nil,
            acceleratorTypes: [DeadlineClientTypes.AcceleratorType]? = nil,
            cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType? = nil,
            customAmounts: [DeadlineClientTypes.FleetAmountCapability]? = nil,
            customAttributes: [DeadlineClientTypes.FleetAttributeCapability]? = nil,
            memoryMiB: DeadlineClientTypes.MemoryMiBRange? = nil,
            osFamily: DeadlineClientTypes.CustomerManagedFleetOperatingSystemFamily? = nil,
            vCpuCount: DeadlineClientTypes.VCpuCountRange? = nil
        )
        {
            self.acceleratorCount = acceleratorCount
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.cpuArchitectureType = cpuArchitectureType
            self.customAmounts = customAmounts
            self.customAttributes = customAttributes
            self.memoryMiB = memoryMiB
            self.osFamily = osFamily
            self.vCpuCount = vCpuCount
        }
    }

}

extension DeadlineClientTypes.DateTimeFilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTime
        case name
        case `operator` = "operator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTime = self.dateTime {
            try encodeContainer.encodeTimestamp(dateTime, format: .dateTime, forKey: .dateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ComparisonOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let dateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .dateTime)
        dateTime = dateTimeDecoded
    }
}

extension DeadlineClientTypes {
    /// The time stamp in date-time format.
    public struct DateTimeFilterExpression: Swift.Equatable {
        /// The date and time.
        /// This member is required.
        public var dateTime: ClientRuntime.Date?
        /// The name of the date-time field to filter on.
        /// This member is required.
        public var name: Swift.String?
        /// The type of comparison to use to filter the results.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.ComparisonOperator?

        public init(
            dateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            `operator`: DeadlineClientTypes.ComparisonOperator? = nil
        )
        {
            self.dateTime = dateTime
            self.name = name
            self.`operator` = `operator`
        }
    }

}

public enum DeadlineClientTypes {}

extension DeadlineClientTypes {
    public enum DeadlinePrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [DeadlinePrincipalType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeadlinePrincipalType(rawValue: rawValue) ?? DeadlinePrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum DefaultQueueBudgetAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultQueueBudgetAction] {
            return [
                .none,
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultQueueBudgetAction(rawValue: rawValue) ?? DefaultQueueBudgetAction.sdkUnknown(rawValue)
        }
    }
}

extension DeleteBudgetInput {

    static func urlPathProvider(_ value: DeleteBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let budgetId = value.budgetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets/\(budgetId.urlPercentEncoding())"
    }
}

public struct DeleteBudgetInput: Swift.Equatable {
    /// The budget ID of the budget to delete.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The farm ID of the farm to remove from the budget.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        budgetId: Swift.String? = nil,
        farmId: Swift.String? = nil
    )
    {
        self.budgetId = budgetId
        self.farmId = farmId
    }
}

struct DeleteBudgetInputBody: Swift.Equatable {
}

extension DeleteBudgetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBudgetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFarmInput {

    static func urlPathProvider(_ value: DeleteFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())"
    }
}

public struct DeleteFarmInput: Swift.Equatable {
    /// The farm ID of the farm to delete.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        farmId: Swift.String? = nil
    )
    {
        self.farmId = farmId
    }
}

struct DeleteFarmInputBody: Swift.Equatable {
}

extension DeleteFarmInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFarmOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetInput {

    static func headerProvider(_ value: DeleteFleetInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteFleetInput {

    static func urlPathProvider(_ value: DeleteFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to remove from the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the fleet to delete.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.fleetId = fleetId
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
}

extension DeleteFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFleetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLicenseEndpointInput {

    static func urlPathProvider(_ value: DeleteLicenseEndpointInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())"
    }
}

public struct DeleteLicenseEndpointInput: Swift.Equatable {
    /// The license endpoint ID of the license endpoint to delete.
    /// This member is required.
    public var licenseEndpointId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
    }
}

struct DeleteLicenseEndpointInputBody: Swift.Equatable {
}

extension DeleteLicenseEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLicenseEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLicenseEndpointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLicenseEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMeteredProductInput {

    static func urlPathProvider(_ value: DeleteMeteredProductInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        guard let productId = value.productId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())/metered-products/\(productId.urlPercentEncoding())"
    }
}

public struct DeleteMeteredProductInput: Swift.Equatable {
    /// The ID of the license endpoint from which to remove the metered product.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The product ID to remove from the license endpoint.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
        self.productId = productId
    }
}

struct DeleteMeteredProductInputBody: Swift.Equatable {
}

extension DeleteMeteredProductInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeteredProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMeteredProductOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMeteredProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMonitorInput {

    static func urlPathProvider(_ value: DeleteMonitorInput) -> Swift.String? {
        guard let monitorId = value.monitorId else {
            return nil
        }
        return "/2023-10-12/monitors/\(monitorId.urlPercentEncoding())"
    }
}

public struct DeleteMonitorInput: Swift.Equatable {
    /// The unique identifier of the monitor to delete. This ID is returned by the CreateMonitor operation, and is included in the response to the GetMonitor operation.
    /// This member is required.
    public var monitorId: Swift.String?

    public init(
        monitorId: Swift.String? = nil
    )
    {
        self.monitorId = monitorId
    }
}

struct DeleteMonitorInputBody: Swift.Equatable {
}

extension DeleteMonitorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMonitorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQueueEnvironmentInput {

    static func urlPathProvider(_ value: DeleteQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let queueEnvironmentId = value.queueEnvironmentId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments/\(queueEnvironmentId.urlPercentEncoding())"
    }
}

public struct DeleteQueueEnvironmentInput: Swift.Equatable {
    /// The farm ID of the farm from which to remove the queue environment.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue environment ID of the queue environment to delete.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The queue ID of the queue environment to delete.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueEnvironmentId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueEnvironmentId = queueEnvironmentId
        self.queueId = queueId
    }
}

struct DeleteQueueEnvironmentInputBody: Swift.Equatable {
}

extension DeleteQueueEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQueueEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQueueEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQueueEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQueueFleetAssociationInput {

    static func urlPathProvider(_ value: DeleteQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations/\(queueId.urlPercentEncoding())/\(fleetId.urlPercentEncoding())"
    }
}

public struct DeleteQueueFleetAssociationInput: Swift.Equatable {
    /// The farm ID of the farm that holds the queue-fleet association.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the queue-fleet association.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID of the queue-fleet association.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
    }
}

struct DeleteQueueFleetAssociationInputBody: Swift.Equatable {
}

extension DeleteQueueFleetAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQueueFleetAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQueueFleetAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQueueFleetAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQueueInput {

    static func urlPathProvider(_ value: DeleteQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())"
    }
}

public struct DeleteQueueInput: Swift.Equatable {
    /// The ID of the farm from which to remove the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID of the queue to delete.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

struct DeleteQueueInputBody: Swift.Equatable {
}

extension DeleteQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQueueOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStorageProfileInput {

    static func urlPathProvider(_ value: DeleteStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

public struct DeleteStorageProfileInput: Swift.Equatable {
    /// The farm ID of the farm from which to remove the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The storage profile ID of the storage profile to delete.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.storageProfileId = storageProfileId
    }
}

struct DeleteStorageProfileInputBody: Swift.Equatable {
}

extension DeleteStorageProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStorageProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkerInput {

    static func urlPathProvider(_ value: DeleteWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())"
    }
}

public struct DeleteWorkerInput: Swift.Equatable {
    /// The farm ID of the worker to delete.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker to delete.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The worker ID of the worker to delete.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.workerId = workerId
    }
}

struct DeleteWorkerInputBody: Swift.Equatable {
}

extension DeleteWorkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes {
    public enum DependencyConsumerResolutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resolved
        case unresolved
        case sdkUnknown(Swift.String)

        public static var allCases: [DependencyConsumerResolutionStatus] {
            return [
                .resolved,
                .unresolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resolved: return "RESOLVED"
            case .unresolved: return "UNRESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DependencyConsumerResolutionStatus(rawValue: rawValue) ?? DependencyConsumerResolutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.DependencyCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumersResolved
        case consumersUnresolved
        case dependenciesResolved
        case dependenciesUnresolved
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumersResolved = self.consumersResolved {
            try encodeContainer.encode(consumersResolved, forKey: .consumersResolved)
        }
        if let consumersUnresolved = self.consumersUnresolved {
            try encodeContainer.encode(consumersUnresolved, forKey: .consumersUnresolved)
        }
        if let dependenciesResolved = self.dependenciesResolved {
            try encodeContainer.encode(dependenciesResolved, forKey: .dependenciesResolved)
        }
        if let dependenciesUnresolved = self.dependenciesUnresolved {
            try encodeContainer.encode(dependenciesUnresolved, forKey: .dependenciesUnresolved)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dependenciesResolvedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dependenciesResolved)
        dependenciesResolved = dependenciesResolvedDecoded
        let dependenciesUnresolvedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dependenciesUnresolved)
        dependenciesUnresolved = dependenciesUnresolvedDecoded
        let consumersResolvedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumersResolved)
        consumersResolved = consumersResolvedDecoded
        let consumersUnresolvedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumersUnresolved)
        consumersUnresolved = consumersUnresolvedDecoded
    }
}

extension DeadlineClientTypes {
    /// The number of dependencies for the consumer.
    public struct DependencyCounts: Swift.Equatable {
        /// The number of consumers resolved.
        /// This member is required.
        public var consumersResolved: Swift.Int?
        /// The number of unresolved consumers.
        /// This member is required.
        public var consumersUnresolved: Swift.Int?
        /// The number of resolved dependencies.
        /// This member is required.
        public var dependenciesResolved: Swift.Int?
        /// The number of unresolved dependencies.
        /// This member is required.
        public var dependenciesUnresolved: Swift.Int?

        public init(
            consumersResolved: Swift.Int? = nil,
            consumersUnresolved: Swift.Int? = nil,
            dependenciesResolved: Swift.Int? = nil,
            dependenciesUnresolved: Swift.Int? = nil
        )
        {
            self.consumersResolved = consumersResolved
            self.consumersUnresolved = consumersUnresolved
            self.dependenciesResolved = dependenciesResolved
            self.dependenciesUnresolved = dependenciesUnresolved
        }
    }

}

extension DeadlineClientTypes {
    public enum DesiredWorkerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredWorkerStatus] {
            return [
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DesiredWorkerStatus(rawValue: rawValue) ?? DesiredWorkerStatus.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateMemberFromFarmInput {

    static func urlPathProvider(_ value: DisassociateMemberFromFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct DisassociateMemberFromFarmInput: Swift.Equatable {
    /// The farm ID of the farm to disassociate from the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// A member's principal ID to disassociate from a farm.
    /// This member is required.
    public var principalId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.principalId = principalId
    }
}

struct DisassociateMemberFromFarmInputBody: Swift.Equatable {
}

extension DisassociateMemberFromFarmInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMemberFromFarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberFromFarmOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberFromFarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMemberFromFleetInput {

    static func urlPathProvider(_ value: DisassociateMemberFromFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct DisassociateMemberFromFleetInput: Swift.Equatable {
    /// The farm ID of the fleet to disassociate a member from.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the fleet to from which to disassociate a member.
    /// This member is required.
    public var fleetId: Swift.String?
    /// A member's principal ID to disassociate from a fleet.
    /// This member is required.
    public var principalId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.principalId = principalId
    }
}

struct DisassociateMemberFromFleetInputBody: Swift.Equatable {
}

extension DisassociateMemberFromFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMemberFromFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberFromFleetOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberFromFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMemberFromJobInput {

    static func urlPathProvider(_ value: DisassociateMemberFromJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct DisassociateMemberFromJobInput: Swift.Equatable {
    /// The farm ID for the job to disassociate from the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to disassociate from a member in a job.
    /// This member is required.
    public var jobId: Swift.String?
    /// A member's principal ID to disassociate from a job.
    /// This member is required.
    public var principalId: Swift.String?
    /// The queue ID connected to a job for which you're disassociating a member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.principalId = principalId
        self.queueId = queueId
    }
}

struct DisassociateMemberFromJobInputBody: Swift.Equatable {
}

extension DisassociateMemberFromJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMemberFromJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberFromJobOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberFromJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMemberFromQueueInput {

    static func urlPathProvider(_ value: DisassociateMemberFromQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

public struct DisassociateMemberFromQueueInput: Swift.Equatable {
    /// The farm ID for the queue to disassociate from a member.
    /// This member is required.
    public var farmId: Swift.String?
    /// A member's principal ID to disassociate from a queue.
    /// This member is required.
    public var principalId: Swift.String?
    /// The queue ID of the queue in which you're disassociating from a member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.principalId = principalId
        self.queueId = queueId
    }
}

struct DisassociateMemberFromQueueInputBody: Swift.Equatable {
}

extension DisassociateMemberFromQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMemberFromQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberFromQueueOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberFromQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.Ec2EbsVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iops
        case sizeGiB
        case throughputMiB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let sizeGiB = self.sizeGiB {
            try encodeContainer.encode(sizeGiB, forKey: .sizeGiB)
        }
        if let throughputMiB = self.throughputMiB {
            try encodeContainer.encode(throughputMiB, forKey: .throughputMiB)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeGiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeGiB)
        sizeGiB = sizeGiBDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let throughputMiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughputMiB)
        throughputMiB = throughputMiBDecoded
    }
}

extension DeadlineClientTypes {
    /// Specifies the EBS volume.
    public struct Ec2EbsVolume: Swift.Equatable {
        /// The IOPS per volume.
        public var iops: Swift.Int?
        /// The EBS volume size in GiB.
        public var sizeGiB: Swift.Int?
        /// The throughput per volume in MiB.
        public var throughputMiB: Swift.Int?

        public init(
            iops: Swift.Int? = nil,
            sizeGiB: Swift.Int? = nil,
            throughputMiB: Swift.Int? = nil
        )
        {
            self.iops = iops
            self.sizeGiB = sizeGiB
            self.throughputMiB = throughputMiB
        }
    }

}

extension DeadlineClientTypes {
    public enum Ec2MarketType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onDemand
        case spot
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2MarketType] {
            return [
                .onDemand,
                .spot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "on-demand"
            case .spot: return "spot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ec2MarketType(rawValue: rawValue) ?? Ec2MarketType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.EnvironmentDetailsEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case jobId
        case schemaVersion
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let templateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .template)
        template = templateDecoded
    }
}

extension DeadlineClientTypes.EnvironmentDetailsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentDetailsEntity(environmentId: \(Swift.String(describing: environmentId)), jobId: \(Swift.String(describing: jobId)), schemaVersion: \(Swift.String(describing: schemaVersion)), template: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The details of a specified environment.
    public struct EnvironmentDetailsEntity: Swift.Equatable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The schema version in the environment.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The template used for the environment.
        /// This member is required.
        public var template: ClientRuntime.Document?

        public init(
            environmentId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            template: ClientRuntime.Document? = nil
        )
        {
            self.environmentId = environmentId
            self.jobId = jobId
            self.schemaVersion = schemaVersion
            self.template = template
        }
    }

}

extension DeadlineClientTypes.EnvironmentDetailsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case environmentId
        case jobId
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobEntityErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeadlineClientTypes {
    /// The error details for the environment.
    public struct EnvironmentDetailsError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            environmentId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.environmentId = environmentId
            self.jobId = jobId
            self.message = message
        }
    }

}

extension DeadlineClientTypes.EnvironmentDetailsIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The IDs of the job and environment.
    public struct EnvironmentDetailsIdentifiers: Swift.Equatable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            environmentId: Swift.String? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
            self.jobId = jobId
        }
    }

}

extension DeadlineClientTypes.EnvironmentEnterSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The environment ID to use to enter a session action.
    public struct EnvironmentEnterSessionActionDefinition: Swift.Equatable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }

}

extension DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// Defines the environment a session action enters in.
    public struct EnvironmentEnterSessionActionDefinitionSummary: Swift.Equatable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }

}

extension DeadlineClientTypes.EnvironmentExitSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// Defines the environment a session action exits from.
    public struct EnvironmentExitSessionActionDefinition: Swift.Equatable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }

}

extension DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeadlineClientTypes {
    /// A summary of the environment details for which a session action to exits.
    public struct EnvironmentExitSessionActionDefinitionSummary: Swift.Equatable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }

}

extension DeadlineClientTypes {
    public enum EnvironmentTemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentTemplateType] {
            return [
                .json,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentTemplateType(rawValue: rawValue) ?? EnvironmentTemplateType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.FarmMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case farmId
        case identityStoreId
        case membershipLevel
        case principalId
        case principalType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension DeadlineClientTypes {
    /// The member of a farm.
    public struct FarmMember: Swift.Equatable {
        /// The farm ID of the farm member.
        /// This member is required.
        public var farmId: Swift.String?
        /// The identity store ID of the farm member.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The farm member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the farm member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the farm member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

        public init(
            farmId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
        )
        {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension DeadlineClientTypes.FarmSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case displayName
        case farmId
        case kmsKeyArn
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DeadlineClientTypes {
    /// The summary of details for a farm.
    public struct FarmSummary: Swift.Equatable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The display name of the farm.
        /// This member is required.
        public var displayName: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The ARN for the KMS key.
        public var kmsKeyArn: Swift.String?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            displayName: Swift.String? = nil,
            farmId: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.farmId = farmId
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DeadlineClientTypes.FieldSortExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeadlineClientTypes {
    /// The field sorting order and name of the field.
    public struct FieldSortExpression: Swift.Equatable {
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// The sort order for the field.
        /// This member is required.
        public var sortOrder: DeadlineClientTypes.SortOrder?

        public init(
            name: Swift.String? = nil,
            sortOrder: DeadlineClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.sortOrder = sortOrder
        }
    }

}

extension DeadlineClientTypes.FileSystemLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case path
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FileSystemLocationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DeadlineClientTypes.FileSystemLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {
    /// The details of the file system location for the resource.
    public struct FileSystemLocation: Swift.Equatable {
        /// The location name.
        /// This member is required.
        public var name: Swift.String?
        /// The file path.
        /// This member is required.
        public var path: Swift.String?
        /// The type of file.
        /// This member is required.
        public var type: DeadlineClientTypes.FileSystemLocationType?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            type: DeadlineClientTypes.FileSystemLocationType? = nil
        )
        {
            self.name = name
            self.path = path
            self.type = type
        }
    }

}

extension DeadlineClientTypes {
    public enum FileSystemLocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSystemLocationType] {
            return [
                .local,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileSystemLocationType(rawValue: rawValue) ?? FileSystemLocationType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.FixedBudgetSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a fixed budget schedule.
    public struct FixedBudgetSchedule: Swift.Equatable {
        /// When the budget ends.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// When the budget starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DeadlineClientTypes.FleetAmountCapability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .max)
        max = maxDecoded
    }
}

extension DeadlineClientTypes {
    /// The fleet amount and attribute capabilities.
    public struct FleetAmountCapability: Swift.Equatable {
        /// The maximum amount of the fleet worker capability.
        public var max: Swift.Float?
        /// The minimum amount of fleet worker capability.
        /// This member is required.
        public var min: Swift.Float?
        /// The name of the fleet capability.
        /// This member is required.
        public var name: Swift.String?

        public init(
            max: Swift.Float? = nil,
            min: Swift.Float? = nil,
            name: Swift.String? = nil
        )
        {
            self.max = max
            self.min = min
            self.name = name
        }
    }

}

extension DeadlineClientTypes.FleetAttributeCapability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for attributecapabilityvalue0 in values {
                try valuesContainer.encode(attributecapabilityvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeadlineClientTypes {
    /// Defines the fleet's capability name, minimum, and maximum.
    public struct FleetAttributeCapability: Swift.Equatable {
        /// The name of the fleet attribute capability for the worker.
        /// This member is required.
        public var name: Swift.String?
        /// The number of fleet attribute capabilities.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension DeadlineClientTypes.FleetCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amounts
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amounts = amounts {
            var amountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amounts)
            for fleetamountcapability0 in amounts {
                try amountsContainer.encode(fleetamountcapability0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for fleetattributecapability0 in attributes {
                try attributesContainer.encode(fleetattributecapability0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetAmountCapability?].self, forKey: .amounts)
        var amountsDecoded0:[DeadlineClientTypes.FleetAmountCapability]? = nil
        if let amountsContainer = amountsContainer {
            amountsDecoded0 = [DeadlineClientTypes.FleetAmountCapability]()
            for structure0 in amountsContainer {
                if let structure0 = structure0 {
                    amountsDecoded0?.append(structure0)
                }
            }
        }
        amounts = amountsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetAttributeCapability?].self, forKey: .attributes)
        var attributesDecoded0:[DeadlineClientTypes.FleetAttributeCapability]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [DeadlineClientTypes.FleetAttributeCapability]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension DeadlineClientTypes {
    /// The amounts and attributes of fleets.
    public struct FleetCapabilities: Swift.Equatable {
        /// Amount capabilities of the fleet.
        public var amounts: [DeadlineClientTypes.FleetAmountCapability]?
        /// Attribute capabilities of the fleet.
        public var attributes: [DeadlineClientTypes.FleetAttributeCapability]?

        public init(
            amounts: [DeadlineClientTypes.FleetAmountCapability]? = nil,
            attributes: [DeadlineClientTypes.FleetAttributeCapability]? = nil
        )
        {
            self.amounts = amounts
            self.attributes = attributes
        }
    }

}

extension DeadlineClientTypes.FleetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customermanaged = "customerManaged"
        case sdkUnknown
        case servicemanagedec2 = "serviceManagedEc2"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customermanaged(customermanaged):
                try container.encode(customermanaged, forKey: .customermanaged)
            case let .servicemanagedec2(servicemanagedec2):
                try container.encode(servicemanagedec2, forKey: .servicemanagedec2)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let customermanagedDecoded = try values.decodeIfPresent(DeadlineClientTypes.CustomerManagedFleetConfiguration.self, forKey: .customermanaged)
        if let customermanaged = customermanagedDecoded {
            self = .customermanaged(customermanaged)
            return
        }
        let servicemanagedec2Decoded = try values.decodeIfPresent(DeadlineClientTypes.ServiceManagedEc2FleetConfiguration.self, forKey: .servicemanagedec2)
        if let servicemanagedec2 = servicemanagedec2Decoded {
            self = .servicemanagedec2(servicemanagedec2)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// Fleet configuration details.
    public enum FleetConfiguration: Swift.Equatable {
        /// The customer managed fleets within a fleet configuration.
        case customermanaged(DeadlineClientTypes.CustomerManagedFleetConfiguration)
        /// The service managed Amazon EC2 instances for a fleet configuration.
        case servicemanagedec2(DeadlineClientTypes.ServiceManagedEc2FleetConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes.FleetMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case farmId
        case fleetId
        case identityStoreId
        case membershipLevel
        case principalId
        case principalType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension DeadlineClientTypes {
    /// The fleet member.
    public struct FleetMember: Swift.Equatable {
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The identity store ID.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The fleet member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the fleet member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the fleet member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

        public init(
            farmId: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
        )
        {
            self.farmId = farmId
            self.fleetId = fleetId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension DeadlineClientTypes {
    public enum FleetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetStatus(rawValue: rawValue) ?? FleetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.FleetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingStatus
        case configuration
        case createdAt
        case createdBy
        case displayName
        case farmId
        case fleetId
        case maxWorkerCount
        case minWorkerCount
        case status
        case targetWorkerCount
        case updatedAt
        case updatedBy
        case workerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingStatus = self.autoScalingStatus {
            try encodeContainer.encode(autoScalingStatus.rawValue, forKey: .autoScalingStatus)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let maxWorkerCount = self.maxWorkerCount {
            try encodeContainer.encode(maxWorkerCount, forKey: .maxWorkerCount)
        }
        if let minWorkerCount = self.minWorkerCount {
            try encodeContainer.encode(minWorkerCount, forKey: .minWorkerCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetWorkerCount = self.targetWorkerCount {
            try encodeContainer.encode(targetWorkerCount, forKey: .targetWorkerCount)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let workerCount = self.workerCount {
            try encodeContainer.encode(workerCount, forKey: .workerCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetStatus.self, forKey: .status)
        status = statusDecoded
        let autoScalingStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AutoScalingStatus.self, forKey: .autoScalingStatus)
        autoScalingStatus = autoScalingStatusDecoded
        let targetWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetWorkerCount)
        targetWorkerCount = targetWorkerCountDecoded
        let workerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workerCount)
        workerCount = workerCountDecoded
        let minWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let maxWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a fleet.
    public struct FleetSummary: Swift.Equatable {
        /// The Auto Scaling status of a fleet.
        public var autoScalingStatus: DeadlineClientTypes.AutoScalingStatus?
        /// The configuration details for the fleet.
        /// This member is required.
        public var configuration: DeadlineClientTypes.FleetConfiguration?
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The display name of the fleet summary to update.
        /// This member is required.
        public var displayName: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The maximum number of workers specified in the fleet.
        /// This member is required.
        public var maxWorkerCount: Swift.Int?
        /// The minimum number of workers in the fleet.
        /// This member is required.
        public var minWorkerCount: Swift.Int?
        /// The status of the fleet.
        /// This member is required.
        public var status: DeadlineClientTypes.FleetStatus?
        /// The target number of workers in a fleet.
        public var targetWorkerCount: Swift.Int?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The number of workers in the fleet summary.
        /// This member is required.
        public var workerCount: Swift.Int?

        public init(
            autoScalingStatus: DeadlineClientTypes.AutoScalingStatus? = nil,
            configuration: DeadlineClientTypes.FleetConfiguration? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            displayName: Swift.String? = nil,
            farmId: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            maxWorkerCount: Swift.Int? = nil,
            minWorkerCount: Swift.Int? = nil,
            status: DeadlineClientTypes.FleetStatus? = nil,
            targetWorkerCount: Swift.Int? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerCount: Swift.Int? = nil
        )
        {
            self.autoScalingStatus = autoScalingStatus
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxWorkerCount = maxWorkerCount
            self.minWorkerCount = minWorkerCount
            self.status = status
            self.targetWorkerCount = targetWorkerCount
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerCount = workerCount
        }
    }

}

extension GetBudgetInput {

    static func urlPathProvider(_ value: GetBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let budgetId = value.budgetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets/\(budgetId.urlPercentEncoding())"
    }
}

public struct GetBudgetInput: Swift.Equatable {
    /// The budget ID.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The farm ID of the farm connected to the budget.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        budgetId: Swift.String? = nil,
        farmId: Swift.String? = nil
    )
    {
        self.budgetId = budgetId
        self.farmId = farmId
    }
}

struct GetBudgetInputBody: Swift.Equatable {
}

extension GetBudgetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBudgetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBudgetOutput(actions: \(Swift.String(describing: actions)), approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), budgetId: \(Swift.String(describing: budgetId)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), queueStoppedAt: \(Swift.String(describing: queueStoppedAt)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), usageTrackingResource: \(Swift.String(describing: usageTrackingResource)), usages: \(Swift.String(describing: usages)), description: \"CONTENT_REDACTED\")"}
}

extension GetBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBudgetOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.approximateDollarLimit = output.approximateDollarLimit
            self.budgetId = output.budgetId
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.displayName = output.displayName
            self.queueStoppedAt = output.queueStoppedAt
            self.schedule = output.schedule
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
            self.usageTrackingResource = output.usageTrackingResource
            self.usages = output.usages
        } else {
            self.actions = nil
            self.approximateDollarLimit = nil
            self.budgetId = nil
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.displayName = nil
            self.queueStoppedAt = nil
            self.schedule = nil
            self.status = nil
            self.updatedAt = nil
            self.updatedBy = nil
            self.usageTrackingResource = nil
            self.usages = nil
        }
    }
}

public struct GetBudgetOutput: Swift.Equatable {
    /// The budget actions for the budget.
    /// This member is required.
    public var actions: [DeadlineClientTypes.ResponseBudgetAction]?
    /// The consumed usage limit for the budget.
    /// This member is required.
    public var approximateDollarLimit: Swift.Float?
    /// The budget ID.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the budget.
    public var description: Swift.String?
    /// The display name of the budget.
    /// This member is required.
    public var displayName: Swift.String?
    /// The date and time the queue stopped.
    public var queueStoppedAt: ClientRuntime.Date?
    /// The budget schedule.
    /// This member is required.
    public var schedule: DeadlineClientTypes.BudgetSchedule?
    /// The status of the budget.
    ///
    /// * ACTIVEGet a budget being evaluated.
    ///
    /// * INACTIVEGet an inactive budget. This can include expired, canceled, or deleted statuses.
    /// This member is required.
    public var status: DeadlineClientTypes.BudgetStatus?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The resource that the budget is tracking usage for.
    /// This member is required.
    public var usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?
    /// The usages of the budget.
    /// This member is required.
    public var usages: DeadlineClientTypes.ConsumedUsages?

    public init(
        actions: [DeadlineClientTypes.ResponseBudgetAction]? = nil,
        approximateDollarLimit: Swift.Float? = nil,
        budgetId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        queueStoppedAt: ClientRuntime.Date? = nil,
        schedule: DeadlineClientTypes.BudgetSchedule? = nil,
        status: DeadlineClientTypes.BudgetStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil,
        usageTrackingResource: DeadlineClientTypes.UsageTrackingResource? = nil,
        usages: DeadlineClientTypes.ConsumedUsages? = nil
    )
    {
        self.actions = actions
        self.approximateDollarLimit = approximateDollarLimit
        self.budgetId = budgetId
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.displayName = displayName
        self.queueStoppedAt = queueStoppedAt
        self.schedule = schedule
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.usageTrackingResource = usageTrackingResource
        self.usages = usages
    }
}

struct GetBudgetOutputBody: Swift.Equatable {
    let budgetId: Swift.String?
    let usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?
    let status: DeadlineClientTypes.BudgetStatus?
    let displayName: Swift.String?
    let description: Swift.String?
    let approximateDollarLimit: Swift.Float?
    let usages: DeadlineClientTypes.ConsumedUsages?
    let actions: [DeadlineClientTypes.ResponseBudgetAction]?
    let schedule: DeadlineClientTypes.BudgetSchedule?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let queueStoppedAt: ClientRuntime.Date?
}

extension GetBudgetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case approximateDollarLimit
        case budgetId
        case createdAt
        case createdBy
        case description
        case displayName
        case queueStoppedAt
        case schedule
        case status
        case updatedAt
        case updatedBy
        case usageTrackingResource
        case usages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetId)
        budgetId = budgetIdDecoded
        let usageTrackingResourceDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UsageTrackingResource.self, forKey: .usageTrackingResource)
        usageTrackingResource = usageTrackingResourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetStatus.self, forKey: .status)
        status = statusDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let approximateDollarLimitDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .approximateDollarLimit)
        approximateDollarLimit = approximateDollarLimitDecoded
        let usagesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ConsumedUsages.self, forKey: .usages)
        usages = usagesDecoded
        let actionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.ResponseBudgetAction?].self, forKey: .actions)
        var actionsDecoded0:[DeadlineClientTypes.ResponseBudgetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DeadlineClientTypes.ResponseBudgetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let queueStoppedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .queueStoppedAt)
        queueStoppedAt = queueStoppedAtDecoded
    }
}

enum GetBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFarmInput {

    static func urlPathProvider(_ value: GetFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())"
    }
}

public struct GetFarmInput: Swift.Equatable {
    /// The farm ID of the farm.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        farmId: Swift.String? = nil
    )
    {
        self.farmId = farmId
    }
}

struct GetFarmInputBody: Swift.Equatable {
}

extension GetFarmInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFarmOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFarmOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetFarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.displayName = output.displayName
            self.farmId = output.farmId
            self.kmsKeyArn = output.kmsKeyArn
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.displayName = nil
            self.farmId = nil
            self.kmsKeyArn = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetFarmOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the farm.
    public var description: Swift.String?
    /// The display name of the farm.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to get.
    /// This member is required.
    public var farmId: Swift.String?
    /// The ARN of the KMS key used on the farm.
    /// This member is required.
    public var kmsKeyArn: Swift.String?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.kmsKeyArn = kmsKeyArn
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetFarmOutputBody: Swift.Equatable {
    let farmId: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let kmsKeyArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetFarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case displayName
        case farmId
        case kmsKeyArn
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetFarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFleetInput {

    static func urlPathProvider(_ value: GetFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())"
    }
}

public struct GetFleetInput: Swift.Equatable {
    /// The farm ID of the farm in the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the fleet to get.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
    }
}

struct GetFleetInputBody: Swift.Equatable {
}

extension GetFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFleetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFleetOutput(autoScalingStatus: \(Swift.String(describing: autoScalingStatus)), capabilities: \(Swift.String(describing: capabilities)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), fleetId: \(Swift.String(describing: fleetId)), maxWorkerCount: \(Swift.String(describing: maxWorkerCount)), minWorkerCount: \(Swift.String(describing: minWorkerCount)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), targetWorkerCount: \(Swift.String(describing: targetWorkerCount)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), workerCount: \(Swift.String(describing: workerCount)), description: \"CONTENT_REDACTED\")"}
}

extension GetFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingStatus = output.autoScalingStatus
            self.capabilities = output.capabilities
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.displayName = output.displayName
            self.farmId = output.farmId
            self.fleetId = output.fleetId
            self.maxWorkerCount = output.maxWorkerCount
            self.minWorkerCount = output.minWorkerCount
            self.roleArn = output.roleArn
            self.status = output.status
            self.targetWorkerCount = output.targetWorkerCount
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
            self.workerCount = output.workerCount
        } else {
            self.autoScalingStatus = nil
            self.capabilities = nil
            self.configuration = nil
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.displayName = nil
            self.farmId = nil
            self.fleetId = nil
            self.maxWorkerCount = nil
            self.minWorkerCount = nil
            self.roleArn = nil
            self.status = nil
            self.targetWorkerCount = nil
            self.updatedAt = nil
            self.updatedBy = nil
            self.workerCount = nil
        }
    }
}

public struct GetFleetOutput: Swift.Equatable {
    /// The Auto Scaling status of the fleet. Either GROWING, STEADY, or SHRINKING.
    public var autoScalingStatus: DeadlineClientTypes.AutoScalingStatus?
    /// Outlines what the fleet is capable of for minimums, maximums, and naming, in addition to attribute names and values.
    public var capabilities: DeadlineClientTypes.FleetCapabilities?
    /// The configuration setting for the fleet.
    /// This member is required.
    public var configuration: DeadlineClientTypes.FleetConfiguration?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the fleet.
    public var description: Swift.String?
    /// The display name of the fleet.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm in the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of workers specified in the fleet.
    /// This member is required.
    public var maxWorkerCount: Swift.Int?
    /// The minimum number of workers specified in the fleet.
    /// This member is required.
    public var minWorkerCount: Swift.Int?
    /// The IAM role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Auto Scaling status of the fleet.
    /// This member is required.
    public var status: DeadlineClientTypes.FleetStatus?
    /// The number of target workers in the fleet.
    public var targetWorkerCount: Swift.Int?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The number of workers in the fleet.
    /// This member is required.
    public var workerCount: Swift.Int?

    public init(
        autoScalingStatus: DeadlineClientTypes.AutoScalingStatus? = nil,
        capabilities: DeadlineClientTypes.FleetCapabilities? = nil,
        configuration: DeadlineClientTypes.FleetConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxWorkerCount: Swift.Int? = nil,
        minWorkerCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        status: DeadlineClientTypes.FleetStatus? = nil,
        targetWorkerCount: Swift.Int? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil,
        workerCount: Swift.Int? = nil
    )
    {
        self.autoScalingStatus = autoScalingStatus
        self.capabilities = capabilities
        self.configuration = configuration
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxWorkerCount = maxWorkerCount
        self.minWorkerCount = minWorkerCount
        self.roleArn = roleArn
        self.status = status
        self.targetWorkerCount = targetWorkerCount
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.workerCount = workerCount
    }
}

struct GetFleetOutputBody: Swift.Equatable {
    let fleetId: Swift.String?
    let farmId: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let status: DeadlineClientTypes.FleetStatus?
    let autoScalingStatus: DeadlineClientTypes.AutoScalingStatus?
    let targetWorkerCount: Swift.Int?
    let workerCount: Swift.Int?
    let minWorkerCount: Swift.Int?
    let maxWorkerCount: Swift.Int?
    let configuration: DeadlineClientTypes.FleetConfiguration?
    let capabilities: DeadlineClientTypes.FleetCapabilities?
    let roleArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingStatus
        case capabilities
        case configuration
        case createdAt
        case createdBy
        case description
        case displayName
        case farmId
        case fleetId
        case maxWorkerCount
        case minWorkerCount
        case roleArn
        case status
        case targetWorkerCount
        case updatedAt
        case updatedBy
        case workerCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetStatus.self, forKey: .status)
        status = statusDecoded
        let autoScalingStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.AutoScalingStatus.self, forKey: .autoScalingStatus)
        autoScalingStatus = autoScalingStatusDecoded
        let targetWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetWorkerCount)
        targetWorkerCount = targetWorkerCountDecoded
        let workerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workerCount)
        workerCount = workerCountDecoded
        let minWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let maxWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.GetJobEntityError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentdetails = "environmentDetails"
        case jobattachmentdetails = "jobAttachmentDetails"
        case jobdetails = "jobDetails"
        case sdkUnknown
        case stepdetails = "stepDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .environmentdetails(environmentdetails):
                try container.encode(environmentdetails, forKey: .environmentdetails)
            case let .jobattachmentdetails(jobattachmentdetails):
                try container.encode(jobattachmentdetails, forKey: .jobattachmentdetails)
            case let .jobdetails(jobdetails):
                try container.encode(jobdetails, forKey: .jobdetails)
            case let .stepdetails(stepdetails):
                try container.encode(stepdetails, forKey: .stepdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let jobdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.JobDetailsError.self, forKey: .jobdetails)
        if let jobdetails = jobdetailsDecoded {
            self = .jobdetails(jobdetails)
            return
        }
        let jobattachmentdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.JobAttachmentDetailsError.self, forKey: .jobattachmentdetails)
        if let jobattachmentdetails = jobattachmentdetailsDecoded {
            self = .jobattachmentdetails(jobattachmentdetails)
            return
        }
        let stepdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.StepDetailsError.self, forKey: .stepdetails)
        if let stepdetails = stepdetailsDecoded {
            self = .stepdetails(stepdetails)
            return
        }
        let environmentdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentDetailsError.self, forKey: .environmentdetails)
        if let environmentdetails = environmentdetailsDecoded {
            self = .environmentdetails(environmentdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The error for the job entity.
    public enum GetJobEntityError: Swift.Equatable {
        /// The job details for the failed job entity.
        case jobdetails(DeadlineClientTypes.JobDetailsError)
        /// The job attachment details for the failed job entity.
        case jobattachmentdetails(DeadlineClientTypes.JobAttachmentDetailsError)
        /// The step details for the failed job entity.
        case stepdetails(DeadlineClientTypes.StepDetailsError)
        /// The environment details for the failed job entity.
        case environmentdetails(DeadlineClientTypes.EnvironmentDetailsError)
        case sdkUnknown(Swift.String)
    }

}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetJobInput: Swift.Equatable {
    /// The farm ID of the farm in the job.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID associated with the job.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
    }
}

struct GetJobInputBody: Swift.Equatable {
}

extension GetJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobOutput(attachments: \(Swift.String(describing: attachments)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), jobId: \(Swift.String(describing: jobId)), lifecycleStatus: \(Swift.String(describing: lifecycleStatus)), lifecycleStatusMessage: \(Swift.String(describing: lifecycleStatusMessage)), maxFailedTasksCount: \(Swift.String(describing: maxFailedTasksCount)), maxRetriesPerTask: \(Swift.String(describing: maxRetriesPerTask)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), startedAt: \(Swift.String(describing: startedAt)), storageProfileId: \(Swift.String(describing: storageProfileId)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), taskRunStatus: \(Swift.String(describing: taskRunStatus)), taskRunStatusCounts: \(Swift.String(describing: taskRunStatusCounts)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", parameters: \"CONTENT_REDACTED\")"}
}

extension GetJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachments = output.attachments
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.endedAt = output.endedAt
            self.jobId = output.jobId
            self.lifecycleStatus = output.lifecycleStatus
            self.lifecycleStatusMessage = output.lifecycleStatusMessage
            self.maxFailedTasksCount = output.maxFailedTasksCount
            self.maxRetriesPerTask = output.maxRetriesPerTask
            self.name = output.name
            self.parameters = output.parameters
            self.priority = output.priority
            self.startedAt = output.startedAt
            self.storageProfileId = output.storageProfileId
            self.targetTaskRunStatus = output.targetTaskRunStatus
            self.taskRunStatus = output.taskRunStatus
            self.taskRunStatusCounts = output.taskRunStatusCounts
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.attachments = nil
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.endedAt = nil
            self.jobId = nil
            self.lifecycleStatus = nil
            self.lifecycleStatusMessage = nil
            self.maxFailedTasksCount = nil
            self.maxRetriesPerTask = nil
            self.name = nil
            self.parameters = nil
            self.priority = nil
            self.startedAt = nil
            self.storageProfileId = nil
            self.targetTaskRunStatus = nil
            self.taskRunStatus = nil
            self.taskRunStatusCounts = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetJobOutput: Swift.Equatable {
    /// The attachments for the job.
    public var attachments: DeadlineClientTypes.Attachments?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the job.
    public var description: Swift.String?
    /// The date and time the resource ended running.
    public var endedAt: ClientRuntime.Date?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The life cycle status for the job.
    /// This member is required.
    public var lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
    /// A message that communicates the status of the life cycle for the job.
    /// This member is required.
    public var lifecycleStatusMessage: Swift.String?
    /// The number of task failures before the job stops running and is marked as FAILED.
    public var maxFailedTasksCount: Swift.Int?
    /// The maximum number of retries per failed tasks.
    public var maxRetriesPerTask: Swift.Int?
    /// The name of the job.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters for the job.
    public var parameters: [Swift.String:DeadlineClientTypes.JobParameter]?
    /// The job priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The date and time the resource started running.
    public var startedAt: ClientRuntime.Date?
    /// The storage profile ID associated with the job.
    public var storageProfileId: Swift.String?
    /// The task status with which the job started.
    public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
    /// The task run status for the job.
    public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
    /// The number of tasks running on the job.
    public var taskRunStatusCounts: [Swift.String:Swift.Int]?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        attachments: DeadlineClientTypes.Attachments? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        endedAt: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus? = nil,
        lifecycleStatusMessage: Swift.String? = nil,
        maxFailedTasksCount: Swift.Int? = nil,
        maxRetriesPerTask: Swift.Int? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:DeadlineClientTypes.JobParameter]? = nil,
        priority: Swift.Int? = nil,
        startedAt: ClientRuntime.Date? = nil,
        storageProfileId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil,
        taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
        taskRunStatusCounts: [Swift.String:Swift.Int]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.endedAt = endedAt
        self.jobId = jobId
        self.lifecycleStatus = lifecycleStatus
        self.lifecycleStatusMessage = lifecycleStatusMessage
        self.maxFailedTasksCount = maxFailedTasksCount
        self.maxRetriesPerTask = maxRetriesPerTask
        self.name = name
        self.parameters = parameters
        self.priority = priority
        self.startedAt = startedAt
        self.storageProfileId = storageProfileId
        self.targetTaskRunStatus = targetTaskRunStatus
        self.taskRunStatus = taskRunStatus
        self.taskRunStatusCounts = taskRunStatusCounts
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let name: Swift.String?
    let lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
    let lifecycleStatusMessage: Swift.String?
    let priority: Swift.Int?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let taskRunStatus: DeadlineClientTypes.TaskRunStatus?
    let targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
    let taskRunStatusCounts: [Swift.String:Swift.Int]?
    let storageProfileId: Swift.String?
    let maxFailedTasksCount: Swift.Int?
    let maxRetriesPerTask: Swift.Int?
    let parameters: [Swift.String:DeadlineClientTypes.JobParameter]?
    let attachments: DeadlineClientTypes.Attachments?
    let description: Swift.String?
}

extension GetJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments
        case createdAt
        case createdBy
        case description
        case endedAt
        case jobId
        case lifecycleStatus
        case lifecycleStatusMessage
        case maxFailedTasksCount
        case maxRetriesPerTask
        case name
        case parameters
        case priority
        case startedAt
        case storageProfileId
        case targetTaskRunStatus
        case taskRunStatus
        case taskRunStatusCounts
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let lifecycleStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStatusMessage)
        lifecycleStatusMessage = lifecycleStatusMessageDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let taskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .taskRunStatus)
        taskRunStatus = taskRunStatusDecoded
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let taskRunStatusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .taskRunStatusCounts)
        var taskRunStatusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let taskRunStatusCountsContainer = taskRunStatusCountsContainer {
            taskRunStatusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in taskRunStatusCountsContainer {
                if let integer0 = integer0 {
                    taskRunStatusCountsDecoded0?[key0] = integer0
                }
            }
        }
        taskRunStatusCounts = taskRunStatusCountsDecoded0
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
        let maxFailedTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFailedTasksCount)
        maxFailedTasksCount = maxFailedTasksCountDecoded
        let maxRetriesPerTaskDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetriesPerTask)
        maxRetriesPerTask = maxRetriesPerTaskDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.JobParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.JobParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.JobParameter]()
            for (key0, jobparameter0) in parametersContainer {
                if let jobparameter0 = jobparameter0 {
                    parametersDecoded0?[key0] = jobparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let attachmentsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Attachments.self, forKey: .attachments)
        attachments = attachmentsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLicenseEndpointInput {

    static func urlPathProvider(_ value: GetLicenseEndpointInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())"
    }
}

public struct GetLicenseEndpointInput: Swift.Equatable {
    /// The license endpoint ID.
    /// This member is required.
    public var licenseEndpointId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
    }
}

struct GetLicenseEndpointInputBody: Swift.Equatable {
}

extension GetLicenseEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLicenseEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLicenseEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.dnsName = output.dnsName
            self.licenseEndpointId = output.licenseEndpointId
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.subnetIds = output.subnetIds
            self.vpcId = output.vpcId
        } else {
            self.dnsName = nil
            self.licenseEndpointId = nil
            self.securityGroupIds = nil
            self.status = nil
            self.statusMessage = nil
            self.subnetIds = nil
            self.vpcId = nil
        }
    }
}

public struct GetLicenseEndpointOutput: Swift.Equatable {
    /// The DNS name.
    public var dnsName: Swift.String?
    /// The license endpoint ID.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The security group IDs for the license endpoint.
    public var securityGroupIds: [Swift.String]?
    /// The status of the license endpoint.
    /// This member is required.
    public var status: DeadlineClientTypes.LicenseEndpointStatus?
    /// The status message of the license endpoint.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The subnet IDs.
    public var subnetIds: [Swift.String]?
    /// The VCP(virtual private cloud) ID associated with the license endpoint.
    public var vpcId: Swift.String?

    public init(
        dnsName: Swift.String? = nil,
        licenseEndpointId: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: DeadlineClientTypes.LicenseEndpointStatus? = nil,
        statusMessage: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.dnsName = dnsName
        self.licenseEndpointId = licenseEndpointId
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.statusMessage = statusMessage
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct GetLicenseEndpointOutputBody: Swift.Equatable {
    let licenseEndpointId: Swift.String?
    let status: DeadlineClientTypes.LicenseEndpointStatus?
    let statusMessage: Swift.String?
    let vpcId: Swift.String?
    let dnsName: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
}

extension GetLicenseEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsName
        case licenseEndpointId
        case securityGroupIds
        case status
        case statusMessage
        case subnetIds
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseEndpointId)
        licenseEndpointId = licenseEndpointIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LicenseEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

enum GetLicenseEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMonitorInput {

    static func urlPathProvider(_ value: GetMonitorInput) -> Swift.String? {
        guard let monitorId = value.monitorId else {
            return nil
        }
        return "/2023-10-12/monitors/\(monitorId.urlPercentEncoding())"
    }
}

public struct GetMonitorInput: Swift.Equatable {
    /// The unique identifier for the monitor. This ID is returned by the CreateMonitor operation.
    /// This member is required.
    public var monitorId: Swift.String?

    public init(
        monitorId: Swift.String? = nil
    )
    {
        self.monitorId = monitorId
    }
}

struct GetMonitorInputBody: Swift.Equatable {
}

extension GetMonitorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.displayName = output.displayName
            self.identityCenterApplicationArn = output.identityCenterApplicationArn
            self.identityCenterInstanceArn = output.identityCenterInstanceArn
            self.monitorId = output.monitorId
            self.roleArn = output.roleArn
            self.subdomain = output.subdomain
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
            self.url = output.url
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.displayName = nil
            self.identityCenterApplicationArn = nil
            self.identityCenterInstanceArn = nil
            self.monitorId = nil
            self.roleArn = nil
            self.subdomain = nil
            self.updatedAt = nil
            self.updatedBy = nil
            self.url = nil
        }
    }
}

public struct GetMonitorOutput: Swift.Equatable {
    /// The UNIX timestamp of the date and time that the monitor was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user name of the person that created the monitor.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The name used to identify the monitor on the Deadline Cloud console.
    /// This member is required.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) that the IAM Identity Center assigned to the monitor when it was created.
    /// This member is required.
    public var identityCenterApplicationArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Identity Center instance responsible for authenticating monitor users.
    /// This member is required.
    public var identityCenterInstanceArn: Swift.String?
    /// The unique identifier for the monitor.
    /// This member is required.
    public var monitorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role for the monitor. Users of the monitor use this role to access Deadline Cloud resources.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The subdomain used for the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    /// This member is required.
    public var subdomain: Swift.String?
    /// The UNIX timestamp of the last date and time that the monitor was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user name of the person that last updated the monitor.
    public var updatedBy: Swift.String?
    /// The complete URL of the monitor. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    /// This member is required.
    public var url: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityCenterApplicationArn: Swift.String? = nil,
        identityCenterInstanceArn: Swift.String? = nil,
        monitorId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.displayName = displayName
        self.identityCenterApplicationArn = identityCenterApplicationArn
        self.identityCenterInstanceArn = identityCenterInstanceArn
        self.monitorId = monitorId
        self.roleArn = roleArn
        self.subdomain = subdomain
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.url = url
    }
}

struct GetMonitorOutputBody: Swift.Equatable {
    let monitorId: Swift.String?
    let displayName: Swift.String?
    let subdomain: Swift.String?
    let url: Swift.String?
    let roleArn: Swift.String?
    let identityCenterInstanceArn: Swift.String?
    let identityCenterApplicationArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case displayName
        case identityCenterApplicationArn
        case identityCenterInstanceArn
        case monitorId
        case roleArn
        case subdomain
        case updatedAt
        case updatedBy
        case url
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorId)
        monitorId = monitorIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let subdomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdomain)
        subdomain = subdomainDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let identityCenterInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterInstanceArn)
        identityCenterInstanceArn = identityCenterInstanceArnDecoded
        let identityCenterApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterApplicationArn)
        identityCenterApplicationArn = identityCenterApplicationArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueueEnvironmentInput {

    static func urlPathProvider(_ value: GetQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let queueEnvironmentId = value.queueEnvironmentId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments/\(queueEnvironmentId.urlPercentEncoding())"
    }
}

public struct GetQueueEnvironmentInput: Swift.Equatable {
    /// The farm ID for the queue environment.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue environment ID.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The queue ID for the queue environment.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueEnvironmentId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueEnvironmentId = queueEnvironmentId
        self.queueId = queueId
    }
}

struct GetQueueEnvironmentInputBody: Swift.Equatable {
}

extension GetQueueEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetQueueEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQueueEnvironmentOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), queueEnvironmentId: \(Swift.String(describing: queueEnvironmentId)), templateType: \(Swift.String(describing: templateType)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), template: \"CONTENT_REDACTED\")"}
}

extension GetQueueEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueueEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.name = output.name
            self.priority = output.priority
            self.queueEnvironmentId = output.queueEnvironmentId
            self.template = output.template
            self.templateType = output.templateType
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.name = nil
            self.priority = nil
            self.queueEnvironmentId = nil
            self.template = nil
            self.templateType = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetQueueEnvironmentOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.>
    /// This member is required.
    public var createdBy: Swift.String?
    /// The name of the queue environment.
    /// This member is required.
    public var name: Swift.String?
    /// The priority of the queue environment.
    /// This member is required.
    public var priority: Swift.Int?
    /// The queue environment ID.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The template for the queue environment.
    /// This member is required.
    public var template: Swift.String?
    /// The type of template for the queue environment.
    /// This member is required.
    public var templateType: DeadlineClientTypes.EnvironmentTemplateType?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queueEnvironmentId: Swift.String? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.EnvironmentTemplateType? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.name = name
        self.priority = priority
        self.queueEnvironmentId = queueEnvironmentId
        self.template = template
        self.templateType = templateType
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetQueueEnvironmentOutputBody: Swift.Equatable {
    let queueEnvironmentId: Swift.String?
    let name: Swift.String?
    let priority: Swift.Int?
    let templateType: DeadlineClientTypes.EnvironmentTemplateType?
    let template: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetQueueEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case name
        case priority
        case queueEnvironmentId
        case template
        case templateType
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueEnvironmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueEnvironmentId)
        queueEnvironmentId = queueEnvironmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.EnvironmentTemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetQueueEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueueFleetAssociationInput {

    static func urlPathProvider(_ value: GetQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations/\(queueId.urlPercentEncoding())/\(fleetId.urlPercentEncoding())"
    }
}

public struct GetQueueFleetAssociationInput: Swift.Equatable {
    /// The farm ID of the farm that contains the queue-fleet association.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID for the queue-fleet association.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID for the queue-fleet association.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
    }
}

struct GetQueueFleetAssociationInputBody: Swift.Equatable {
}

extension GetQueueFleetAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetQueueFleetAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueueFleetAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.fleetId = output.fleetId
            self.queueId = output.queueId
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.fleetId = nil
            self.queueId = nil
            self.status = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetQueueFleetAssociationOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The fleet ID for the queue-fleet association.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID for the queue-fleet association.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status of the queue-fleet association.
    /// This member is required.
    public var status: DeadlineClientTypes.QueueFleetAssociationStatus?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: DeadlineClientTypes.QueueFleetAssociationStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.fleetId = fleetId
        self.queueId = queueId
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetQueueFleetAssociationOutputBody: Swift.Equatable {
    let queueId: Swift.String?
    let fleetId: Swift.String?
    let status: DeadlineClientTypes.QueueFleetAssociationStatus?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetQueueFleetAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case fleetId
        case queueId
        case status
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.QueueFleetAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetQueueFleetAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueueInput {

    static func urlPathProvider(_ value: GetQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())"
    }
}

public struct GetQueueInput: Swift.Equatable {
    /// The farm ID of the farm in the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID for the queue to retrieve.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

struct GetQueueInputBody: Swift.Equatable {
}

extension GetQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetQueueOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQueueOutput(allowedStorageProfileIds: \(Swift.String(describing: allowedStorageProfileIds)), blockedReason: \(Swift.String(describing: blockedReason)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), defaultBudgetAction: \(Swift.String(describing: defaultBudgetAction)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), queueId: \(Swift.String(describing: queueId)), requiredFileSystemLocationNames: \(Swift.String(describing: requiredFileSystemLocationNames)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueueOutputBody = try responseDecoder.decode(responseBody: data)
            self.allowedStorageProfileIds = output.allowedStorageProfileIds
            self.blockedReason = output.blockedReason
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.defaultBudgetAction = output.defaultBudgetAction
            self.description = output.description
            self.displayName = output.displayName
            self.farmId = output.farmId
            self.jobAttachmentSettings = output.jobAttachmentSettings
            self.jobRunAsUser = output.jobRunAsUser
            self.queueId = output.queueId
            self.requiredFileSystemLocationNames = output.requiredFileSystemLocationNames
            self.roleArn = output.roleArn
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.allowedStorageProfileIds = nil
            self.blockedReason = nil
            self.createdAt = nil
            self.createdBy = nil
            self.defaultBudgetAction = nil
            self.description = nil
            self.displayName = nil
            self.farmId = nil
            self.jobAttachmentSettings = nil
            self.jobRunAsUser = nil
            self.queueId = nil
            self.requiredFileSystemLocationNames = nil
            self.roleArn = nil
            self.status = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetQueueOutput: Swift.Equatable {
    /// The storage profile IDs for the queue.
    public var allowedStorageProfileIds: [Swift.String]?
    /// The reason the queue was blocked.
    public var blockedReason: DeadlineClientTypes.QueueBlockedReason?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The default action taken on a queue if a budget wasn't configured.
    /// This member is required.
    public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    /// The description of the queue.
    public var description: Swift.String?
    /// The display name of the queue.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID for the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job attachment settings for the queue.
    public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    /// The jobs in the queue ran as this specified POSIX user.
    public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?
    /// A list of the required file system location names in the queue.
    public var requiredFileSystemLocationNames: [Swift.String]?
    /// The IAM role ARN.
    public var roleArn: Swift.String?
    /// The status of the queue.
    ///
    /// * ACTIVEThe queue is active.
    ///
    /// * SCHEDULINGThe queue is scheduling.
    ///
    /// * SCHEDULING_BLOCKEDThe queue scheduling is blocked. See the provided reason.
    /// This member is required.
    public var status: DeadlineClientTypes.QueueStatus?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        allowedStorageProfileIds: [Swift.String]? = nil,
        blockedReason: DeadlineClientTypes.QueueBlockedReason? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
        jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
        queueId: Swift.String? = nil,
        requiredFileSystemLocationNames: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        status: DeadlineClientTypes.QueueStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.allowedStorageProfileIds = allowedStorageProfileIds
        self.blockedReason = blockedReason
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.defaultBudgetAction = defaultBudgetAction
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.jobAttachmentSettings = jobAttachmentSettings
        self.jobRunAsUser = jobRunAsUser
        self.queueId = queueId
        self.requiredFileSystemLocationNames = requiredFileSystemLocationNames
        self.roleArn = roleArn
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetQueueOutputBody: Swift.Equatable {
    let queueId: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let farmId: Swift.String?
    let status: DeadlineClientTypes.QueueStatus?
    let defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    let blockedReason: DeadlineClientTypes.QueueBlockedReason?
    let jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    let roleArn: Swift.String?
    let requiredFileSystemLocationNames: [Swift.String]?
    let allowedStorageProfileIds: [Swift.String]?
    let jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetQueueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedStorageProfileIds
        case blockedReason
        case createdAt
        case createdBy
        case defaultBudgetAction
        case description
        case displayName
        case farmId
        case jobAttachmentSettings
        case jobRunAsUser
        case queueId
        case requiredFileSystemLocationNames
        case roleArn
        case status
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.QueueStatus.self, forKey: .status)
        status = statusDecoded
        let defaultBudgetActionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DefaultQueueBudgetAction.self, forKey: .defaultBudgetAction)
        defaultBudgetAction = defaultBudgetActionDecoded
        let blockedReasonDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.QueueBlockedReason.self, forKey: .blockedReason)
        blockedReason = blockedReasonDecoded
        let jobAttachmentSettingsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobAttachmentSettings.self, forKey: .jobAttachmentSettings)
        jobAttachmentSettings = jobAttachmentSettingsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let requiredFileSystemLocationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredFileSystemLocationNames)
        var requiredFileSystemLocationNamesDecoded0:[Swift.String]? = nil
        if let requiredFileSystemLocationNamesContainer = requiredFileSystemLocationNamesContainer {
            requiredFileSystemLocationNamesDecoded0 = [Swift.String]()
            for string0 in requiredFileSystemLocationNamesContainer {
                if let string0 = string0 {
                    requiredFileSystemLocationNamesDecoded0?.append(string0)
                }
            }
        }
        requiredFileSystemLocationNames = requiredFileSystemLocationNamesDecoded0
        let allowedStorageProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedStorageProfileIds)
        var allowedStorageProfileIdsDecoded0:[Swift.String]? = nil
        if let allowedStorageProfileIdsContainer = allowedStorageProfileIdsContainer {
            allowedStorageProfileIdsDecoded0 = [Swift.String]()
            for string0 in allowedStorageProfileIdsContainer {
                if let string0 = string0 {
                    allowedStorageProfileIdsDecoded0?.append(string0)
                }
            }
        }
        allowedStorageProfileIds = allowedStorageProfileIdsDecoded0
        let jobRunAsUserDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobRunAsUser.self, forKey: .jobRunAsUser)
        jobRunAsUser = jobRunAsUserDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSessionActionInput {

    static func urlPathProvider(_ value: GetSessionActionInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let sessionActionId = value.sessionActionId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/session-actions/\(sessionActionId.urlPercentEncoding())"
    }
}

public struct GetSessionActionInput: Swift.Equatable {
    /// The farm ID for the session action.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the session.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the session action.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session action ID for the session.
    /// This member is required.
    public var sessionActionId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionActionId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.sessionActionId = sessionActionId
    }
}

struct GetSessionActionInputBody: Swift.Equatable {
}

extension GetSessionActionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionActionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionActionOutput(definition: \(Swift.String(describing: definition)), endedAt: \(Swift.String(describing: endedAt)), processExitCode: \(Swift.String(describing: processExitCode)), progressPercent: \(Swift.String(describing: progressPercent)), sessionActionId: \(Swift.String(describing: sessionActionId)), sessionId: \(Swift.String(describing: sessionId)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), workerUpdatedAt: \(Swift.String(describing: workerUpdatedAt)), progressMessage: \"CONTENT_REDACTED\")"}
}

extension GetSessionActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSessionActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.definition = output.definition
            self.endedAt = output.endedAt
            self.processExitCode = output.processExitCode
            self.progressMessage = output.progressMessage
            self.progressPercent = output.progressPercent
            self.sessionActionId = output.sessionActionId
            self.sessionId = output.sessionId
            self.startedAt = output.startedAt
            self.status = output.status
            self.workerUpdatedAt = output.workerUpdatedAt
        } else {
            self.definition = nil
            self.endedAt = nil
            self.processExitCode = nil
            self.progressMessage = nil
            self.progressPercent = nil
            self.sessionActionId = nil
            self.sessionId = nil
            self.startedAt = nil
            self.status = nil
            self.workerUpdatedAt = nil
        }
    }
}

public struct GetSessionActionOutput: Swift.Equatable {
    /// The session action definition.
    /// This member is required.
    public var definition: DeadlineClientTypes.SessionActionDefinition?
    /// The date and time the resource ended running.
    public var endedAt: ClientRuntime.Date?
    /// The exit code to exit the session.
    public var processExitCode: Swift.Int?
    /// The message that communicates the progress of the session action.
    public var progressMessage: Swift.String?
    /// The percentage completed for a session action.
    public var progressPercent: Swift.Float?
    /// The session action ID.
    /// This member is required.
    public var sessionActionId: Swift.String?
    /// The session ID for the session action.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The date and time the resource started running.
    public var startedAt: ClientRuntime.Date?
    /// The status of the session action.
    /// This member is required.
    public var status: DeadlineClientTypes.SessionActionStatus?
    /// The Linux timestamp of the date and time the session action was last updated.
    public var workerUpdatedAt: ClientRuntime.Date?

    public init(
        definition: DeadlineClientTypes.SessionActionDefinition? = nil,
        endedAt: ClientRuntime.Date? = nil,
        processExitCode: Swift.Int? = nil,
        progressMessage: Swift.String? = nil,
        progressPercent: Swift.Float? = nil,
        sessionActionId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: DeadlineClientTypes.SessionActionStatus? = nil,
        workerUpdatedAt: ClientRuntime.Date? = nil
    )
    {
        self.definition = definition
        self.endedAt = endedAt
        self.processExitCode = processExitCode
        self.progressMessage = progressMessage
        self.progressPercent = progressPercent
        self.sessionActionId = sessionActionId
        self.sessionId = sessionId
        self.startedAt = startedAt
        self.status = status
        self.workerUpdatedAt = workerUpdatedAt
    }
}

struct GetSessionActionOutputBody: Swift.Equatable {
    let sessionActionId: Swift.String?
    let status: DeadlineClientTypes.SessionActionStatus?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let workerUpdatedAt: ClientRuntime.Date?
    let progressPercent: Swift.Float?
    let sessionId: Swift.String?
    let processExitCode: Swift.Int?
    let progressMessage: Swift.String?
    let definition: DeadlineClientTypes.SessionActionDefinition?
}

extension GetSessionActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case endedAt
        case processExitCode
        case progressMessage
        case progressPercent
        case sessionActionId
        case sessionId
        case startedAt
        case status
        case workerUpdatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionActionId)
        sessionActionId = sessionActionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionActionStatus.self, forKey: .status)
        status = statusDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let workerUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .workerUpdatedAt)
        workerUpdatedAt = workerUpdatedAtDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let processExitCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processExitCode)
        processExitCode = processExitCodeDecoded
        let progressMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressMessage)
        progressMessage = progressMessageDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionActionDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

enum GetSessionActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The farm ID for the session.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the session.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the session.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.endedAt = output.endedAt
            self.fleetId = output.fleetId
            self.hostProperties = output.hostProperties
            self.lifecycleStatus = output.lifecycleStatus
            self.log = output.log
            self.sessionId = output.sessionId
            self.startedAt = output.startedAt
            self.targetLifecycleStatus = output.targetLifecycleStatus
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
            self.workerId = output.workerId
            self.workerLog = output.workerLog
        } else {
            self.endedAt = nil
            self.fleetId = nil
            self.hostProperties = nil
            self.lifecycleStatus = nil
            self.log = nil
            self.sessionId = nil
            self.startedAt = nil
            self.targetLifecycleStatus = nil
            self.updatedAt = nil
            self.updatedBy = nil
            self.workerId = nil
            self.workerLog = nil
        }
    }
}

public struct GetSessionOutput: Swift.Equatable {
    /// The date and time the resource ended running.
    public var endedAt: ClientRuntime.Date?
    /// The fleet ID for the session.
    /// This member is required.
    public var fleetId: Swift.String?
    /// Provides the Amazon EC2 properties of the host.
    public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
    /// The life cycle status of the session.
    /// This member is required.
    public var lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
    /// The session log.
    /// This member is required.
    public var log: DeadlineClientTypes.LogConfiguration?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The date and time the resource started running.
    /// This member is required.
    public var startedAt: ClientRuntime.Date?
    /// The life cycle status with which the session started.
    public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The worker ID for the session.
    /// This member is required.
    public var workerId: Swift.String?
    /// The worker log for the session.
    public var workerLog: DeadlineClientTypes.LogConfiguration?

    public init(
        endedAt: ClientRuntime.Date? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
        lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus? = nil,
        log: DeadlineClientTypes.LogConfiguration? = nil,
        sessionId: Swift.String? = nil,
        startedAt: ClientRuntime.Date? = nil,
        targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil,
        workerId: Swift.String? = nil,
        workerLog: DeadlineClientTypes.LogConfiguration? = nil
    )
    {
        self.endedAt = endedAt
        self.fleetId = fleetId
        self.hostProperties = hostProperties
        self.lifecycleStatus = lifecycleStatus
        self.log = log
        self.sessionId = sessionId
        self.startedAt = startedAt
        self.targetLifecycleStatus = targetLifecycleStatus
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.workerId = workerId
        self.workerLog = workerLog
    }
}

struct GetSessionOutputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let fleetId: Swift.String?
    let workerId: Swift.String?
    let startedAt: ClientRuntime.Date?
    let log: DeadlineClientTypes.LogConfiguration?
    let lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
    let endedAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
    let targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?
    let hostProperties: DeadlineClientTypes.HostPropertiesResponse?
    let workerLog: DeadlineClientTypes.LogConfiguration?
}

extension GetSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt
        case fleetId
        case hostProperties
        case lifecycleStatus
        case log
        case sessionId
        case startedAt
        case targetLifecycleStatus
        case updatedAt
        case updatedBy
        case workerId
        case workerLog
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let logDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogConfiguration.self, forKey: .log)
        log = logDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let targetLifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleTargetStatus.self, forKey: .targetLifecycleStatus)
        targetLifecycleStatus = targetLifecycleStatusDecoded
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.HostPropertiesResponse.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
        let workerLogDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogConfiguration.self, forKey: .workerLog)
        workerLog = workerLogDecoded
    }
}

enum GetSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSessionsStatisticsAggregationInput {

    static func queryItemProvider(_ value: GetSessionsStatisticsAggregationInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let aggregationId = value.aggregationId else {
            let message = "Creating a URL Query Item failed. aggregationId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let aggregationIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "aggregationId".urlPercentEncoding(), value: Swift.String(aggregationId).urlPercentEncoding())
        items.append(aggregationIdQueryItem)
        return items
    }
}

extension GetSessionsStatisticsAggregationInput {

    static func urlPathProvider(_ value: GetSessionsStatisticsAggregationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/sessions-statistics-aggregation"
    }
}

public struct GetSessionsStatisticsAggregationInput: Swift.Equatable {
    /// The identifier returned by the StartSessionsStatisticsAggregation operation that identifies the aggregated statistics.
    /// This member is required.
    public var aggregationId: Swift.String?
    /// The identifier of the farm to include in the statistics. This should be the same as the farm ID used in the call to the StartSessionsStatisticsAggregation operation.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        aggregationId: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregationId = aggregationId
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetSessionsStatisticsAggregationInputBody: Swift.Equatable {
}

extension GetSessionsStatisticsAggregationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionsStatisticsAggregationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSessionsStatisticsAggregationOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.statistics = output.statistics
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.nextToken = nil
            self.statistics = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetSessionsStatisticsAggregationOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The statistics for the specified fleets or queues.
    public var statistics: [DeadlineClientTypes.Statistics]?
    /// The status of the aggregated results.
    /// This member is required.
    public var status: DeadlineClientTypes.SessionsStatisticsAggregationStatus?
    /// A message that describes the status.
    public var statusMessage: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        statistics: [DeadlineClientTypes.Statistics]? = nil,
        status: DeadlineClientTypes.SessionsStatisticsAggregationStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.statistics = statistics
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetSessionsStatisticsAggregationOutputBody: Swift.Equatable {
    let statistics: [DeadlineClientTypes.Statistics]?
    let nextToken: Swift.String?
    let status: DeadlineClientTypes.SessionsStatisticsAggregationStatus?
    let statusMessage: Swift.String?
}

extension GetSessionsStatisticsAggregationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case statistics
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.Statistics?].self, forKey: .statistics)
        var statisticsDecoded0:[DeadlineClientTypes.Statistics]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [DeadlineClientTypes.Statistics]()
            for structure0 in statisticsContainer {
                if let structure0 = structure0 {
                    statisticsDecoded0?.append(structure0)
                }
            }
        }
        statistics = statisticsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionsStatisticsAggregationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

enum GetSessionsStatisticsAggregationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStepInput {

    static func urlPathProvider(_ value: GetStepInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())"
    }
}

public struct GetStepInput: Swift.Equatable {
    /// The farm ID for the step.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the step.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the step.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
    }
}

struct GetStepInputBody: Swift.Equatable {
}

extension GetStepInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStepOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStepOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), dependencyCounts: \(Swift.String(describing: dependencyCounts)), endedAt: \(Swift.String(describing: endedAt)), lifecycleStatus: \(Swift.String(describing: lifecycleStatus)), lifecycleStatusMessage: \(Swift.String(describing: lifecycleStatusMessage)), name: \(Swift.String(describing: name)), parameterSpace: \(Swift.String(describing: parameterSpace)), requiredCapabilities: \(Swift.String(describing: requiredCapabilities)), startedAt: \(Swift.String(describing: startedAt)), stepId: \(Swift.String(describing: stepId)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), taskRunStatus: \(Swift.String(describing: taskRunStatus)), taskRunStatusCounts: \(Swift.String(describing: taskRunStatusCounts)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStepOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.dependencyCounts = output.dependencyCounts
            self.description = output.description
            self.endedAt = output.endedAt
            self.lifecycleStatus = output.lifecycleStatus
            self.lifecycleStatusMessage = output.lifecycleStatusMessage
            self.name = output.name
            self.parameterSpace = output.parameterSpace
            self.requiredCapabilities = output.requiredCapabilities
            self.startedAt = output.startedAt
            self.stepId = output.stepId
            self.targetTaskRunStatus = output.targetTaskRunStatus
            self.taskRunStatus = output.taskRunStatus
            self.taskRunStatusCounts = output.taskRunStatusCounts
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.dependencyCounts = nil
            self.description = nil
            self.endedAt = nil
            self.lifecycleStatus = nil
            self.lifecycleStatusMessage = nil
            self.name = nil
            self.parameterSpace = nil
            self.requiredCapabilities = nil
            self.startedAt = nil
            self.stepId = nil
            self.targetTaskRunStatus = nil
            self.taskRunStatus = nil
            self.taskRunStatusCounts = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetStepOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The number of dependencies in the step.
    public var dependencyCounts: DeadlineClientTypes.DependencyCounts?
    /// The description of the step.
    public var description: Swift.String?
    /// The date and time the resource ended running.
    public var endedAt: ClientRuntime.Date?
    /// The life cycle status of the step.
    /// This member is required.
    public var lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
    /// A message that describes the lifecycle status of the step.
    public var lifecycleStatusMessage: Swift.String?
    /// The name of the step.
    /// This member is required.
    public var name: Swift.String?
    /// A list of step parameters and the combination expression for the step.
    public var parameterSpace: DeadlineClientTypes.ParameterSpace?
    /// The required capabilities of the step.
    public var requiredCapabilities: DeadlineClientTypes.StepRequiredCapabilities?
    /// The date and time the resource started running.
    public var startedAt: ClientRuntime.Date?
    /// The step ID.
    /// This member is required.
    public var stepId: Swift.String?
    /// The task status with which the job started.
    public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
    /// The task run status for the job.
    /// This member is required.
    public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
    /// The number of tasks running on the job.
    /// This member is required.
    public var taskRunStatusCounts: [Swift.String:Swift.Int]?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        dependencyCounts: DeadlineClientTypes.DependencyCounts? = nil,
        description: Swift.String? = nil,
        endedAt: ClientRuntime.Date? = nil,
        lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus? = nil,
        lifecycleStatusMessage: Swift.String? = nil,
        name: Swift.String? = nil,
        parameterSpace: DeadlineClientTypes.ParameterSpace? = nil,
        requiredCapabilities: DeadlineClientTypes.StepRequiredCapabilities? = nil,
        startedAt: ClientRuntime.Date? = nil,
        stepId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil,
        taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
        taskRunStatusCounts: [Swift.String:Swift.Int]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.dependencyCounts = dependencyCounts
        self.description = description
        self.endedAt = endedAt
        self.lifecycleStatus = lifecycleStatus
        self.lifecycleStatusMessage = lifecycleStatusMessage
        self.name = name
        self.parameterSpace = parameterSpace
        self.requiredCapabilities = requiredCapabilities
        self.startedAt = startedAt
        self.stepId = stepId
        self.targetTaskRunStatus = targetTaskRunStatus
        self.taskRunStatus = taskRunStatus
        self.taskRunStatusCounts = taskRunStatusCounts
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetStepOutputBody: Swift.Equatable {
    let stepId: Swift.String?
    let name: Swift.String?
    let lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
    let lifecycleStatusMessage: Swift.String?
    let taskRunStatus: DeadlineClientTypes.TaskRunStatus?
    let taskRunStatusCounts: [Swift.String:Swift.Int]?
    let targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let dependencyCounts: DeadlineClientTypes.DependencyCounts?
    let requiredCapabilities: DeadlineClientTypes.StepRequiredCapabilities?
    let parameterSpace: DeadlineClientTypes.ParameterSpace?
    let description: Swift.String?
}

extension GetStepOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case dependencyCounts
        case description
        case endedAt
        case lifecycleStatus
        case lifecycleStatusMessage
        case name
        case parameterSpace
        case requiredCapabilities
        case startedAt
        case stepId
        case targetTaskRunStatus
        case taskRunStatus
        case taskRunStatusCounts
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let lifecycleStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStatusMessage)
        lifecycleStatusMessage = lifecycleStatusMessageDecoded
        let taskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .taskRunStatus)
        taskRunStatus = taskRunStatusDecoded
        let taskRunStatusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .taskRunStatusCounts)
        var taskRunStatusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let taskRunStatusCountsContainer = taskRunStatusCountsContainer {
            taskRunStatusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in taskRunStatusCountsContainer {
                if let integer0 = integer0 {
                    taskRunStatusCountsDecoded0?[key0] = integer0
                }
            }
        }
        taskRunStatusCounts = taskRunStatusCountsDecoded0
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let dependencyCountsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DependencyCounts.self, forKey: .dependencyCounts)
        dependencyCounts = dependencyCountsDecoded
        let requiredCapabilitiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepRequiredCapabilities.self, forKey: .requiredCapabilities)
        requiredCapabilities = requiredCapabilitiesDecoded
        let parameterSpaceDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ParameterSpace.self, forKey: .parameterSpace)
        parameterSpace = parameterSpaceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStorageProfileForQueueInput {

    static func urlPathProvider(_ value: GetStorageProfileForQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

public struct GetStorageProfileForQueueInput: Swift.Equatable {
    /// The farm ID for the queue in storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID the queue in the storage profile.
    /// This member is required.
    public var queueId: Swift.String?
    /// The storage profile ID for the storage profile in the queue.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
        self.storageProfileId = storageProfileId
    }
}

struct GetStorageProfileForQueueInputBody: Swift.Equatable {
}

extension GetStorageProfileForQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStorageProfileForQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStorageProfileForQueueOutputBody = try responseDecoder.decode(responseBody: data)
            self.displayName = output.displayName
            self.fileSystemLocations = output.fileSystemLocations
            self.osFamily = output.osFamily
            self.storageProfileId = output.storageProfileId
        } else {
            self.displayName = nil
            self.fileSystemLocations = nil
            self.osFamily = nil
            self.storageProfileId = nil
        }
    }
}

public struct GetStorageProfileForQueueOutput: Swift.Equatable {
    /// The display name of the storage profile connected to a queue.
    /// This member is required.
    public var displayName: Swift.String?
    /// The location of the files for the storage profile within the queue.
    public var fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
    /// The operating system of the storage profile in the queue.
    /// This member is required.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.fileSystemLocations = fileSystemLocations
        self.osFamily = osFamily
        self.storageProfileId = storageProfileId
    }
}

struct GetStorageProfileForQueueOutputBody: Swift.Equatable {
    let storageProfileId: Swift.String?
    let displayName: Swift.String?
    let osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    let fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
}

extension GetStorageProfileForQueueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case fileSystemLocations
        case osFamily
        case storageProfileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StorageProfileOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[DeadlineClientTypes.FileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [DeadlineClientTypes.FileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
    }
}

enum GetStorageProfileForQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStorageProfileInput {

    static func urlPathProvider(_ value: GetStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

public struct GetStorageProfileInput: Swift.Equatable {
    /// The farm ID for the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.storageProfileId = storageProfileId
    }
}

struct GetStorageProfileInputBody: Swift.Equatable {
}

extension GetStorageProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStorageProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStorageProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.displayName = output.displayName
            self.fileSystemLocations = output.fileSystemLocations
            self.osFamily = output.osFamily
            self.storageProfileId = output.storageProfileId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.displayName = nil
            self.fileSystemLocations = nil
            self.osFamily = nil
            self.storageProfileId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetStorageProfileOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The display name of the storage profile.
    /// This member is required.
    public var displayName: Swift.String?
    /// The location of the files for the storage profile.
    public var fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
    /// The operating system (OS) for the storage profile.
    /// This member is required.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        displayName: Swift.String? = nil,
        fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.displayName = displayName
        self.fileSystemLocations = fileSystemLocations
        self.osFamily = osFamily
        self.storageProfileId = storageProfileId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetStorageProfileOutputBody: Swift.Equatable {
    let storageProfileId: Swift.String?
    let displayName: Swift.String?
    let osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
    let fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
}

extension GetStorageProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case displayName
        case fileSystemLocations
        case osFamily
        case storageProfileId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StorageProfileOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[DeadlineClientTypes.FileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [DeadlineClientTypes.FileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
    }
}

enum GetStorageProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTaskInput {

    static func urlPathProvider(_ value: GetTaskInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        guard let taskId = value.taskId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct GetTaskInput: Swift.Equatable {
    /// The farm ID of the farm connected to the task.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID of the job connected to the task.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the queue connected to the task.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID for the step connected to the task.
    /// This member is required.
    public var stepId: Swift.String?
    /// The task ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
        self.taskId = taskId
    }
}

struct GetTaskInputBody: Swift.Equatable {
}

extension GetTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTaskOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), failureRetryCount: \(Swift.String(describing: failureRetryCount)), latestSessionActionId: \(Swift.String(describing: latestSessionActionId)), runStatus: \(Swift.String(describing: runStatus)), startedAt: \(Swift.String(describing: startedAt)), targetRunStatus: \(Swift.String(describing: targetRunStatus)), taskId: \(Swift.String(describing: taskId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), parameters: \"CONTENT_REDACTED\")"}
}

extension GetTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.endedAt = output.endedAt
            self.failureRetryCount = output.failureRetryCount
            self.latestSessionActionId = output.latestSessionActionId
            self.parameters = output.parameters
            self.runStatus = output.runStatus
            self.startedAt = output.startedAt
            self.targetRunStatus = output.targetRunStatus
            self.taskId = output.taskId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.endedAt = nil
            self.failureRetryCount = nil
            self.latestSessionActionId = nil
            self.parameters = nil
            self.runStatus = nil
            self.startedAt = nil
            self.targetRunStatus = nil
            self.taskId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetTaskOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The date and time the resource ended running.
    public var endedAt: ClientRuntime.Date?
    /// The number of times that the task failed and was retried.
    public var failureRetryCount: Swift.Int?
    /// The latest session ID for the task.
    public var latestSessionActionId: Swift.String?
    /// The parameters for the task.
    public var parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]?
    /// The run status for the task.
    /// This member is required.
    public var runStatus: DeadlineClientTypes.TaskRunStatus?
    /// The date and time the resource started running.
    public var startedAt: ClientRuntime.Date?
    /// The run status with which to start the task.
    public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
    /// The task ID.
    /// This member is required.
    public var taskId: Swift.String?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        endedAt: ClientRuntime.Date? = nil,
        failureRetryCount: Swift.Int? = nil,
        latestSessionActionId: Swift.String? = nil,
        parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil,
        runStatus: DeadlineClientTypes.TaskRunStatus? = nil,
        startedAt: ClientRuntime.Date? = nil,
        targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
        taskId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.endedAt = endedAt
        self.failureRetryCount = failureRetryCount
        self.latestSessionActionId = latestSessionActionId
        self.parameters = parameters
        self.runStatus = runStatus
        self.startedAt = startedAt
        self.targetRunStatus = targetRunStatus
        self.taskId = taskId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let runStatus: DeadlineClientTypes.TaskRunStatus?
    let targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
    let failureRetryCount: Swift.Int?
    let parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
    let latestSessionActionId: Swift.String?
}

extension GetTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case endedAt
        case failureRetryCount
        case latestSessionActionId
        case parameters
        case runStatus
        case startedAt
        case targetRunStatus
        case taskId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let runStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .runStatus)
        runStatus = runStatusDecoded
        let targetRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskTargetRunStatus.self, forKey: .targetRunStatus)
        targetRunStatus = targetRunStatusDecoded
        let failureRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureRetryCount)
        failureRetryCount = failureRetryCountDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.TaskParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.TaskParameterValue]()
            for (key0, taskparametervalue0) in parametersContainer {
                if let taskparametervalue0 = taskparametervalue0 {
                    parametersDecoded0?[key0] = taskparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let latestSessionActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestSessionActionId)
        latestSessionActionId = latestSessionActionIdDecoded
    }
}

enum GetTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkerInput {

    static func urlPathProvider(_ value: GetWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())"
    }
}

public struct GetWorkerInput: Swift.Equatable {
    /// The farm ID for the worker.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The worker ID.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.workerId = workerId
    }
}

struct GetWorkerInputBody: Swift.Equatable {
}

extension GetWorkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.farmId = output.farmId
            self.fleetId = output.fleetId
            self.hostProperties = output.hostProperties
            self.log = output.log
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
            self.workerId = output.workerId
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.farmId = nil
            self.fleetId = nil
            self.hostProperties = nil
            self.log = nil
            self.status = nil
            self.updatedAt = nil
            self.updatedBy = nil
            self.workerId = nil
        }
    }
}

public struct GetWorkerOutput: Swift.Equatable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The farm ID.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The host properties for the worker.
    public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
    /// The logs for the associated worker.
    public var log: DeadlineClientTypes.LogConfiguration?
    /// The status of the worker.
    /// This member is required.
    public var status: DeadlineClientTypes.WorkerStatus?
    /// The date and time the resource was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The worker ID.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
        log: DeadlineClientTypes.LogConfiguration? = nil,
        status: DeadlineClientTypes.WorkerStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.farmId = farmId
        self.fleetId = fleetId
        self.hostProperties = hostProperties
        self.log = log
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.workerId = workerId
    }
}

struct GetWorkerOutputBody: Swift.Equatable {
    let workerId: Swift.String?
    let farmId: Swift.String?
    let fleetId: Swift.String?
    let hostProperties: DeadlineClientTypes.HostPropertiesResponse?
    let status: DeadlineClientTypes.WorkerStatus?
    let log: DeadlineClientTypes.LogConfiguration?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case farmId
        case fleetId
        case hostProperties
        case log
        case status
        case updatedAt
        case updatedBy
        case workerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.HostPropertiesResponse.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.WorkerStatus.self, forKey: .status)
        status = statusDecoded
        let logDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogConfiguration.self, forKey: .log)
        log = logDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.HostPropertiesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostName
        case ipAddresses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let ipAddresses = self.ipAddresses {
            try encodeContainer.encode(ipAddresses, forKey: .ipAddresses)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.IpAddresses.self, forKey: .ipAddresses)
        ipAddresses = ipAddressesDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
    }
}

extension DeadlineClientTypes {
    /// The host property details.
    public struct HostPropertiesRequest: Swift.Equatable {
        /// The host name.
        public var hostName: Swift.String?
        /// The IP address of the host.
        public var ipAddresses: DeadlineClientTypes.IpAddresses?

        public init(
            hostName: Swift.String? = nil,
            ipAddresses: DeadlineClientTypes.IpAddresses? = nil
        )
        {
            self.hostName = hostName
            self.ipAddresses = ipAddresses
        }
    }

}

extension DeadlineClientTypes.HostPropertiesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceArn
        case ec2InstanceType
        case hostName
        case ipAddresses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceArn = self.ec2InstanceArn {
            try encodeContainer.encode(ec2InstanceArn, forKey: .ec2InstanceArn)
        }
        if let ec2InstanceType = self.ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType, forKey: .ec2InstanceType)
        }
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let ipAddresses = self.ipAddresses {
            try encodeContainer.encode(ipAddresses, forKey: .ipAddresses)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.IpAddresses.self, forKey: .ipAddresses)
        ipAddresses = ipAddressesDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let ec2InstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceArn)
        ec2InstanceArn = ec2InstanceArnDecoded
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
    }
}

extension DeadlineClientTypes {
    /// The host property details.
    public struct HostPropertiesResponse: Swift.Equatable {
        /// The ARN of the host EC2 instance.
        public var ec2InstanceArn: Swift.String?
        /// The instance type of the host EC2 instance.
        public var ec2InstanceType: Swift.String?
        /// The host name.
        public var hostName: Swift.String?
        /// The IP address of the host.
        public var ipAddresses: DeadlineClientTypes.IpAddresses?

        public init(
            ec2InstanceArn: Swift.String? = nil,
            ec2InstanceType: Swift.String? = nil,
            hostName: Swift.String? = nil,
            ipAddresses: DeadlineClientTypes.IpAddresses? = nil
        )
        {
            self.ec2InstanceArn = ec2InstanceArn
            self.ec2InstanceType = ec2InstanceType
            self.hostName = hostName
            self.ipAddresses = ipAddresses
        }
    }

}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Deadline Cloud can't process your request right now. Try again later.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeadlineClientTypes.IpAddresses: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipV4Addresses
        case ipV6Addresses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipV4Addresses = ipV4Addresses {
            var ipV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV4Addresses)
            for ipv4address0 in ipV4Addresses {
                try ipV4AddressesContainer.encode(ipv4address0)
            }
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for ipv6address0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(ipv6address0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipV4AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV4Addresses)
        var ipV4AddressesDecoded0:[Swift.String]? = nil
        if let ipV4AddressesContainer = ipV4AddressesContainer {
            ipV4AddressesDecoded0 = [Swift.String]()
            for string0 in ipV4AddressesContainer {
                if let string0 = string0 {
                    ipV4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV4Addresses = ipV4AddressesDecoded0
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[Swift.String]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [Swift.String]()
            for string0 in ipV6AddressesContainer {
                if let string0 = string0 {
                    ipV6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
    }
}

extension DeadlineClientTypes {
    /// The IP addresses for a host.
    public struct IpAddresses: Swift.Equatable {
        /// The IpV4 address of the network.
        public var ipV4Addresses: [Swift.String]?
        /// The IpV6 address for the network and node component.
        public var ipV6Addresses: [Swift.String]?

        public init(
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil
        )
        {
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
        }
    }

}

extension DeadlineClientTypes.JobAttachmentDetailsEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = self.attachments {
            try encodeContainer.encode(attachments, forKey: .attachments)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let attachmentsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Attachments.self, forKey: .attachments)
        attachments = attachmentsDecoded
    }
}

extension DeadlineClientTypes {
    /// The job attachments.
    public struct JobAttachmentDetailsEntity: Swift.Equatable {
        /// The job attachments.
        /// This member is required.
        public var attachments: DeadlineClientTypes.Attachments?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            attachments: DeadlineClientTypes.Attachments? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.attachments = attachments
            self.jobId = jobId
        }
    }

}

extension DeadlineClientTypes.JobAttachmentDetailsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case jobId
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobEntityErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeadlineClientTypes {
    /// The error details for job attachments.
    public struct JobAttachmentDetailsError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.jobId = jobId
            self.message = message
        }
    }

}

extension DeadlineClientTypes.JobAttachmentDetailsIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeadlineClientTypes {
    /// Identifier details for job attachments.
    public struct JobAttachmentDetailsIdentifiers: Swift.Equatable {
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            jobId: Swift.String? = nil
        )
        {
            self.jobId = jobId
        }
    }

}

extension DeadlineClientTypes.JobAttachmentSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rootPrefix
        case s3BucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rootPrefix = self.rootPrefix {
            try encodeContainer.encode(rootPrefix, forKey: .rootPrefix)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let rootPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootPrefix)
        rootPrefix = rootPrefixDecoded
    }
}

extension DeadlineClientTypes {
    /// The job attachment settings. These are the Amazon S3 bucket name and the Amazon S3 prefix.
    public struct JobAttachmentSettings: Swift.Equatable {
        /// The root prefix.
        /// This member is required.
        public var rootPrefix: Swift.String?
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var s3BucketName: Swift.String?

        public init(
            rootPrefix: Swift.String? = nil,
            s3BucketName: Swift.String? = nil
        )
        {
            self.rootPrefix = rootPrefix
            self.s3BucketName = s3BucketName
        }
    }

}

extension DeadlineClientTypes {
    public enum JobAttachmentsFileSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copied
        case virtual
        case sdkUnknown(Swift.String)

        public static var allCases: [JobAttachmentsFileSystem] {
            return [
                .copied,
                .virtual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copied: return "COPIED"
            case .virtual: return "VIRTUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobAttachmentsFileSystem(rawValue: rawValue) ?? JobAttachmentsFileSystem.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.JobDetailsEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobAttachmentSettings
        case jobId
        case jobRunAsUser
        case logGroupName
        case parameters
        case pathMappingRules
        case queueRoleArn
        case schemaVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobAttachmentSettings = self.jobAttachmentSettings {
            try encodeContainer.encode(jobAttachmentSettings, forKey: .jobAttachmentSettings)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobRunAsUser = self.jobRunAsUser {
            try encodeContainer.encode(jobRunAsUser, forKey: .jobRunAsUser)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, jobParameters0) in parameters {
                try parametersContainer.encode(jobParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let pathMappingRules = pathMappingRules {
            var pathMappingRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathMappingRules)
            for pathmappingrule0 in pathMappingRules {
                try pathMappingRulesContainer.encode(pathmappingrule0)
            }
        }
        if let queueRoleArn = self.queueRoleArn {
            try encodeContainer.encode(queueRoleArn, forKey: .queueRoleArn)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobAttachmentSettingsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobAttachmentSettings.self, forKey: .jobAttachmentSettings)
        jobAttachmentSettings = jobAttachmentSettingsDecoded
        let jobRunAsUserDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobRunAsUser.self, forKey: .jobRunAsUser)
        jobRunAsUser = jobRunAsUserDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let queueRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueRoleArn)
        queueRoleArn = queueRoleArnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.JobParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.JobParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.JobParameter]()
            for (key0, jobparameter0) in parametersContainer {
                if let jobparameter0 = jobparameter0 {
                    parametersDecoded0?[key0] = jobparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let pathMappingRulesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.PathMappingRule?].self, forKey: .pathMappingRules)
        var pathMappingRulesDecoded0:[DeadlineClientTypes.PathMappingRule]? = nil
        if let pathMappingRulesContainer = pathMappingRulesContainer {
            pathMappingRulesDecoded0 = [DeadlineClientTypes.PathMappingRule]()
            for structure0 in pathMappingRulesContainer {
                if let structure0 = structure0 {
                    pathMappingRulesDecoded0?.append(structure0)
                }
            }
        }
        pathMappingRules = pathMappingRulesDecoded0
    }
}

extension DeadlineClientTypes.JobDetailsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobDetailsEntity(jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobId: \(Swift.String(describing: jobId)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), logGroupName: \(Swift.String(describing: logGroupName)), pathMappingRules: \(Swift.String(describing: pathMappingRules)), queueRoleArn: \(Swift.String(describing: queueRoleArn)), schemaVersion: \(Swift.String(describing: schemaVersion)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The job details for a specific job.
    public struct JobDetailsEntity: Swift.Equatable {
        /// The job attachment settings.
        public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user name and group that the job uses when run.
        public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The parameters.
        public var parameters: [Swift.String:DeadlineClientTypes.JobParameter]?
        /// The path mapping rules.
        public var pathMappingRules: [DeadlineClientTypes.PathMappingRule]?
        /// The queue role ARN.
        public var queueRoleArn: Swift.String?
        /// The schema version.
        /// This member is required.
        public var schemaVersion: Swift.String?

        public init(
            jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
            jobId: Swift.String? = nil,
            jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
            logGroupName: Swift.String? = nil,
            parameters: [Swift.String:DeadlineClientTypes.JobParameter]? = nil,
            pathMappingRules: [DeadlineClientTypes.PathMappingRule]? = nil,
            queueRoleArn: Swift.String? = nil,
            schemaVersion: Swift.String? = nil
        )
        {
            self.jobAttachmentSettings = jobAttachmentSettings
            self.jobId = jobId
            self.jobRunAsUser = jobRunAsUser
            self.logGroupName = logGroupName
            self.parameters = parameters
            self.pathMappingRules = pathMappingRules
            self.queueRoleArn = queueRoleArn
            self.schemaVersion = schemaVersion
        }
    }

}

extension DeadlineClientTypes.JobDetailsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case jobId
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobEntityErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a job error.
    public struct JobDetailsError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.jobId = jobId
            self.message = message
        }
    }

}

extension DeadlineClientTypes.JobDetailsIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The identifiers for a job.
    public struct JobDetailsIdentifiers: Swift.Equatable {
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            jobId: Swift.String? = nil
        )
        {
            self.jobId = jobId
        }
    }

}

extension DeadlineClientTypes.JobEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentdetails = "environmentDetails"
        case jobattachmentdetails = "jobAttachmentDetails"
        case jobdetails = "jobDetails"
        case sdkUnknown
        case stepdetails = "stepDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .environmentdetails(environmentdetails):
                try container.encode(environmentdetails, forKey: .environmentdetails)
            case let .jobattachmentdetails(jobattachmentdetails):
                try container.encode(jobattachmentdetails, forKey: .jobattachmentdetails)
            case let .jobdetails(jobdetails):
                try container.encode(jobdetails, forKey: .jobdetails)
            case let .stepdetails(stepdetails):
                try container.encode(stepdetails, forKey: .stepdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let jobdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.JobDetailsEntity.self, forKey: .jobdetails)
        if let jobdetails = jobdetailsDecoded {
            self = .jobdetails(jobdetails)
            return
        }
        let jobattachmentdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.JobAttachmentDetailsEntity.self, forKey: .jobattachmentdetails)
        if let jobattachmentdetails = jobattachmentdetailsDecoded {
            self = .jobattachmentdetails(jobattachmentdetails)
            return
        }
        let stepdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.StepDetailsEntity.self, forKey: .stepdetails)
        if let stepdetails = stepdetailsDecoded {
            self = .stepdetails(stepdetails)
            return
        }
        let environmentdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentDetailsEntity.self, forKey: .environmentdetails)
        if let environmentdetails = environmentdetailsDecoded {
            self = .environmentdetails(environmentdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The details of a job entity.
    public enum JobEntity: Swift.Equatable {
        /// The job details.
        case jobdetails(DeadlineClientTypes.JobDetailsEntity)
        /// The job attachment details.
        case jobattachmentdetails(DeadlineClientTypes.JobAttachmentDetailsEntity)
        /// The step details.
        case stepdetails(DeadlineClientTypes.StepDetailsEntity)
        /// The environment details for the job entity.
        case environmentdetails(DeadlineClientTypes.EnvironmentDetailsEntity)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes {
    public enum JobEntityErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case conflictexception
        case internalserverexception
        case maxpayloadsizeexceeded
        case resourcenotfoundexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEntityErrorCode] {
            return [
                .accessdeniedexception,
                .conflictexception,
                .internalserverexception,
                .maxpayloadsizeexceeded,
                .resourcenotfoundexception,
                .validationexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .conflictexception: return "ConflictException"
            case .internalserverexception: return "InternalServerException"
            case .maxpayloadsizeexceeded: return "MaxPayloadSizeExceeded"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobEntityErrorCode(rawValue: rawValue) ?? JobEntityErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.JobEntityIdentifiersUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentdetails = "environmentDetails"
        case jobattachmentdetails = "jobAttachmentDetails"
        case jobdetails = "jobDetails"
        case sdkUnknown
        case stepdetails = "stepDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .environmentdetails(environmentdetails):
                try container.encode(environmentdetails, forKey: .environmentdetails)
            case let .jobattachmentdetails(jobattachmentdetails):
                try container.encode(jobattachmentdetails, forKey: .jobattachmentdetails)
            case let .jobdetails(jobdetails):
                try container.encode(jobdetails, forKey: .jobdetails)
            case let .stepdetails(stepdetails):
                try container.encode(stepdetails, forKey: .stepdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let jobdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.JobDetailsIdentifiers.self, forKey: .jobdetails)
        if let jobdetails = jobdetailsDecoded {
            self = .jobdetails(jobdetails)
            return
        }
        let jobattachmentdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.JobAttachmentDetailsIdentifiers.self, forKey: .jobattachmentdetails)
        if let jobattachmentdetails = jobattachmentdetailsDecoded {
            self = .jobattachmentdetails(jobattachmentdetails)
            return
        }
        let stepdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.StepDetailsIdentifiers.self, forKey: .stepdetails)
        if let stepdetails = stepdetailsDecoded {
            self = .stepdetails(stepdetails)
            return
        }
        let environmentdetailsDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentDetailsIdentifiers.self, forKey: .environmentdetails)
        if let environmentdetails = environmentdetailsDecoded {
            self = .environmentdetails(environmentdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The details of a job entity identifier.
    public enum JobEntityIdentifiersUnion: Swift.Equatable {
        /// The job details.
        case jobdetails(DeadlineClientTypes.JobDetailsIdentifiers)
        /// The job attachment details.
        case jobattachmentdetails(DeadlineClientTypes.JobAttachmentDetailsIdentifiers)
        /// The step details.
        case stepdetails(DeadlineClientTypes.StepDetailsIdentifiers)
        /// The environment details.
        case environmentdetails(DeadlineClientTypes.EnvironmentDetailsIdentifiers)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes {
    public enum JobLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case createComplete
        case createFailed
        case createInProgress
        case updateFailed
        case updateInProgress
        case updateSucceeded
        case uploadFailed
        case uploadInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLifecycleStatus] {
            return [
                .archived,
                .createComplete,
                .createFailed,
                .createInProgress,
                .updateFailed,
                .updateInProgress,
                .updateSucceeded,
                .uploadFailed,
                .uploadInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSucceeded: return "UPDATE_SUCCEEDED"
            case .uploadFailed: return "UPLOAD_FAILED"
            case .uploadInProgress: return "UPLOAD_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobLifecycleStatus(rawValue: rawValue) ?? JobLifecycleStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.JobMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case farmId
        case identityStoreId
        case jobId
        case membershipLevel
        case principalId
        case principalType
        case queueId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension DeadlineClientTypes {
    /// The details for a job member.
    public struct JobMember: Swift.Equatable {
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The identity store ID.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The job member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the job member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the job member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            farmId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.jobId = jobId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }
    }

}

extension DeadlineClientTypes.JobParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case float
        case int
        case path
        case sdkUnknown
        case string
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .float(float):
                try container.encode(float, forKey: .float)
            case let .int(int):
                try container.encode(int, forKey: .int)
            case let .path(path):
                try container.encode(path, forKey: .path)
            case let .string(string):
                try container.encode(string, forKey: .string)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let intDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .int)
        if let int = intDecoded {
            self = .int(int)
            return
        }
        let floatDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .float)
        if let float = floatDecoded {
            self = .float(float)
            return
        }
        let stringDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .string)
        if let string = stringDecoded {
            self = .string(string)
            return
        }
        let pathDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .path)
        if let path = pathDecoded {
            self = .path(path)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The details of job parameters.
    public enum JobParameter: Swift.Equatable {
        /// A signed integer represented as a string.
        case int(Swift.String)
        /// A double precision IEEE-754 floating point number represented as a string.
        case float(Swift.String)
        /// A UTF-8 string.
        case string(Swift.String)
        /// A file system path represented as a string.
        case path(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes.JobRunAsUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case posix
        case runAs
        case windows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let posix = self.posix {
            try encodeContainer.encode(posix, forKey: .posix)
        }
        if let runAs = self.runAs {
            try encodeContainer.encode(runAs.rawValue, forKey: .runAs)
        }
        if let windows = self.windows {
            try encodeContainer.encode(windows, forKey: .windows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let posixDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.PosixUser.self, forKey: .posix)
        posix = posixDecoded
        let windowsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.WindowsUser.self, forKey: .windows)
        windows = windowsDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.RunAs.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension DeadlineClientTypes {
    /// Identifies the user for a job.
    public struct JobRunAsUser: Swift.Equatable {
        /// The user and group that the jobs in the queue run as.
        public var posix: DeadlineClientTypes.PosixUser?
        /// Specifies whether the job should run using the queue's system user or if the job should run using the worker agent system user.
        /// This member is required.
        public var runAs: DeadlineClientTypes.RunAs?
        /// Identifies a Microsoft Windows user.
        public var windows: DeadlineClientTypes.WindowsUser?

        public init(
            posix: DeadlineClientTypes.PosixUser? = nil,
            runAs: DeadlineClientTypes.RunAs? = nil,
            windows: DeadlineClientTypes.WindowsUser? = nil
        )
        {
            self.posix = posix
            self.runAs = runAs
            self.windows = windows
        }
    }

}

extension DeadlineClientTypes.JobSearchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case endedAt
        case jobId
        case jobParameters
        case lifecycleStatus
        case lifecycleStatusMessage
        case maxFailedTasksCount
        case maxRetriesPerTask
        case name
        case priority
        case queueId
        case startedAt
        case targetTaskRunStatus
        case taskRunStatus
        case taskRunStatusCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobParameters = jobParameters {
            var jobParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .jobParameters)
            for (dictKey0, jobParameters0) in jobParameters {
                try jobParametersContainer.encode(jobParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let lifecycleStatusMessage = self.lifecycleStatusMessage {
            try encodeContainer.encode(lifecycleStatusMessage, forKey: .lifecycleStatusMessage)
        }
        if let maxFailedTasksCount = self.maxFailedTasksCount {
            try encodeContainer.encode(maxFailedTasksCount, forKey: .maxFailedTasksCount)
        }
        if let maxRetriesPerTask = self.maxRetriesPerTask {
            try encodeContainer.encode(maxRetriesPerTask, forKey: .maxRetriesPerTask)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
        if let taskRunStatus = self.taskRunStatus {
            try encodeContainer.encode(taskRunStatus.rawValue, forKey: .taskRunStatus)
        }
        if let taskRunStatusCounts = taskRunStatusCounts {
            var taskRunStatusCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskRunStatusCounts)
            for (dictKey0, taskRunStatusCounts0) in taskRunStatusCounts {
                try taskRunStatusCountsContainer.encode(taskRunStatusCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let lifecycleStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStatusMessage)
        lifecycleStatusMessage = lifecycleStatusMessageDecoded
        let taskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .taskRunStatus)
        taskRunStatus = taskRunStatusDecoded
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let taskRunStatusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .taskRunStatusCounts)
        var taskRunStatusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let taskRunStatusCountsContainer = taskRunStatusCountsContainer {
            taskRunStatusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in taskRunStatusCountsContainer {
                if let integer0 = integer0 {
                    taskRunStatusCountsDecoded0?[key0] = integer0
                }
            }
        }
        taskRunStatusCounts = taskRunStatusCountsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxFailedTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFailedTasksCount)
        maxFailedTasksCount = maxFailedTasksCountDecoded
        let maxRetriesPerTaskDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetriesPerTask)
        maxRetriesPerTask = maxRetriesPerTaskDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let jobParametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.JobParameter?].self, forKey: .jobParameters)
        var jobParametersDecoded0: [Swift.String:DeadlineClientTypes.JobParameter]? = nil
        if let jobParametersContainer = jobParametersContainer {
            jobParametersDecoded0 = [Swift.String:DeadlineClientTypes.JobParameter]()
            for (key0, jobparameter0) in jobParametersContainer {
                if let jobparameter0 = jobparameter0 {
                    jobParametersDecoded0?[key0] = jobparameter0
                }
            }
        }
        jobParameters = jobParametersDecoded0
    }
}

extension DeadlineClientTypes.JobSearchSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobSearchSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), jobId: \(Swift.String(describing: jobId)), lifecycleStatus: \(Swift.String(describing: lifecycleStatus)), lifecycleStatusMessage: \(Swift.String(describing: lifecycleStatusMessage)), maxFailedTasksCount: \(Swift.String(describing: maxFailedTasksCount)), maxRetriesPerTask: \(Swift.String(describing: maxRetriesPerTask)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), queueId: \(Swift.String(describing: queueId)), startedAt: \(Swift.String(describing: startedAt)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), taskRunStatus: \(Swift.String(describing: taskRunStatus)), taskRunStatusCounts: \(Swift.String(describing: taskRunStatusCounts)), jobParameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The details of a job search.
    public struct JobSearchSummary: Swift.Equatable {
        /// The date and time the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        public var createdBy: Swift.String?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The job ID.
        public var jobId: Swift.String?
        /// The job parameters.
        public var jobParameters: [Swift.String:DeadlineClientTypes.JobParameter]?
        /// The life cycle status.
        public var lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
        /// The life cycle status message.
        public var lifecycleStatusMessage: Swift.String?
        /// The number of task failures before the job stops running and is marked as FAILED.
        public var maxFailedTasksCount: Swift.Int?
        /// The maximum number of retries for a job.
        public var maxRetriesPerTask: Swift.Int?
        /// The job name.
        public var name: Swift.String?
        /// The job priority.
        public var priority: Swift.Int?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
        /// task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to be processed.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to be run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        public var taskRunStatusCounts: [Swift.String:Swift.Int]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobParameters: [Swift.String:DeadlineClientTypes.JobParameter]? = nil,
            lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            maxFailedTasksCount: Swift.Int? = nil,
            maxRetriesPerTask: Swift.Int? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queueId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobParameters = jobParameters
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.name = name
            self.priority = priority
            self.queueId = queueId
            self.startedAt = startedAt
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
        }
    }

}

extension DeadlineClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case endedAt
        case jobId
        case lifecycleStatus
        case lifecycleStatusMessage
        case maxFailedTasksCount
        case maxRetriesPerTask
        case name
        case priority
        case startedAt
        case targetTaskRunStatus
        case taskRunStatus
        case taskRunStatusCounts
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let lifecycleStatusMessage = self.lifecycleStatusMessage {
            try encodeContainer.encode(lifecycleStatusMessage, forKey: .lifecycleStatusMessage)
        }
        if let maxFailedTasksCount = self.maxFailedTasksCount {
            try encodeContainer.encode(maxFailedTasksCount, forKey: .maxFailedTasksCount)
        }
        if let maxRetriesPerTask = self.maxRetriesPerTask {
            try encodeContainer.encode(maxRetriesPerTask, forKey: .maxRetriesPerTask)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
        if let taskRunStatus = self.taskRunStatus {
            try encodeContainer.encode(taskRunStatus.rawValue, forKey: .taskRunStatus)
        }
        if let taskRunStatusCounts = taskRunStatusCounts {
            var taskRunStatusCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskRunStatusCounts)
            for (dictKey0, taskRunStatusCounts0) in taskRunStatusCounts {
                try taskRunStatusCountsContainer.encode(taskRunStatusCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let lifecycleStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStatusMessage)
        lifecycleStatusMessage = lifecycleStatusMessageDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let taskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .taskRunStatus)
        taskRunStatus = taskRunStatusDecoded
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let taskRunStatusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .taskRunStatusCounts)
        var taskRunStatusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let taskRunStatusCountsContainer = taskRunStatusCountsContainer {
            taskRunStatusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in taskRunStatusCountsContainer {
                if let integer0 = integer0 {
                    taskRunStatusCountsDecoded0?[key0] = integer0
                }
            }
        }
        taskRunStatusCounts = taskRunStatusCountsDecoded0
        let maxFailedTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFailedTasksCount)
        maxFailedTasksCount = maxFailedTasksCountDecoded
        let maxRetriesPerTaskDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetriesPerTask)
        maxRetriesPerTask = maxRetriesPerTaskDecoded
    }
}

extension DeadlineClientTypes {
    /// A summary of job details.
    public struct JobSummary: Swift.Equatable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The life cycle status.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
        /// The life cycle status message.
        /// This member is required.
        public var lifecycleStatusMessage: Swift.String?
        /// The number of task failures before the job stops running and is marked as FAILED.
        public var maxFailedTasksCount: Swift.Int?
        /// The maximum number of retries for a job.
        public var maxRetriesPerTask: Swift.Int?
        /// The job name.
        /// This member is required.
        public var name: Swift.String?
        /// The job priority.
        /// This member is required.
        public var priority: Swift.Int?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to be processed.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to be run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        public var taskRunStatusCounts: [Swift.String:Swift.Int]?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            maxFailedTasksCount: Swift.Int? = nil,
            maxRetriesPerTask: Swift.Int? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            startedAt: ClientRuntime.Date? = nil,
            targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.name = name
            self.priority = priority
            self.startedAt = startedAt
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DeadlineClientTypes {
    public enum JobTargetTaskRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case pending
        case ready
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [JobTargetTaskRunStatus] {
            return [
                .canceled,
                .failed,
                .pending,
                .ready,
                .succeeded,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobTargetTaskRunStatus(rawValue: rawValue) ?? JobTargetTaskRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum JobTemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [JobTemplateType] {
            return [
                .json,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobTemplateType(rawValue: rawValue) ?? JobTemplateType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum LicenseEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createInProgress
        case deleteInProgress
        case notReady
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseEndpointStatus] {
            return [
                .createInProgress,
                .deleteInProgress,
                .notReady,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseEndpointStatus(rawValue: rawValue) ?? LicenseEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.LicenseEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseEndpointId
        case status
        case statusMessage
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseEndpointId = self.licenseEndpointId {
            try encodeContainer.encode(licenseEndpointId, forKey: .licenseEndpointId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseEndpointId)
        licenseEndpointId = licenseEndpointIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LicenseEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The details for a license endpoint.
    public struct LicenseEndpointSummary: Swift.Equatable {
        /// The license endpoint ID.
        public var licenseEndpointId: Swift.String?
        /// The status of the license endpoint.
        public var status: DeadlineClientTypes.LicenseEndpointStatus?
        /// The status message of the license endpoint.
        public var statusMessage: Swift.String?
        /// The VCP(virtual private cloud) ID associated with the license endpoint.
        public var vpcId: Swift.String?

        public init(
            licenseEndpointId: Swift.String? = nil,
            status: DeadlineClientTypes.LicenseEndpointStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.licenseEndpointId = licenseEndpointId
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }

}

extension ListAvailableMeteredProductsInput {

    static func queryItemProvider(_ value: ListAvailableMeteredProductsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAvailableMeteredProductsInput {

    static func urlPathProvider(_ value: ListAvailableMeteredProductsInput) -> Swift.String? {
        return "/2023-10-12/metered-products"
    }
}

public struct ListAvailableMeteredProductsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAvailableMeteredProductsInputBody: Swift.Equatable {
}

extension ListAvailableMeteredProductsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAvailableMeteredProductsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableMeteredProductsOutputBody = try responseDecoder.decode(responseBody: data)
            self.meteredProducts = output.meteredProducts
            self.nextToken = output.nextToken
        } else {
            self.meteredProducts = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableMeteredProductsOutput: Swift.Equatable {
    /// The metered products.
    /// This member is required.
    public var meteredProducts: [DeadlineClientTypes.MeteredProductSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        meteredProducts: [DeadlineClientTypes.MeteredProductSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meteredProducts = meteredProducts
        self.nextToken = nextToken
    }
}

struct ListAvailableMeteredProductsOutputBody: Swift.Equatable {
    let meteredProducts: [DeadlineClientTypes.MeteredProductSummary]?
    let nextToken: Swift.String?
}

extension ListAvailableMeteredProductsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteredProducts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteredProductsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.MeteredProductSummary?].self, forKey: .meteredProducts)
        var meteredProductsDecoded0:[DeadlineClientTypes.MeteredProductSummary]? = nil
        if let meteredProductsContainer = meteredProductsContainer {
            meteredProductsDecoded0 = [DeadlineClientTypes.MeteredProductSummary]()
            for structure0 in meteredProductsContainer {
                if let structure0 = structure0 {
                    meteredProductsDecoded0?.append(structure0)
                }
            }
        }
        meteredProducts = meteredProductsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAvailableMeteredProductsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBudgetsInput {

    static func queryItemProvider(_ value: ListBudgetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListBudgetsInput {

    static func urlPathProvider(_ value: ListBudgetsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets"
    }
}

public struct ListBudgetsInput: Swift.Equatable {
    /// The farm ID associated with the budgets.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The status to list for the budgets.
    public var status: DeadlineClientTypes.BudgetStatus?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DeadlineClientTypes.BudgetStatus? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListBudgetsInputBody: Swift.Equatable {
}

extension ListBudgetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBudgetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBudgetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.nextToken = output.nextToken
        } else {
            self.budgets = nil
            self.nextToken = nil
        }
    }
}

public struct ListBudgetsOutput: Swift.Equatable {
    /// The budgets to include on the list.
    /// This member is required.
    public var budgets: [DeadlineClientTypes.BudgetSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        budgets: [DeadlineClientTypes.BudgetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

struct ListBudgetsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let budgets: [DeadlineClientTypes.BudgetSummary]?
}

extension ListBudgetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let budgetsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.BudgetSummary?].self, forKey: .budgets)
        var budgetsDecoded0:[DeadlineClientTypes.BudgetSummary]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [DeadlineClientTypes.BudgetSummary]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

enum ListBudgetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFarmMembersInput {

    static func queryItemProvider(_ value: ListFarmMembersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFarmMembersInput {

    static func urlPathProvider(_ value: ListFarmMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/members"
    }
}

public struct ListFarmMembersInput: Swift.Equatable {
    /// The farm ID.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFarmMembersInputBody: Swift.Equatable {
}

extension ListFarmMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFarmMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFarmMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListFarmMembersOutput: Swift.Equatable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.FarmMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.FarmMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListFarmMembersOutputBody: Swift.Equatable {
    let members: [DeadlineClientTypes.FarmMember]?
    let nextToken: Swift.String?
}

extension ListFarmMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FarmMember?].self, forKey: .members)
        var membersDecoded0:[DeadlineClientTypes.FarmMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DeadlineClientTypes.FarmMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFarmMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFarmsInput {

    static func queryItemProvider(_ value: ListFarmsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        return items
    }
}

extension ListFarmsInput {

    static func urlPathProvider(_ value: ListFarmsInput) -> Swift.String? {
        return "/2023-10-12/farms"
    }
}

public struct ListFarmsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID of the member to list on the farm.
    public var principalId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
    }
}

struct ListFarmsInputBody: Swift.Equatable {
}

extension ListFarmsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFarmsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFarmsOutputBody = try responseDecoder.decode(responseBody: data)
            self.farms = output.farms
            self.nextToken = output.nextToken
        } else {
            self.farms = nil
            self.nextToken = nil
        }
    }
}

public struct ListFarmsOutput: Swift.Equatable {
    /// Farms on the list.
    /// This member is required.
    public var farms: [DeadlineClientTypes.FarmSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        farms: [DeadlineClientTypes.FarmSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.farms = farms
        self.nextToken = nextToken
    }
}

struct ListFarmsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let farms: [DeadlineClientTypes.FarmSummary]?
}

extension ListFarmsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case farms
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let farmsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FarmSummary?].self, forKey: .farms)
        var farmsDecoded0:[DeadlineClientTypes.FarmSummary]? = nil
        if let farmsContainer = farmsContainer {
            farmsDecoded0 = [DeadlineClientTypes.FarmSummary]()
            for structure0 in farmsContainer {
                if let structure0 = structure0 {
                    farmsDecoded0?.append(structure0)
                }
            }
        }
        farms = farmsDecoded0
    }
}

enum ListFarmsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetMembersInput {

    static func queryItemProvider(_ value: ListFleetMembersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFleetMembersInput {

    static func urlPathProvider(_ value: ListFleetMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/members"
    }
}

public struct ListFleetMembersInput: Swift.Equatable {
    /// The farm ID of the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to include on the list.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetMembersInputBody: Swift.Equatable {
}

extension ListFleetMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetMembersOutput: Swift.Equatable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.FleetMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.FleetMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListFleetMembersOutputBody: Swift.Equatable {
    let members: [DeadlineClientTypes.FleetMember]?
    let nextToken: Swift.String?
}

extension ListFleetMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetMember?].self, forKey: .members)
        var membersDecoded0:[DeadlineClientTypes.FleetMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DeadlineClientTypes.FleetMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetsInput {

    static func queryItemProvider(_ value: ListFleetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let displayName = value.displayName {
            let displayNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "displayName".urlPercentEncoding(), value: Swift.String(displayName).urlPercentEncoding())
            items.append(displayNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListFleetsInput {

    static func urlPathProvider(_ value: ListFleetsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets"
    }
}

public struct ListFleetsInput: Swift.Equatable {
    /// The display names of a list of fleets.
    public var displayName: Swift.String?
    /// The farm ID of the fleets.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID of the members to include in the fleet.
    public var principalId: Swift.String?
    /// The status of the fleet.
    public var status: DeadlineClientTypes.FleetStatus?

    public init(
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        status: DeadlineClientTypes.FleetStatus? = nil
    )
    {
        self.displayName = displayName
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.status = status
    }
}

struct ListFleetsInputBody: Swift.Equatable {
}

extension ListFleetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutput: Swift.Equatable {
    /// The fleets on the list.
    /// This member is required.
    public var fleets: [DeadlineClientTypes.FleetSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        fleets: [DeadlineClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputBody: Swift.Equatable {
    let fleets: [DeadlineClientTypes.FleetSummary]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetSummary?].self, forKey: .fleets)
        var fleetsDecoded0:[DeadlineClientTypes.FleetSummary]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [DeadlineClientTypes.FleetSummary]()
            for structure0 in fleetsContainer {
                if let structure0 = structure0 {
                    fleetsDecoded0?.append(structure0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobMembersInput {

    static func queryItemProvider(_ value: ListJobMembersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJobMembersInput {

    static func urlPathProvider(_ value: ListJobMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/members"
    }
}

public struct ListJobMembersInput: Swift.Equatable {
    /// The farm ID of the job to list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to include on the list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListJobMembersInputBody: Swift.Equatable {
}

extension ListJobMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobMembersOutput: Swift.Equatable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.JobMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.JobMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListJobMembersOutputBody: Swift.Equatable {
    let members: [DeadlineClientTypes.JobMember]?
    let nextToken: Swift.String?
}

extension ListJobMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.JobMember?].self, forKey: .members)
        var membersDecoded0:[DeadlineClientTypes.JobMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DeadlineClientTypes.JobMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobsInput {

    static func queryItemProvider(_ value: ListJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        return items
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The farm ID for the jobs.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID of the members on the jobs.
    public var principalId: Swift.String?
    /// The queue ID for the job.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.queueId = queueId
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// The jobs on the list.
    /// This member is required.
    public var jobs: [DeadlineClientTypes.JobSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        jobs: [DeadlineClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let jobs: [DeadlineClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[DeadlineClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DeadlineClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicenseEndpointsInput {

    static func queryItemProvider(_ value: ListLicenseEndpointsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLicenseEndpointsInput {

    static func urlPathProvider(_ value: ListLicenseEndpointsInput) -> Swift.String? {
        return "/2023-10-12/license-endpoints"
    }
}

public struct ListLicenseEndpointsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseEndpointsInputBody: Swift.Equatable {
}

extension ListLicenseEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLicenseEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicenseEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseEndpoints = output.licenseEndpoints
            self.nextToken = output.nextToken
        } else {
            self.licenseEndpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseEndpointsOutput: Swift.Equatable {
    /// The license endpoints.
    /// This member is required.
    public var licenseEndpoints: [DeadlineClientTypes.LicenseEndpointSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        licenseEndpoints: [DeadlineClientTypes.LicenseEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseEndpoints = licenseEndpoints
        self.nextToken = nextToken
    }
}

struct ListLicenseEndpointsOutputBody: Swift.Equatable {
    let licenseEndpoints: [DeadlineClientTypes.LicenseEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListLicenseEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseEndpoints
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseEndpointsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.LicenseEndpointSummary?].self, forKey: .licenseEndpoints)
        var licenseEndpointsDecoded0:[DeadlineClientTypes.LicenseEndpointSummary]? = nil
        if let licenseEndpointsContainer = licenseEndpointsContainer {
            licenseEndpointsDecoded0 = [DeadlineClientTypes.LicenseEndpointSummary]()
            for structure0 in licenseEndpointsContainer {
                if let structure0 = structure0 {
                    licenseEndpointsDecoded0?.append(structure0)
                }
            }
        }
        licenseEndpoints = licenseEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicenseEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMeteredProductsInput {

    static func queryItemProvider(_ value: ListMeteredProductsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMeteredProductsInput {

    static func urlPathProvider(_ value: ListMeteredProductsInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())/metered-products"
    }
}

public struct ListMeteredProductsInput: Swift.Equatable {
    /// The license endpoint ID to include on the list of metered products.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMeteredProductsInputBody: Swift.Equatable {
}

extension ListMeteredProductsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMeteredProductsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMeteredProductsOutputBody = try responseDecoder.decode(responseBody: data)
            self.meteredProducts = output.meteredProducts
            self.nextToken = output.nextToken
        } else {
            self.meteredProducts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMeteredProductsOutput: Swift.Equatable {
    /// The metered products to list.
    /// This member is required.
    public var meteredProducts: [DeadlineClientTypes.MeteredProductSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        meteredProducts: [DeadlineClientTypes.MeteredProductSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meteredProducts = meteredProducts
        self.nextToken = nextToken
    }
}

struct ListMeteredProductsOutputBody: Swift.Equatable {
    let meteredProducts: [DeadlineClientTypes.MeteredProductSummary]?
    let nextToken: Swift.String?
}

extension ListMeteredProductsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteredProducts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteredProductsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.MeteredProductSummary?].self, forKey: .meteredProducts)
        var meteredProductsDecoded0:[DeadlineClientTypes.MeteredProductSummary]? = nil
        if let meteredProductsContainer = meteredProductsContainer {
            meteredProductsDecoded0 = [DeadlineClientTypes.MeteredProductSummary]()
            for structure0 in meteredProductsContainer {
                if let structure0 = structure0 {
                    meteredProductsDecoded0?.append(structure0)
                }
            }
        }
        meteredProducts = meteredProductsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMeteredProductsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMonitorsInput {

    static func queryItemProvider(_ value: ListMonitorsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMonitorsInput {

    static func urlPathProvider(_ value: ListMonitorsInput) -> Swift.String? {
        return "/2023-10-12/monitors"
    }
}

public struct ListMonitorsInput: Swift.Equatable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMonitorsInputBody: Swift.Equatable {
}

extension ListMonitorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMonitorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMonitorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitors = output.monitors
            self.nextToken = output.nextToken
        } else {
            self.monitors = nil
            self.nextToken = nil
        }
    }
}

public struct ListMonitorsOutput: Swift.Equatable {
    /// A list of MonitorSummary objects that describe your monitors in the Deadline Cloud.
    /// This member is required.
    public var monitors: [DeadlineClientTypes.MonitorSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        monitors: [DeadlineClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

struct ListMonitorsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let monitors: [DeadlineClientTypes.MonitorSummary]?
}

extension ListMonitorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitors
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.MonitorSummary?].self, forKey: .monitors)
        var monitorsDecoded0:[DeadlineClientTypes.MonitorSummary]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [DeadlineClientTypes.MonitorSummary]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

enum ListMonitorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueueEnvironmentsInput {

    static func queryItemProvider(_ value: ListQueueEnvironmentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueueEnvironmentsInput {

    static func urlPathProvider(_ value: ListQueueEnvironmentsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments"
    }
}

public struct ListQueueEnvironmentsInput: Swift.Equatable {
    /// The farm ID for the queue environment list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the queue environment list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListQueueEnvironmentsInputBody: Swift.Equatable {
}

extension ListQueueEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueueEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueueEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListQueueEnvironmentsOutput: Swift.Equatable {
    /// The environments to include in the queue environments list.
    /// This member is required.
    public var environments: [DeadlineClientTypes.QueueEnvironmentSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        environments: [DeadlineClientTypes.QueueEnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListQueueEnvironmentsOutputBody: Swift.Equatable {
    let environments: [DeadlineClientTypes.QueueEnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListQueueEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.QueueEnvironmentSummary?].self, forKey: .environments)
        var environmentsDecoded0:[DeadlineClientTypes.QueueEnvironmentSummary]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [DeadlineClientTypes.QueueEnvironmentSummary]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueueEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueueFleetAssociationsInput {

    static func queryItemProvider(_ value: ListQueueFleetAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let queueId = value.queueId {
            let queueIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "queueId".urlPercentEncoding(), value: Swift.String(queueId).urlPercentEncoding())
            items.append(queueIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let fleetId = value.fleetId {
            let fleetIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "fleetId".urlPercentEncoding(), value: Swift.String(fleetId).urlPercentEncoding())
            items.append(fleetIdQueryItem)
        }
        return items
    }
}

extension ListQueueFleetAssociationsInput {

    static func urlPathProvider(_ value: ListQueueFleetAssociationsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations"
    }
}

public struct ListQueueFleetAssociationsInput: Swift.Equatable {
    /// The farm ID for the queue-fleet association list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID for the queue-fleet association list.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the queue-fleet association list.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListQueueFleetAssociationsInputBody: Swift.Equatable {
}

extension ListQueueFleetAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueueFleetAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueueFleetAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queueFleetAssociations = output.queueFleetAssociations
        } else {
            self.nextToken = nil
            self.queueFleetAssociations = nil
        }
    }
}

public struct ListQueueFleetAssociationsOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The queue-fleet associations on the list.
    /// This member is required.
    public var queueFleetAssociations: [DeadlineClientTypes.QueueFleetAssociationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        queueFleetAssociations: [DeadlineClientTypes.QueueFleetAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queueFleetAssociations = queueFleetAssociations
    }
}

struct ListQueueFleetAssociationsOutputBody: Swift.Equatable {
    let queueFleetAssociations: [DeadlineClientTypes.QueueFleetAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListQueueFleetAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case queueFleetAssociations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueFleetAssociationsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.QueueFleetAssociationSummary?].self, forKey: .queueFleetAssociations)
        var queueFleetAssociationsDecoded0:[DeadlineClientTypes.QueueFleetAssociationSummary]? = nil
        if let queueFleetAssociationsContainer = queueFleetAssociationsContainer {
            queueFleetAssociationsDecoded0 = [DeadlineClientTypes.QueueFleetAssociationSummary]()
            for structure0 in queueFleetAssociationsContainer {
                if let structure0 = structure0 {
                    queueFleetAssociationsDecoded0?.append(structure0)
                }
            }
        }
        queueFleetAssociations = queueFleetAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueueFleetAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueueMembersInput {

    static func queryItemProvider(_ value: ListQueueMembersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueueMembersInput {

    static func urlPathProvider(_ value: ListQueueMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/members"
    }
}

public struct ListQueueMembersInput: Swift.Equatable {
    /// The farm ID for the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListQueueMembersInputBody: Swift.Equatable {
}

extension ListQueueMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueueMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueueMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListQueueMembersOutput: Swift.Equatable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.QueueMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.QueueMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListQueueMembersOutputBody: Swift.Equatable {
    let members: [DeadlineClientTypes.QueueMember]?
    let nextToken: Swift.String?
}

extension ListQueueMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.QueueMember?].self, forKey: .members)
        var membersDecoded0:[DeadlineClientTypes.QueueMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DeadlineClientTypes.QueueMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueueMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueuesInput {

    static func queryItemProvider(_ value: ListQueuesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListQueuesInput {

    static func urlPathProvider(_ value: ListQueuesInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues"
    }
}

public struct ListQueuesInput: Swift.Equatable {
    /// The farm ID of the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID. This filter is only valid when using Nimble Studio credentials and should match the user ID in the credentials of the caller.
    public var principalId: Swift.String?
    /// The status of the queues listed.
    ///
    /// * ACTIVEThe queues are active.
    ///
    /// * SCHEDULINGThe queues are scheduling.
    ///
    /// * SCHEDULING_BLOCKEDThe queue scheduling is blocked for these queues.
    public var status: DeadlineClientTypes.QueueStatus?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        status: DeadlineClientTypes.QueueStatus? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.status = status
    }
}

struct ListQueuesInputBody: Swift.Equatable {
}

extension ListQueuesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queues = output.queues
        } else {
            self.nextToken = nil
            self.queues = nil
        }
    }
}

public struct ListQueuesOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The queues on the list.
    /// This member is required.
    public var queues: [DeadlineClientTypes.QueueSummary]?

    public init(
        nextToken: Swift.String? = nil,
        queues: [DeadlineClientTypes.QueueSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queues = queues
    }
}

struct ListQueuesOutputBody: Swift.Equatable {
    let queues: [DeadlineClientTypes.QueueSummary]?
    let nextToken: Swift.String?
}

extension ListQueuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case queues
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.QueueSummary?].self, forKey: .queues)
        var queuesDecoded0:[DeadlineClientTypes.QueueSummary]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [DeadlineClientTypes.QueueSummary]()
            for structure0 in queuesContainer {
                if let structure0 = structure0 {
                    queuesDecoded0?.append(structure0)
                }
            }
        }
        queues = queuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSessionActionsInput {

    static func queryItemProvider(_ value: ListSessionActionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sessionId = value.sessionId {
            let sessionIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
            items.append(sessionIdQueryItem)
        }
        if let taskId = value.taskId {
            let taskIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
            items.append(taskIdQueryItem)
        }
        return items
    }
}

extension ListSessionActionsInput {

    static func urlPathProvider(_ value: ListSessionActionsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/session-actions"
    }
}

public struct ListSessionActionsInput: Swift.Equatable {
    /// The farm ID for the session actions list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the session actions list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the session actions list.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session ID to include on the sessions action list.
    public var sessionId: Swift.String?
    /// The task ID for the session actions list.
    public var taskId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.sessionId = sessionId
        self.taskId = taskId
    }
}

struct ListSessionActionsInputBody: Swift.Equatable {
}

extension ListSessionActionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSessionActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSessionActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessionActions = output.sessionActions
        } else {
            self.nextToken = nil
            self.sessionActions = nil
        }
    }
}

public struct ListSessionActionsOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The session actions.
    /// This member is required.
    public var sessionActions: [DeadlineClientTypes.SessionActionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionActions: [DeadlineClientTypes.SessionActionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessionActions = sessionActions
    }
}

struct ListSessionActionsOutputBody: Swift.Equatable {
    let sessionActions: [DeadlineClientTypes.SessionActionSummary]?
    let nextToken: Swift.String?
}

extension ListSessionActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessionActions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionActionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SessionActionSummary?].self, forKey: .sessionActions)
        var sessionActionsDecoded0:[DeadlineClientTypes.SessionActionSummary]? = nil
        if let sessionActionsContainer = sessionActionsContainer {
            sessionActionsDecoded0 = [DeadlineClientTypes.SessionActionSummary]()
            for structure0 in sessionActionsContainer {
                if let structure0 = structure0 {
                    sessionActionsDecoded0?.append(structure0)
                }
            }
        }
        sessionActions = sessionActionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSessionActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSessionsForWorkerInput {

    static func queryItemProvider(_ value: ListSessionsForWorkerInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSessionsForWorkerInput {

    static func urlPathProvider(_ value: ListSessionsForWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/sessions"
    }
}

public struct ListSessionsForWorkerInput: Swift.Equatable {
    /// The farm ID for the session.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID for the session.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The worker ID for the session.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workerId = workerId
    }
}

struct ListSessionsForWorkerInputBody: Swift.Equatable {
}

extension ListSessionsForWorkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSessionsForWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSessionsForWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListSessionsForWorkerOutput: Swift.Equatable {
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The sessions in the response.
    /// This member is required.
    public var sessions: [DeadlineClientTypes.WorkerSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [DeadlineClientTypes.WorkerSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListSessionsForWorkerOutputBody: Swift.Equatable {
    let sessions: [DeadlineClientTypes.WorkerSessionSummary]?
    let nextToken: Swift.String?
}

extension ListSessionsForWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.WorkerSessionSummary?].self, forKey: .sessions)
        var sessionsDecoded0:[DeadlineClientTypes.WorkerSessionSummary]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [DeadlineClientTypes.WorkerSessionSummary]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSessionsForWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSessionsInput {

    static func queryItemProvider(_ value: ListSessionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/sessions"
    }
}

public struct ListSessionsInput: Swift.Equatable {
    /// The farm ID for the list of sessions.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the list of sessions.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the list of sessions
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListSessionsInputBody: Swift.Equatable {
}

extension ListSessionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListSessionsOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The sessions on the list.
    /// This member is required.
    public var sessions: [DeadlineClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [DeadlineClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListSessionsOutputBody: Swift.Equatable {
    let sessions: [DeadlineClientTypes.SessionSummary]?
    let nextToken: Swift.String?
}

extension ListSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SessionSummary?].self, forKey: .sessions)
        var sessionsDecoded0:[DeadlineClientTypes.SessionSummary]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [DeadlineClientTypes.SessionSummary]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStepConsumersInput {

    static func queryItemProvider(_ value: ListStepConsumersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStepConsumersInput {

    static func urlPathProvider(_ value: ListStepConsumersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/consumers"
    }
}

public struct ListStepConsumersInput: Swift.Equatable {
    /// The farm ID for the list of step consumers.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the step consumer.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the step consumer.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to include on the list.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.stepId = stepId
    }
}

struct ListStepConsumersInputBody: Swift.Equatable {
}

extension ListStepConsumersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStepConsumersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStepConsumersOutputBody = try responseDecoder.decode(responseBody: data)
            self.consumers = output.consumers
            self.nextToken = output.nextToken
        } else {
            self.consumers = nil
            self.nextToken = nil
        }
    }
}

public struct ListStepConsumersOutput: Swift.Equatable {
    /// The consumers on the list.
    /// This member is required.
    public var consumers: [DeadlineClientTypes.StepConsumer]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        consumers: [DeadlineClientTypes.StepConsumer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumers = consumers
        self.nextToken = nextToken
    }
}

struct ListStepConsumersOutputBody: Swift.Equatable {
    let consumers: [DeadlineClientTypes.StepConsumer]?
    let nextToken: Swift.String?
}

extension ListStepConsumersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumers
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepConsumer?].self, forKey: .consumers)
        var consumersDecoded0:[DeadlineClientTypes.StepConsumer]? = nil
        if let consumersContainer = consumersContainer {
            consumersDecoded0 = [DeadlineClientTypes.StepConsumer]()
            for structure0 in consumersContainer {
                if let structure0 = structure0 {
                    consumersDecoded0?.append(structure0)
                }
            }
        }
        consumers = consumersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStepConsumersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStepDependenciesInput {

    static func queryItemProvider(_ value: ListStepDependenciesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStepDependenciesInput {

    static func urlPathProvider(_ value: ListStepDependenciesInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/dependencies"
    }
}

public struct ListStepDependenciesInput: Swift.Equatable {
    /// The farm ID for the step dependencies list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the step dependencies list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the step dependencies list.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to include on the list.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.stepId = stepId
    }
}

struct ListStepDependenciesInputBody: Swift.Equatable {
}

extension ListStepDependenciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStepDependenciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStepDependenciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dependencies = output.dependencies
            self.nextToken = output.nextToken
        } else {
            self.dependencies = nil
            self.nextToken = nil
        }
    }
}

public struct ListStepDependenciesOutput: Swift.Equatable {
    /// The dependencies on the list.
    /// This member is required.
    public var dependencies: [DeadlineClientTypes.StepDependency]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        dependencies: [DeadlineClientTypes.StepDependency]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.nextToken = nextToken
    }
}

struct ListStepDependenciesOutputBody: Swift.Equatable {
    let dependencies: [DeadlineClientTypes.StepDependency]?
    let nextToken: Swift.String?
}

extension ListStepDependenciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dependenciesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepDependency?].self, forKey: .dependencies)
        var dependenciesDecoded0:[DeadlineClientTypes.StepDependency]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [DeadlineClientTypes.StepDependency]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStepDependenciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStepsInput {

    static func queryItemProvider(_ value: ListStepsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStepsInput {

    static func urlPathProvider(_ value: ListStepsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps"
    }
}

public struct ListStepsInput: Swift.Equatable {
    /// The farm ID to include on the list of steps.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to include on the list of steps.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list of steps.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListStepsInputBody: Swift.Equatable {
}

extension ListStepsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStepsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStepsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.steps = output.steps
        } else {
            self.nextToken = nil
            self.steps = nil
        }
    }
}

public struct ListStepsOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The steps on the list.
    /// This member is required.
    public var steps: [DeadlineClientTypes.StepSummary]?

    public init(
        nextToken: Swift.String? = nil,
        steps: [DeadlineClientTypes.StepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.steps = steps
    }
}

struct ListStepsOutputBody: Swift.Equatable {
    let steps: [DeadlineClientTypes.StepSummary]?
    let nextToken: Swift.String?
}

extension ListStepsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case steps
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepSummary?].self, forKey: .steps)
        var stepsDecoded0:[DeadlineClientTypes.StepSummary]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DeadlineClientTypes.StepSummary]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStepsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStorageProfilesForQueueInput {

    static func queryItemProvider(_ value: ListStorageProfilesForQueueInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStorageProfilesForQueueInput {

    static func urlPathProvider(_ value: ListStorageProfilesForQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/storage-profiles"
    }
}

public struct ListStorageProfilesForQueueInput: Swift.Equatable {
    /// The farm ID of the queue's storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the storage profile.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListStorageProfilesForQueueInputBody: Swift.Equatable {
}

extension ListStorageProfilesForQueueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStorageProfilesForQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStorageProfilesForQueueOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageProfiles = output.storageProfiles
        } else {
            self.nextToken = nil
            self.storageProfiles = nil
        }
    }
}

public struct ListStorageProfilesForQueueOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The storage profiles in the queue.
    /// This member is required.
    public var storageProfiles: [DeadlineClientTypes.StorageProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageProfiles: [DeadlineClientTypes.StorageProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageProfiles = storageProfiles
    }
}

struct ListStorageProfilesForQueueOutputBody: Swift.Equatable {
    let storageProfiles: [DeadlineClientTypes.StorageProfileSummary]?
    let nextToken: Swift.String?
}

extension ListStorageProfilesForQueueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case storageProfiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageProfilesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StorageProfileSummary?].self, forKey: .storageProfiles)
        var storageProfilesDecoded0:[DeadlineClientTypes.StorageProfileSummary]? = nil
        if let storageProfilesContainer = storageProfilesContainer {
            storageProfilesDecoded0 = [DeadlineClientTypes.StorageProfileSummary]()
            for structure0 in storageProfilesContainer {
                if let structure0 = structure0 {
                    storageProfilesDecoded0?.append(structure0)
                }
            }
        }
        storageProfiles = storageProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStorageProfilesForQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStorageProfilesInput {

    static func queryItemProvider(_ value: ListStorageProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStorageProfilesInput {

    static func urlPathProvider(_ value: ListStorageProfilesInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles"
    }
}

public struct ListStorageProfilesInput: Swift.Equatable {
    /// The farm ID of the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStorageProfilesInputBody: Swift.Equatable {
}

extension ListStorageProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStorageProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStorageProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageProfiles = output.storageProfiles
        } else {
            self.nextToken = nil
            self.storageProfiles = nil
        }
    }
}

public struct ListStorageProfilesOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The storage profiles.
    /// This member is required.
    public var storageProfiles: [DeadlineClientTypes.StorageProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageProfiles: [DeadlineClientTypes.StorageProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageProfiles = storageProfiles
    }
}

struct ListStorageProfilesOutputBody: Swift.Equatable {
    let storageProfiles: [DeadlineClientTypes.StorageProfileSummary]?
    let nextToken: Swift.String?
}

extension ListStorageProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case storageProfiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageProfilesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StorageProfileSummary?].self, forKey: .storageProfiles)
        var storageProfilesDecoded0:[DeadlineClientTypes.StorageProfileSummary]? = nil
        if let storageProfilesContainer = storageProfilesContainer {
            storageProfilesDecoded0 = [DeadlineClientTypes.StorageProfileSummary]()
            for structure0 in storageProfilesContainer {
                if let structure0 = structure0 {
                    storageProfilesDecoded0?.append(structure0)
                }
            }
        }
        storageProfiles = storageProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStorageProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2023-10-12/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTasksInput {

    static func queryItemProvider(_ value: ListTasksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTasksInput {

    static func urlPathProvider(_ value: ListTasksInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/tasks"
    }
}

public struct ListTasksInput: Swift.Equatable {
    /// The farm ID connected to the tasks.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the tasks.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID connected to the tasks.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID for the tasks.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.stepId = stepId
    }
}

struct ListTasksInputBody: Swift.Equatable {
}

extension ListTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListTasksOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// Tasks for the job.
    /// This member is required.
    public var tasks: [DeadlineClientTypes.TaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [DeadlineClientTypes.TaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListTasksOutputBody: Swift.Equatable {
    let tasks: [DeadlineClientTypes.TaskSummary]?
    let nextToken: Swift.String?
}

extension ListTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.TaskSummary?].self, forKey: .tasks)
        var tasksDecoded0:[DeadlineClientTypes.TaskSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [DeadlineClientTypes.TaskSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkersInput {

    static func queryItemProvider(_ value: ListWorkersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkersInput {

    static func urlPathProvider(_ value: ListWorkersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers"
    }
}

public struct ListWorkersInput: Swift.Equatable {
    /// The farm ID connected to the workers.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the workers.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkersInputBody: Swift.Equatable {
}

extension ListWorkersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workers = output.workers
        } else {
            self.nextToken = nil
            self.workers = nil
        }
    }
}

public struct ListWorkersOutput: Swift.Equatable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The workers on the list.
    /// This member is required.
    public var workers: [DeadlineClientTypes.WorkerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workers: [DeadlineClientTypes.WorkerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workers = workers
    }
}

struct ListWorkersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workers: [DeadlineClientTypes.WorkerSummary]?
}

extension ListWorkersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.WorkerSummary?].self, forKey: .workers)
        var workersDecoded0:[DeadlineClientTypes.WorkerSummary]? = nil
        if let workersContainer = workersContainer {
            workersDecoded0 = [DeadlineClientTypes.WorkerSummary]()
            for structure0 in workersContainer {
                if let structure0 = structure0 {
                    workersDecoded0?.append(structure0)
                }
            }
        }
        workers = workersDecoded0
    }
}

enum ListWorkersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.LogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case logDriver
        case options
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let logDriver = self.logDriver {
            try encodeContainer.encode(logDriver, forKey: .logDriver)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .options)
            for (dictKey0, logOptions0) in options {
                try optionsContainer.encode(logOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, logParameters0) in parameters {
                try parametersContainer.encode(logParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDriverDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDriver)
        logDriver = logDriverDecoded
        let optionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .options)
        var optionsDecoded0: [Swift.String:Swift.String]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in optionsContainer {
                if let string0 = string0 {
                    optionsDecoded0?[key0] = string0
                }
            }
        }
        options = optionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension DeadlineClientTypes {
    /// Log configuration details.
    public struct LogConfiguration: Swift.Equatable {
        /// The log configuration error details.
        public var error: Swift.String?
        /// The log drivers for worker related logs.
        /// This member is required.
        public var logDriver: Swift.String?
        /// The options for a log driver.
        public var options: [Swift.String:Swift.String]?
        /// The parameters for the log configuration.
        public var parameters: [Swift.String:Swift.String]?

        public init(
            error: Swift.String? = nil,
            logDriver: Swift.String? = nil,
            options: [Swift.String:Swift.String]? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.error = error
            self.logDriver = logDriver
            self.options = options
            self.parameters = parameters
        }
    }

}

extension DeadlineClientTypes {
    public enum LogicalOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .or,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogicalOperator(rawValue: rawValue) ?? LogicalOperator.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.ManifestProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemLocationName
        case inputManifestHash
        case inputManifestPath
        case outputRelativeDirectories
        case rootPath
        case rootPathFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemLocationName = self.fileSystemLocationName {
            try encodeContainer.encode(fileSystemLocationName, forKey: .fileSystemLocationName)
        }
        if let inputManifestHash = self.inputManifestHash {
            try encodeContainer.encode(inputManifestHash, forKey: .inputManifestHash)
        }
        if let inputManifestPath = self.inputManifestPath {
            try encodeContainer.encode(inputManifestPath, forKey: .inputManifestPath)
        }
        if let outputRelativeDirectories = outputRelativeDirectories {
            var outputRelativeDirectoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputRelativeDirectories)
            for string0 in outputRelativeDirectories {
                try outputRelativeDirectoriesContainer.encode(string0)
            }
        }
        if let rootPath = self.rootPath {
            try encodeContainer.encode(rootPath, forKey: .rootPath)
        }
        if let rootPathFormat = self.rootPathFormat {
            try encodeContainer.encode(rootPathFormat.rawValue, forKey: .rootPathFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemLocationName)
        fileSystemLocationName = fileSystemLocationNameDecoded
        let rootPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootPath)
        rootPath = rootPathDecoded
        let rootPathFormatDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.PathFormat.self, forKey: .rootPathFormat)
        rootPathFormat = rootPathFormatDecoded
        let outputRelativeDirectoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outputRelativeDirectories)
        var outputRelativeDirectoriesDecoded0:[Swift.String]? = nil
        if let outputRelativeDirectoriesContainer = outputRelativeDirectoriesContainer {
            outputRelativeDirectoriesDecoded0 = [Swift.String]()
            for string0 in outputRelativeDirectoriesContainer {
                if let string0 = string0 {
                    outputRelativeDirectoriesDecoded0?.append(string0)
                }
            }
        }
        outputRelativeDirectories = outputRelativeDirectoriesDecoded0
        let inputManifestPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputManifestPath)
        inputManifestPath = inputManifestPathDecoded
        let inputManifestHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputManifestHash)
        inputManifestHash = inputManifestHashDecoded
    }
}

extension DeadlineClientTypes.ManifestProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {
    /// The details of the manifest that links a job's source information.
    public struct ManifestProperties: Swift.Equatable {
        /// The file system location name.
        public var fileSystemLocationName: Swift.String?
        /// The has value of the file.
        public var inputManifestHash: Swift.String?
        /// The file path.
        public var inputManifestPath: Swift.String?
        /// The file path relative to the directory.
        public var outputRelativeDirectories: [Swift.String]?
        /// The file's root path.
        /// This member is required.
        public var rootPath: Swift.String?
        /// The format of the root path.
        /// This member is required.
        public var rootPathFormat: DeadlineClientTypes.PathFormat?

        public init(
            fileSystemLocationName: Swift.String? = nil,
            inputManifestHash: Swift.String? = nil,
            inputManifestPath: Swift.String? = nil,
            outputRelativeDirectories: [Swift.String]? = nil,
            rootPath: Swift.String? = nil,
            rootPathFormat: DeadlineClientTypes.PathFormat? = nil
        )
        {
            self.fileSystemLocationName = fileSystemLocationName
            self.inputManifestHash = inputManifestHash
            self.inputManifestPath = inputManifestPath
            self.outputRelativeDirectories = outputRelativeDirectories
            self.rootPath = rootPath
            self.rootPathFormat = rootPathFormat
        }
    }

}

extension DeadlineClientTypes {
    public enum MembershipLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case manager
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipLevel] {
            return [
                .contributor,
                .manager,
                .owner,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .manager: return "MANAGER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MembershipLevel(rawValue: rawValue) ?? MembershipLevel.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.MemoryMiBRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension DeadlineClientTypes {
    /// The range of memory in MiB.
    public struct MemoryMiBRange: Swift.Equatable {
        /// The maximum amount of memory (in MiB).
        public var max: Swift.Int?
        /// The minimum amount of memory (in MiB).
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension DeadlineClientTypes.MeteredProductSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case family
        case port
        case productId
        case vendor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a metered product.
    public struct MeteredProductSummary: Swift.Equatable {
        /// The family to which the metered product belongs.
        /// This member is required.
        public var family: Swift.String?
        /// The port on which the metered product should run.
        /// This member is required.
        public var port: Swift.Int?
        /// The product ID.
        /// This member is required.
        public var productId: Swift.String?
        /// The vendor.
        /// This member is required.
        public var vendor: Swift.String?

        public init(
            family: Swift.String? = nil,
            port: Swift.Int? = nil,
            productId: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.family = family
            self.port = port
            self.productId = productId
            self.vendor = vendor
        }
    }

}

extension DeadlineClientTypes.MonitorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case displayName
        case identityCenterApplicationArn
        case identityCenterInstanceArn
        case monitorId
        case roleArn
        case subdomain
        case updatedAt
        case updatedBy
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let identityCenterApplicationArn = self.identityCenterApplicationArn {
            try encodeContainer.encode(identityCenterApplicationArn, forKey: .identityCenterApplicationArn)
        }
        if let identityCenterInstanceArn = self.identityCenterInstanceArn {
            try encodeContainer.encode(identityCenterInstanceArn, forKey: .identityCenterInstanceArn)
        }
        if let monitorId = self.monitorId {
            try encodeContainer.encode(monitorId, forKey: .monitorId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let subdomain = self.subdomain {
            try encodeContainer.encode(subdomain, forKey: .subdomain)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorId)
        monitorId = monitorIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let subdomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdomain)
        subdomain = subdomainDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let identityCenterInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterInstanceArn)
        identityCenterInstanceArn = identityCenterInstanceArnDecoded
        let identityCenterApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterApplicationArn)
        identityCenterApplicationArn = identityCenterApplicationArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DeadlineClientTypes {
    /// Provides information about a monitor in Deadline Cloud.
    public struct MonitorSummary: Swift.Equatable {
        /// The UNIX timestamp of the date and time that the monitor was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user name of the person that created the monitor.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The name of the monitor that displays on the Deadline Cloud console.
        /// This member is required.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) that the IAM Identity Center assigned to the monitor when it was created.
        /// This member is required.
        public var identityCenterApplicationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM Identity Center instance responsible for authenticating monitor users.
        /// This member is required.
        public var identityCenterInstanceArn: Swift.String?
        /// The unique identifier for the monitor.
        /// This member is required.
        public var monitorId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role for the monitor. Users of the monitor use this role to access Deadline Cloud resources.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The subdomain used for the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        /// This member is required.
        public var subdomain: Swift.String?
        /// The UNIX timestamp of the date and time that the monitor was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user name of the person that last updated the monitor.
        public var updatedBy: Swift.String?
        /// The complete URL of the monitor. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        /// This member is required.
        public var url: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            displayName: Swift.String? = nil,
            identityCenterApplicationArn: Swift.String? = nil,
            identityCenterInstanceArn: Swift.String? = nil,
            monitorId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            subdomain: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.monitorId = monitorId
            self.roleArn = roleArn
            self.subdomain = subdomain
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.url = url
        }
    }

}

extension DeadlineClientTypes.ParameterFilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ComparisonOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a filtered search for parameters.
    public struct ParameterFilterExpression: Swift.Equatable {
        /// The name of the parameter to filter on.
        /// This member is required.
        public var name: Swift.String?
        /// The type of comparison to use to filter results.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.ComparisonOperator?
        /// The parameter's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            `operator`: DeadlineClientTypes.ComparisonOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension DeadlineClientTypes.ParameterSortExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeadlineClientTypes {
    /// Organizes parameters according to your specifications.
    public struct ParameterSortExpression: Swift.Equatable {
        /// The parameter name to sort by.
        /// This member is required.
        public var name: Swift.String?
        /// The sort order for the parameter.
        /// This member is required.
        public var sortOrder: DeadlineClientTypes.SortOrder?

        public init(
            name: Swift.String? = nil,
            sortOrder: DeadlineClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.sortOrder = sortOrder
        }
    }

}

extension DeadlineClientTypes.ParameterSpace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case combination
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let combination = self.combination {
            try encodeContainer.encode(combination, forKey: .combination)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for stepparameter0 in parameters {
                try parametersContainer.encode(stepparameter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepParameter?].self, forKey: .parameters)
        var parametersDecoded0:[DeadlineClientTypes.StepParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DeadlineClientTypes.StepParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let combinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .combination)
        combination = combinationDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a search for two or more step parameters.
    public struct ParameterSpace: Swift.Equatable {
        /// The combination expression to use in the search.
        public var combination: Swift.String?
        /// The parameters to search for.
        /// This member is required.
        public var parameters: [DeadlineClientTypes.StepParameter]?

        public init(
            combination: Swift.String? = nil,
            parameters: [DeadlineClientTypes.StepParameter]? = nil
        )
        {
            self.combination = combination
            self.parameters = parameters
        }
    }

}

extension DeadlineClientTypes {
    public enum PathFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case posix
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [PathFormat] {
            return [
                .posix,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .posix: return "posix"
            case .windows: return "windows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PathFormat(rawValue: rawValue) ?? PathFormat.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.PathMappingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath
        case sourcePath
        case sourcePathFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
        if let sourcePathFormat = self.sourcePathFormat {
            try encodeContainer.encode(sourcePathFormat.rawValue, forKey: .sourcePathFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathFormatDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.PathFormat.self, forKey: .sourcePathFormat)
        sourcePathFormat = sourcePathFormatDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
    }
}

extension DeadlineClientTypes.PathMappingRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {
    /// The details of a source and destination path.
    public struct PathMappingRule: Swift.Equatable {
        /// The destination path.
        /// This member is required.
        public var destinationPath: Swift.String?
        /// The source path.
        /// This member is required.
        public var sourcePath: Swift.String?
        /// The source path format.
        /// This member is required.
        public var sourcePathFormat: DeadlineClientTypes.PathFormat?

        public init(
            destinationPath: Swift.String? = nil,
            sourcePath: Swift.String? = nil,
            sourcePathFormat: DeadlineClientTypes.PathFormat? = nil
        )
        {
            self.destinationPath = destinationPath
            self.sourcePath = sourcePath
            self.sourcePathFormat = sourcePathFormat
        }
    }

}

extension DeadlineClientTypes {
    public enum Period: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [Period] {
            return [
                .daily,
                .hourly,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Period(rawValue: rawValue) ?? Period.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.PosixUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .user)
        user = userDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
    }
}

extension DeadlineClientTypes {
    /// The POSIX user.
    public struct PosixUser: Swift.Equatable {
        /// The name of the POSIX user's group.
        /// This member is required.
        public var group: Swift.String?
        /// The name of the POSIX user.
        /// This member is required.
        public var user: Swift.String?

        public init(
            group: Swift.String? = nil,
            user: Swift.String? = nil
        )
        {
            self.group = group
            self.user = user
        }
    }

}

extension PutMeteredProductInput {

    static func urlPathProvider(_ value: PutMeteredProductInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        guard let productId = value.productId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())/metered-products/\(productId.urlPercentEncoding())"
    }
}

public struct PutMeteredProductInput: Swift.Equatable {
    /// The license endpoint ID to add to the metered product.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The product ID to add to the metered product.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
        self.productId = productId
    }
}

struct PutMeteredProductInputBody: Swift.Equatable {
}

extension PutMeteredProductInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PutMeteredProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutMeteredProductOutput: Swift.Equatable {

    public init() { }
}

enum PutMeteredProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes {
    public enum QueueBlockedReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case budgetThresholdReached
        case noBudgetConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueBlockedReason] {
            return [
                .budgetThresholdReached,
                .noBudgetConfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .budgetThresholdReached: return "BUDGET_THRESHOLD_REACHED"
            case .noBudgetConfigured: return "NO_BUDGET_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueBlockedReason(rawValue: rawValue) ?? QueueBlockedReason.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.QueueEnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case priority
        case queueEnvironmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueEnvironmentId = self.queueEnvironmentId {
            try encodeContainer.encode(queueEnvironmentId, forKey: .queueEnvironmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueEnvironmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueEnvironmentId)
        queueEnvironmentId = queueEnvironmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension DeadlineClientTypes {
    /// The summary of a queue environment.
    public struct QueueEnvironmentSummary: Swift.Equatable {
        /// The name of the queue environment.
        /// This member is required.
        public var name: Swift.String?
        /// The queue environment's priority.
        /// This member is required.
        public var priority: Swift.Int?
        /// The queue environment ID.
        /// This member is required.
        public var queueEnvironmentId: Swift.String?

        public init(
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queueEnvironmentId: Swift.String? = nil
        )
        {
            self.name = name
            self.priority = priority
            self.queueEnvironmentId = queueEnvironmentId
        }
    }

}

extension DeadlineClientTypes {
    public enum QueueFleetAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case stopped
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueFleetAssociationStatus] {
            return [
                .active,
                .stopped,
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .stopped: return "STOPPED"
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueFleetAssociationStatus(rawValue: rawValue) ?? QueueFleetAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.QueueFleetAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case fleetId
        case queueId
        case status
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.QueueFleetAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a queue-fleet association.
    public struct QueueFleetAssociationSummary: Swift.Equatable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?
        /// The status of task scheduling in the queue-fleet association.
        ///
        /// * ACTIVEAssociation is active.
        ///
        /// * STOP_SCHEDULING_AND_COMPLETE_TASKSAssociation has stopped scheduling new tasks and is completing current tasks.
        ///
        /// * STOP_SCHEDULING_AND_CANCEL_TASKSAssociation has stopped scheduling new tasks and is canceling current tasks.
        ///
        /// * STOPPEDAssociation has been stopped.
        /// This member is required.
        public var status: DeadlineClientTypes.QueueFleetAssociationStatus?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: DeadlineClientTypes.QueueFleetAssociationStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DeadlineClientTypes.QueueMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case farmId
        case identityStoreId
        case membershipLevel
        case principalId
        case principalType
        case queueId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipLevel = self.membershipLevel {
            try encodeContainer.encode(membershipLevel.rawValue, forKey: .membershipLevel)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DeadlinePrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipLevelDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MembershipLevel.self, forKey: .membershipLevel)
        membershipLevel = membershipLevelDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a queue member.
    public struct QueueMember: Swift.Equatable {
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The identity store ID.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The queue member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the queue member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the queue member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            farmId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }
    }

}

extension DeadlineClientTypes {
    public enum QueueStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case idle
        case scheduling
        case schedulingBlocked
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueStatus] {
            return [
                .idle,
                .scheduling,
                .schedulingBlocked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .idle: return "IDLE"
            case .scheduling: return "SCHEDULING"
            case .schedulingBlocked: return "SCHEDULING_BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueStatus(rawValue: rawValue) ?? QueueStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.QueueSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedReason
        case createdAt
        case createdBy
        case defaultBudgetAction
        case displayName
        case farmId
        case queueId
        case status
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedReason = self.blockedReason {
            try encodeContainer.encode(blockedReason.rawValue, forKey: .blockedReason)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let defaultBudgetAction = self.defaultBudgetAction {
            try encodeContainer.encode(defaultBudgetAction.rawValue, forKey: .defaultBudgetAction)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.QueueStatus.self, forKey: .status)
        status = statusDecoded
        let defaultBudgetActionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DefaultQueueBudgetAction.self, forKey: .defaultBudgetAction)
        defaultBudgetAction = defaultBudgetActionDecoded
        let blockedReasonDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.QueueBlockedReason.self, forKey: .blockedReason)
        blockedReason = blockedReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a queue summary.
    public struct QueueSummary: Swift.Equatable {
        /// The reason the queue is blocked, if applicable.
        public var blockedReason: DeadlineClientTypes.QueueBlockedReason?
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The default action taken on a queue summary if a budget wasn't configured.
        /// This member is required.
        public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
        /// The display name of the queue summary to update.
        /// This member is required.
        public var displayName: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?
        /// That status of the queue.
        /// This member is required.
        public var status: DeadlineClientTypes.QueueStatus?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            blockedReason: DeadlineClientTypes.QueueBlockedReason? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
            displayName: Swift.String? = nil,
            farmId: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: DeadlineClientTypes.QueueStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.blockedReason = blockedReason
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.defaultBudgetAction = defaultBudgetAction
            self.displayName = displayName
            self.farmId = farmId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.context = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that couldn't be found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that couldn't be found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let context: [Swift.String:Swift.String]?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
    }
}

extension DeadlineClientTypes.ResponseBudgetAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case thresholdPercentage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let thresholdPercentage = self.thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetActionType.self, forKey: .type)
        type = typeDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DeadlineClientTypes.ResponseBudgetAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseBudgetAction(thresholdPercentage: \(Swift.String(describing: thresholdPercentage)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The details of a budget action.
    public struct ResponseBudgetAction: Swift.Equatable {
        /// The budget action description.
        public var description: Swift.String?
        /// The percentage threshold for the budget.
        /// This member is required.
        public var thresholdPercentage: Swift.Float?
        /// The action taken on the budget once scheduling stops.
        /// This member is required.
        public var type: DeadlineClientTypes.BudgetActionType?

        public init(
            description: Swift.String? = nil,
            thresholdPercentage: Swift.Float? = nil,
            type: DeadlineClientTypes.BudgetActionType? = nil
        )
        {
            self.description = description
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }
    }

}

extension DeadlineClientTypes {
    public enum RunAs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case queueConfiguredUser
        case workerAgentUser
        case sdkUnknown(Swift.String)

        public static var allCases: [RunAs] {
            return [
                .queueConfiguredUser,
                .workerAgentUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .queueConfiguredUser: return "QUEUE_CONFIGURED_USER"
            case .workerAgentUser: return "WORKER_AGENT_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunAs(rawValue: rawValue) ?? RunAs.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension DeadlineClientTypes {
    /// The Amazon S3 location information.
    public struct S3Location: Swift.Equatable {
        /// The name of the Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The Amazon S3 object key that uniquely identifies the Amazon S3 bucket.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }

}

extension DeadlineClientTypes.SearchFilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetimefilter = "dateTimeFilter"
        case groupfilter = "groupFilter"
        case parameterfilter = "parameterFilter"
        case sdkUnknown
        case searchtermfilter = "searchTermFilter"
        case stringfilter = "stringFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .datetimefilter(datetimefilter):
                try container.encode(datetimefilter, forKey: .datetimefilter)
            case let .groupfilter(groupfilter):
                try container.encode(groupfilter, forKey: .groupfilter)
            case let .parameterfilter(parameterfilter):
                try container.encode(parameterfilter, forKey: .parameterfilter)
            case let .searchtermfilter(searchtermfilter):
                try container.encode(searchtermfilter, forKey: .searchtermfilter)
            case let .stringfilter(stringfilter):
                try container.encode(stringfilter, forKey: .stringfilter)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let datetimefilterDecoded = try values.decodeIfPresent(DeadlineClientTypes.DateTimeFilterExpression.self, forKey: .datetimefilter)
        if let datetimefilter = datetimefilterDecoded {
            self = .datetimefilter(datetimefilter)
            return
        }
        let parameterfilterDecoded = try values.decodeIfPresent(DeadlineClientTypes.ParameterFilterExpression.self, forKey: .parameterfilter)
        if let parameterfilter = parameterfilterDecoded {
            self = .parameterfilter(parameterfilter)
            return
        }
        let searchtermfilterDecoded = try values.decodeIfPresent(DeadlineClientTypes.SearchTermFilterExpression.self, forKey: .searchtermfilter)
        if let searchtermfilter = searchtermfilterDecoded {
            self = .searchtermfilter(searchtermfilter)
            return
        }
        let stringfilterDecoded = try values.decodeIfPresent(DeadlineClientTypes.StringFilterExpression.self, forKey: .stringfilter)
        if let stringfilter = stringfilterDecoded {
            self = .stringfilter(stringfilter)
            return
        }
        let groupfilterDecoded = try values.decodeIfPresent(DeadlineClientTypes.SearchGroupedFilterExpressions.self, forKey: .groupfilter)
        if let groupfilter = groupfilterDecoded {
            self = .groupfilter(groupfilter)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The type of search filter to apply.
    public indirect enum SearchFilterExpression: Swift.Equatable {
        /// Filters based on date and time.
        case datetimefilter(DeadlineClientTypes.DateTimeFilterExpression)
        /// Filters by parameter.
        case parameterfilter(DeadlineClientTypes.ParameterFilterExpression)
        /// Filters by a specified search term.
        case searchtermfilter(DeadlineClientTypes.SearchTermFilterExpression)
        /// Filters by a string.
        case stringfilter(DeadlineClientTypes.StringFilterExpression)
        /// Filters by group.
        case groupfilter(DeadlineClientTypes.SearchGroupedFilterExpressions)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes.SearchGroupedFilterExpressions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case `operator` = "operator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchfilterexpression0 in filters {
                try filtersContainer.encode(searchfilterexpression0)
            }
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SearchFilterExpression?].self, forKey: .filters)
        var filtersDecoded0:[DeadlineClientTypes.SearchFilterExpression]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeadlineClientTypes.SearchFilterExpression]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogicalOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension DeadlineClientTypes {
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public struct SearchGroupedFilterExpressions: Swift.Equatable {
        /// The filters to use for the search.
        /// This member is required.
        public var filters: [DeadlineClientTypes.SearchFilterExpression]?
        /// The operators to include in the search.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.LogicalOperator?

        public init(
            filters: [DeadlineClientTypes.SearchFilterExpression]? = nil,
            `operator`: DeadlineClientTypes.LogicalOperator? = nil
        )
        {
            self.filters = filters
            self.`operator` = `operator`
        }
    }

}

extension SearchJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case itemOffset
        case pageSize
        case queueIds
        case sortExpressions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpressions = self.filterExpressions {
            try encodeContainer.encode(filterExpressions, forKey: .filterExpressions)
        }
        if let itemOffset = self.itemOffset {
            try encodeContainer.encode(itemOffset, forKey: .itemOffset)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let queueIds = queueIds {
            var queueIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueIds)
            for queueid0 in queueIds {
                try queueIdsContainer.encode(queueid0)
            }
        }
        if let sortExpressions = sortExpressions {
            var sortExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortExpressions)
            for searchsortexpression0 in sortExpressions {
                try sortExpressionsContainer.encode(searchsortexpression0)
            }
        }
    }
}

extension SearchJobsInput {

    static func urlPathProvider(_ value: SearchJobsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/jobs"
    }
}

public struct SearchJobsInput: Swift.Equatable {
    /// The farm ID of the job.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The queue ID to use in the job search.
    /// This member is required.
    public var queueIds: [Swift.String]?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        itemOffset: Swift.Int? = nil,
        pageSize: Swift.Int? = nil,
        queueIds: [Swift.String]? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.itemOffset = itemOffset
        self.pageSize = pageSize
        self.queueIds = queueIds
        self.sortExpressions = sortExpressions
    }
}

struct SearchJobsInputBody: Swift.Equatable {
    let queueIds: [Swift.String]?
    let filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    let sortExpressions: [DeadlineClientTypes.SearchSortExpression]?
    let itemOffset: Swift.Int?
    let pageSize: Swift.Int?
}

extension SearchJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case itemOffset
        case pageSize
        case queueIds
        case sortExpressions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queueIds)
        var queueIdsDecoded0:[Swift.String]? = nil
        if let queueIdsContainer = queueIdsContainer {
            queueIdsDecoded0 = [Swift.String]()
            for string0 in queueIdsContainer {
                if let string0 = string0 {
                    queueIdsDecoded0?.append(string0)
                }
            }
        }
        queueIds = queueIdsDecoded0
        let filterExpressionsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SearchGroupedFilterExpressions.self, forKey: .filterExpressions)
        filterExpressions = filterExpressionsDecoded
        let sortExpressionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SearchSortExpression?].self, forKey: .sortExpressions)
        var sortExpressionsDecoded0:[DeadlineClientTypes.SearchSortExpression]? = nil
        if let sortExpressionsContainer = sortExpressionsContainer {
            sortExpressionsDecoded0 = [DeadlineClientTypes.SearchSortExpression]()
            for union0 in sortExpressionsContainer {
                if let union0 = union0 {
                    sortExpressionsDecoded0?.append(union0)
                }
            }
        }
        sortExpressions = sortExpressionsDecoded0
        let itemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemOffset)
        itemOffset = itemOffsetDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension SearchJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextItemOffset = output.nextItemOffset
            self.totalResults = output.totalResults
        } else {
            self.jobs = nil
            self.nextItemOffset = nil
            self.totalResults = nil
        }
    }
}

public struct SearchJobsOutput: Swift.Equatable {
    /// The jobs in the search.
    /// This member is required.
    public var jobs: [DeadlineClientTypes.JobSearchSummary]?
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?

    public init(
        jobs: [DeadlineClientTypes.JobSearchSummary]? = nil,
        nextItemOffset: Swift.Int? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.jobs = jobs
        self.nextItemOffset = nextItemOffset
        self.totalResults = totalResults
    }
}

struct SearchJobsOutputBody: Swift.Equatable {
    let jobs: [DeadlineClientTypes.JobSearchSummary]?
    let nextItemOffset: Swift.Int?
    let totalResults: Swift.Int?
}

extension SearchJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextItemOffset
        case totalResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.JobSearchSummary?].self, forKey: .jobs)
        var jobsDecoded0:[DeadlineClientTypes.JobSearchSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DeadlineClientTypes.JobSearchSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextItemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextItemOffset)
        nextItemOffset = nextItemOffsetDecoded
        let totalResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResults)
        totalResults = totalResultsDecoded
    }
}

enum SearchJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.SearchSortExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldsort = "fieldSort"
        case parametersort = "parameterSort"
        case sdkUnknown
        case userjobsfirst = "userJobsFirst"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fieldsort(fieldsort):
                try container.encode(fieldsort, forKey: .fieldsort)
            case let .parametersort(parametersort):
                try container.encode(parametersort, forKey: .parametersort)
            case let .userjobsfirst(userjobsfirst):
                try container.encode(userjobsfirst, forKey: .userjobsfirst)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let userjobsfirstDecoded = try values.decodeIfPresent(DeadlineClientTypes.UserJobsFirst.self, forKey: .userjobsfirst)
        if let userjobsfirst = userjobsfirstDecoded {
            self = .userjobsfirst(userjobsfirst)
            return
        }
        let fieldsortDecoded = try values.decodeIfPresent(DeadlineClientTypes.FieldSortExpression.self, forKey: .fieldsort)
        if let fieldsort = fieldsortDecoded {
            self = .fieldsort(fieldsort)
            return
        }
        let parametersortDecoded = try values.decodeIfPresent(DeadlineClientTypes.ParameterSortExpression.self, forKey: .parametersort)
        if let parametersort = parametersortDecoded {
            self = .parametersort(parametersort)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The resources to search.
    public enum SearchSortExpression: Swift.Equatable {
        /// Options for sorting a particular user's jobs first.
        case userjobsfirst(DeadlineClientTypes.UserJobsFirst)
        /// Options for sorting by a field.
        case fieldsort(DeadlineClientTypes.FieldSortExpression)
        /// Options for sorting by a parameter.
        case parametersort(DeadlineClientTypes.ParameterSortExpression)
        case sdkUnknown(Swift.String)
    }

}

extension SearchStepsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case itemOffset
        case jobId
        case pageSize
        case queueIds
        case sortExpressions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpressions = self.filterExpressions {
            try encodeContainer.encode(filterExpressions, forKey: .filterExpressions)
        }
        if let itemOffset = self.itemOffset {
            try encodeContainer.encode(itemOffset, forKey: .itemOffset)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let queueIds = queueIds {
            var queueIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueIds)
            for queueid0 in queueIds {
                try queueIdsContainer.encode(queueid0)
            }
        }
        if let sortExpressions = sortExpressions {
            var sortExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortExpressions)
            for searchsortexpression0 in sortExpressions {
                try sortExpressionsContainer.encode(searchsortexpression0)
            }
        }
    }
}

extension SearchStepsInput {

    static func urlPathProvider(_ value: SearchStepsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/steps"
    }
}

public struct SearchStepsInput: Swift.Equatable {
    /// The farm ID to use for the step search.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// The job ID to use in the step search.
    public var jobId: Swift.String?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The queue IDs in the step search.
    /// This member is required.
    public var queueIds: [Swift.String]?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        itemOffset: Swift.Int? = nil,
        jobId: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        queueIds: [Swift.String]? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.itemOffset = itemOffset
        self.jobId = jobId
        self.pageSize = pageSize
        self.queueIds = queueIds
        self.sortExpressions = sortExpressions
    }
}

struct SearchStepsInputBody: Swift.Equatable {
    let queueIds: [Swift.String]?
    let jobId: Swift.String?
    let filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    let sortExpressions: [DeadlineClientTypes.SearchSortExpression]?
    let itemOffset: Swift.Int?
    let pageSize: Swift.Int?
}

extension SearchStepsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case itemOffset
        case jobId
        case pageSize
        case queueIds
        case sortExpressions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queueIds)
        var queueIdsDecoded0:[Swift.String]? = nil
        if let queueIdsContainer = queueIdsContainer {
            queueIdsDecoded0 = [Swift.String]()
            for string0 in queueIdsContainer {
                if let string0 = string0 {
                    queueIdsDecoded0?.append(string0)
                }
            }
        }
        queueIds = queueIdsDecoded0
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let filterExpressionsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SearchGroupedFilterExpressions.self, forKey: .filterExpressions)
        filterExpressions = filterExpressionsDecoded
        let sortExpressionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SearchSortExpression?].self, forKey: .sortExpressions)
        var sortExpressionsDecoded0:[DeadlineClientTypes.SearchSortExpression]? = nil
        if let sortExpressionsContainer = sortExpressionsContainer {
            sortExpressionsDecoded0 = [DeadlineClientTypes.SearchSortExpression]()
            for union0 in sortExpressionsContainer {
                if let union0 = union0 {
                    sortExpressionsDecoded0?.append(union0)
                }
            }
        }
        sortExpressions = sortExpressionsDecoded0
        let itemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemOffset)
        itemOffset = itemOffsetDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension SearchStepsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchStepsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextItemOffset = output.nextItemOffset
            self.steps = output.steps
            self.totalResults = output.totalResults
        } else {
            self.nextItemOffset = nil
            self.steps = nil
            self.totalResults = nil
        }
    }
}

public struct SearchStepsOutput: Swift.Equatable {
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// The steps in the search.
    /// This member is required.
    public var steps: [DeadlineClientTypes.StepSearchSummary]?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?

    public init(
        nextItemOffset: Swift.Int? = nil,
        steps: [DeadlineClientTypes.StepSearchSummary]? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.nextItemOffset = nextItemOffset
        self.steps = steps
        self.totalResults = totalResults
    }
}

struct SearchStepsOutputBody: Swift.Equatable {
    let steps: [DeadlineClientTypes.StepSearchSummary]?
    let nextItemOffset: Swift.Int?
    let totalResults: Swift.Int?
}

extension SearchStepsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextItemOffset
        case steps
        case totalResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepSearchSummary?].self, forKey: .steps)
        var stepsDecoded0:[DeadlineClientTypes.StepSearchSummary]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DeadlineClientTypes.StepSearchSummary]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let nextItemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextItemOffset)
        nextItemOffset = nextItemOffsetDecoded
        let totalResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResults)
        totalResults = totalResultsDecoded
    }
}

enum SearchStepsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case itemOffset
        case jobId
        case pageSize
        case queueIds
        case sortExpressions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpressions = self.filterExpressions {
            try encodeContainer.encode(filterExpressions, forKey: .filterExpressions)
        }
        if let itemOffset = self.itemOffset {
            try encodeContainer.encode(itemOffset, forKey: .itemOffset)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let queueIds = queueIds {
            var queueIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueIds)
            for queueid0 in queueIds {
                try queueIdsContainer.encode(queueid0)
            }
        }
        if let sortExpressions = sortExpressions {
            var sortExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortExpressions)
            for searchsortexpression0 in sortExpressions {
                try sortExpressionsContainer.encode(searchsortexpression0)
            }
        }
    }
}

extension SearchTasksInput {

    static func urlPathProvider(_ value: SearchTasksInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/tasks"
    }
}

public struct SearchTasksInput: Swift.Equatable {
    /// The farm ID of the task.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// The job ID for the task search.
    public var jobId: Swift.String?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The queue IDs to include in the search.
    /// This member is required.
    public var queueIds: [Swift.String]?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        itemOffset: Swift.Int? = nil,
        jobId: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        queueIds: [Swift.String]? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.itemOffset = itemOffset
        self.jobId = jobId
        self.pageSize = pageSize
        self.queueIds = queueIds
        self.sortExpressions = sortExpressions
    }
}

struct SearchTasksInputBody: Swift.Equatable {
    let queueIds: [Swift.String]?
    let jobId: Swift.String?
    let filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    let sortExpressions: [DeadlineClientTypes.SearchSortExpression]?
    let itemOffset: Swift.Int?
    let pageSize: Swift.Int?
}

extension SearchTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case itemOffset
        case jobId
        case pageSize
        case queueIds
        case sortExpressions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queueIds)
        var queueIdsDecoded0:[Swift.String]? = nil
        if let queueIdsContainer = queueIdsContainer {
            queueIdsDecoded0 = [Swift.String]()
            for string0 in queueIdsContainer {
                if let string0 = string0 {
                    queueIdsDecoded0?.append(string0)
                }
            }
        }
        queueIds = queueIdsDecoded0
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let filterExpressionsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SearchGroupedFilterExpressions.self, forKey: .filterExpressions)
        filterExpressions = filterExpressionsDecoded
        let sortExpressionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SearchSortExpression?].self, forKey: .sortExpressions)
        var sortExpressionsDecoded0:[DeadlineClientTypes.SearchSortExpression]? = nil
        if let sortExpressionsContainer = sortExpressionsContainer {
            sortExpressionsDecoded0 = [DeadlineClientTypes.SearchSortExpression]()
            for union0 in sortExpressionsContainer {
                if let union0 = union0 {
                    sortExpressionsDecoded0?.append(union0)
                }
            }
        }
        sortExpressions = sortExpressionsDecoded0
        let itemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemOffset)
        itemOffset = itemOffsetDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension SearchTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextItemOffset = output.nextItemOffset
            self.tasks = output.tasks
            self.totalResults = output.totalResults
        } else {
            self.nextItemOffset = nil
            self.tasks = nil
            self.totalResults = nil
        }
    }
}

public struct SearchTasksOutput: Swift.Equatable {
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// Tasks in the search.
    /// This member is required.
    public var tasks: [DeadlineClientTypes.TaskSearchSummary]?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?

    public init(
        nextItemOffset: Swift.Int? = nil,
        tasks: [DeadlineClientTypes.TaskSearchSummary]? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.nextItemOffset = nextItemOffset
        self.tasks = tasks
        self.totalResults = totalResults
    }
}

struct SearchTasksOutputBody: Swift.Equatable {
    let tasks: [DeadlineClientTypes.TaskSearchSummary]?
    let nextItemOffset: Swift.Int?
    let totalResults: Swift.Int?
}

extension SearchTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextItemOffset
        case tasks
        case totalResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.TaskSearchSummary?].self, forKey: .tasks)
        var tasksDecoded0:[DeadlineClientTypes.TaskSearchSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [DeadlineClientTypes.TaskSearchSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextItemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextItemOffset)
        nextItemOffset = nextItemOffsetDecoded
        let totalResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResults)
        totalResults = totalResultsDecoded
    }
}

enum SearchTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.SearchTermFilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchTerm
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchTerm = self.searchTerm {
            try encodeContainer.encode(searchTerm, forKey: .searchTerm)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchTermDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchTerm)
        searchTerm = searchTermDecoded
    }
}

extension DeadlineClientTypes {
    /// Searches for a particular search term.
    public struct SearchTermFilterExpression: Swift.Equatable {
        /// The term to search for.
        /// This member is required.
        public var searchTerm: Swift.String?

        public init(
            searchTerm: Swift.String? = nil
        )
        {
            self.searchTerm = searchTerm
        }
    }

}

extension SearchWorkersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case fleetIds
        case itemOffset
        case pageSize
        case sortExpressions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpressions = self.filterExpressions {
            try encodeContainer.encode(filterExpressions, forKey: .filterExpressions)
        }
        if let fleetIds = fleetIds {
            var fleetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fleetIds)
            for fleetid0 in fleetIds {
                try fleetIdsContainer.encode(fleetid0)
            }
        }
        if let itemOffset = self.itemOffset {
            try encodeContainer.encode(itemOffset, forKey: .itemOffset)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let sortExpressions = sortExpressions {
            var sortExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortExpressions)
            for searchsortexpression0 in sortExpressions {
                try sortExpressionsContainer.encode(searchsortexpression0)
            }
        }
    }
}

extension SearchWorkersInput {

    static func urlPathProvider(_ value: SearchWorkersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/workers"
    }
}

public struct SearchWorkersInput: Swift.Equatable {
    /// The farm ID in the workers search.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// The fleet ID of the workers to search for.
    /// This member is required.
    public var fleetIds: [Swift.String]?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        fleetIds: [Swift.String]? = nil,
        itemOffset: Swift.Int? = nil,
        pageSize: Swift.Int? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.fleetIds = fleetIds
        self.itemOffset = itemOffset
        self.pageSize = pageSize
        self.sortExpressions = sortExpressions
    }
}

struct SearchWorkersInputBody: Swift.Equatable {
    let fleetIds: [Swift.String]?
    let filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    let sortExpressions: [DeadlineClientTypes.SearchSortExpression]?
    let itemOffset: Swift.Int?
    let pageSize: Swift.Int?
}

extension SearchWorkersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpressions
        case fleetIds
        case itemOffset
        case pageSize
        case sortExpressions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fleetIds)
        var fleetIdsDecoded0:[Swift.String]? = nil
        if let fleetIdsContainer = fleetIdsContainer {
            fleetIdsDecoded0 = [Swift.String]()
            for string0 in fleetIdsContainer {
                if let string0 = string0 {
                    fleetIdsDecoded0?.append(string0)
                }
            }
        }
        fleetIds = fleetIdsDecoded0
        let filterExpressionsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SearchGroupedFilterExpressions.self, forKey: .filterExpressions)
        filterExpressions = filterExpressionsDecoded
        let sortExpressionsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.SearchSortExpression?].self, forKey: .sortExpressions)
        var sortExpressionsDecoded0:[DeadlineClientTypes.SearchSortExpression]? = nil
        if let sortExpressionsContainer = sortExpressionsContainer {
            sortExpressionsDecoded0 = [DeadlineClientTypes.SearchSortExpression]()
            for union0 in sortExpressionsContainer {
                if let union0 = union0 {
                    sortExpressionsDecoded0?.append(union0)
                }
            }
        }
        sortExpressions = sortExpressionsDecoded0
        let itemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemOffset)
        itemOffset = itemOffsetDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension SearchWorkersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchWorkersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextItemOffset = output.nextItemOffset
            self.totalResults = output.totalResults
            self.workers = output.workers
        } else {
            self.nextItemOffset = nil
            self.totalResults = nil
            self.workers = nil
        }
    }
}

public struct SearchWorkersOutput: Swift.Equatable {
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?
    /// The workers for the search.
    /// This member is required.
    public var workers: [DeadlineClientTypes.WorkerSearchSummary]?

    public init(
        nextItemOffset: Swift.Int? = nil,
        totalResults: Swift.Int? = nil,
        workers: [DeadlineClientTypes.WorkerSearchSummary]? = nil
    )
    {
        self.nextItemOffset = nextItemOffset
        self.totalResults = totalResults
        self.workers = workers
    }
}

struct SearchWorkersOutputBody: Swift.Equatable {
    let workers: [DeadlineClientTypes.WorkerSearchSummary]?
    let nextItemOffset: Swift.Int?
    let totalResults: Swift.Int?
}

extension SearchWorkersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextItemOffset
        case totalResults
        case workers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workersContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.WorkerSearchSummary?].self, forKey: .workers)
        var workersDecoded0:[DeadlineClientTypes.WorkerSearchSummary]? = nil
        if let workersContainer = workersContainer {
            workersDecoded0 = [DeadlineClientTypes.WorkerSearchSummary]()
            for structure0 in workersContainer {
                if let structure0 = structure0 {
                    workersDecoded0?.append(structure0)
                }
            }
        }
        workers = workersDecoded0
        let nextItemOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextItemOffset)
        nextItemOffset = nextItemOffsetDecoded
        let totalResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResults)
        totalResults = totalResultsDecoded
    }
}

enum SearchWorkersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.ServiceManagedEc2FleetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCapabilities
        case instanceMarketOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceCapabilities = self.instanceCapabilities {
            try encodeContainer.encode(instanceCapabilities, forKey: .instanceCapabilities)
        }
        if let instanceMarketOptions = self.instanceMarketOptions {
            try encodeContainer.encode(instanceMarketOptions, forKey: .instanceMarketOptions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceCapabilitiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities.self, forKey: .instanceCapabilities)
        instanceCapabilities = instanceCapabilitiesDecoded
        let instanceMarketOptionsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions.self, forKey: .instanceMarketOptions)
        instanceMarketOptions = instanceMarketOptionsDecoded
    }
}

extension DeadlineClientTypes {
    /// The configuration details for a service managed Amazon EC2 fleet.
    public struct ServiceManagedEc2FleetConfiguration: Swift.Equatable {
        /// The Amazon EC2 instance capabilities.
        /// This member is required.
        public var instanceCapabilities: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities?
        /// The Amazon EC2 market type.
        /// This member is required.
        public var instanceMarketOptions: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions?

        public init(
            instanceCapabilities: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities? = nil,
            instanceMarketOptions: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions? = nil
        )
        {
            self.instanceCapabilities = instanceCapabilities
            self.instanceMarketOptions = instanceMarketOptions
        }
    }

}

extension DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedInstanceTypes
        case cpuArchitectureType
        case customAmounts
        case customAttributes
        case excludedInstanceTypes
        case memoryMiB
        case osFamily
        case rootEbsVolume
        case vCpuCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedInstanceTypes = allowedInstanceTypes {
            var allowedInstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedInstanceTypes)
            for instancetype0 in allowedInstanceTypes {
                try allowedInstanceTypesContainer.encode(instancetype0)
            }
        }
        if let cpuArchitectureType = self.cpuArchitectureType {
            try encodeContainer.encode(cpuArchitectureType.rawValue, forKey: .cpuArchitectureType)
        }
        if let customAmounts = customAmounts {
            var customAmountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customAmounts)
            for fleetamountcapability0 in customAmounts {
                try customAmountsContainer.encode(fleetamountcapability0)
            }
        }
        if let customAttributes = customAttributes {
            var customAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customAttributes)
            for fleetattributecapability0 in customAttributes {
                try customAttributesContainer.encode(fleetattributecapability0)
            }
        }
        if let excludedInstanceTypes = excludedInstanceTypes {
            var excludedInstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedInstanceTypes)
            for instancetype0 in excludedInstanceTypes {
                try excludedInstanceTypesContainer.encode(instancetype0)
            }
        }
        if let memoryMiB = self.memoryMiB {
            try encodeContainer.encode(memoryMiB, forKey: .memoryMiB)
        }
        if let osFamily = self.osFamily {
            try encodeContainer.encode(osFamily.rawValue, forKey: .osFamily)
        }
        if let rootEbsVolume = self.rootEbsVolume {
            try encodeContainer.encode(rootEbsVolume, forKey: .rootEbsVolume)
        }
        if let vCpuCount = self.vCpuCount {
            try encodeContainer.encode(vCpuCount, forKey: .vCpuCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCpuCountDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.VCpuCountRange.self, forKey: .vCpuCount)
        vCpuCount = vCpuCountDecoded
        let memoryMiBDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.MemoryMiBRange.self, forKey: .memoryMiB)
        memoryMiB = memoryMiBDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ServiceManagedFleetOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
        let cpuArchitectureTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.CpuArchitectureType.self, forKey: .cpuArchitectureType)
        cpuArchitectureType = cpuArchitectureTypeDecoded
        let rootEbsVolumeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Ec2EbsVolume.self, forKey: .rootEbsVolume)
        rootEbsVolume = rootEbsVolumeDecoded
        let allowedInstanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedInstanceTypes)
        var allowedInstanceTypesDecoded0:[Swift.String]? = nil
        if let allowedInstanceTypesContainer = allowedInstanceTypesContainer {
            allowedInstanceTypesDecoded0 = [Swift.String]()
            for string0 in allowedInstanceTypesContainer {
                if let string0 = string0 {
                    allowedInstanceTypesDecoded0?.append(string0)
                }
            }
        }
        allowedInstanceTypes = allowedInstanceTypesDecoded0
        let excludedInstanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedInstanceTypes)
        var excludedInstanceTypesDecoded0:[Swift.String]? = nil
        if let excludedInstanceTypesContainer = excludedInstanceTypesContainer {
            excludedInstanceTypesDecoded0 = [Swift.String]()
            for string0 in excludedInstanceTypesContainer {
                if let string0 = string0 {
                    excludedInstanceTypesDecoded0?.append(string0)
                }
            }
        }
        excludedInstanceTypes = excludedInstanceTypesDecoded0
        let customAmountsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetAmountCapability?].self, forKey: .customAmounts)
        var customAmountsDecoded0:[DeadlineClientTypes.FleetAmountCapability]? = nil
        if let customAmountsContainer = customAmountsContainer {
            customAmountsDecoded0 = [DeadlineClientTypes.FleetAmountCapability]()
            for structure0 in customAmountsContainer {
                if let structure0 = structure0 {
                    customAmountsDecoded0?.append(structure0)
                }
            }
        }
        customAmounts = customAmountsDecoded0
        let customAttributesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FleetAttributeCapability?].self, forKey: .customAttributes)
        var customAttributesDecoded0:[DeadlineClientTypes.FleetAttributeCapability]? = nil
        if let customAttributesContainer = customAttributesContainer {
            customAttributesDecoded0 = [DeadlineClientTypes.FleetAttributeCapability]()
            for structure0 in customAttributesContainer {
                if let structure0 = structure0 {
                    customAttributesDecoded0?.append(structure0)
                }
            }
        }
        customAttributes = customAttributesDecoded0
    }
}

extension DeadlineClientTypes {
    /// The Amazon EC2 instance capabilities.
    public struct ServiceManagedEc2InstanceCapabilities: Swift.Equatable {
        /// The allowable Amazon EC2 instance types.
        public var allowedInstanceTypes: [Swift.String]?
        /// The CPU architecture type.
        /// This member is required.
        public var cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType?
        /// The custom capability amounts to require for instances in this fleet.
        public var customAmounts: [DeadlineClientTypes.FleetAmountCapability]?
        /// The custom capability attributes to require for instances in this fleet.
        public var customAttributes: [DeadlineClientTypes.FleetAttributeCapability]?
        /// The instance types to exclude from the fleet.
        public var excludedInstanceTypes: [Swift.String]?
        /// The memory, as MiB, for the Amazon EC2 instance type.
        /// This member is required.
        public var memoryMiB: DeadlineClientTypes.MemoryMiBRange?
        /// The operating system (OS) family.
        /// This member is required.
        public var osFamily: DeadlineClientTypes.ServiceManagedFleetOperatingSystemFamily?
        /// The root EBS volume.
        public var rootEbsVolume: DeadlineClientTypes.Ec2EbsVolume?
        /// The amount of vCPU to require for instances in this fleet.
        /// This member is required.
        public var vCpuCount: DeadlineClientTypes.VCpuCountRange?

        public init(
            allowedInstanceTypes: [Swift.String]? = nil,
            cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType? = nil,
            customAmounts: [DeadlineClientTypes.FleetAmountCapability]? = nil,
            customAttributes: [DeadlineClientTypes.FleetAttributeCapability]? = nil,
            excludedInstanceTypes: [Swift.String]? = nil,
            memoryMiB: DeadlineClientTypes.MemoryMiBRange? = nil,
            osFamily: DeadlineClientTypes.ServiceManagedFleetOperatingSystemFamily? = nil,
            rootEbsVolume: DeadlineClientTypes.Ec2EbsVolume? = nil,
            vCpuCount: DeadlineClientTypes.VCpuCountRange? = nil
        )
        {
            self.allowedInstanceTypes = allowedInstanceTypes
            self.cpuArchitectureType = cpuArchitectureType
            self.customAmounts = customAmounts
            self.customAttributes = customAttributes
            self.excludedInstanceTypes = excludedInstanceTypes
            self.memoryMiB = memoryMiB
            self.osFamily = osFamily
            self.rootEbsVolume = rootEbsVolume
            self.vCpuCount = vCpuCount
        }
    }

}

extension DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Ec2MarketType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of the Amazon EC2 instance market options for a service managed fleet.
    public struct ServiceManagedEc2InstanceMarketOptions: Swift.Equatable {
        /// The Amazon EC2 instance type.
        /// This member is required.
        public var type: DeadlineClientTypes.Ec2MarketType?

        public init(
            type: DeadlineClientTypes.Ec2MarketType? = nil
        )
        {
            self.type = type
        }
    }

}

extension DeadlineClientTypes {
    public enum ServiceManagedFleetOperatingSystemFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceManagedFleetOperatingSystemFamily] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceManagedFleetOperatingSystemFamily(rawValue: rawValue) ?? ServiceManagedFleetOperatingSystemFamily.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.reason = output.reason
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.context = nil
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.reason = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifies the quota that has been exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// A string that describes the reason the quota was exceeded.
        /// This member is required.
        public internal(set) var reason: DeadlineClientTypes.ServiceQuotaExceededExceptionReason? = nil
        /// The identifier of the affected resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the affected resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Identifies the service that exceeded the quota.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        reason: DeadlineClientTypes.ServiceQuotaExceededExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: DeadlineClientTypes.ServiceQuotaExceededExceptionReason?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let resourceId: Swift.String?
    let context: [Swift.String:Swift.String]?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case message
        case quotaCode
        case reason
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
    }
}

extension DeadlineClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kmsKeyLimitExceeded
        case serviceQuotaExceededException
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .kmsKeyLimitExceeded,
                .serviceQuotaExceededException,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kmsKeyLimitExceeded: return "KMS_KEY_LIMIT_EXCEEDED"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.SessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enventer = "envEnter"
        case envexit = "envExit"
        case sdkUnknown
        case syncinputjobattachments = "syncInputJobAttachments"
        case taskrun = "taskRun"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .enventer(enventer):
                try container.encode(enventer, forKey: .enventer)
            case let .envexit(envexit):
                try container.encode(envexit, forKey: .envexit)
            case let .syncinputjobattachments(syncinputjobattachments):
                try container.encode(syncinputjobattachments, forKey: .syncinputjobattachments)
            case let .taskrun(taskrun):
                try container.encode(taskrun, forKey: .taskrun)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let enventerDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentEnterSessionActionDefinition.self, forKey: .enventer)
        if let enventer = enventerDecoded {
            self = .enventer(enventer)
            return
        }
        let envexitDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentExitSessionActionDefinition.self, forKey: .envexit)
        if let envexit = envexitDecoded {
            self = .envexit(envexit)
            return
        }
        let taskrunDecoded = try values.decodeIfPresent(DeadlineClientTypes.TaskRunSessionActionDefinition.self, forKey: .taskrun)
        if let taskrun = taskrunDecoded {
            self = .taskrun(taskrun)
            return
        }
        let syncinputjobattachmentsDecoded = try values.decodeIfPresent(DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition.self, forKey: .syncinputjobattachments)
        if let syncinputjobattachments = syncinputjobattachmentsDecoded {
            self = .syncinputjobattachments(syncinputjobattachments)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The definition of the session action.
    public enum SessionActionDefinition: Swift.Equatable {
        /// The environment to enter into.
        case enventer(DeadlineClientTypes.EnvironmentEnterSessionActionDefinition)
        /// The environment to exit from.
        case envexit(DeadlineClientTypes.EnvironmentExitSessionActionDefinition)
        /// The task run in the session.
        case taskrun(DeadlineClientTypes.TaskRunSessionActionDefinition)
        /// The job attachments to sync with a session action.
        case syncinputjobattachments(DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes.SessionActionDefinitionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enventer = "envEnter"
        case envexit = "envExit"
        case sdkUnknown
        case syncinputjobattachments = "syncInputJobAttachments"
        case taskrun = "taskRun"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .enventer(enventer):
                try container.encode(enventer, forKey: .enventer)
            case let .envexit(envexit):
                try container.encode(envexit, forKey: .envexit)
            case let .syncinputjobattachments(syncinputjobattachments):
                try container.encode(syncinputjobattachments, forKey: .syncinputjobattachments)
            case let .taskrun(taskrun):
                try container.encode(taskrun, forKey: .taskrun)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let enventerDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary.self, forKey: .enventer)
        if let enventer = enventerDecoded {
            self = .enventer(enventer)
            return
        }
        let envexitDecoded = try values.decodeIfPresent(DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary.self, forKey: .envexit)
        if let envexit = envexitDecoded {
            self = .envexit(envexit)
            return
        }
        let taskrunDecoded = try values.decodeIfPresent(DeadlineClientTypes.TaskRunSessionActionDefinitionSummary.self, forKey: .taskrun)
        if let taskrun = taskrunDecoded {
            self = .taskrun(taskrun)
            return
        }
        let syncinputjobattachmentsDecoded = try values.decodeIfPresent(DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary.self, forKey: .syncinputjobattachments)
        if let syncinputjobattachments = syncinputjobattachmentsDecoded {
            self = .syncinputjobattachments(syncinputjobattachments)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The details of a session action definition.
    public enum SessionActionDefinitionSummary: Swift.Equatable {
        /// The environment to enter into.
        case enventer(DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary)
        /// The environment to exit from.
        case envexit(DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary)
        /// The task run.
        case taskrun(DeadlineClientTypes.TaskRunSessionActionDefinitionSummary)
        /// The job attachments to sync with the session action definition.
        case syncinputjobattachments(DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes {
    public enum SessionActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assigned
        case canceled
        case canceling
        case failed
        case interrupted
        case neverAttempted
        case reclaimed
        case reclaiming
        case running
        case scheduled
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionActionStatus] {
            return [
                .assigned,
                .canceled,
                .canceling,
                .failed,
                .interrupted,
                .neverAttempted,
                .reclaimed,
                .reclaiming,
                .running,
                .scheduled,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .neverAttempted: return "NEVER_ATTEMPTED"
            case .reclaimed: return "RECLAIMED"
            case .reclaiming: return "RECLAIMING"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionActionStatus(rawValue: rawValue) ?? SessionActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.SessionActionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case endedAt
        case progressPercent
        case sessionActionId
        case startedAt
        case status
        case workerUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let sessionActionId = self.sessionActionId {
            try encodeContainer.encode(sessionActionId, forKey: .sessionActionId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workerUpdatedAt = self.workerUpdatedAt {
            try encodeContainer.encodeTimestamp(workerUpdatedAt, format: .dateTime, forKey: .workerUpdatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionActionId)
        sessionActionId = sessionActionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionActionStatus.self, forKey: .status)
        status = statusDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let workerUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .workerUpdatedAt)
        workerUpdatedAt = workerUpdatedAtDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionActionDefinitionSummary.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a session action.
    public struct SessionActionSummary: Swift.Equatable {
        /// The session action definition.
        /// This member is required.
        public var definition: DeadlineClientTypes.SessionActionDefinitionSummary?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The completion percentage for the session action.
        public var progressPercent: Swift.Float?
        /// The session action ID.
        /// This member is required.
        public var sessionActionId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The status of the session action.
        /// This member is required.
        public var status: DeadlineClientTypes.SessionActionStatus?
        /// The Linux timestamp of the last date and time that the session action was updated.
        public var workerUpdatedAt: ClientRuntime.Date?

        public init(
            definition: DeadlineClientTypes.SessionActionDefinitionSummary? = nil,
            endedAt: ClientRuntime.Date? = nil,
            progressPercent: Swift.Float? = nil,
            sessionActionId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: DeadlineClientTypes.SessionActionStatus? = nil,
            workerUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.definition = definition
            self.endedAt = endedAt
            self.progressPercent = progressPercent
            self.sessionActionId = sessionActionId
            self.startedAt = startedAt
            self.status = status
            self.workerUpdatedAt = workerUpdatedAt
        }
    }

}

extension DeadlineClientTypes {
    public enum SessionLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ended
        case started
        case updateFailed
        case updateInProgress
        case updateSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionLifecycleStatus] {
            return [
                .ended,
                .started,
                .updateFailed,
                .updateInProgress,
                .updateSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .started: return "STARTED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSucceeded: return "UPDATE_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionLifecycleStatus(rawValue: rawValue) ?? SessionLifecycleStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum SessionLifecycleTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ended
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionLifecycleTargetStatus] {
            return [
                .ended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionLifecycleTargetStatus(rawValue: rawValue) ?? SessionLifecycleTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.SessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt
        case fleetId
        case lifecycleStatus
        case sessionId
        case startedAt
        case targetLifecycleStatus
        case updatedAt
        case updatedBy
        case workerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let targetLifecycleStatus = self.targetLifecycleStatus {
            try encodeContainer.encode(targetLifecycleStatus.rawValue, forKey: .targetLifecycleStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let workerId = self.workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let targetLifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleTargetStatus.self, forKey: .targetLifecycleStatus)
        targetLifecycleStatus = targetLifecycleStatusDecoded
    }
}

extension DeadlineClientTypes {
    /// The summary of a session.
    public struct SessionSummary: Swift.Equatable {
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The life cycle status for the session.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
        /// The session ID.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The date and time the resource started running.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The target life cycle status for the session.
        public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The worker ID.
        /// This member is required.
        public var workerId: Swift.String?

        public init(
            endedAt: ClientRuntime.Date? = nil,
            fleetId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus? = nil,
            sessionId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.endedAt = endedAt
            self.fleetId = fleetId
            self.lifecycleStatus = lifecycleStatus
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }
    }

}

extension DeadlineClientTypes {
    public enum SessionsStatisticsAggregationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionsStatisticsAggregationStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionsStatisticsAggregationStatus(rawValue: rawValue) ?? SessionsStatisticsAggregationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.SessionsStatisticsResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetids = "fleetIds"
        case queueids = "queueIds"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fleetids(fleetids):
                var fleetidsContainer = container.nestedUnkeyedContainer(forKey: .fleetids)
                for fleetid0 in fleetids {
                    try fleetidsContainer.encode(fleetid0)
                }
            case let .queueids(queueids):
                var queueidsContainer = container.nestedUnkeyedContainer(forKey: .queueids)
                for queueid0 in queueids {
                    try queueidsContainer.encode(queueid0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let queueidsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .queueids)
        var queueidsDecoded0:[Swift.String]? = nil
        if let queueidsContainer = queueidsContainer {
            queueidsDecoded0 = [Swift.String]()
            for string0 in queueidsContainer {
                if let string0 = string0 {
                    queueidsDecoded0?.append(string0)
                }
            }
        }
        if let queueids = queueidsDecoded0 {
            self = .queueids(queueids)
            return
        }
        let fleetidsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .fleetids)
        var fleetidsDecoded0:[Swift.String]? = nil
        if let fleetidsContainer = fleetidsContainer {
            fleetidsDecoded0 = [Swift.String]()
            for string0 in fleetidsContainer {
                if let string0 = string0 {
                    fleetidsDecoded0?.append(string0)
                }
            }
        }
        if let fleetids = fleetidsDecoded0 {
            self = .fleetids(fleetids)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// Specifies the fleet IDs or queue IDs to return statistics. You can specify only fleet IDs or queue IDS, not both.
    public enum SessionsStatisticsResources: Swift.Equatable {
        /// One to 10 queue IDs that specify the queues to return statistics for. If you specify the queueIds field, you can't specify the fleetIds field.
        case queueids([Swift.String])
        /// One to 10 fleet IDs that specify the fleets to return statistics for. If you specify the fleetIds field, you can't specify the queueIds field.
        case fleetids([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartSessionsStatisticsAggregationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groupBy
        case period
        case resourceIds
        case startTime
        case statistics
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for usagegroupbyfield0 in groupBy {
                try groupByContainer.encode(usagegroupbyfield0.rawValue)
            }
        }
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let resourceIds = self.resourceIds {
            try encodeContainer.encode(resourceIds, forKey: .resourceIds)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let statistics = statistics {
            var statisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statistics)
            for usagestatistic0 in statistics {
                try statisticsContainer.encode(usagestatistic0.rawValue)
            }
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }
}

extension StartSessionsStatisticsAggregationInput {

    static func urlPathProvider(_ value: StartSessionsStatisticsAggregationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/sessions-statistics-aggregation"
    }
}

public struct StartSessionsStatisticsAggregationInput: Swift.Equatable {
    /// The Linux timestamp of the date and time that the statistics end.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The identifier of the farm that contains queues or fleets to return statistics for.
    /// This member is required.
    public var farmId: Swift.String?
    /// The field to use to group the statistics.
    /// This member is required.
    public var groupBy: [DeadlineClientTypes.UsageGroupByField]?
    /// The period to aggregate the statistics.
    public var period: DeadlineClientTypes.Period?
    /// A list of fleet IDs or queue IDs to gather statistics for.
    /// This member is required.
    public var resourceIds: DeadlineClientTypes.SessionsStatisticsResources?
    /// The Linux timestamp of the date and time that the statistics start.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// One to four statistics to return.
    /// This member is required.
    public var statistics: [DeadlineClientTypes.UsageStatistic]?
    /// The timezone to use for the statistics. Use UTC notation such as "UTC+8."
    public var timezone: Swift.String?

    public init(
        endTime: ClientRuntime.Date? = nil,
        farmId: Swift.String? = nil,
        groupBy: [DeadlineClientTypes.UsageGroupByField]? = nil,
        period: DeadlineClientTypes.Period? = nil,
        resourceIds: DeadlineClientTypes.SessionsStatisticsResources? = nil,
        startTime: ClientRuntime.Date? = nil,
        statistics: [DeadlineClientTypes.UsageStatistic]? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.farmId = farmId
        self.groupBy = groupBy
        self.period = period
        self.resourceIds = resourceIds
        self.startTime = startTime
        self.statistics = statistics
        self.timezone = timezone
    }
}

struct StartSessionsStatisticsAggregationInputBody: Swift.Equatable {
    let resourceIds: DeadlineClientTypes.SessionsStatisticsResources?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let timezone: Swift.String?
    let period: DeadlineClientTypes.Period?
    let groupBy: [DeadlineClientTypes.UsageGroupByField]?
    let statistics: [DeadlineClientTypes.UsageStatistic]?
}

extension StartSessionsStatisticsAggregationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groupBy
        case period
        case resourceIds
        case startTime
        case statistics
        case timezone
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionsStatisticsResources.self, forKey: .resourceIds)
        resourceIds = resourceIdsDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let periodDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Period.self, forKey: .period)
        period = periodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.UsageGroupByField?].self, forKey: .groupBy)
        var groupByDecoded0:[DeadlineClientTypes.UsageGroupByField]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [DeadlineClientTypes.UsageGroupByField]()
            for enum0 in groupByContainer {
                if let enum0 = enum0 {
                    groupByDecoded0?.append(enum0)
                }
            }
        }
        groupBy = groupByDecoded0
        let statisticsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.UsageStatistic?].self, forKey: .statistics)
        var statisticsDecoded0:[DeadlineClientTypes.UsageStatistic]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [DeadlineClientTypes.UsageStatistic]()
            for enum0 in statisticsContainer {
                if let enum0 = enum0 {
                    statisticsDecoded0?.append(enum0)
                }
            }
        }
        statistics = statisticsDecoded0
    }
}

extension StartSessionsStatisticsAggregationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSessionsStatisticsAggregationOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationId = output.aggregationId
        } else {
            self.aggregationId = nil
        }
    }
}

public struct StartSessionsStatisticsAggregationOutput: Swift.Equatable {
    /// A unique identifier for the aggregated statistics. Use this identifier with the GetAggregatedStatisticsForSessions operation to return the statistics.
    /// This member is required.
    public var aggregationId: Swift.String?

    public init(
        aggregationId: Swift.String? = nil
    )
    {
        self.aggregationId = aggregationId
    }
}

struct StartSessionsStatisticsAggregationOutputBody: Swift.Equatable {
    let aggregationId: Swift.String?
}

extension StartSessionsStatisticsAggregationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationId)
        aggregationId = aggregationIdDecoded
    }
}

enum StartSessionsStatisticsAggregationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationEndTime
        case aggregationStartTime
        case costInUsd
        case count
        case fleetId
        case instanceType
        case jobId
        case jobName
        case licenseProduct
        case queueId
        case runtimeInSeconds
        case usageType
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationEndTime = self.aggregationEndTime {
            try encodeContainer.encodeTimestamp(aggregationEndTime, format: .dateTime, forKey: .aggregationEndTime)
        }
        if let aggregationStartTime = self.aggregationStartTime {
            try encodeContainer.encodeTimestamp(aggregationStartTime, format: .dateTime, forKey: .aggregationStartTime)
        }
        if let costInUsd = self.costInUsd {
            try encodeContainer.encode(costInUsd, forKey: .costInUsd)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let licenseProduct = self.licenseProduct {
            try encodeContainer.encode(licenseProduct, forKey: .licenseProduct)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let runtimeInSeconds = self.runtimeInSeconds {
            try encodeContainer.encode(runtimeInSeconds, forKey: .runtimeInSeconds)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType.rawValue, forKey: .usageType)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UsageType.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let licenseProductDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseProduct)
        licenseProduct = licenseProductDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let costInUsdDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Stats.self, forKey: .costInUsd)
        costInUsd = costInUsdDecoded
        let runtimeInSecondsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.Stats.self, forKey: .runtimeInSeconds)
        runtimeInSeconds = runtimeInSecondsDecoded
        let aggregationStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .aggregationStartTime)
        aggregationStartTime = aggregationStartTimeDecoded
        let aggregationEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .aggregationEndTime)
        aggregationEndTime = aggregationEndTimeDecoded
    }
}

extension DeadlineClientTypes {
    /// A list of statistics for a session.
    public struct Statistics: Swift.Equatable {
        /// The end time for the aggregation.
        public var aggregationEndTime: ClientRuntime.Date?
        /// The start time for the aggregation.
        public var aggregationStartTime: ClientRuntime.Date?
        /// How the statistics should appear in USD. Options include: minimum, maximum, average or sum.
        /// This member is required.
        public var costInUsd: DeadlineClientTypes.Stats?
        /// The number of instances in a list of statistics.
        /// This member is required.
        public var count: Swift.Int?
        /// The fleet ID.
        public var fleetId: Swift.String?
        /// The type of instance.
        public var instanceType: Swift.String?
        /// The job ID.
        public var jobId: Swift.String?
        /// The job name.
        public var jobName: Swift.String?
        /// The licensed product.
        public var licenseProduct: Swift.String?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The total aggregated runtime.
        /// This member is required.
        public var runtimeInSeconds: DeadlineClientTypes.Stats?
        /// The type of usage for the statistics.
        public var usageType: DeadlineClientTypes.UsageType?
        /// The user ID.
        public var userId: Swift.String?

        public init(
            aggregationEndTime: ClientRuntime.Date? = nil,
            aggregationStartTime: ClientRuntime.Date? = nil,
            costInUsd: DeadlineClientTypes.Stats? = nil,
            count: Swift.Int? = nil,
            fleetId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            licenseProduct: Swift.String? = nil,
            queueId: Swift.String? = nil,
            runtimeInSeconds: DeadlineClientTypes.Stats? = nil,
            usageType: DeadlineClientTypes.UsageType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.aggregationEndTime = aggregationEndTime
            self.aggregationStartTime = aggregationStartTime
            self.costInUsd = costInUsd
            self.count = count
            self.fleetId = fleetId
            self.instanceType = instanceType
            self.jobId = jobId
            self.jobName = jobName
            self.licenseProduct = licenseProduct
            self.queueId = queueId
            self.runtimeInSeconds = runtimeInSeconds
            self.usageType = usageType
            self.userId = userId
        }
    }

}

extension DeadlineClientTypes.Stats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avg
        case max
        case min
        case sum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avg = self.avg {
            try encodeContainer.encode(avg, forKey: .avg)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let sum = self.sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let avgDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avg)
        avg = avgDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
    }
}

extension DeadlineClientTypes {
    /// The minimum, maximum, average, and sum.
    public struct Stats: Swift.Equatable {
        /// The average of the usage statistics.
        public var avg: Swift.Double?
        /// The maximum among the usage statistics.
        public var max: Swift.Double?
        /// The minimum of the usage statistics.
        public var min: Swift.Double?
        /// The sum of the usage statistics.
        public var sum: Swift.Double?

        public init(
            avg: Swift.Double? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.max = max
            self.min = min
            self.sum = sum
        }
    }

}

extension DeadlineClientTypes.StepAmountCapability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeadlineClientTypes {
    /// The details outlining the minimum and maximum capability of a step.
    public struct StepAmountCapability: Swift.Equatable {
        /// The maximum amount.
        public var max: Swift.Double?
        /// The minimum amount.
        public var min: Swift.Double?
        /// The name of the step.
        /// This member is required.
        public var name: Swift.String?
        /// The amount value.
        public var value: Swift.Double?

        public init(
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            name: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
            self.name = name
            self.value = value
        }
    }

}

extension DeadlineClientTypes.StepAttributeCapability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allOf
        case anyOf
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allOf = allOf {
            var allOfContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allOf)
            for attributecapabilityvalue0 in allOf {
                try allOfContainer.encode(attributecapabilityvalue0)
            }
        }
        if let anyOf = anyOf {
            var anyOfContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anyOf)
            for attributecapabilityvalue0 in anyOf {
                try anyOfContainer.encode(attributecapabilityvalue0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let anyOfContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .anyOf)
        var anyOfDecoded0:[Swift.String]? = nil
        if let anyOfContainer = anyOfContainer {
            anyOfDecoded0 = [Swift.String]()
            for string0 in anyOfContainer {
                if let string0 = string0 {
                    anyOfDecoded0?.append(string0)
                }
            }
        }
        anyOf = anyOfDecoded0
        let allOfContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allOf)
        var allOfDecoded0:[Swift.String]? = nil
        if let allOfContainer = allOfContainer {
            allOfDecoded0 = [Swift.String]()
            for string0 in allOfContainer {
                if let string0 = string0 {
                    allOfDecoded0?.append(string0)
                }
            }
        }
        allOf = allOfDecoded0
    }
}

extension DeadlineClientTypes {
    /// The list of step attributes.
    public struct StepAttributeCapability: Swift.Equatable {
        /// Requires all of the step attribute values.
        public var allOf: [Swift.String]?
        /// Requires any of the step attributes in a given list.
        public var anyOf: [Swift.String]?
        /// The name of the step attribute.
        /// This member is required.
        public var name: Swift.String?

        public init(
            allOf: [Swift.String]? = nil,
            anyOf: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.allOf = allOf
            self.anyOf = anyOf
            self.name = name
        }
    }

}

extension DeadlineClientTypes.StepConsumer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DependencyConsumerResolutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a step consumer.
    public struct StepConsumer: Swift.Equatable {
        /// The step consumer status.
        /// This member is required.
        public var status: DeadlineClientTypes.DependencyConsumerResolutionStatus?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            status: DeadlineClientTypes.DependencyConsumerResolutionStatus? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.status = status
            self.stepId = stepId
        }
    }

}

extension DeadlineClientTypes.StepDependency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DependencyConsumerResolutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of step dependency.
    public struct StepDependency: Swift.Equatable {
        /// The step dependency status.
        /// This member is required.
        public var status: DeadlineClientTypes.DependencyConsumerResolutionStatus?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            status: DeadlineClientTypes.DependencyConsumerResolutionStatus? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.status = status
            self.stepId = stepId
        }
    }

}

extension DeadlineClientTypes.StepDetailsEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case jobId
        case schemaVersion
        case stepId
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencies = dependencies {
            var dependenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependencies)
            for stepid0 in dependencies {
                try dependenciesContainer.encode(stepid0)
            }
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let templateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .template)
        template = templateDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dependencies)
        var dependenciesDecoded0:[Swift.String]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [Swift.String]()
            for string0 in dependenciesContainer {
                if let string0 = string0 {
                    dependenciesDecoded0?.append(string0)
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

extension DeadlineClientTypes.StepDetailsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StepDetailsEntity(dependencies: \(Swift.String(describing: dependencies)), jobId: \(Swift.String(describing: jobId)), schemaVersion: \(Swift.String(describing: schemaVersion)), stepId: \(Swift.String(describing: stepId)), template: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The details of a step entity.
    public struct StepDetailsEntity: Swift.Equatable {
        /// The dependencies for a step.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The schema version for a step template.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The template for a step.
        /// This member is required.
        public var template: ClientRuntime.Document?

        public init(
            dependencies: [Swift.String]? = nil,
            jobId: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            stepId: Swift.String? = nil,
            template: ClientRuntime.Document? = nil
        )
        {
            self.dependencies = dependencies
            self.jobId = jobId
            self.schemaVersion = schemaVersion
            self.stepId = stepId
            self.template = template
        }
    }

}

extension DeadlineClientTypes.StepDetailsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case jobId
        case message
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobEntityErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of the step error.
    public struct StepDetailsError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.code = code
            self.jobId = jobId
            self.message = message
            self.stepId = stepId
        }
    }

}

extension DeadlineClientTypes.StepDetailsIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of identifiers for a step.
    public struct StepDetailsIdentifiers: Swift.Equatable {
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            jobId: Swift.String? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.jobId = jobId
            self.stepId = stepId
        }
    }

}

extension DeadlineClientTypes {
    public enum StepLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case updateFailed
        case updateInProgress
        case updateSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StepLifecycleStatus] {
            return [
                .createComplete,
                .updateFailed,
                .updateInProgress,
                .updateSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSucceeded: return "UPDATE_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepLifecycleStatus(rawValue: rawValue) ?? StepLifecycleStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.StepParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepParameterType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a step parameter.
    public struct StepParameter: Swift.Equatable {
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the parameter.
        /// This member is required.
        public var type: DeadlineClientTypes.StepParameterType?

        public init(
            name: Swift.String? = nil,
            type: DeadlineClientTypes.StepParameterType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DeadlineClientTypes {
    public enum StepParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case float
        case int
        case path
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [StepParameterType] {
            return [
                .float,
                .int,
                .path,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float: return "FLOAT"
            case .int: return "INT"
            case .path: return "PATH"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepParameterType(rawValue: rawValue) ?? StepParameterType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.StepRequiredCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amounts
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amounts = amounts {
            var amountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amounts)
            for stepamountcapability0 in amounts {
                try amountsContainer.encode(stepamountcapability0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for stepattributecapability0 in attributes {
                try attributesContainer.encode(stepattributecapability0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepAttributeCapability?].self, forKey: .attributes)
        var attributesDecoded0:[DeadlineClientTypes.StepAttributeCapability]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [DeadlineClientTypes.StepAttributeCapability]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let amountsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.StepAmountCapability?].self, forKey: .amounts)
        var amountsDecoded0:[DeadlineClientTypes.StepAmountCapability]? = nil
        if let amountsContainer = amountsContainer {
            amountsDecoded0 = [DeadlineClientTypes.StepAmountCapability]()
            for structure0 in amountsContainer {
                if let structure0 = structure0 {
                    amountsDecoded0?.append(structure0)
                }
            }
        }
        amounts = amountsDecoded0
    }
}

extension DeadlineClientTypes {
    /// The details of required step capabilities.
    public struct StepRequiredCapabilities: Swift.Equatable {
        /// The capability amounts that the step requires.
        /// This member is required.
        public var amounts: [DeadlineClientTypes.StepAmountCapability]?
        /// The capability attributes that the step requires.
        /// This member is required.
        public var attributes: [DeadlineClientTypes.StepAttributeCapability]?

        public init(
            amounts: [DeadlineClientTypes.StepAmountCapability]? = nil,
            attributes: [DeadlineClientTypes.StepAttributeCapability]? = nil
        )
        {
            self.amounts = amounts
            self.attributes = attributes
        }
    }

}

extension DeadlineClientTypes.StepSearchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case endedAt
        case jobId
        case lifecycleStatus
        case lifecycleStatusMessage
        case name
        case parameterSpace
        case queueId
        case startedAt
        case stepId
        case targetTaskRunStatus
        case taskRunStatus
        case taskRunStatusCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let lifecycleStatusMessage = self.lifecycleStatusMessage {
            try encodeContainer.encode(lifecycleStatusMessage, forKey: .lifecycleStatusMessage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterSpace = self.parameterSpace {
            try encodeContainer.encode(parameterSpace, forKey: .parameterSpace)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
        if let taskRunStatus = self.taskRunStatus {
            try encodeContainer.encode(taskRunStatus.rawValue, forKey: .taskRunStatus)
        }
        if let taskRunStatusCounts = taskRunStatusCounts {
            var taskRunStatusCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskRunStatusCounts)
            for (dictKey0, taskRunStatusCounts0) in taskRunStatusCounts {
                try taskRunStatusCountsContainer.encode(taskRunStatusCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let lifecycleStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStatusMessage)
        lifecycleStatusMessage = lifecycleStatusMessageDecoded
        let taskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .taskRunStatus)
        taskRunStatus = taskRunStatusDecoded
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let taskRunStatusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .taskRunStatusCounts)
        var taskRunStatusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let taskRunStatusCountsContainer = taskRunStatusCountsContainer {
            taskRunStatusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in taskRunStatusCountsContainer {
                if let integer0 = integer0 {
                    taskRunStatusCountsDecoded0?[key0] = integer0
                }
            }
        }
        taskRunStatusCounts = taskRunStatusCountsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let parameterSpaceDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ParameterSpace.self, forKey: .parameterSpace)
        parameterSpace = parameterSpaceDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a step search.
    public struct StepSearchSummary: Swift.Equatable {
        /// The date and time the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The job ID.
        public var jobId: Swift.String?
        /// The life cycle status.
        public var lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
        /// The life cycle status message.
        public var lifecycleStatusMessage: Swift.String?
        /// The step name.
        public var name: Swift.String?
        /// The parameters and combination expressions for the search.
        public var parameterSpace: DeadlineClientTypes.ParameterSpace?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The step ID.
        public var stepId: Swift.String?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to be processed.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to be run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        public var taskRunStatusCounts: [Swift.String:Swift.Int]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            endedAt: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            parameterSpace: DeadlineClientTypes.ParameterSpace? = nil,
            queueId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            stepId: Swift.String? = nil,
            targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.parameterSpace = parameterSpace
            self.queueId = queueId
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
        }
    }

}

extension DeadlineClientTypes.StepSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case dependencyCounts
        case endedAt
        case lifecycleStatus
        case lifecycleStatusMessage
        case name
        case startedAt
        case stepId
        case targetTaskRunStatus
        case taskRunStatus
        case taskRunStatusCounts
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let dependencyCounts = self.dependencyCounts {
            try encodeContainer.encode(dependencyCounts, forKey: .dependencyCounts)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let lifecycleStatusMessage = self.lifecycleStatusMessage {
            try encodeContainer.encode(lifecycleStatusMessage, forKey: .lifecycleStatusMessage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
        if let taskRunStatus = self.taskRunStatus {
            try encodeContainer.encode(taskRunStatus.rawValue, forKey: .taskRunStatus)
        }
        if let taskRunStatusCounts = taskRunStatusCounts {
            var taskRunStatusCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskRunStatusCounts)
            for (dictKey0, taskRunStatusCounts0) in taskRunStatusCounts {
                try taskRunStatusCountsContainer.encode(taskRunStatusCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let lifecycleStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStatusMessage)
        lifecycleStatusMessage = lifecycleStatusMessageDecoded
        let taskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .taskRunStatus)
        taskRunStatus = taskRunStatusDecoded
        let taskRunStatusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .taskRunStatusCounts)
        var taskRunStatusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let taskRunStatusCountsContainer = taskRunStatusCountsContainer {
            taskRunStatusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in taskRunStatusCountsContainer {
                if let integer0 = integer0 {
                    taskRunStatusCountsDecoded0?[key0] = integer0
                }
            }
        }
        taskRunStatusCounts = taskRunStatusCountsDecoded0
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let dependencyCountsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DependencyCounts.self, forKey: .dependencyCounts)
        dependencyCounts = dependencyCountsDecoded
    }
}

extension DeadlineClientTypes {
    /// The details for a step.
    public struct StepSummary: Swift.Equatable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The number of dependencies for the step.
        public var dependencyCounts: DeadlineClientTypes.DependencyCounts?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The life cycle status.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
        /// A message that describes the lifecycle of the step.
        public var lifecycleStatusMessage: Swift.String?
        /// The name of the step.
        /// This member is required.
        public var name: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to process.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        /// This member is required.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        /// This member is required.
        public var taskRunStatusCounts: [Swift.String:Swift.Int]?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            dependencyCounts: DeadlineClientTypes.DependencyCounts? = nil,
            endedAt: ClientRuntime.Date? = nil,
            lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            stepId: Swift.String? = nil,
            targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dependencyCounts = dependencyCounts
            self.endedAt = endedAt
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DeadlineClientTypes {
    public enum StepTargetTaskRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case pending
        case ready
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [StepTargetTaskRunStatus] {
            return [
                .canceled,
                .failed,
                .pending,
                .ready,
                .succeeded,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepTargetTaskRunStatus(rawValue: rawValue) ?? StepTargetTaskRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum StorageProfileOperatingSystemFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageProfileOperatingSystemFamily] {
            return [
                .linux,
                .macos,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .macos: return "MACOS"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageProfileOperatingSystemFamily(rawValue: rawValue) ?? StorageProfileOperatingSystemFamily.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.StorageProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case osFamily
        case storageProfileId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let osFamily = self.osFamily {
            try encodeContainer.encode(osFamily.rawValue, forKey: .osFamily)
        }
        if let storageProfileId = self.storageProfileId {
            try encodeContainer.encode(storageProfileId, forKey: .storageProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageProfileId)
        storageProfileId = storageProfileIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StorageProfileOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a storage profile.
    public struct StorageProfileSummary: Swift.Equatable {
        /// The display name of the storage profile summary to update.
        /// This member is required.
        public var displayName: Swift.String?
        /// The operating system (OS) family.
        /// This member is required.
        public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
        /// The storage profile ID.
        /// This member is required.
        public var storageProfileId: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
            storageProfileId: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.osFamily = osFamily
            self.storageProfileId = storageProfileId
        }
    }

}

extension DeadlineClientTypes.StringFilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ComparisonOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeadlineClientTypes {
    /// Searches for a particular string.
    public struct StringFilterExpression: Swift.Equatable {
        /// The field name to search.
        /// This member is required.
        public var name: Swift.String?
        /// The type of comparison to use for this search.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.ComparisonOperator?
        /// The string to search for.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            `operator`: DeadlineClientTypes.ComparisonOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The job attachment in a session action to sync.
    public struct SyncInputJobAttachmentsSessionActionDefinition: Swift.Equatable {
        /// The step ID for the step in the job attachment.
        public var stepId: Swift.String?

        public init(
            stepId: Swift.String? = nil
        )
        {
            self.stepId = stepId
        }
    }

}

extension DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a synced job attachment.
    public struct SyncInputJobAttachmentsSessionActionDefinitionSummary: Swift.Equatable {
        /// The step ID of the step in the job attachment.
        public var stepId: Swift.String?

        public init(
            stepId: Swift.String? = nil
        )
        {
            self.stepId = stepId
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2023-10-12/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to apply tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.TaskParameterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case float
        case int
        case path
        case sdkUnknown
        case string
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .float(float):
                try container.encode(float, forKey: .float)
            case let .int(int):
                try container.encode(int, forKey: .int)
            case let .path(path):
                try container.encode(path, forKey: .path)
            case let .string(string):
                try container.encode(string, forKey: .string)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let intDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .int)
        if let int = intDecoded {
            self = .int(int)
            return
        }
        let floatDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .float)
        if let float = floatDecoded {
            self = .float(float)
            return
        }
        let stringDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .string)
        if let string = stringDecoded {
            self = .string(string)
            return
        }
        let pathDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .path)
        if let path = pathDecoded {
            self = .path(path)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The data types for the task parameters.
    public enum TaskParameterValue: Swift.Equatable {
        /// A signed integer represented as a string.
        case int(Swift.String)
        /// A double precision IEEE-754 floating point number represented as a string.
        case float(Swift.String)
        /// A UTF-8 string.
        case string(Swift.String)
        /// A file system path represented as a string.
        case path(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes.TaskRunSessionActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
        case stepId
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, taskParameters0) in parameters {
                try parametersContainer.encode(taskParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.TaskParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.TaskParameterValue]()
            for (key0, taskparametervalue0) in parametersContainer {
                if let taskparametervalue0 = taskparametervalue0 {
                    parametersDecoded0?[key0] = taskparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DeadlineClientTypes.TaskRunSessionActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskRunSessionActionDefinition(stepId: \(Swift.String(describing: stepId)), taskId: \(Swift.String(describing: taskId)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The task, step, and parameters for the task run in the session action.
    public struct TaskRunSessionActionDefinition: Swift.Equatable {
        /// The task parameters.
        /// This member is required.
        public var parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil,
            stepId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.stepId = stepId
            self.taskId = taskId
        }
    }

}

extension DeadlineClientTypes.TaskRunSessionActionDefinitionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepId
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a task run in a session action.
    public struct TaskRunSessionActionDefinitionSummary: Swift.Equatable {
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            stepId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.stepId = stepId
            self.taskId = taskId
        }
    }

}

extension DeadlineClientTypes {
    public enum TaskRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assigned
        case canceled
        case failed
        case interrupting
        case notCompatible
        case pending
        case ready
        case running
        case scheduled
        case starting
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskRunStatus] {
            return [
                .assigned,
                .canceled,
                .failed,
                .interrupting,
                .notCompatible,
                .pending,
                .ready,
                .running,
                .scheduled,
                .starting,
                .succeeded,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .interrupting: return "INTERRUPTING"
            case .notCompatible: return "NOT_COMPATIBLE"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .starting: return "STARTING"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskRunStatus(rawValue: rawValue) ?? TaskRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.TaskSearchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt
        case failureRetryCount
        case jobId
        case parameters
        case queueId
        case runStatus
        case startedAt
        case stepId
        case targetRunStatus
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let failureRetryCount = self.failureRetryCount {
            try encodeContainer.encode(failureRetryCount, forKey: .failureRetryCount)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, taskParameters0) in parameters {
                try parametersContainer.encode(taskParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let runStatus = self.runStatus {
            try encodeContainer.encode(runStatus.rawValue, forKey: .runStatus)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let stepId = self.stepId {
            try encodeContainer.encode(stepId, forKey: .stepId)
        }
        if let targetRunStatus = self.targetRunStatus {
            try encodeContainer.encode(targetRunStatus.rawValue, forKey: .targetRunStatus)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let stepIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepId)
        stepId = stepIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let runStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .runStatus)
        runStatus = runStatusDecoded
        let targetRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskTargetRunStatus.self, forKey: .targetRunStatus)
        targetRunStatus = targetRunStatusDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.TaskParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.TaskParameterValue]()
            for (key0, taskparametervalue0) in parametersContainer {
                if let taskparametervalue0 = taskparametervalue0 {
                    parametersDecoded0?[key0] = taskparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
        let failureRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureRetryCount)
        failureRetryCount = failureRetryCountDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
    }
}

extension DeadlineClientTypes.TaskSearchSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSearchSummary(endedAt: \(Swift.String(describing: endedAt)), failureRetryCount: \(Swift.String(describing: failureRetryCount)), jobId: \(Swift.String(describing: jobId)), queueId: \(Swift.String(describing: queueId)), runStatus: \(Swift.String(describing: runStatus)), startedAt: \(Swift.String(describing: startedAt)), stepId: \(Swift.String(describing: stepId)), targetRunStatus: \(Swift.String(describing: targetRunStatus)), taskId: \(Swift.String(describing: taskId)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The details of a task search.
    public struct TaskSearchSummary: Swift.Equatable {
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The number of times that the task failed and was retried.
        public var failureRetryCount: Swift.Int?
        /// The job ID.
        public var jobId: Swift.String?
        /// The parameters to search for.
        public var parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The run status of the task.
        public var runStatus: DeadlineClientTypes.TaskRunStatus?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The step ID.
        public var stepId: Swift.String?
        /// The run status that the task is being updated to.
        public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
        /// The task ID.
        public var taskId: Swift.String?

        public init(
            endedAt: ClientRuntime.Date? = nil,
            failureRetryCount: Swift.Int? = nil,
            jobId: Swift.String? = nil,
            parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil,
            queueId: Swift.String? = nil,
            runStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            startedAt: ClientRuntime.Date? = nil,
            stepId: Swift.String? = nil,
            targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.jobId = jobId
            self.parameters = parameters
            self.queueId = queueId
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
        }
    }

}

extension DeadlineClientTypes.TaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case endedAt
        case failureRetryCount
        case latestSessionActionId
        case parameters
        case runStatus
        case startedAt
        case targetRunStatus
        case taskId
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let failureRetryCount = self.failureRetryCount {
            try encodeContainer.encode(failureRetryCount, forKey: .failureRetryCount)
        }
        if let latestSessionActionId = self.latestSessionActionId {
            try encodeContainer.encode(latestSessionActionId, forKey: .latestSessionActionId)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, taskParameters0) in parameters {
                try parametersContainer.encode(taskParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let runStatus = self.runStatus {
            try encodeContainer.encode(runStatus.rawValue, forKey: .runStatus)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let targetRunStatus = self.targetRunStatus {
            try encodeContainer.encode(targetRunStatus.rawValue, forKey: .targetRunStatus)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let runStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskRunStatus.self, forKey: .runStatus)
        runStatus = runStatusDecoded
        let targetRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskTargetRunStatus.self, forKey: .targetRunStatus)
        targetRunStatus = targetRunStatusDecoded
        let failureRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureRetryCount)
        failureRetryCount = failureRetryCountDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.TaskParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DeadlineClientTypes.TaskParameterValue]()
            for (key0, taskparametervalue0) in parametersContainer {
                if let taskparametervalue0 = taskparametervalue0 {
                    parametersDecoded0?[key0] = taskparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let latestSessionActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestSessionActionId)
        latestSessionActionId = latestSessionActionIdDecoded
    }
}

extension DeadlineClientTypes.TaskSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), failureRetryCount: \(Swift.String(describing: failureRetryCount)), latestSessionActionId: \(Swift.String(describing: latestSessionActionId)), runStatus: \(Swift.String(describing: runStatus)), startedAt: \(Swift.String(describing: startedAt)), targetRunStatus: \(Swift.String(describing: targetRunStatus)), taskId: \(Swift.String(describing: taskId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The details of a task.
    public struct TaskSummary: Swift.Equatable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The number of times that the task failed and was retried.
        public var failureRetryCount: Swift.Int?
        /// The latest session action for the task.
        public var latestSessionActionId: Swift.String?
        /// The task parameters.
        public var parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]?
        /// The run status of the task.
        /// This member is required.
        public var runStatus: DeadlineClientTypes.TaskRunStatus?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The run status on which the started.
        public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureRetryCount: Swift.Int? = nil,
            latestSessionActionId: Swift.String? = nil,
            parameters: [Swift.String:DeadlineClientTypes.TaskParameterValue]? = nil,
            runStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            startedAt: ClientRuntime.Date? = nil,
            targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
            taskId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.latestSessionActionId = latestSessionActionId
            self.parameters = parameters
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DeadlineClientTypes {
    public enum TaskTargetRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case pending
        case ready
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskTargetRunStatus] {
            return [
                .canceled,
                .failed,
                .pending,
                .ready,
                .succeeded,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskTargetRunStatus(rawValue: rawValue) ?? TaskTargetRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.context = output.context
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.context = nil
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request exceeded a request rate quota.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifies the quota that is being throttled.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Identifies the service that is being throttled.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let context: [Swift.String:Swift.String]?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2023-10-12/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// They keys of the tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBudgetInput(actionsToAdd: \(Swift.String(describing: actionsToAdd)), actionsToRemove: \(Swift.String(describing: actionsToRemove)), approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), budgetId: \(Swift.String(describing: budgetId)), clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsToAdd
        case actionsToRemove
        case approximateDollarLimit
        case description
        case displayName
        case schedule
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsToAdd = actionsToAdd {
            var actionsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionsToAdd)
            for budgetactiontoadd0 in actionsToAdd {
                try actionsToAddContainer.encode(budgetactiontoadd0)
            }
        }
        if let actionsToRemove = actionsToRemove {
            var actionsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionsToRemove)
            for budgetactiontoremove0 in actionsToRemove {
                try actionsToRemoveContainer.encode(budgetactiontoremove0)
            }
        }
        if let approximateDollarLimit = self.approximateDollarLimit {
            try encodeContainer.encode(approximateDollarLimit, forKey: .approximateDollarLimit)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateBudgetInput {

    static func headerProvider(_ value: UpdateBudgetInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateBudgetInput {

    static func urlPathProvider(_ value: UpdateBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let budgetId = value.budgetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets/\(budgetId.urlPercentEncoding())"
    }
}

public struct UpdateBudgetInput: Swift.Equatable {
    /// The budget actions to add. Budget actions specify what happens when the budget runs out.
    public var actionsToAdd: [DeadlineClientTypes.BudgetActionToAdd]?
    /// The budget actions to remove from the budget.
    public var actionsToRemove: [DeadlineClientTypes.BudgetActionToRemove]?
    /// The dollar limit to update on the budget. Based on consumed usage.
    public var approximateDollarLimit: Swift.Float?
    /// The budget ID to update.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The description of the budget to update.
    public var description: Swift.String?
    /// The display name of the budget to update.
    public var displayName: Swift.String?
    /// The farm ID of the budget to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The schedule to update.
    public var schedule: DeadlineClientTypes.BudgetSchedule?
    /// Updates the status of the budget.
    ///
    /// * ACTIVEThe budget is being evaluated.
    ///
    /// * INACTIVEThe budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
    public var status: DeadlineClientTypes.BudgetStatus?

    public init(
        actionsToAdd: [DeadlineClientTypes.BudgetActionToAdd]? = nil,
        actionsToRemove: [DeadlineClientTypes.BudgetActionToRemove]? = nil,
        approximateDollarLimit: Swift.Float? = nil,
        budgetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        schedule: DeadlineClientTypes.BudgetSchedule? = nil,
        status: DeadlineClientTypes.BudgetStatus? = nil
    )
    {
        self.actionsToAdd = actionsToAdd
        self.actionsToRemove = actionsToRemove
        self.approximateDollarLimit = approximateDollarLimit
        self.budgetId = budgetId
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.schedule = schedule
        self.status = status
    }
}

struct UpdateBudgetInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let status: DeadlineClientTypes.BudgetStatus?
    let approximateDollarLimit: Swift.Float?
    let actionsToAdd: [DeadlineClientTypes.BudgetActionToAdd]?
    let actionsToRemove: [DeadlineClientTypes.BudgetActionToRemove]?
    let schedule: DeadlineClientTypes.BudgetSchedule?
}

extension UpdateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsToAdd
        case actionsToRemove
        case approximateDollarLimit
        case description
        case displayName
        case schedule
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetStatus.self, forKey: .status)
        status = statusDecoded
        let approximateDollarLimitDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .approximateDollarLimit)
        approximateDollarLimit = approximateDollarLimitDecoded
        let actionsToAddContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.BudgetActionToAdd?].self, forKey: .actionsToAdd)
        var actionsToAddDecoded0:[DeadlineClientTypes.BudgetActionToAdd]? = nil
        if let actionsToAddContainer = actionsToAddContainer {
            actionsToAddDecoded0 = [DeadlineClientTypes.BudgetActionToAdd]()
            for structure0 in actionsToAddContainer {
                if let structure0 = structure0 {
                    actionsToAddDecoded0?.append(structure0)
                }
            }
        }
        actionsToAdd = actionsToAddDecoded0
        let actionsToRemoveContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.BudgetActionToRemove?].self, forKey: .actionsToRemove)
        var actionsToRemoveDecoded0:[DeadlineClientTypes.BudgetActionToRemove]? = nil
        if let actionsToRemoveContainer = actionsToRemoveContainer {
            actionsToRemoveDecoded0 = [DeadlineClientTypes.BudgetActionToRemove]()
            for structure0 in actionsToRemoveContainer {
                if let structure0 = structure0 {
                    actionsToRemoveDecoded0?.append(structure0)
                }
            }
        }
        actionsToRemove = actionsToRemoveDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.BudgetSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension UpdateBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateBudgetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFarmInput(displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateFarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension UpdateFarmInput {

    static func urlPathProvider(_ value: UpdateFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())"
    }
}

public struct UpdateFarmInput: Swift.Equatable {
    /// The description of the farm to update.
    public var description: Swift.String?
    /// The display name of the farm to update.
    public var displayName: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
    }
}

struct UpdateFarmInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
}

extension UpdateFarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateFarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFarmOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFleetInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), fleetId: \(Swift.String(describing: fleetId)), maxWorkerCount: \(Swift.String(describing: maxWorkerCount)), minWorkerCount: \(Swift.String(describing: minWorkerCount)), roleArn: \(Swift.String(describing: roleArn)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case displayName
        case maxWorkerCount
        case minWorkerCount
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let maxWorkerCount = self.maxWorkerCount {
            try encodeContainer.encode(maxWorkerCount, forKey: .maxWorkerCount)
        }
        if let minWorkerCount = self.minWorkerCount {
            try encodeContainer.encode(minWorkerCount, forKey: .minWorkerCount)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateFleetInput {

    static func headerProvider(_ value: UpdateFleetInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateFleetInput {

    static func urlPathProvider(_ value: UpdateFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())"
    }
}

public struct UpdateFleetInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The fleet configuration to update.
    public var configuration: DeadlineClientTypes.FleetConfiguration?
    /// The description of the fleet to update.
    public var description: Swift.String?
    /// The display name of the fleet to update.
    public var displayName: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of workers in the fleet.
    public var maxWorkerCount: Swift.Int?
    /// The minimum number of workers in the fleet.
    public var minWorkerCount: Swift.Int?
    /// The IAM role ARN that the fleet's workers assume while running jobs.
    public var roleArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        configuration: DeadlineClientTypes.FleetConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxWorkerCount: Swift.Int? = nil,
        minWorkerCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxWorkerCount = maxWorkerCount
        self.minWorkerCount = minWorkerCount
        self.roleArn = roleArn
    }
}

struct UpdateFleetInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let minWorkerCount: Swift.Int?
    let maxWorkerCount: Swift.Int?
    let configuration: DeadlineClientTypes.FleetConfiguration?
}

extension UpdateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case displayName
        case maxWorkerCount
        case minWorkerCount
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let minWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let maxWorkerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.FleetConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFleetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleStatus
        case maxFailedTasksCount
        case maxRetriesPerTask
        case priority
        case targetTaskRunStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let maxFailedTasksCount = self.maxFailedTasksCount {
            try encodeContainer.encode(maxFailedTasksCount, forKey: .maxFailedTasksCount)
        }
        if let maxRetriesPerTask = self.maxRetriesPerTask {
            try encodeContainer.encode(maxRetriesPerTask, forKey: .maxRetriesPerTask)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
    }
}

extension UpdateJobInput {

    static func headerProvider(_ value: UpdateJobInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateJobInput {

    static func urlPathProvider(_ value: UpdateJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct UpdateJobInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the job to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of a job in its lifecycle.
    public var lifecycleStatus: DeadlineClientTypes.UpdateJobLifecycleStatus?
    /// The number of task failures before the job stops running and is marked as FAILED.
    public var maxFailedTasksCount: Swift.Int?
    /// The maximum number of retries for a job.
    public var maxRetriesPerTask: Swift.Int?
    /// The job priority to update.
    public var priority: Swift.Int?
    /// The queue ID of the job to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The task status to update the job's tasks to.
    public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        lifecycleStatus: DeadlineClientTypes.UpdateJobLifecycleStatus? = nil,
        maxFailedTasksCount: Swift.Int? = nil,
        maxRetriesPerTask: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        queueId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.lifecycleStatus = lifecycleStatus
        self.maxFailedTasksCount = maxFailedTasksCount
        self.maxRetriesPerTask = maxRetriesPerTask
        self.priority = priority
        self.queueId = queueId
        self.targetTaskRunStatus = targetTaskRunStatus
    }
}

struct UpdateJobInputBody: Swift.Equatable {
    let targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
    let priority: Swift.Int?
    let maxFailedTasksCount: Swift.Int?
    let maxRetriesPerTask: Swift.Int?
    let lifecycleStatus: DeadlineClientTypes.UpdateJobLifecycleStatus?
}

extension UpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleStatus
        case maxFailedTasksCount
        case maxRetriesPerTask
        case priority
        case targetTaskRunStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxFailedTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFailedTasksCount)
        maxFailedTasksCount = maxFailedTasksCountDecoded
        let maxRetriesPerTaskDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetriesPerTask)
        maxRetriesPerTask = maxRetriesPerTaskDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UpdateJobLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
    }
}

extension DeadlineClientTypes {
    public enum UpdateJobLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateJobLifecycleStatus] {
            return [
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateJobLifecycleStatus(rawValue: rawValue) ?? UpdateJobLifecycleStatus.sdkUnknown(rawValue)
        }
    }
}

extension UpdateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateJobOutput: Swift.Equatable {

    public init() { }
}

enum UpdateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case roleArn
        case subdomain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let subdomain = self.subdomain {
            try encodeContainer.encode(subdomain, forKey: .subdomain)
        }
    }
}

extension UpdateMonitorInput {

    static func urlPathProvider(_ value: UpdateMonitorInput) -> Swift.String? {
        guard let monitorId = value.monitorId else {
            return nil
        }
        return "/2023-10-12/monitors/\(monitorId.urlPercentEncoding())"
    }
}

public struct UpdateMonitorInput: Swift.Equatable {
    /// The new value to use for the monitor's display name.
    public var displayName: Swift.String?
    /// The unique identifier of the monitor to update.
    /// This member is required.
    public var monitorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the new IAM role to use with the monitor.
    public var roleArn: Swift.String?
    /// The new value of the subdomain to use when forming the monitor URL.
    public var subdomain: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        monitorId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.monitorId = monitorId
        self.roleArn = roleArn
        self.subdomain = subdomain
    }
}

struct UpdateMonitorInputBody: Swift.Equatable {
    let subdomain: Swift.String?
    let displayName: Swift.String?
    let roleArn: Swift.String?
}

extension UpdateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case roleArn
        case subdomain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subdomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdomain)
        subdomain = subdomainDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMonitorOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQueueEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), farmId: \(Swift.String(describing: farmId)), priority: \(Swift.String(describing: priority)), queueEnvironmentId: \(Swift.String(describing: queueEnvironmentId)), queueId: \(Swift.String(describing: queueId)), templateType: \(Swift.String(describing: templateType)), template: \"CONTENT_REDACTED\")"}
}

extension UpdateQueueEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority
        case template
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension UpdateQueueEnvironmentInput {

    static func headerProvider(_ value: UpdateQueueEnvironmentInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateQueueEnvironmentInput {

    static func urlPathProvider(_ value: UpdateQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let queueEnvironmentId = value.queueEnvironmentId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments/\(queueEnvironmentId.urlPercentEncoding())"
    }
}

public struct UpdateQueueEnvironmentInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the queue environment to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The priority to update.
    public var priority: Swift.Int?
    /// The queue environment ID to update.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The queue ID of the queue environment to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The template to update.
    public var template: Swift.String?
    /// The template type to update.
    public var templateType: DeadlineClientTypes.EnvironmentTemplateType?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queueEnvironmentId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.EnvironmentTemplateType? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.priority = priority
        self.queueEnvironmentId = queueEnvironmentId
        self.queueId = queueId
        self.template = template
        self.templateType = templateType
    }
}

struct UpdateQueueEnvironmentInputBody: Swift.Equatable {
    let priority: Swift.Int?
    let templateType: DeadlineClientTypes.EnvironmentTemplateType?
    let template: Swift.String?
}

extension UpdateQueueEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority
        case template
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.EnvironmentTemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension UpdateQueueEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQueueFleetAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateQueueFleetAssociationInput {

    static func urlPathProvider(_ value: UpdateQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations/\(queueId.urlPercentEncoding())/\(fleetId.urlPercentEncoding())"
    }
}

public struct UpdateQueueFleetAssociationInput: Swift.Equatable {
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status to update.
    /// This member is required.
    public var status: DeadlineClientTypes.UpdateQueueFleetAssociationStatus?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: DeadlineClientTypes.UpdateQueueFleetAssociationStatus? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
        self.status = status
    }
}

struct UpdateQueueFleetAssociationInputBody: Swift.Equatable {
    let status: DeadlineClientTypes.UpdateQueueFleetAssociationStatus?
}

extension UpdateQueueFleetAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UpdateQueueFleetAssociationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateQueueFleetAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueFleetAssociationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueFleetAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes {
    public enum UpdateQueueFleetAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateQueueFleetAssociationStatus] {
            return [
                .active,
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateQueueFleetAssociationStatus(rawValue: rawValue) ?? UpdateQueueFleetAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension UpdateQueueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQueueInput(allowedStorageProfileIdsToAdd: \(Swift.String(describing: allowedStorageProfileIdsToAdd)), allowedStorageProfileIdsToRemove: \(Swift.String(describing: allowedStorageProfileIdsToRemove)), clientToken: \(Swift.String(describing: clientToken)), defaultBudgetAction: \(Swift.String(describing: defaultBudgetAction)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), queueId: \(Swift.String(describing: queueId)), requiredFileSystemLocationNamesToAdd: \(Swift.String(describing: requiredFileSystemLocationNamesToAdd)), requiredFileSystemLocationNamesToRemove: \(Swift.String(describing: requiredFileSystemLocationNamesToRemove)), roleArn: \(Swift.String(describing: roleArn)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedStorageProfileIdsToAdd
        case allowedStorageProfileIdsToRemove
        case defaultBudgetAction
        case description
        case displayName
        case jobAttachmentSettings
        case jobRunAsUser
        case requiredFileSystemLocationNamesToAdd
        case requiredFileSystemLocationNamesToRemove
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedStorageProfileIdsToAdd = allowedStorageProfileIdsToAdd {
            var allowedStorageProfileIdsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedStorageProfileIdsToAdd)
            for storageprofileid0 in allowedStorageProfileIdsToAdd {
                try allowedStorageProfileIdsToAddContainer.encode(storageprofileid0)
            }
        }
        if let allowedStorageProfileIdsToRemove = allowedStorageProfileIdsToRemove {
            var allowedStorageProfileIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedStorageProfileIdsToRemove)
            for storageprofileid0 in allowedStorageProfileIdsToRemove {
                try allowedStorageProfileIdsToRemoveContainer.encode(storageprofileid0)
            }
        }
        if let defaultBudgetAction = self.defaultBudgetAction {
            try encodeContainer.encode(defaultBudgetAction.rawValue, forKey: .defaultBudgetAction)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let jobAttachmentSettings = self.jobAttachmentSettings {
            try encodeContainer.encode(jobAttachmentSettings, forKey: .jobAttachmentSettings)
        }
        if let jobRunAsUser = self.jobRunAsUser {
            try encodeContainer.encode(jobRunAsUser, forKey: .jobRunAsUser)
        }
        if let requiredFileSystemLocationNamesToAdd = requiredFileSystemLocationNamesToAdd {
            var requiredFileSystemLocationNamesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFileSystemLocationNamesToAdd)
            for filesystemlocationname0 in requiredFileSystemLocationNamesToAdd {
                try requiredFileSystemLocationNamesToAddContainer.encode(filesystemlocationname0)
            }
        }
        if let requiredFileSystemLocationNamesToRemove = requiredFileSystemLocationNamesToRemove {
            var requiredFileSystemLocationNamesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFileSystemLocationNamesToRemove)
            for filesystemlocationname0 in requiredFileSystemLocationNamesToRemove {
                try requiredFileSystemLocationNamesToRemoveContainer.encode(filesystemlocationname0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateQueueInput {

    static func headerProvider(_ value: UpdateQueueInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateQueueInput {

    static func urlPathProvider(_ value: UpdateQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())"
    }
}

public struct UpdateQueueInput: Swift.Equatable {
    /// The storage profile IDs to add.
    public var allowedStorageProfileIdsToAdd: [Swift.String]?
    /// The storage profile ID to remove.
    public var allowedStorageProfileIdsToRemove: [Swift.String]?
    /// The idempotency token to update in the queue.
    public var clientToken: Swift.String?
    /// The default action to take for a queue update if a budget isn't configured.
    public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    /// The description of the queue to update.
    public var description: Swift.String?
    /// The display name of the queue to update.
    public var displayName: Swift.String?
    /// The farm ID to update in the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job attachment settings to update for the queue.
    public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    /// Update the jobs in the queue to run as a specified POSIX user.
    public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The required file system location names to add to the queue.
    public var requiredFileSystemLocationNamesToAdd: [Swift.String]?
    /// The required file system location names to remove from the queue.
    public var requiredFileSystemLocationNamesToRemove: [Swift.String]?
    /// The IAM role ARN that's used to run jobs from this queue.
    public var roleArn: Swift.String?

    public init(
        allowedStorageProfileIdsToAdd: [Swift.String]? = nil,
        allowedStorageProfileIdsToRemove: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
        jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
        queueId: Swift.String? = nil,
        requiredFileSystemLocationNamesToAdd: [Swift.String]? = nil,
        requiredFileSystemLocationNamesToRemove: [Swift.String]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.allowedStorageProfileIdsToAdd = allowedStorageProfileIdsToAdd
        self.allowedStorageProfileIdsToRemove = allowedStorageProfileIdsToRemove
        self.clientToken = clientToken
        self.defaultBudgetAction = defaultBudgetAction
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.jobAttachmentSettings = jobAttachmentSettings
        self.jobRunAsUser = jobRunAsUser
        self.queueId = queueId
        self.requiredFileSystemLocationNamesToAdd = requiredFileSystemLocationNamesToAdd
        self.requiredFileSystemLocationNamesToRemove = requiredFileSystemLocationNamesToRemove
        self.roleArn = roleArn
    }
}

struct UpdateQueueInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    let jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    let roleArn: Swift.String?
    let jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    let requiredFileSystemLocationNamesToAdd: [Swift.String]?
    let requiredFileSystemLocationNamesToRemove: [Swift.String]?
    let allowedStorageProfileIdsToAdd: [Swift.String]?
    let allowedStorageProfileIdsToRemove: [Swift.String]?
}

extension UpdateQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedStorageProfileIdsToAdd
        case allowedStorageProfileIdsToRemove
        case defaultBudgetAction
        case description
        case displayName
        case jobAttachmentSettings
        case jobRunAsUser
        case requiredFileSystemLocationNamesToAdd
        case requiredFileSystemLocationNamesToRemove
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultBudgetActionDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DefaultQueueBudgetAction.self, forKey: .defaultBudgetAction)
        defaultBudgetAction = defaultBudgetActionDecoded
        let jobAttachmentSettingsDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobAttachmentSettings.self, forKey: .jobAttachmentSettings)
        jobAttachmentSettings = jobAttachmentSettingsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let jobRunAsUserDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.JobRunAsUser.self, forKey: .jobRunAsUser)
        jobRunAsUser = jobRunAsUserDecoded
        let requiredFileSystemLocationNamesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredFileSystemLocationNamesToAdd)
        var requiredFileSystemLocationNamesToAddDecoded0:[Swift.String]? = nil
        if let requiredFileSystemLocationNamesToAddContainer = requiredFileSystemLocationNamesToAddContainer {
            requiredFileSystemLocationNamesToAddDecoded0 = [Swift.String]()
            for string0 in requiredFileSystemLocationNamesToAddContainer {
                if let string0 = string0 {
                    requiredFileSystemLocationNamesToAddDecoded0?.append(string0)
                }
            }
        }
        requiredFileSystemLocationNamesToAdd = requiredFileSystemLocationNamesToAddDecoded0
        let requiredFileSystemLocationNamesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredFileSystemLocationNamesToRemove)
        var requiredFileSystemLocationNamesToRemoveDecoded0:[Swift.String]? = nil
        if let requiredFileSystemLocationNamesToRemoveContainer = requiredFileSystemLocationNamesToRemoveContainer {
            requiredFileSystemLocationNamesToRemoveDecoded0 = [Swift.String]()
            for string0 in requiredFileSystemLocationNamesToRemoveContainer {
                if let string0 = string0 {
                    requiredFileSystemLocationNamesToRemoveDecoded0?.append(string0)
                }
            }
        }
        requiredFileSystemLocationNamesToRemove = requiredFileSystemLocationNamesToRemoveDecoded0
        let allowedStorageProfileIdsToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedStorageProfileIdsToAdd)
        var allowedStorageProfileIdsToAddDecoded0:[Swift.String]? = nil
        if let allowedStorageProfileIdsToAddContainer = allowedStorageProfileIdsToAddContainer {
            allowedStorageProfileIdsToAddDecoded0 = [Swift.String]()
            for string0 in allowedStorageProfileIdsToAddContainer {
                if let string0 = string0 {
                    allowedStorageProfileIdsToAddDecoded0?.append(string0)
                }
            }
        }
        allowedStorageProfileIdsToAdd = allowedStorageProfileIdsToAddDecoded0
        let allowedStorageProfileIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedStorageProfileIdsToRemove)
        var allowedStorageProfileIdsToRemoveDecoded0:[Swift.String]? = nil
        if let allowedStorageProfileIdsToRemoveContainer = allowedStorageProfileIdsToRemoveContainer {
            allowedStorageProfileIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in allowedStorageProfileIdsToRemoveContainer {
                if let string0 = string0 {
                    allowedStorageProfileIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        allowedStorageProfileIdsToRemove = allowedStorageProfileIdsToRemoveDecoded0
    }
}

extension UpdateQueueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateQueueOutput: Swift.Equatable {

    public init() { }
}

enum UpdateQueueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetLifecycleStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetLifecycleStatus = self.targetLifecycleStatus {
            try encodeContainer.encode(targetLifecycleStatus.rawValue, forKey: .targetLifecycleStatus)
        }
    }
}

extension UpdateSessionInput {

    static func headerProvider(_ value: UpdateSessionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateSessionInput {

    static func urlPathProvider(_ value: UpdateSessionInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct UpdateSessionInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID to update in the session.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update in the session.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to update in the session.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session ID to update.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The life cycle status to update in the session.
    /// This member is required.
    public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.sessionId = sessionId
        self.targetLifecycleStatus = targetLifecycleStatus
    }
}

struct UpdateSessionInputBody: Swift.Equatable {
    let targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?
}

extension UpdateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetLifecycleStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetLifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleTargetStatus.self, forKey: .targetLifecycleStatus)
        targetLifecycleStatus = targetLifecycleStatusDecoded
    }
}

extension UpdateSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSessionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStepInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetTaskRunStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetTaskRunStatus = self.targetTaskRunStatus {
            try encodeContainer.encode(targetTaskRunStatus.rawValue, forKey: .targetTaskRunStatus)
        }
    }
}

extension UpdateStepInput {

    static func headerProvider(_ value: UpdateStepInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStepInput {

    static func urlPathProvider(_ value: UpdateStepInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())"
    }
}

public struct UpdateStepInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to update.
    /// This member is required.
    public var stepId: Swift.String?
    /// The task status to update the step's tasks to.
    /// This member is required.
    public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
        self.targetTaskRunStatus = targetTaskRunStatus
    }
}

struct UpdateStepInputBody: Swift.Equatable {
    let targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
}

extension UpdateStepInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetTaskRunStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTaskRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StepTargetTaskRunStatus.self, forKey: .targetTaskRunStatus)
        targetTaskRunStatus = targetTaskRunStatusDecoded
    }
}

extension UpdateStepOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateStepOutput: Swift.Equatable {

    public init() { }
}

enum UpdateStepOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStorageProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case fileSystemLocationsToAdd
        case fileSystemLocationsToRemove
        case osFamily
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fileSystemLocationsToAdd = fileSystemLocationsToAdd {
            var fileSystemLocationsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocationsToAdd)
            for filesystemlocation0 in fileSystemLocationsToAdd {
                try fileSystemLocationsToAddContainer.encode(filesystemlocation0)
            }
        }
        if let fileSystemLocationsToRemove = fileSystemLocationsToRemove {
            var fileSystemLocationsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocationsToRemove)
            for filesystemlocation0 in fileSystemLocationsToRemove {
                try fileSystemLocationsToRemoveContainer.encode(filesystemlocation0)
            }
        }
        if let osFamily = self.osFamily {
            try encodeContainer.encode(osFamily.rawValue, forKey: .osFamily)
        }
    }
}

extension UpdateStorageProfileInput {

    static func headerProvider(_ value: UpdateStorageProfileInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStorageProfileInput {

    static func urlPathProvider(_ value: UpdateStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

public struct UpdateStorageProfileInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The display name of the storage profile to update.
    public var displayName: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The file system location names to add.
    public var fileSystemLocationsToAdd: [DeadlineClientTypes.FileSystemLocation]?
    /// The file system location names to remove.
    public var fileSystemLocationsToRemove: [DeadlineClientTypes.FileSystemLocation]?
    /// The OS system to update.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    /// The storage profile ID to update.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fileSystemLocationsToAdd: [DeadlineClientTypes.FileSystemLocation]? = nil,
        fileSystemLocationsToRemove: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.displayName = displayName
        self.farmId = farmId
        self.fileSystemLocationsToAdd = fileSystemLocationsToAdd
        self.fileSystemLocationsToRemove = fileSystemLocationsToRemove
        self.osFamily = osFamily
        self.storageProfileId = storageProfileId
    }
}

struct UpdateStorageProfileInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    let fileSystemLocationsToAdd: [DeadlineClientTypes.FileSystemLocation]?
    let fileSystemLocationsToRemove: [DeadlineClientTypes.FileSystemLocation]?
}

extension UpdateStorageProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case fileSystemLocationsToAdd
        case fileSystemLocationsToRemove
        case osFamily
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let osFamilyDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.StorageProfileOperatingSystemFamily.self, forKey: .osFamily)
        osFamily = osFamilyDecoded
        let fileSystemLocationsToAddContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FileSystemLocation?].self, forKey: .fileSystemLocationsToAdd)
        var fileSystemLocationsToAddDecoded0:[DeadlineClientTypes.FileSystemLocation]? = nil
        if let fileSystemLocationsToAddContainer = fileSystemLocationsToAddContainer {
            fileSystemLocationsToAddDecoded0 = [DeadlineClientTypes.FileSystemLocation]()
            for structure0 in fileSystemLocationsToAddContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsToAddDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocationsToAdd = fileSystemLocationsToAddDecoded0
        let fileSystemLocationsToRemoveContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.FileSystemLocation?].self, forKey: .fileSystemLocationsToRemove)
        var fileSystemLocationsToRemoveDecoded0:[DeadlineClientTypes.FileSystemLocation]? = nil
        if let fileSystemLocationsToRemoveContainer = fileSystemLocationsToRemoveContainer {
            fileSystemLocationsToRemoveDecoded0 = [DeadlineClientTypes.FileSystemLocation]()
            for structure0 in fileSystemLocationsToRemoveContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsToRemoveDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocationsToRemove = fileSystemLocationsToRemoveDecoded0
    }
}

extension UpdateStorageProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateStorageProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateStorageProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetRunStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetRunStatus = self.targetRunStatus {
            try encodeContainer.encode(targetRunStatus.rawValue, forKey: .targetRunStatus)
        }
    }
}

extension UpdateTaskInput {

    static func headerProvider(_ value: UpdateTaskInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = value.clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateTaskInput {

    static func urlPathProvider(_ value: UpdateTaskInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        guard let taskId = value.taskId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct UpdateTaskInput: Swift.Equatable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to update.
    /// This member is required.
    public var stepId: Swift.String?
    /// The run status with which to start the task.
    /// This member is required.
    public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
    /// The task ID to update.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
        self.targetRunStatus = targetRunStatus
        self.taskId = taskId
    }
}

struct UpdateTaskInputBody: Swift.Equatable {
    let targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
}

extension UpdateTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetRunStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetRunStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.TaskTargetRunStatus.self, forKey: .targetRunStatus)
        targetRunStatus = targetRunStatusDecoded
    }
}

extension UpdateTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTaskOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case hostProperties
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let hostProperties = self.hostProperties {
            try encodeContainer.encode(hostProperties, forKey: .hostProperties)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateWorkerInput {

    static func urlPathProvider(_ value: UpdateWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())"
    }
}

public struct UpdateWorkerInput: Swift.Equatable {
    /// The worker capabilities to update.
    public var capabilities: DeadlineClientTypes.WorkerCapabilities?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The host properties to update.
    public var hostProperties: DeadlineClientTypes.HostPropertiesRequest?
    /// The worker status to update.
    public var status: DeadlineClientTypes.UpdatedWorkerStatus?
    /// The worker ID to update.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        capabilities: DeadlineClientTypes.WorkerCapabilities? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesRequest? = nil,
        status: DeadlineClientTypes.UpdatedWorkerStatus? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.farmId = farmId
        self.fleetId = fleetId
        self.hostProperties = hostProperties
        self.status = status
        self.workerId = workerId
    }
}

struct UpdateWorkerInputBody: Swift.Equatable {
    let status: DeadlineClientTypes.UpdatedWorkerStatus?
    let capabilities: DeadlineClientTypes.WorkerCapabilities?
    let hostProperties: DeadlineClientTypes.HostPropertiesRequest?
}

extension UpdateWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case hostProperties
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.UpdatedWorkerStatus.self, forKey: .status)
        status = statusDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.WorkerCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.HostPropertiesRequest.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
    }
}

extension UpdateWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.log = output.log
        } else {
            self.log = nil
        }
    }
}

public struct UpdateWorkerOutput: Swift.Equatable {
    /// The worker log to update.
    public var log: DeadlineClientTypes.LogConfiguration?

    public init(
        log: DeadlineClientTypes.LogConfiguration? = nil
    )
    {
        self.log = log
    }
}

struct UpdateWorkerOutputBody: Swift.Equatable {
    let log: DeadlineClientTypes.LogConfiguration?
}

extension UpdateWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case log
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogConfiguration.self, forKey: .log)
        log = logDecoded
    }
}

enum UpdateWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkerScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedSessionActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedSessionActions = updatedSessionActions {
            var updatedSessionActionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .updatedSessionActions)
            for (dictKey0, updatedSessionActions0) in updatedSessionActions {
                try updatedSessionActionsContainer.encode(updatedSessionActions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateWorkerScheduleInput {

    static func urlPathProvider(_ value: UpdateWorkerScheduleInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/schedule"
    }
}

public struct UpdateWorkerScheduleInput: Swift.Equatable {
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The session actions associated with the worker schedule to update.
    public var updatedSessionActions: [Swift.String:DeadlineClientTypes.UpdatedSessionActionInfo]?
    /// The worker ID to update.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        updatedSessionActions: [Swift.String:DeadlineClientTypes.UpdatedSessionActionInfo]? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.updatedSessionActions = updatedSessionActions
        self.workerId = workerId
    }
}

struct UpdateWorkerScheduleInputBody: Swift.Equatable {
    let updatedSessionActions: [Swift.String:DeadlineClientTypes.UpdatedSessionActionInfo]?
}

extension UpdateWorkerScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedSessionActions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedSessionActionsContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.UpdatedSessionActionInfo?].self, forKey: .updatedSessionActions)
        var updatedSessionActionsDecoded0: [Swift.String:DeadlineClientTypes.UpdatedSessionActionInfo]? = nil
        if let updatedSessionActionsContainer = updatedSessionActionsContainer {
            updatedSessionActionsDecoded0 = [Swift.String:DeadlineClientTypes.UpdatedSessionActionInfo]()
            for (key0, updatedsessionactioninfo0) in updatedSessionActionsContainer {
                if let updatedsessionactioninfo0 = updatedsessionactioninfo0 {
                    updatedSessionActionsDecoded0?[key0] = updatedsessionactioninfo0
                }
            }
        }
        updatedSessionActions = updatedSessionActionsDecoded0
    }
}

extension UpdateWorkerScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkerScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.assignedSessions = output.assignedSessions
            self.cancelSessionActions = output.cancelSessionActions
            self.desiredWorkerStatus = output.desiredWorkerStatus
            self.updateIntervalSeconds = output.updateIntervalSeconds
        } else {
            self.assignedSessions = nil
            self.cancelSessionActions = nil
            self.desiredWorkerStatus = nil
            self.updateIntervalSeconds = nil
        }
    }
}

public struct UpdateWorkerScheduleOutput: Swift.Equatable {
    /// The assigned sessions to update.
    /// This member is required.
    public var assignedSessions: [Swift.String:DeadlineClientTypes.AssignedSession]?
    /// The session actions associated with the worker schedule to cancel.
    /// This member is required.
    public var cancelSessionActions: [Swift.String:[Swift.String]]?
    /// The status to update the worker to.
    public var desiredWorkerStatus: DeadlineClientTypes.DesiredWorkerStatus?
    /// Updates the time interval (in seconds) for the schedule.
    /// This member is required.
    public var updateIntervalSeconds: Swift.Int?

    public init(
        assignedSessions: [Swift.String:DeadlineClientTypes.AssignedSession]? = nil,
        cancelSessionActions: [Swift.String:[Swift.String]]? = nil,
        desiredWorkerStatus: DeadlineClientTypes.DesiredWorkerStatus? = nil,
        updateIntervalSeconds: Swift.Int? = nil
    )
    {
        self.assignedSessions = assignedSessions
        self.cancelSessionActions = cancelSessionActions
        self.desiredWorkerStatus = desiredWorkerStatus
        self.updateIntervalSeconds = updateIntervalSeconds
    }
}

struct UpdateWorkerScheduleOutputBody: Swift.Equatable {
    let assignedSessions: [Swift.String:DeadlineClientTypes.AssignedSession]?
    let cancelSessionActions: [Swift.String:[Swift.String]]?
    let desiredWorkerStatus: DeadlineClientTypes.DesiredWorkerStatus?
    let updateIntervalSeconds: Swift.Int?
}

extension UpdateWorkerScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignedSessions
        case cancelSessionActions
        case desiredWorkerStatus
        case updateIntervalSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignedSessionsContainer = try containerValues.decodeIfPresent([Swift.String: DeadlineClientTypes.AssignedSession?].self, forKey: .assignedSessions)
        var assignedSessionsDecoded0: [Swift.String:DeadlineClientTypes.AssignedSession]? = nil
        if let assignedSessionsContainer = assignedSessionsContainer {
            assignedSessionsDecoded0 = [Swift.String:DeadlineClientTypes.AssignedSession]()
            for (key0, assignedsession0) in assignedSessionsContainer {
                if let assignedsession0 = assignedsession0 {
                    assignedSessionsDecoded0?[key0] = assignedsession0
                }
            }
        }
        assignedSessions = assignedSessionsDecoded0
        let cancelSessionActionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .cancelSessionActions)
        var cancelSessionActionsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let cancelSessionActionsContainer = cancelSessionActionsContainer {
            cancelSessionActionsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, sessionactionidlist0) in cancelSessionActionsContainer {
                var sessionactionidlist0Decoded0: [Swift.String]? = nil
                if let sessionactionidlist0 = sessionactionidlist0 {
                    sessionactionidlist0Decoded0 = [Swift.String]()
                    for string1 in sessionactionidlist0 {
                        if let string1 = string1 {
                            sessionactionidlist0Decoded0?.append(string1)
                        }
                    }
                }
                cancelSessionActionsDecoded0?[key0] = sessionactionidlist0Decoded0
            }
        }
        cancelSessionActions = cancelSessionActionsDecoded0
        let desiredWorkerStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.DesiredWorkerStatus.self, forKey: .desiredWorkerStatus)
        desiredWorkerStatus = desiredWorkerStatusDecoded
        let updateIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updateIntervalSeconds)
        updateIntervalSeconds = updateIntervalSecondsDecoded
    }
}

enum UpdateWorkerScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeadlineClientTypes.UpdatedSessionActionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedStatus
        case endedAt
        case processExitCode
        case progressMessage
        case progressPercent
        case startedAt
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedStatus = self.completedStatus {
            try encodeContainer.encode(completedStatus.rawValue, forKey: .completedStatus)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let processExitCode = self.processExitCode {
            try encodeContainer.encode(processExitCode, forKey: .processExitCode)
        }
        if let progressMessage = self.progressMessage {
            try encodeContainer.encode(progressMessage, forKey: .progressMessage)
        }
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let completedStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.CompletedStatus.self, forKey: .completedStatus)
        completedStatus = completedStatusDecoded
        let processExitCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processExitCode)
        processExitCode = processExitCodeDecoded
        let progressMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressMessage)
        progressMessage = progressMessageDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
    }
}

extension DeadlineClientTypes.UpdatedSessionActionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatedSessionActionInfo(completedStatus: \(Swift.String(describing: completedStatus)), endedAt: \(Swift.String(describing: endedAt)), processExitCode: \(Swift.String(describing: processExitCode)), progressPercent: \(Swift.String(describing: progressPercent)), startedAt: \(Swift.String(describing: startedAt)), updatedAt: \(Swift.String(describing: updatedAt)), progressMessage: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {
    /// The updated session action information as it relates to completion and progress of the session.
    public struct UpdatedSessionActionInfo: Swift.Equatable {
        /// The status of the session upon completion.
        public var completedStatus: DeadlineClientTypes.CompletedStatus?
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The process exit code.
        public var processExitCode: Swift.Int?
        /// A message to indicate the progress of the updated session action.
        public var progressMessage: Swift.String?
        /// The percentage completed.
        public var progressPercent: Swift.Float?
        /// The date and time the resource started running.
        public var startedAt: ClientRuntime.Date?
        /// The updated time.
        public var updatedAt: ClientRuntime.Date?

        public init(
            completedStatus: DeadlineClientTypes.CompletedStatus? = nil,
            endedAt: ClientRuntime.Date? = nil,
            processExitCode: Swift.Int? = nil,
            progressMessage: Swift.String? = nil,
            progressPercent: Swift.Float? = nil,
            startedAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.completedStatus = completedStatus
            self.endedAt = endedAt
            self.processExitCode = processExitCode
            self.progressMessage = progressMessage
            self.progressPercent = progressPercent
            self.startedAt = startedAt
            self.updatedAt = updatedAt
        }
    }

}

extension DeadlineClientTypes {
    public enum UpdatedWorkerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdatedWorkerStatus] {
            return [
                .started,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdatedWorkerStatus(rawValue: rawValue) ?? UpdatedWorkerStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum UsageGroupByField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fleetId
        case instanceType
        case jobId
        case licenseProduct
        case queueId
        case usageType
        case userId
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageGroupByField] {
            return [
                .fleetId,
                .instanceType,
                .jobId,
                .licenseProduct,
                .queueId,
                .usageType,
                .userId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fleetId: return "FLEET_ID"
            case .instanceType: return "INSTANCE_TYPE"
            case .jobId: return "JOB_ID"
            case .licenseProduct: return "LICENSE_PRODUCT"
            case .queueId: return "QUEUE_ID"
            case .usageType: return "USAGE_TYPE"
            case .userId: return "USER_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageGroupByField(rawValue: rawValue) ?? UsageGroupByField.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes {
    public enum UsageStatistic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case max
        case min
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatistic] {
            return [
                .avg,
                .max,
                .min,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .max: return "MAX"
            case .min: return "MIN"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatistic(rawValue: rawValue) ?? UsageStatistic.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.UsageTrackingResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueid = "queueId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .queueid(queueid):
                try container.encode(queueid, forKey: .queueid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let queueidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .queueid)
        if let queueid = queueidDecoded {
            self = .queueid(queueid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DeadlineClientTypes {
    /// The usage details of the allotted budget.
    public enum UsageTrackingResource: Swift.Equatable {
        /// The queue ID.
        case queueid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DeadlineClientTypes {
    public enum UsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compute
        case license
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageType] {
            return [
                .compute,
                .license,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compute: return "COMPUTE"
            case .license: return "LICENSE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageType(rawValue: rawValue) ?? UsageType.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.UserJobsFirst: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdentityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userIdentityId = self.userIdentityId {
            try encodeContainer.encode(userIdentityId, forKey: .userIdentityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdentityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userIdentityId)
        userIdentityId = userIdentityIdDecoded
    }
}

extension DeadlineClientTypes {
    /// Allows setting a specific user's job to run first.
    public struct UserJobsFirst: Swift.Equatable {
        /// The user's ID.
        /// This member is required.
        public var userIdentityId: Swift.String?

        public init(
            userIdentityId: Swift.String? = nil
        )
        {
            self.userIdentityId = userIdentityId
        }
    }

}

extension DeadlineClientTypes.VCpuCountRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension DeadlineClientTypes {
    /// The allowable range of vCPU processing power for the fleet.
    public struct VCpuCountRange: Swift.Equatable {
        /// The maximum amount of vCPU.
        public var max: Swift.Int?
        /// The minimum amount of vCPU.
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.context = output.context
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.context = nil
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A list of fields that failed validation.
        public internal(set) var fieldList: [DeadlineClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the request failed validation.
        /// This member is required.
        public internal(set) var reason: DeadlineClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String:Swift.String]? = nil,
        fieldList: [DeadlineClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DeadlineClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.context = context
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: DeadlineClientTypes.ValidationExceptionReason?
    let fieldList: [DeadlineClientTypes.ValidationExceptionField]?
    let context: [Swift.String:Swift.String]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[DeadlineClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [DeadlineClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
    }
}

extension DeadlineClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The error message for the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DeadlineClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.WindowsUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case passwordArn
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let passwordArn = self.passwordArn {
            try encodeContainer.encode(passwordArn, forKey: .passwordArn)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .user)
        user = userDecoded
        let passwordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passwordArn)
        passwordArn = passwordArnDecoded
    }
}

extension DeadlineClientTypes {
    /// The Windows user details.
    public struct WindowsUser: Swift.Equatable {
        /// The password ARN for the Windows user.
        /// This member is required.
        public var passwordArn: Swift.String?
        /// The user.
        /// This member is required.
        public var user: Swift.String?

        public init(
            passwordArn: Swift.String? = nil,
            user: Swift.String? = nil
        )
        {
            self.passwordArn = passwordArn
            self.user = user
        }
    }

}

extension DeadlineClientTypes.WorkerAmountCapability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of the worker amount capability.
    public struct WorkerAmountCapability: Swift.Equatable {
        /// The name of the worker amount capability.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the worker amount capability.
        /// This member is required.
        public var value: Swift.Float?

        public init(
            name: Swift.String? = nil,
            value: Swift.Float? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DeadlineClientTypes.WorkerAttributeCapability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for attributecapabilityvalue0 in values {
                try valuesContainer.encode(attributecapabilityvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeadlineClientTypes {
    /// The details of the worker attribute capability.
    public struct WorkerAttributeCapability: Swift.Equatable {
        /// The name of the worker attribute capability.
        /// This member is required.
        public var name: Swift.String?
        /// The values of the worker amount capability.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension DeadlineClientTypes.WorkerCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amounts
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amounts = amounts {
            var amountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amounts)
            for workeramountcapability0 in amounts {
                try amountsContainer.encode(workeramountcapability0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for workerattributecapability0 in attributes {
                try attributesContainer.encode(workerattributecapability0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountsContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.WorkerAmountCapability?].self, forKey: .amounts)
        var amountsDecoded0:[DeadlineClientTypes.WorkerAmountCapability]? = nil
        if let amountsContainer = amountsContainer {
            amountsDecoded0 = [DeadlineClientTypes.WorkerAmountCapability]()
            for structure0 in amountsContainer {
                if let structure0 = structure0 {
                    amountsDecoded0?.append(structure0)
                }
            }
        }
        amounts = amountsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([DeadlineClientTypes.WorkerAttributeCapability?].self, forKey: .attributes)
        var attributesDecoded0:[DeadlineClientTypes.WorkerAttributeCapability]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [DeadlineClientTypes.WorkerAttributeCapability]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension DeadlineClientTypes {
    /// The details for worker capabilities.
    public struct WorkerCapabilities: Swift.Equatable {
        /// The worker capabilities amounts on a list of worker capabilities.
        /// This member is required.
        public var amounts: [DeadlineClientTypes.WorkerAmountCapability]?
        /// The worker attribute capabilities in the list of attribute capabilities.
        /// This member is required.
        public var attributes: [DeadlineClientTypes.WorkerAttributeCapability]?

        public init(
            amounts: [DeadlineClientTypes.WorkerAmountCapability]? = nil,
            attributes: [DeadlineClientTypes.WorkerAttributeCapability]? = nil
        )
        {
            self.amounts = amounts
            self.attributes = attributes
        }
    }

}

extension DeadlineClientTypes.WorkerSearchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case fleetId
        case hostProperties
        case status
        case updatedAt
        case updatedBy
        case workerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let hostProperties = self.hostProperties {
            try encodeContainer.encode(hostProperties, forKey: .hostProperties)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let workerId = self.workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.WorkerStatus.self, forKey: .status)
        status = statusDecoded
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.HostPropertiesResponse.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DeadlineClientTypes {
    /// The details of a worker search.
    public struct WorkerSearchSummary: Swift.Equatable {
        /// The date and time the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        public var createdBy: Swift.String?
        /// The fleet ID.
        public var fleetId: Swift.String?
        /// Provides the Amazon EC2 instance properties of the worker host.
        public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
        /// The status of the worker search.
        public var status: DeadlineClientTypes.WorkerStatus?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The worker ID.
        public var workerId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
            status: DeadlineClientTypes.WorkerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }
    }

}

extension DeadlineClientTypes.WorkerSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt
        case jobId
        case lifecycleStatus
        case queueId
        case sessionId
        case startedAt
        case targetLifecycleStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lifecycleStatus = self.lifecycleStatus {
            try encodeContainer.encode(lifecycleStatus.rawValue, forKey: .lifecycleStatus)
        }
        if let queueId = self.queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let targetLifecycleStatus = self.targetLifecycleStatus {
            try encodeContainer.encode(targetLifecycleStatus.rawValue, forKey: .targetLifecycleStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleStatus.self, forKey: .lifecycleStatus)
        lifecycleStatus = lifecycleStatusDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let targetLifecycleStatusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.SessionLifecycleTargetStatus.self, forKey: .targetLifecycleStatus)
        targetLifecycleStatus = targetLifecycleStatusDecoded
    }
}

extension DeadlineClientTypes {
    /// Summarizes the session for a particular worker.
    public struct WorkerSessionSummary: Swift.Equatable {
        /// The date and time the resource ended running.
        public var endedAt: ClientRuntime.Date?
        /// The job ID for the job associated with the worker's session.
        /// This member is required.
        public var jobId: Swift.String?
        /// The life cycle status for the worker's session.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
        /// The queue ID for the queue associated to the worker.
        /// This member is required.
        public var queueId: Swift.String?
        /// The session ID for the session action.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The date and time the resource started running.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The life cycle status
        public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?

        public init(
            endedAt: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus? = nil,
            queueId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil
        )
        {
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.queueId = queueId
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
        }
    }

}

extension DeadlineClientTypes {
    public enum WorkerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case idle
        case notCompatible
        case notResponding
        case running
        case started
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkerStatus] {
            return [
                .created,
                .idle,
                .notCompatible,
                .notResponding,
                .running,
                .started,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .idle: return "IDLE"
            case .notCompatible: return "NOT_COMPATIBLE"
            case .notResponding: return "NOT_RESPONDING"
            case .running: return "RUNNING"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkerStatus(rawValue: rawValue) ?? WorkerStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeadlineClientTypes.WorkerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case farmId
        case fleetId
        case hostProperties
        case log
        case status
        case updatedAt
        case updatedBy
        case workerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let farmId = self.farmId {
            try encodeContainer.encode(farmId, forKey: .farmId)
        }
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
        if let hostProperties = self.hostProperties {
            try encodeContainer.encode(hostProperties, forKey: .hostProperties)
        }
        if let log = self.log {
            try encodeContainer.encode(log, forKey: .log)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let workerId = self.workerId {
            try encodeContainer.encode(workerId, forKey: .workerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerId)
        workerId = workerIdDecoded
        let farmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .farmId)
        farmId = farmIdDecoded
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.WorkerStatus.self, forKey: .status)
        status = statusDecoded
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.HostPropertiesResponse.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
        let logDecoded = try containerValues.decodeIfPresent(DeadlineClientTypes.LogConfiguration.self, forKey: .log)
        log = logDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DeadlineClientTypes {
    /// The summary of details for a worker.
    public struct WorkerSummary: Swift.Equatable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The host properties of the worker.
        public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
        /// The log configuration for the worker.
        public var log: DeadlineClientTypes.LogConfiguration?
        /// The status of the worker.
        /// This member is required.
        public var status: DeadlineClientTypes.WorkerStatus?
        /// The date and time the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The worker ID.
        /// This member is required.
        public var workerId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            farmId: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
            log: DeadlineClientTypes.LogConfiguration? = nil,
            status: DeadlineClientTypes.WorkerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.farmId = farmId
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.log = log
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }
    }

}
