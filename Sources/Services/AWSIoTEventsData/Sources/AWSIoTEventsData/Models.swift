//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension IoTEventsDataClientTypes {

    /// Contains the configuration information of an acknowledge action.
    public struct AcknowledgeActionConfiguration: Swift.Sendable {
        /// The note that you can leave when you acknowledge the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information needed to acknowledge the alarm.
    public struct AcknowledgeAlarmActionRequest: Swift.Sendable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you acknowledge the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }
}

extension IoTEventsDataClientTypes {

    public enum CustomerActionName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acknowledge
        case disable
        case enable
        case reset
        case snooze
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerActionName] {
            return [
                .acknowledge,
                .disable,
                .enable,
                .reset,
                .snooze
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acknowledge: return "ACKNOWLEDGE"
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .reset: return "RESET"
            case .snooze: return "SNOOZE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains the configuration information of a disable action.
    public struct DisableActionConfiguration: Swift.Sendable {
        /// The note that you can leave when you disable the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains the configuration information of an enable action.
    public struct EnableActionConfiguration: Swift.Sendable {
        /// The note that you can leave when you enable the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains the configuration information of a reset action.
    public struct ResetActionConfiguration: Swift.Sendable {
        /// The note that you can leave when you reset the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains the configuration information of a snooze action.
    public struct SnoozeActionConfiguration: Swift.Sendable {
        /// The note that you can leave when you snooze the alarm.
        public var note: Swift.String?
        /// The snooze time in seconds. The alarm automatically changes to the NORMAL state after this duration.
        public var snoozeDuration: Swift.Int?

        public init(
            note: Swift.String? = nil,
            snoozeDuration: Swift.Int? = nil
        )
        {
            self.note = note
            self.snoozeDuration = snoozeDuration
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains information about the action that you can take to respond to the alarm.
    public struct CustomerAction: Swift.Sendable {
        /// Contains the configuration information of an acknowledge action.
        public var acknowledgeActionConfiguration: IoTEventsDataClientTypes.AcknowledgeActionConfiguration?
        /// The name of the action. The action name can be one of the following values:
        ///
        /// * SNOOZE - When you snooze the alarm, the alarm state changes to SNOOZE_DISABLED.
        ///
        /// * ENABLE - When you enable the alarm, the alarm state changes to NORMAL.
        ///
        /// * DISABLE - When you disable the alarm, the alarm state changes to DISABLED.
        ///
        /// * ACKNOWLEDGE - When you acknowledge the alarm, the alarm state changes to ACKNOWLEDGED.
        ///
        /// * RESET - When you reset the alarm, the alarm state changes to NORMAL.
        ///
        ///
        /// For more information, see the [AlarmState](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_AlarmState.html) API.
        public var actionName: IoTEventsDataClientTypes.CustomerActionName?
        /// Contains the configuration information of a disable action.
        public var disableActionConfiguration: IoTEventsDataClientTypes.DisableActionConfiguration?
        /// Contains the configuration information of an enable action.
        public var enableActionConfiguration: IoTEventsDataClientTypes.EnableActionConfiguration?
        /// Contains the configuration information of a reset action.
        public var resetActionConfiguration: IoTEventsDataClientTypes.ResetActionConfiguration?
        /// Contains the configuration information of a snooze action.
        public var snoozeActionConfiguration: IoTEventsDataClientTypes.SnoozeActionConfiguration?

        public init(
            acknowledgeActionConfiguration: IoTEventsDataClientTypes.AcknowledgeActionConfiguration? = nil,
            actionName: IoTEventsDataClientTypes.CustomerActionName? = nil,
            disableActionConfiguration: IoTEventsDataClientTypes.DisableActionConfiguration? = nil,
            enableActionConfiguration: IoTEventsDataClientTypes.EnableActionConfiguration? = nil,
            resetActionConfiguration: IoTEventsDataClientTypes.ResetActionConfiguration? = nil,
            snoozeActionConfiguration: IoTEventsDataClientTypes.SnoozeActionConfiguration? = nil
        )
        {
            self.acknowledgeActionConfiguration = acknowledgeActionConfiguration
            self.actionName = actionName
            self.disableActionConfiguration = disableActionConfiguration
            self.enableActionConfiguration = enableActionConfiguration
            self.resetActionConfiguration = resetActionConfiguration
            self.snoozeActionConfiguration = snoozeActionConfiguration
        }
    }
}

extension IoTEventsDataClientTypes {

    public enum ComparisonOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case less
        case lessOrEqual
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .less,
                .lessOrEqual,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .less: return "LESS"
            case .lessOrEqual: return "LESS_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information needed to compare two values with a comparison operator.
    public struct SimpleRuleEvaluation: Swift.Sendable {
        /// The value of the input property, on the left side of the comparison operator.
        public var inputPropertyValue: Swift.String?
        /// The comparison operator.
        public var `operator`: IoTEventsDataClientTypes.ComparisonOperator?
        /// The threshold value, on the right side of the comparison operator.
        public var thresholdValue: Swift.String?

        public init(
            inputPropertyValue: Swift.String? = nil,
            `operator`: IoTEventsDataClientTypes.ComparisonOperator? = nil,
            thresholdValue: Swift.String? = nil
        )
        {
            self.inputPropertyValue = inputPropertyValue
            self.`operator` = `operator`
            self.thresholdValue = thresholdValue
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information needed to evaluate data.
    public struct RuleEvaluation: Swift.Sendable {
        /// Information needed to compare two values with a comparison operator.
        public var simpleRuleEvaluation: IoTEventsDataClientTypes.SimpleRuleEvaluation?

        public init(
            simpleRuleEvaluation: IoTEventsDataClientTypes.SimpleRuleEvaluation? = nil
        )
        {
            self.simpleRuleEvaluation = simpleRuleEvaluation
        }
    }
}

extension IoTEventsDataClientTypes {

    public enum AlarmStateName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acknowledged
        case active
        case disabled
        case latched
        case normal
        case snoozeDisabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmStateName] {
            return [
                .acknowledged,
                .active,
                .disabled,
                .latched,
                .normal,
                .snoozeDisabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case .latched: return "LATCHED"
            case .normal: return "NORMAL"
            case .snoozeDisabled: return "SNOOZE_DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsDataClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stateChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .stateChange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stateChange: return "STATE_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsDataClientTypes {

    public enum TriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case snoozeTimeout
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .snoozeTimeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .snoozeTimeout: return "SNOOZE_TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains the configuration information of alarm state changes.
    public struct StateChangeConfiguration: Swift.Sendable {
        /// The trigger type. If the value is SNOOZE_TIMEOUT, the snooze duration ends and the alarm automatically changes to the NORMAL state.
        public var triggerType: IoTEventsDataClientTypes.TriggerType?

        public init(
            triggerType: IoTEventsDataClientTypes.TriggerType? = nil
        )
        {
            self.triggerType = triggerType
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains information about alarm state changes.
    public struct SystemEvent: Swift.Sendable {
        /// The event type. If the value is STATE_CHANGE, the event contains information about alarm state changes.
        public var eventType: IoTEventsDataClientTypes.EventType?
        /// Contains the configuration information of alarm state changes.
        public var stateChangeConfiguration: IoTEventsDataClientTypes.StateChangeConfiguration?

        public init(
            eventType: IoTEventsDataClientTypes.EventType? = nil,
            stateChangeConfiguration: IoTEventsDataClientTypes.StateChangeConfiguration? = nil
        )
        {
            self.eventType = eventType
            self.stateChangeConfiguration = stateChangeConfiguration
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains information about the current state of the alarm.
    public struct AlarmState: Swift.Sendable {
        /// Contains information about the action that you can take to respond to the alarm.
        public var customerAction: IoTEventsDataClientTypes.CustomerAction?
        /// Information needed to evaluate data.
        public var ruleEvaluation: IoTEventsDataClientTypes.RuleEvaluation?
        /// The name of the alarm state. The state name can be one of the following values:
        ///
        /// * DISABLED - When the alarm is in the DISABLED state, it isn't ready to evaluate data. To enable the alarm, you must change the alarm to the NORMAL state.
        ///
        /// * NORMAL - When the alarm is in the NORMAL state, it's ready to evaluate data.
        ///
        /// * ACTIVE - If the alarm is in the ACTIVE state, the alarm is invoked.
        ///
        /// * ACKNOWLEDGED - When the alarm is in the ACKNOWLEDGED state, the alarm was invoked and you acknowledged the alarm.
        ///
        /// * SNOOZE_DISABLED - When the alarm is in the SNOOZE_DISABLED state, the alarm is disabled for a specified period of time. After the snooze time, the alarm automatically changes to the NORMAL state.
        ///
        /// * LATCHED - When the alarm is in the LATCHED state, the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range. To change the alarm to the NORMAL state, you must acknowledge the alarm.
        public var stateName: IoTEventsDataClientTypes.AlarmStateName?
        /// Contains information about alarm state changes.
        public var systemEvent: IoTEventsDataClientTypes.SystemEvent?

        public init(
            customerAction: IoTEventsDataClientTypes.CustomerAction? = nil,
            ruleEvaluation: IoTEventsDataClientTypes.RuleEvaluation? = nil,
            stateName: IoTEventsDataClientTypes.AlarmStateName? = nil,
            systemEvent: IoTEventsDataClientTypes.SystemEvent? = nil
        )
        {
            self.customerAction = customerAction
            self.ruleEvaluation = ruleEvaluation
            self.stateName = stateName
            self.systemEvent = systemEvent
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains information about an alarm.
    public struct Alarm: Swift.Sendable {
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The version of the alarm model.
        public var alarmModelVersion: Swift.String?
        /// Contains information about the current state of the alarm.
        public var alarmState: IoTEventsDataClientTypes.AlarmState?
        /// The time the alarm was created, in the Unix epoch format.
        public var creationTime: Foundation.Date?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The time the alarm was last updated, in the Unix epoch format.
        public var lastUpdateTime: Foundation.Date?
        /// A non-negative integer that reflects the severity level of the alarm.
        public var severity: Swift.Int?

        public init(
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            alarmState: IoTEventsDataClientTypes.AlarmState? = nil,
            creationTime: Foundation.Date? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            severity: Swift.Int? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.alarmState = alarmState
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.severity = severity
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains a summary of an alarm.
    public struct AlarmSummary: Swift.Sendable {
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The version of the alarm model.
        public var alarmModelVersion: Swift.String?
        /// The time the alarm was created, in the Unix epoch format.
        public var creationTime: Foundation.Date?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The time the alarm was last updated, in the Unix epoch format.
        public var lastUpdateTime: Foundation.Date?
        /// The name of the alarm state. The state name can be one of the following values:
        ///
        /// * DISABLED - When the alarm is in the DISABLED state, it isn't ready to evaluate data. To enable the alarm, you must change the alarm to the NORMAL state.
        ///
        /// * NORMAL - When the alarm is in the NORMAL state, it's ready to evaluate data.
        ///
        /// * ACTIVE - If the alarm is in the ACTIVE state, the alarm is invoked.
        ///
        /// * ACKNOWLEDGED - When the alarm is in the ACKNOWLEDGED state, the alarm was invoked and you acknowledged the alarm.
        ///
        /// * SNOOZE_DISABLED - When the alarm is in the SNOOZE_DISABLED state, the alarm is disabled for a specified period of time. After the snooze time, the alarm automatically changes to the NORMAL state.
        ///
        /// * LATCHED - When the alarm is in the LATCHED state, the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range. To change the alarm to the NORMAL state, you must acknowledge the alarm.
        public var stateName: IoTEventsDataClientTypes.AlarmStateName?

        public init(
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            stateName: IoTEventsDataClientTypes.AlarmStateName? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.stateName = stateName
        }
    }
}

/// An internal failure occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was invalid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request could not be completed due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchAcknowledgeAlarmInput: Swift.Sendable {
    /// The list of acknowledge action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var acknowledgeActionRequests: [IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]?

    public init(
        acknowledgeActionRequests: [IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]? = nil
    )
    {
        self.acknowledgeActionRequests = acknowledgeActionRequests
    }
}

extension IoTEventsDataClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalfailureexception
        case invalidrequestexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalfailureexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Contains error messages associated with one of the following requests:
    ///
    /// * [BatchAcknowledgeAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchAcknowledgeAlarm.html)
    ///
    /// * [BatchDisableAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchDisableAlarm.html)
    ///
    /// * [BatchEnableAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchEnableAlarm.html)
    ///
    /// * [BatchResetAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchResetAlarm.html)
    ///
    /// * [BatchSnoozeAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchSnoozeAlarm.html)
    public struct BatchAlarmActionErrorEntry: Swift.Sendable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        public var requestId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.requestId = requestId
        }
    }
}

public struct BatchAcknowledgeAlarmOutput: Swift.Sendable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// Information used to delete the detector model.
    public struct DeleteDetectorRequest: Swift.Sendable {
        /// The name of the detector model that was used to create the detector instance.
        /// This member is required.
        public var detectorModelName: Swift.String?
        /// The value of the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateDetectorModel.html#iotevents-CreateDetectorModel-request-key) used to identify the detector.
        public var keyValue: Swift.String?
        /// The ID to assign to the DeleteDetectorRequest. Each "messageId" must be unique within each batch sent.
        /// This member is required.
        public var messageId: Swift.String?

        public init(
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
        }
    }
}

public struct BatchDeleteDetectorInput: Swift.Sendable {
    /// The list of one or more detectors to be deleted.
    /// This member is required.
    public var detectors: [IoTEventsDataClientTypes.DeleteDetectorRequest]?

    public init(
        detectors: [IoTEventsDataClientTypes.DeleteDetectorRequest]? = nil
    )
    {
        self.detectors = detectors
    }
}

extension IoTEventsDataClientTypes {

    /// Contains error messages associated with the deletion request.
    public struct BatchDeleteDetectorErrorEntry: Swift.Sendable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the message that caused the error. (See the value of the "messageId" in the [detectors](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchDeleteDetector.html#iotevents-iotevents-data_BatchDeleteDetector-request-detectors) object of the DeleteDetectorRequest.)
        public var messageId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }
}

public struct BatchDeleteDetectorOutput: Swift.Sendable {
    /// A list of errors associated with the request, or an empty array ([]) if there are no errors. Each error entry contains a messageId that helps you identify the entry that failed.
    public var batchDeleteDetectorErrorEntries: [IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]?

    public init(
        batchDeleteDetectorErrorEntries: [IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]? = nil
    )
    {
        self.batchDeleteDetectorErrorEntries = batchDeleteDetectorErrorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// Information used to disable the alarm.
    public struct DisableAlarmActionRequest: Swift.Sendable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you disable the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }
}

public struct BatchDisableAlarmInput: Swift.Sendable {
    /// The list of disable action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var disableActionRequests: [IoTEventsDataClientTypes.DisableAlarmActionRequest]?

    public init(
        disableActionRequests: [IoTEventsDataClientTypes.DisableAlarmActionRequest]? = nil
    )
    {
        self.disableActionRequests = disableActionRequests
    }
}

public struct BatchDisableAlarmOutput: Swift.Sendable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// Information needed to enable the alarm.
    public struct EnableAlarmActionRequest: Swift.Sendable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you enable the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }
}

public struct BatchEnableAlarmInput: Swift.Sendable {
    /// The list of enable action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var enableActionRequests: [IoTEventsDataClientTypes.EnableAlarmActionRequest]?

    public init(
        enableActionRequests: [IoTEventsDataClientTypes.EnableAlarmActionRequest]? = nil
    )
    {
        self.enableActionRequests = enableActionRequests
    }
}

public struct BatchEnableAlarmOutput: Swift.Sendable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// Contains information about a timestamp.
    public struct TimestampValue: Swift.Sendable {
        /// The value of the timestamp, in the Unix epoch format.
        public var timeInMillis: Swift.Int?

        public init(
            timeInMillis: Swift.Int? = nil
        )
        {
            self.timeInMillis = timeInMillis
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information about a message.
    public struct Message: Swift.Sendable {
        /// The name of the input into which the message payload is transformed.
        /// This member is required.
        public var inputName: Swift.String?
        /// The ID to assign to the message. Within each batch sent, each "messageId" must be unique.
        /// This member is required.
        public var messageId: Swift.String?
        /// The payload of the message. This can be a JSON string or a Base-64-encoded string representing binary data (in which case you must decode it).
        /// This member is required.
        public var payload: Foundation.Data?
        /// The timestamp associated with the message.
        public var timestamp: IoTEventsDataClientTypes.TimestampValue?

        public init(
            inputName: Swift.String? = nil,
            messageId: Swift.String? = nil,
            payload: Foundation.Data? = nil,
            timestamp: IoTEventsDataClientTypes.TimestampValue? = nil
        )
        {
            self.inputName = inputName
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }
    }
}

public struct BatchPutMessageInput: Swift.Sendable {
    /// The list of messages to send. Each message has the following format: '{ "messageId": "string", "inputName": "string", "payload": "string"}'
    /// This member is required.
    public var messages: [IoTEventsDataClientTypes.Message]?

    public init(
        messages: [IoTEventsDataClientTypes.Message]? = nil
    )
    {
        self.messages = messages
    }
}

extension IoTEventsDataClientTypes {

    /// Contains information about the errors encountered.
    public struct BatchPutMessageErrorEntry: Swift.Sendable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the message that caused the error. (See the value corresponding to the "messageId" key in the "message" object.)
        public var messageId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }
}

public struct BatchPutMessageOutput: Swift.Sendable {
    /// A list of any errors encountered when sending the messages.
    public var batchPutMessageErrorEntries: [IoTEventsDataClientTypes.BatchPutMessageErrorEntry]?

    public init(
        batchPutMessageErrorEntries: [IoTEventsDataClientTypes.BatchPutMessageErrorEntry]? = nil
    )
    {
        self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// Information needed to reset the alarm.
    public struct ResetAlarmActionRequest: Swift.Sendable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you reset the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }
}

public struct BatchResetAlarmInput: Swift.Sendable {
    /// The list of reset action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var resetActionRequests: [IoTEventsDataClientTypes.ResetAlarmActionRequest]?

    public init(
        resetActionRequests: [IoTEventsDataClientTypes.ResetAlarmActionRequest]? = nil
    )
    {
        self.resetActionRequests = resetActionRequests
    }
}

public struct BatchResetAlarmOutput: Swift.Sendable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// Information needed to snooze the alarm.
    public struct SnoozeAlarmActionRequest: Swift.Sendable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you snooze the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?
        /// The snooze time in seconds. The alarm automatically changes to the NORMAL state after this duration.
        /// This member is required.
        public var snoozeDuration: Swift.Int?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil,
            snoozeDuration: Swift.Int? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
            self.snoozeDuration = snoozeDuration
        }
    }
}

public struct BatchSnoozeAlarmInput: Swift.Sendable {
    /// The list of snooze action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var snoozeActionRequests: [IoTEventsDataClientTypes.SnoozeAlarmActionRequest]?

    public init(
        snoozeActionRequests: [IoTEventsDataClientTypes.SnoozeAlarmActionRequest]? = nil
    )
    {
        self.snoozeActionRequests = snoozeActionRequests
    }
}

public struct BatchSnoozeAlarmOutput: Swift.Sendable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

extension IoTEventsDataClientTypes {

    /// The new setting of a timer.
    public struct TimerDefinition: Swift.Sendable {
        /// The name of the timer.
        /// This member is required.
        public var name: Swift.String?
        /// The new setting of the timer (the number of seconds before the timer elapses).
        /// This member is required.
        public var seconds: Swift.Int?

        public init(
            name: Swift.String? = nil,
            seconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.seconds = seconds
        }
    }
}

extension IoTEventsDataClientTypes {

    /// The new value of the variable.
    public struct VariableDefinition: Swift.Sendable {
        /// The name of the variable.
        /// This member is required.
        public var name: Swift.String?
        /// The new value of the variable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension IoTEventsDataClientTypes {

    /// The new state, variable values, and timer settings of the detector (instance).
    public struct DetectorStateDefinition: Swift.Sendable {
        /// The name of the new state of the detector (instance).
        /// This member is required.
        public var stateName: Swift.String?
        /// The new values of the detector's timers. Any timer whose value isn't specified is cleared, and its timeout event won't occur.
        /// This member is required.
        public var timers: [IoTEventsDataClientTypes.TimerDefinition]?
        /// The new values of the detector's variables. Any variable whose value isn't specified is cleared.
        /// This member is required.
        public var variables: [IoTEventsDataClientTypes.VariableDefinition]?

        public init(
            stateName: Swift.String? = nil,
            timers: [IoTEventsDataClientTypes.TimerDefinition]? = nil,
            variables: [IoTEventsDataClientTypes.VariableDefinition]? = nil
        )
        {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information used to update the detector (instance).
    public struct UpdateDetectorRequest: Swift.Sendable {
        /// The name of the detector model that created the detectors (instances).
        /// This member is required.
        public var detectorModelName: Swift.String?
        /// The value of the input key attribute (identifying the device or system) that caused the creation of this detector (instance).
        public var keyValue: Swift.String?
        /// The ID to assign to the detector update "message". Each "messageId" must be unique within each batch sent.
        /// This member is required.
        public var messageId: Swift.String?
        /// The new state, variable values, and timer settings of the detector (instance).
        /// This member is required.
        public var state: IoTEventsDataClientTypes.DetectorStateDefinition?

        public init(
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            messageId: Swift.String? = nil,
            state: IoTEventsDataClientTypes.DetectorStateDefinition? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
            self.state = state
        }
    }
}

public struct BatchUpdateDetectorInput: Swift.Sendable {
    /// The list of detectors (instances) to update, along with the values to update.
    /// This member is required.
    public var detectors: [IoTEventsDataClientTypes.UpdateDetectorRequest]?

    public init(
        detectors: [IoTEventsDataClientTypes.UpdateDetectorRequest]? = nil
    )
    {
        self.detectors = detectors
    }
}

extension IoTEventsDataClientTypes {

    /// Information about the error that occurred when attempting to update a detector.
    public struct BatchUpdateDetectorErrorEntry: Swift.Sendable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The "messageId" of the update request that caused the error. (The value of the "messageId" in the update request "Detector" object.)
        public var messageId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }
}

public struct BatchUpdateDetectorOutput: Swift.Sendable {
    /// A list of those detector updates that resulted in errors. (If an error is listed here, the specific update did not occur.)
    public var batchUpdateDetectorErrorEntries: [IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]?

    public init(
        batchUpdateDetectorErrorEntries: [IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]? = nil
    )
    {
        self.batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntries
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeAlarmInput: Swift.Sendable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
    public var keyValue: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil,
        keyValue: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
    }
}

public struct DescribeAlarmOutput: Swift.Sendable {
    /// Contains information about an alarm.
    public var alarm: IoTEventsDataClientTypes.Alarm?

    public init(
        alarm: IoTEventsDataClientTypes.Alarm? = nil
    )
    {
        self.alarm = alarm
    }
}

public struct DescribeDetectorInput: Swift.Sendable {
    /// The name of the detector model whose detectors (instances) you want information about.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// A filter used to limit results to detectors (instances) created because of the given key ID.
    public var keyValue: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil,
        keyValue: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.keyValue = keyValue
    }
}

extension IoTEventsDataClientTypes {

    /// The current state of a timer.
    public struct Timer: Swift.Sendable {
        /// The name of the timer.
        /// This member is required.
        public var name: Swift.String?
        /// The expiration time for the timer.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            name: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.name = name
            self.timestamp = timestamp
        }
    }
}

extension IoTEventsDataClientTypes {

    /// The current state of the variable.
    public struct Variable: Swift.Sendable {
        /// The name of the variable.
        /// This member is required.
        public var name: Swift.String?
        /// The current value of the variable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information about the current state of the detector instance.
    public struct DetectorState: Swift.Sendable {
        /// The name of the state.
        /// This member is required.
        public var stateName: Swift.String?
        /// The current state of the detector's timers.
        /// This member is required.
        public var timers: [IoTEventsDataClientTypes.Timer]?
        /// The current values of the detector's variables.
        /// This member is required.
        public var variables: [IoTEventsDataClientTypes.Variable]?

        public init(
            stateName: Swift.String? = nil,
            timers: [IoTEventsDataClientTypes.Timer]? = nil,
            variables: [IoTEventsDataClientTypes.Variable]? = nil
        )
        {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information about the detector (instance).
    public struct Detector: Swift.Sendable {
        /// The time the detector (instance) was created.
        public var creationTime: Foundation.Date?
        /// The name of the detector model that created this detector (instance).
        public var detectorModelName: Swift.String?
        /// The version of the detector model that created this detector (instance).
        public var detectorModelVersion: Swift.String?
        /// The value of the key (identifying the device or system) that caused the creation of this detector (instance).
        public var keyValue: Swift.String?
        /// The time the detector (instance) was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The current state of the detector (instance).
        public var state: IoTEventsDataClientTypes.DetectorState?

        public init(
            creationTime: Foundation.Date? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            state: IoTEventsDataClientTypes.DetectorState? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }
    }
}

public struct DescribeDetectorOutput: Swift.Sendable {
    /// Information about the detector (instance).
    public var detector: IoTEventsDataClientTypes.Detector?

    public init(
        detector: IoTEventsDataClientTypes.Detector? = nil
    )
    {
        self.detector = detector
    }
}

extension IoTEventsDataClientTypes {

    /// Information about the detector state.
    public struct DetectorStateSummary: Swift.Sendable {
        /// The name of the state.
        public var stateName: Swift.String?

        public init(
            stateName: Swift.String? = nil
        )
        {
            self.stateName = stateName
        }
    }
}

extension IoTEventsDataClientTypes {

    /// Information about the detector (instance).
    public struct DetectorSummary: Swift.Sendable {
        /// The time the detector (instance) was created.
        public var creationTime: Foundation.Date?
        /// The name of the detector model that created this detector (instance).
        public var detectorModelName: Swift.String?
        /// The version of the detector model that created this detector (instance).
        public var detectorModelVersion: Swift.String?
        /// The value of the key (identifying the device or system) that caused the creation of this detector (instance).
        public var keyValue: Swift.String?
        /// The time the detector (instance) was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The current state of the detector (instance).
        public var state: IoTEventsDataClientTypes.DetectorStateSummary?

        public init(
            creationTime: Foundation.Date? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            state: IoTEventsDataClientTypes.DetectorStateSummary? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }
    }
}

public struct ListAlarmsInput: Swift.Sendable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAlarmsOutput: Swift.Sendable {
    /// A list that summarizes each alarm.
    public var alarmSummaries: [IoTEventsDataClientTypes.AlarmSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        alarmSummaries: [IoTEventsDataClientTypes.AlarmSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmSummaries = alarmSummaries
        self.nextToken = nextToken
    }
}

public struct ListDetectorsInput: Swift.Sendable {
    /// The name of the detector model whose detectors (instances) are listed.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?
    /// A filter that limits results to those detectors (instances) in the given state.
    public var stateName: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stateName: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateName = stateName
    }
}

public struct ListDetectorsOutput: Swift.Sendable {
    /// A list of summary information about the detectors (instances).
    public var detectorSummaries: [IoTEventsDataClientTypes.DetectorSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        detectorSummaries: [IoTEventsDataClientTypes.DetectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorSummaries = detectorSummaries
        self.nextToken = nextToken
    }
}

extension BatchAcknowledgeAlarmInput {

    static func urlPathProvider(_ value: BatchAcknowledgeAlarmInput) -> Swift.String? {
        return "/alarms/acknowledge"
    }
}

extension BatchDeleteDetectorInput {

    static func urlPathProvider(_ value: BatchDeleteDetectorInput) -> Swift.String? {
        return "/detectors/delete"
    }
}

extension BatchDisableAlarmInput {

    static func urlPathProvider(_ value: BatchDisableAlarmInput) -> Swift.String? {
        return "/alarms/disable"
    }
}

extension BatchEnableAlarmInput {

    static func urlPathProvider(_ value: BatchEnableAlarmInput) -> Swift.String? {
        return "/alarms/enable"
    }
}

extension BatchPutMessageInput {

    static func urlPathProvider(_ value: BatchPutMessageInput) -> Swift.String? {
        return "/inputs/messages"
    }
}

extension BatchResetAlarmInput {

    static func urlPathProvider(_ value: BatchResetAlarmInput) -> Swift.String? {
        return "/alarms/reset"
    }
}

extension BatchSnoozeAlarmInput {

    static func urlPathProvider(_ value: BatchSnoozeAlarmInput) -> Swift.String? {
        return "/alarms/snooze"
    }
}

extension BatchUpdateDetectorInput {

    static func urlPathProvider(_ value: BatchUpdateDetectorInput) -> Swift.String? {
        return "/detectors"
    }
}

extension DescribeAlarmInput {

    static func urlPathProvider(_ value: DescribeAlarmInput) -> Swift.String? {
        guard let alarmModelName = value.alarmModelName else {
            return nil
        }
        return "/alarms/\(alarmModelName.urlPercentEncoding())/keyValues"
    }
}

extension DescribeAlarmInput {

    static func queryItemProvider(_ value: DescribeAlarmInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let keyValue = value.keyValue {
            let keyValueQueryItem = Smithy.URIQueryItem(name: "keyValue".urlPercentEncoding(), value: Swift.String(keyValue).urlPercentEncoding())
            items.append(keyValueQueryItem)
        }
        return items
    }
}

extension DescribeDetectorInput {

    static func urlPathProvider(_ value: DescribeDetectorInput) -> Swift.String? {
        guard let detectorModelName = value.detectorModelName else {
            return nil
        }
        return "/detectors/\(detectorModelName.urlPercentEncoding())/keyValues"
    }
}

extension DescribeDetectorInput {

    static func queryItemProvider(_ value: DescribeDetectorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let keyValue = value.keyValue {
            let keyValueQueryItem = Smithy.URIQueryItem(name: "keyValue".urlPercentEncoding(), value: Swift.String(keyValue).urlPercentEncoding())
            items.append(keyValueQueryItem)
        }
        return items
    }
}

extension ListAlarmsInput {

    static func urlPathProvider(_ value: ListAlarmsInput) -> Swift.String? {
        guard let alarmModelName = value.alarmModelName else {
            return nil
        }
        return "/alarms/\(alarmModelName.urlPercentEncoding())"
    }
}

extension ListAlarmsInput {

    static func queryItemProvider(_ value: ListAlarmsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDetectorsInput {

    static func urlPathProvider(_ value: ListDetectorsInput) -> Swift.String? {
        guard let detectorModelName = value.detectorModelName else {
            return nil
        }
        return "/detectors/\(detectorModelName.urlPercentEncoding())"
    }
}

extension ListDetectorsInput {

    static func queryItemProvider(_ value: ListDetectorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stateName = value.stateName {
            let stateNameQueryItem = Smithy.URIQueryItem(name: "stateName".urlPercentEncoding(), value: Swift.String(stateName).urlPercentEncoding())
            items.append(stateNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension BatchAcknowledgeAlarmInput {

    static func write(value: BatchAcknowledgeAlarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acknowledgeActionRequests"].writeList(value.acknowledgeActionRequests, memberWritingClosure: IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteDetectorInput {

    static func write(value: BatchDeleteDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectors"].writeList(value.detectors, memberWritingClosure: IoTEventsDataClientTypes.DeleteDetectorRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDisableAlarmInput {

    static func write(value: BatchDisableAlarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["disableActionRequests"].writeList(value.disableActionRequests, memberWritingClosure: IoTEventsDataClientTypes.DisableAlarmActionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchEnableAlarmInput {

    static func write(value: BatchEnableAlarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableActionRequests"].writeList(value.enableActionRequests, memberWritingClosure: IoTEventsDataClientTypes.EnableAlarmActionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchPutMessageInput {

    static func write(value: BatchPutMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["messages"].writeList(value.messages, memberWritingClosure: IoTEventsDataClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchResetAlarmInput {

    static func write(value: BatchResetAlarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resetActionRequests"].writeList(value.resetActionRequests, memberWritingClosure: IoTEventsDataClientTypes.ResetAlarmActionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchSnoozeAlarmInput {

    static func write(value: BatchSnoozeAlarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["snoozeActionRequests"].writeList(value.snoozeActionRequests, memberWritingClosure: IoTEventsDataClientTypes.SnoozeAlarmActionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateDetectorInput {

    static func write(value: BatchUpdateDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectors"].writeList(value.detectors, memberWritingClosure: IoTEventsDataClientTypes.UpdateDetectorRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchAcknowledgeAlarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAcknowledgeAlarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAcknowledgeAlarmOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchAlarmActionErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteDetectorOutput()
        value.batchDeleteDetectorErrorEntries = try reader["batchDeleteDetectorErrorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisableAlarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisableAlarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisableAlarmOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchAlarmActionErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchEnableAlarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchEnableAlarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchEnableAlarmOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchAlarmActionErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchPutMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutMessageOutput()
        value.batchPutMessageErrorEntries = try reader["BatchPutMessageErrorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchPutMessageErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchResetAlarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchResetAlarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchResetAlarmOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchAlarmActionErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchSnoozeAlarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchSnoozeAlarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchSnoozeAlarmOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchAlarmActionErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateDetectorOutput()
        value.batchUpdateDetectorErrorEntries = try reader["batchUpdateDetectorErrorEntries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeAlarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAlarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAlarmOutput()
        value.alarm = try reader["alarm"].readIfPresent(with: IoTEventsDataClientTypes.Alarm.read(from:))
        return value
    }
}

extension DescribeDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDetectorOutput()
        value.detector = try reader["detector"].readIfPresent(with: IoTEventsDataClientTypes.Detector.read(from:))
        return value
    }
}

extension ListAlarmsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAlarmsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAlarmsOutput()
        value.alarmSummaries = try reader["alarmSummaries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.AlarmSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDetectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDetectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDetectorsOutput()
        value.detectorSummaries = try reader["detectorSummaries"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.DetectorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

enum BatchAcknowledgeAlarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisableAlarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchEnableAlarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchResetAlarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchSnoozeAlarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAlarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAlarmsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDetectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTEventsDataClientTypes.BatchAlarmActionErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.BatchAlarmActionErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.BatchAlarmActionErrorEntry()
        value.requestId = try reader["requestId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry()
        value.messageId = try reader["messageId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.BatchPutMessageErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.BatchPutMessageErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.BatchPutMessageErrorEntry()
        value.messageId = try reader["messageId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry()
        value.messageId = try reader["messageId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.Alarm {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.Alarm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.Alarm()
        value.alarmModelName = try reader["alarmModelName"].readIfPresent()
        value.alarmModelVersion = try reader["alarmModelVersion"].readIfPresent()
        value.keyValue = try reader["keyValue"].readIfPresent()
        value.alarmState = try reader["alarmState"].readIfPresent(with: IoTEventsDataClientTypes.AlarmState.read(from:))
        value.severity = try reader["severity"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTEventsDataClientTypes.AlarmState {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.AlarmState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.AlarmState()
        value.stateName = try reader["stateName"].readIfPresent()
        value.ruleEvaluation = try reader["ruleEvaluation"].readIfPresent(with: IoTEventsDataClientTypes.RuleEvaluation.read(from:))
        value.customerAction = try reader["customerAction"].readIfPresent(with: IoTEventsDataClientTypes.CustomerAction.read(from:))
        value.systemEvent = try reader["systemEvent"].readIfPresent(with: IoTEventsDataClientTypes.SystemEvent.read(from:))
        return value
    }
}

extension IoTEventsDataClientTypes.SystemEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.SystemEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.SystemEvent()
        value.eventType = try reader["eventType"].readIfPresent()
        value.stateChangeConfiguration = try reader["stateChangeConfiguration"].readIfPresent(with: IoTEventsDataClientTypes.StateChangeConfiguration.read(from:))
        return value
    }
}

extension IoTEventsDataClientTypes.StateChangeConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.StateChangeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.StateChangeConfiguration()
        value.triggerType = try reader["triggerType"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.CustomerAction {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.CustomerAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.CustomerAction()
        value.actionName = try reader["actionName"].readIfPresent()
        value.snoozeActionConfiguration = try reader["snoozeActionConfiguration"].readIfPresent(with: IoTEventsDataClientTypes.SnoozeActionConfiguration.read(from:))
        value.enableActionConfiguration = try reader["enableActionConfiguration"].readIfPresent(with: IoTEventsDataClientTypes.EnableActionConfiguration.read(from:))
        value.disableActionConfiguration = try reader["disableActionConfiguration"].readIfPresent(with: IoTEventsDataClientTypes.DisableActionConfiguration.read(from:))
        value.acknowledgeActionConfiguration = try reader["acknowledgeActionConfiguration"].readIfPresent(with: IoTEventsDataClientTypes.AcknowledgeActionConfiguration.read(from:))
        value.resetActionConfiguration = try reader["resetActionConfiguration"].readIfPresent(with: IoTEventsDataClientTypes.ResetActionConfiguration.read(from:))
        return value
    }
}

extension IoTEventsDataClientTypes.ResetActionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.ResetActionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.ResetActionConfiguration()
        value.note = try reader["note"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.AcknowledgeActionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.AcknowledgeActionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.AcknowledgeActionConfiguration()
        value.note = try reader["note"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.DisableActionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.DisableActionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.DisableActionConfiguration()
        value.note = try reader["note"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.EnableActionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.EnableActionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.EnableActionConfiguration()
        value.note = try reader["note"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.SnoozeActionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.SnoozeActionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.SnoozeActionConfiguration()
        value.snoozeDuration = try reader["snoozeDuration"].readIfPresent()
        value.note = try reader["note"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.RuleEvaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.RuleEvaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.RuleEvaluation()
        value.simpleRuleEvaluation = try reader["simpleRuleEvaluation"].readIfPresent(with: IoTEventsDataClientTypes.SimpleRuleEvaluation.read(from:))
        return value
    }
}

extension IoTEventsDataClientTypes.SimpleRuleEvaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.SimpleRuleEvaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.SimpleRuleEvaluation()
        value.inputPropertyValue = try reader["inputPropertyValue"].readIfPresent()
        value.`operator` = try reader["operator"].readIfPresent()
        value.thresholdValue = try reader["thresholdValue"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.Detector {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.Detector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.Detector()
        value.detectorModelName = try reader["detectorModelName"].readIfPresent()
        value.keyValue = try reader["keyValue"].readIfPresent()
        value.detectorModelVersion = try reader["detectorModelVersion"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: IoTEventsDataClientTypes.DetectorState.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTEventsDataClientTypes.DetectorState {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.DetectorState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.DetectorState()
        value.stateName = try reader["stateName"].readIfPresent() ?? ""
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.Variable.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timers = try reader["timers"].readListIfPresent(memberReadingClosure: IoTEventsDataClientTypes.Timer.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTEventsDataClientTypes.Timer {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.Timer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.Timer()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTEventsDataClientTypes.Variable {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.Variable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.Variable()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsDataClientTypes.AlarmSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.AlarmSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.AlarmSummary()
        value.alarmModelName = try reader["alarmModelName"].readIfPresent()
        value.alarmModelVersion = try reader["alarmModelVersion"].readIfPresent()
        value.keyValue = try reader["keyValue"].readIfPresent()
        value.stateName = try reader["stateName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTEventsDataClientTypes.DetectorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.DetectorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.DetectorSummary()
        value.detectorModelName = try reader["detectorModelName"].readIfPresent()
        value.keyValue = try reader["keyValue"].readIfPresent()
        value.detectorModelVersion = try reader["detectorModelVersion"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: IoTEventsDataClientTypes.DetectorStateSummary.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTEventsDataClientTypes.DetectorStateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsDataClientTypes.DetectorStateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsDataClientTypes.DetectorStateSummary()
        value.stateName = try reader["stateName"].readIfPresent()
        return value
    }
}

extension IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest {

    static func write(value: IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmModelName"].write(value.alarmModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["note"].write(value.note)
        try writer["requestId"].write(value.requestId)
    }
}

extension IoTEventsDataClientTypes.DeleteDetectorRequest {

    static func write(value: IoTEventsDataClientTypes.DeleteDetectorRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorModelName"].write(value.detectorModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["messageId"].write(value.messageId)
    }
}

extension IoTEventsDataClientTypes.DisableAlarmActionRequest {

    static func write(value: IoTEventsDataClientTypes.DisableAlarmActionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmModelName"].write(value.alarmModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["note"].write(value.note)
        try writer["requestId"].write(value.requestId)
    }
}

extension IoTEventsDataClientTypes.EnableAlarmActionRequest {

    static func write(value: IoTEventsDataClientTypes.EnableAlarmActionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmModelName"].write(value.alarmModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["note"].write(value.note)
        try writer["requestId"].write(value.requestId)
    }
}

extension IoTEventsDataClientTypes.Message {

    static func write(value: IoTEventsDataClientTypes.Message?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputName"].write(value.inputName)
        try writer["messageId"].write(value.messageId)
        try writer["payload"].write(value.payload)
        try writer["timestamp"].write(value.timestamp, with: IoTEventsDataClientTypes.TimestampValue.write(value:to:))
    }
}

extension IoTEventsDataClientTypes.TimestampValue {

    static func write(value: IoTEventsDataClientTypes.TimestampValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timeInMillis"].write(value.timeInMillis)
    }
}

extension IoTEventsDataClientTypes.ResetAlarmActionRequest {

    static func write(value: IoTEventsDataClientTypes.ResetAlarmActionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmModelName"].write(value.alarmModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["note"].write(value.note)
        try writer["requestId"].write(value.requestId)
    }
}

extension IoTEventsDataClientTypes.SnoozeAlarmActionRequest {

    static func write(value: IoTEventsDataClientTypes.SnoozeAlarmActionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmModelName"].write(value.alarmModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["note"].write(value.note)
        try writer["requestId"].write(value.requestId)
        try writer["snoozeDuration"].write(value.snoozeDuration)
    }
}

extension IoTEventsDataClientTypes.UpdateDetectorRequest {

    static func write(value: IoTEventsDataClientTypes.UpdateDetectorRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorModelName"].write(value.detectorModelName)
        try writer["keyValue"].write(value.keyValue)
        try writer["messageId"].write(value.messageId)
        try writer["state"].write(value.state, with: IoTEventsDataClientTypes.DetectorStateDefinition.write(value:to:))
    }
}

extension IoTEventsDataClientTypes.DetectorStateDefinition {

    static func write(value: IoTEventsDataClientTypes.DetectorStateDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stateName"].write(value.stateName)
        try writer["timers"].writeList(value.timers, memberWritingClosure: IoTEventsDataClientTypes.TimerDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["variables"].writeList(value.variables, memberWritingClosure: IoTEventsDataClientTypes.VariableDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTEventsDataClientTypes.TimerDefinition {

    static func write(value: IoTEventsDataClientTypes.TimerDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["seconds"].write(value.seconds)
    }
}

extension IoTEventsDataClientTypes.VariableDefinition {

    static func write(value: IoTEventsDataClientTypes.VariableDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

public enum IoTEventsDataClientTypes {}
