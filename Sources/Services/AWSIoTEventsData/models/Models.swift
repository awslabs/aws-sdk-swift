// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTEventsDataClientTypes.AcknowledgeActionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains the configuration information of an acknowledge action.
    public struct AcknowledgeActionConfiguration: Swift.Equatable {
        /// The note that you can leave when you acknowledge the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information needed to acknowledge the alarm.
    public struct AcknowledgeAlarmActionRequest: Swift.Equatable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you acknowledge the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension IoTEventsDataClientTypes.Alarm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case alarmModelVersion
        case alarmState
        case creationTime
        case keyValue
        case lastUpdateTime
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = self.alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let alarmState = self.alarmState {
            try encodeContainer.encode(alarmState, forKey: .alarmState)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let alarmStateDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.AlarmState.self, forKey: .alarmState)
        alarmState = alarmStateDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains information about an alarm.
    public struct Alarm: Swift.Equatable {
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The version of the alarm model.
        public var alarmModelVersion: Swift.String?
        /// Contains information about the current state of the alarm.
        public var alarmState: IoTEventsDataClientTypes.AlarmState?
        /// The time the alarm was created, in the Unix epoch format.
        public var creationTime: ClientRuntime.Date?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The time the alarm was last updated, in the Unix epoch format.
        public var lastUpdateTime: ClientRuntime.Date?
        /// A non-negative integer that reflects the severity level of the alarm.
        public var severity: Swift.Int?

        public init(
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            alarmState: IoTEventsDataClientTypes.AlarmState? = nil,
            creationTime: ClientRuntime.Date? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            severity: Swift.Int? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.alarmState = alarmState
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.severity = severity
        }
    }

}

extension IoTEventsDataClientTypes.AlarmState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerAction
        case ruleEvaluation
        case stateName
        case systemEvent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerAction = self.customerAction {
            try encodeContainer.encode(customerAction, forKey: .customerAction)
        }
        if let ruleEvaluation = self.ruleEvaluation {
            try encodeContainer.encode(ruleEvaluation, forKey: .ruleEvaluation)
        }
        if let stateName = self.stateName {
            try encodeContainer.encode(stateName.rawValue, forKey: .stateName)
        }
        if let systemEvent = self.systemEvent {
            try encodeContainer.encode(systemEvent, forKey: .systemEvent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.AlarmStateName.self, forKey: .stateName)
        stateName = stateNameDecoded
        let ruleEvaluationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.RuleEvaluation.self, forKey: .ruleEvaluation)
        ruleEvaluation = ruleEvaluationDecoded
        let customerActionDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.CustomerAction.self, forKey: .customerAction)
        customerAction = customerActionDecoded
        let systemEventDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.SystemEvent.self, forKey: .systemEvent)
        systemEvent = systemEventDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains information about the current state of the alarm.
    public struct AlarmState: Swift.Equatable {
        /// Contains information about the action that you can take to respond to the alarm.
        public var customerAction: IoTEventsDataClientTypes.CustomerAction?
        /// Information needed to evaluate data.
        public var ruleEvaluation: IoTEventsDataClientTypes.RuleEvaluation?
        /// The name of the alarm state. The state name can be one of the following values:
        ///
        /// * DISABLED - When the alarm is in the DISABLED state, it isn't ready to evaluate data. To enable the alarm, you must change the alarm to the NORMAL state.
        ///
        /// * NORMAL - When the alarm is in the NORMAL state, it's ready to evaluate data.
        ///
        /// * ACTIVE - If the alarm is in the ACTIVE state, the alarm is invoked.
        ///
        /// * ACKNOWLEDGED - When the alarm is in the ACKNOWLEDGED state, the alarm was invoked and you acknowledged the alarm.
        ///
        /// * SNOOZE_DISABLED - When the alarm is in the SNOOZE_DISABLED state, the alarm is disabled for a specified period of time. After the snooze time, the alarm automatically changes to the NORMAL state.
        ///
        /// * LATCHED - When the alarm is in the LATCHED state, the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range. To change the alarm to the NORMAL state, you must acknowledge the alarm.
        public var stateName: IoTEventsDataClientTypes.AlarmStateName?
        /// Contains information about alarm state changes.
        public var systemEvent: IoTEventsDataClientTypes.SystemEvent?

        public init(
            customerAction: IoTEventsDataClientTypes.CustomerAction? = nil,
            ruleEvaluation: IoTEventsDataClientTypes.RuleEvaluation? = nil,
            stateName: IoTEventsDataClientTypes.AlarmStateName? = nil,
            systemEvent: IoTEventsDataClientTypes.SystemEvent? = nil
        )
        {
            self.customerAction = customerAction
            self.ruleEvaluation = ruleEvaluation
            self.stateName = stateName
            self.systemEvent = systemEvent
        }
    }

}

extension IoTEventsDataClientTypes {
    public enum AlarmStateName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledged
        case active
        case disabled
        case latched
        case normal
        case snoozeDisabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmStateName] {
            return [
                .acknowledged,
                .active,
                .disabled,
                .latched,
                .normal,
                .snoozeDisabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case .latched: return "LATCHED"
            case .normal: return "NORMAL"
            case .snoozeDisabled: return "SNOOZE_DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmStateName(rawValue: rawValue) ?? AlarmStateName.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsDataClientTypes.AlarmSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case alarmModelVersion
        case creationTime
        case keyValue
        case lastUpdateTime
        case stateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = self.alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let stateName = self.stateName {
            try encodeContainer.encode(stateName.rawValue, forKey: .stateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let stateNameDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.AlarmStateName.self, forKey: .stateName)
        stateName = stateNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains a summary of an alarm.
    public struct AlarmSummary: Swift.Equatable {
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The version of the alarm model.
        public var alarmModelVersion: Swift.String?
        /// The time the alarm was created, in the Unix epoch format.
        public var creationTime: ClientRuntime.Date?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The time the alarm was last updated, in the Unix epoch format.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the alarm state. The state name can be one of the following values:
        ///
        /// * DISABLED - When the alarm is in the DISABLED state, it isn't ready to evaluate data. To enable the alarm, you must change the alarm to the NORMAL state.
        ///
        /// * NORMAL - When the alarm is in the NORMAL state, it's ready to evaluate data.
        ///
        /// * ACTIVE - If the alarm is in the ACTIVE state, the alarm is invoked.
        ///
        /// * ACKNOWLEDGED - When the alarm is in the ACKNOWLEDGED state, the alarm was invoked and you acknowledged the alarm.
        ///
        /// * SNOOZE_DISABLED - When the alarm is in the SNOOZE_DISABLED state, the alarm is disabled for a specified period of time. After the snooze time, the alarm automatically changes to the NORMAL state.
        ///
        /// * LATCHED - When the alarm is in the LATCHED state, the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range. To change the alarm to the NORMAL state, you must acknowledge the alarm.
        public var stateName: IoTEventsDataClientTypes.AlarmStateName?

        public init(
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            stateName: IoTEventsDataClientTypes.AlarmStateName? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.stateName = stateName
        }
    }

}

extension BatchAcknowledgeAlarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeActionRequests = acknowledgeActionRequests {
            var acknowledgeActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acknowledgeActionRequests)
            for acknowledgealarmactionrequest0 in acknowledgeActionRequests {
                try acknowledgeActionRequestsContainer.encode(acknowledgealarmactionrequest0)
            }
        }
    }
}

extension BatchAcknowledgeAlarmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarms/acknowledge"
    }
}

public struct BatchAcknowledgeAlarmInput: Swift.Equatable {
    /// The list of acknowledge action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var acknowledgeActionRequests: [IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]?

    public init(
        acknowledgeActionRequests: [IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]? = nil
    )
    {
        self.acknowledgeActionRequests = acknowledgeActionRequests
    }
}

struct BatchAcknowledgeAlarmInputBody: Swift.Equatable {
    let acknowledgeActionRequests: [IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]?
}

extension BatchAcknowledgeAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeActionRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acknowledgeActionRequestsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest?].self, forKey: .acknowledgeActionRequests)
        var acknowledgeActionRequestsDecoded0:[IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]? = nil
        if let acknowledgeActionRequestsContainer = acknowledgeActionRequestsContainer {
            acknowledgeActionRequestsDecoded0 = [IoTEventsDataClientTypes.AcknowledgeAlarmActionRequest]()
            for structure0 in acknowledgeActionRequestsContainer {
                if let structure0 = structure0 {
                    acknowledgeActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        acknowledgeActionRequests = acknowledgeActionRequestsDecoded0
    }
}

extension BatchAcknowledgeAlarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAcknowledgeAlarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchAcknowledgeAlarmOutput: Swift.Equatable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchAcknowledgeAlarmOutputBody: Swift.Equatable {
    let errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchAcknowledgeAlarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchAcknowledgeAlarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTEventsDataClientTypes.BatchAlarmActionErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains error messages associated with one of the following requests:
    ///
    /// * [BatchAcknowledgeAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchAcknowledgeAlarm.html)
    ///
    /// * [BatchDisableAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchDisableAlarm.html)
    ///
    /// * [BatchEnableAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchEnableAlarm.html)
    ///
    /// * [BatchResetAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchResetAlarm.html)
    ///
    /// * [BatchSnoozeAlarm](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchSnoozeAlarm.html)
    public struct BatchAlarmActionErrorEntry: Swift.Equatable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        public var requestId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.requestId = requestId
        }
    }

}

extension IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains error messages associated with the deletion request.
    public struct BatchDeleteDetectorErrorEntry: Swift.Equatable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the message that caused the error. (See the value of the "messageId" in the [detectors](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchDeleteDetector.html#iotevents-iotevents-data_BatchDeleteDetector-request-detectors) object of the DeleteDetectorRequest.)
        public var messageId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }

}

extension BatchDeleteDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectors = detectors {
            var detectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectors)
            for deletedetectorrequest0 in detectors {
                try detectorsContainer.encode(deletedetectorrequest0)
            }
        }
    }
}

extension BatchDeleteDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detectors/delete"
    }
}

public struct BatchDeleteDetectorInput: Swift.Equatable {
    /// The list of one or more detectors to be deleted.
    /// This member is required.
    public var detectors: [IoTEventsDataClientTypes.DeleteDetectorRequest]?

    public init(
        detectors: [IoTEventsDataClientTypes.DeleteDetectorRequest]? = nil
    )
    {
        self.detectors = detectors
    }
}

struct BatchDeleteDetectorInputBody: Swift.Equatable {
    let detectors: [IoTEventsDataClientTypes.DeleteDetectorRequest]?
}

extension BatchDeleteDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.DeleteDetectorRequest?].self, forKey: .detectors)
        var detectorsDecoded0:[IoTEventsDataClientTypes.DeleteDetectorRequest]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [IoTEventsDataClientTypes.DeleteDetectorRequest]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
    }
}

extension BatchDeleteDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteDetectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchDeleteDetectorErrorEntries = output.batchDeleteDetectorErrorEntries
        } else {
            self.batchDeleteDetectorErrorEntries = nil
        }
    }
}

public struct BatchDeleteDetectorOutput: Swift.Equatable {
    /// A list of errors associated with the request, or an empty array ([]) if there are no errors. Each error entry contains a messageId that helps you identify the entry that failed.
    public var batchDeleteDetectorErrorEntries: [IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]?

    public init(
        batchDeleteDetectorErrorEntries: [IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]? = nil
    )
    {
        self.batchDeleteDetectorErrorEntries = batchDeleteDetectorErrorEntries
    }
}

struct BatchDeleteDetectorOutputBody: Swift.Equatable {
    let batchDeleteDetectorErrorEntries: [IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]?
}

extension BatchDeleteDetectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchDeleteDetectorErrorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDeleteDetectorErrorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry?].self, forKey: .batchDeleteDetectorErrorEntries)
        var batchDeleteDetectorErrorEntriesDecoded0:[IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]? = nil
        if let batchDeleteDetectorErrorEntriesContainer = batchDeleteDetectorErrorEntriesContainer {
            batchDeleteDetectorErrorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchDeleteDetectorErrorEntry]()
            for structure0 in batchDeleteDetectorErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchDeleteDetectorErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchDeleteDetectorErrorEntries = batchDeleteDetectorErrorEntriesDecoded0
    }
}

enum BatchDeleteDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisableAlarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disableActionRequests = disableActionRequests {
            var disableActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disableActionRequests)
            for disablealarmactionrequest0 in disableActionRequests {
                try disableActionRequestsContainer.encode(disablealarmactionrequest0)
            }
        }
    }
}

extension BatchDisableAlarmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarms/disable"
    }
}

public struct BatchDisableAlarmInput: Swift.Equatable {
    /// The list of disable action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var disableActionRequests: [IoTEventsDataClientTypes.DisableAlarmActionRequest]?

    public init(
        disableActionRequests: [IoTEventsDataClientTypes.DisableAlarmActionRequest]? = nil
    )
    {
        self.disableActionRequests = disableActionRequests
    }
}

struct BatchDisableAlarmInputBody: Swift.Equatable {
    let disableActionRequests: [IoTEventsDataClientTypes.DisableAlarmActionRequest]?
}

extension BatchDisableAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableActionRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableActionRequestsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.DisableAlarmActionRequest?].self, forKey: .disableActionRequests)
        var disableActionRequestsDecoded0:[IoTEventsDataClientTypes.DisableAlarmActionRequest]? = nil
        if let disableActionRequestsContainer = disableActionRequestsContainer {
            disableActionRequestsDecoded0 = [IoTEventsDataClientTypes.DisableAlarmActionRequest]()
            for structure0 in disableActionRequestsContainer {
                if let structure0 = structure0 {
                    disableActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        disableActionRequests = disableActionRequestsDecoded0
    }
}

extension BatchDisableAlarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisableAlarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchDisableAlarmOutput: Swift.Equatable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchDisableAlarmOutputBody: Swift.Equatable {
    let errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchDisableAlarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchDisableAlarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchEnableAlarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableActionRequests = enableActionRequests {
            var enableActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enableActionRequests)
            for enablealarmactionrequest0 in enableActionRequests {
                try enableActionRequestsContainer.encode(enablealarmactionrequest0)
            }
        }
    }
}

extension BatchEnableAlarmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarms/enable"
    }
}

public struct BatchEnableAlarmInput: Swift.Equatable {
    /// The list of enable action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var enableActionRequests: [IoTEventsDataClientTypes.EnableAlarmActionRequest]?

    public init(
        enableActionRequests: [IoTEventsDataClientTypes.EnableAlarmActionRequest]? = nil
    )
    {
        self.enableActionRequests = enableActionRequests
    }
}

struct BatchEnableAlarmInputBody: Swift.Equatable {
    let enableActionRequests: [IoTEventsDataClientTypes.EnableAlarmActionRequest]?
}

extension BatchEnableAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableActionRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableActionRequestsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.EnableAlarmActionRequest?].self, forKey: .enableActionRequests)
        var enableActionRequestsDecoded0:[IoTEventsDataClientTypes.EnableAlarmActionRequest]? = nil
        if let enableActionRequestsContainer = enableActionRequestsContainer {
            enableActionRequestsDecoded0 = [IoTEventsDataClientTypes.EnableAlarmActionRequest]()
            for structure0 in enableActionRequestsContainer {
                if let structure0 = structure0 {
                    enableActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        enableActionRequests = enableActionRequestsDecoded0
    }
}

extension BatchEnableAlarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchEnableAlarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchEnableAlarmOutput: Swift.Equatable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchEnableAlarmOutputBody: Swift.Equatable {
    let errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchEnableAlarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchEnableAlarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTEventsDataClientTypes.BatchPutMessageErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains information about the errors encountered.
    public struct BatchPutMessageErrorEntry: Swift.Equatable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the message that caused the error. (See the value corresponding to the "messageId" key in the "message" object.)
        public var messageId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }

}

extension BatchPutMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for message0 in messages {
                try messagesContainer.encode(message0)
            }
        }
    }
}

extension BatchPutMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/inputs/messages"
    }
}

public struct BatchPutMessageInput: Swift.Equatable {
    /// The list of messages to send. Each message has the following format: '{ "messageId": "string", "inputName": "string", "payload": "string"}'
    /// This member is required.
    public var messages: [IoTEventsDataClientTypes.Message]?

    public init(
        messages: [IoTEventsDataClientTypes.Message]? = nil
    )
    {
        self.messages = messages
    }
}

struct BatchPutMessageInputBody: Swift.Equatable {
    let messages: [IoTEventsDataClientTypes.Message]?
}

extension BatchPutMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[IoTEventsDataClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [IoTEventsDataClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension BatchPutMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchPutMessageErrorEntries = output.batchPutMessageErrorEntries
        } else {
            self.batchPutMessageErrorEntries = nil
        }
    }
}

public struct BatchPutMessageOutput: Swift.Equatable {
    /// A list of any errors encountered when sending the messages.
    public var batchPutMessageErrorEntries: [IoTEventsDataClientTypes.BatchPutMessageErrorEntry]?

    public init(
        batchPutMessageErrorEntries: [IoTEventsDataClientTypes.BatchPutMessageErrorEntry]? = nil
    )
    {
        self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
    }
}

struct BatchPutMessageOutputBody: Swift.Equatable {
    let batchPutMessageErrorEntries: [IoTEventsDataClientTypes.BatchPutMessageErrorEntry]?
}

extension BatchPutMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPutMessageErrorEntries = "BatchPutMessageErrorEntries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPutMessageErrorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchPutMessageErrorEntry?].self, forKey: .batchPutMessageErrorEntries)
        var batchPutMessageErrorEntriesDecoded0:[IoTEventsDataClientTypes.BatchPutMessageErrorEntry]? = nil
        if let batchPutMessageErrorEntriesContainer = batchPutMessageErrorEntriesContainer {
            batchPutMessageErrorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchPutMessageErrorEntry]()
            for structure0 in batchPutMessageErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchPutMessageErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchPutMessageErrorEntries = batchPutMessageErrorEntriesDecoded0
    }
}

enum BatchPutMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchResetAlarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resetActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resetActionRequests = resetActionRequests {
            var resetActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resetActionRequests)
            for resetalarmactionrequest0 in resetActionRequests {
                try resetActionRequestsContainer.encode(resetalarmactionrequest0)
            }
        }
    }
}

extension BatchResetAlarmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarms/reset"
    }
}

public struct BatchResetAlarmInput: Swift.Equatable {
    /// The list of reset action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var resetActionRequests: [IoTEventsDataClientTypes.ResetAlarmActionRequest]?

    public init(
        resetActionRequests: [IoTEventsDataClientTypes.ResetAlarmActionRequest]? = nil
    )
    {
        self.resetActionRequests = resetActionRequests
    }
}

struct BatchResetAlarmInputBody: Swift.Equatable {
    let resetActionRequests: [IoTEventsDataClientTypes.ResetAlarmActionRequest]?
}

extension BatchResetAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resetActionRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resetActionRequestsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.ResetAlarmActionRequest?].self, forKey: .resetActionRequests)
        var resetActionRequestsDecoded0:[IoTEventsDataClientTypes.ResetAlarmActionRequest]? = nil
        if let resetActionRequestsContainer = resetActionRequestsContainer {
            resetActionRequestsDecoded0 = [IoTEventsDataClientTypes.ResetAlarmActionRequest]()
            for structure0 in resetActionRequestsContainer {
                if let structure0 = structure0 {
                    resetActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        resetActionRequests = resetActionRequestsDecoded0
    }
}

extension BatchResetAlarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchResetAlarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchResetAlarmOutput: Swift.Equatable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchResetAlarmOutputBody: Swift.Equatable {
    let errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchResetAlarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchResetAlarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchSnoozeAlarmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snoozeActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snoozeActionRequests = snoozeActionRequests {
            var snoozeActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snoozeActionRequests)
            for snoozealarmactionrequest0 in snoozeActionRequests {
                try snoozeActionRequestsContainer.encode(snoozealarmactionrequest0)
            }
        }
    }
}

extension BatchSnoozeAlarmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarms/snooze"
    }
}

public struct BatchSnoozeAlarmInput: Swift.Equatable {
    /// The list of snooze action requests. You can specify up to 10 requests per operation.
    /// This member is required.
    public var snoozeActionRequests: [IoTEventsDataClientTypes.SnoozeAlarmActionRequest]?

    public init(
        snoozeActionRequests: [IoTEventsDataClientTypes.SnoozeAlarmActionRequest]? = nil
    )
    {
        self.snoozeActionRequests = snoozeActionRequests
    }
}

struct BatchSnoozeAlarmInputBody: Swift.Equatable {
    let snoozeActionRequests: [IoTEventsDataClientTypes.SnoozeAlarmActionRequest]?
}

extension BatchSnoozeAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snoozeActionRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snoozeActionRequestsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.SnoozeAlarmActionRequest?].self, forKey: .snoozeActionRequests)
        var snoozeActionRequestsDecoded0:[IoTEventsDataClientTypes.SnoozeAlarmActionRequest]? = nil
        if let snoozeActionRequestsContainer = snoozeActionRequestsContainer {
            snoozeActionRequestsDecoded0 = [IoTEventsDataClientTypes.SnoozeAlarmActionRequest]()
            for structure0 in snoozeActionRequestsContainer {
                if let structure0 = structure0 {
                    snoozeActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        snoozeActionRequests = snoozeActionRequestsDecoded0
    }
}

extension BatchSnoozeAlarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchSnoozeAlarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchSnoozeAlarmOutput: Swift.Equatable {
    /// A list of errors associated with the request, or null if there are no errors. Each error entry contains an entry ID that helps you identify the entry that failed.
    public var errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init(
        errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchSnoozeAlarmOutputBody: Swift.Equatable {
    let errorEntries: [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchSnoozeAlarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchSnoozeAlarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information about the error that occurred when attempting to update a detector.
    public struct BatchUpdateDetectorErrorEntry: Swift.Equatable {
        /// The error code.
        public var errorCode: IoTEventsDataClientTypes.ErrorCode?
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The "messageId" of the update request that caused the error. (The value of the "messageId" in the update request "Detector" object.)
        public var messageId: Swift.String?

        public init(
            errorCode: IoTEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }

}

extension BatchUpdateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectors = detectors {
            var detectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectors)
            for updatedetectorrequest0 in detectors {
                try detectorsContainer.encode(updatedetectorrequest0)
            }
        }
    }
}

extension BatchUpdateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detectors"
    }
}

public struct BatchUpdateDetectorInput: Swift.Equatable {
    /// The list of detectors (instances) to update, along with the values to update.
    /// This member is required.
    public var detectors: [IoTEventsDataClientTypes.UpdateDetectorRequest]?

    public init(
        detectors: [IoTEventsDataClientTypes.UpdateDetectorRequest]? = nil
    )
    {
        self.detectors = detectors
    }
}

struct BatchUpdateDetectorInputBody: Swift.Equatable {
    let detectors: [IoTEventsDataClientTypes.UpdateDetectorRequest]?
}

extension BatchUpdateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.UpdateDetectorRequest?].self, forKey: .detectors)
        var detectorsDecoded0:[IoTEventsDataClientTypes.UpdateDetectorRequest]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [IoTEventsDataClientTypes.UpdateDetectorRequest]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
    }
}

extension BatchUpdateDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateDetectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchUpdateDetectorErrorEntries = output.batchUpdateDetectorErrorEntries
        } else {
            self.batchUpdateDetectorErrorEntries = nil
        }
    }
}

public struct BatchUpdateDetectorOutput: Swift.Equatable {
    /// A list of those detector updates that resulted in errors. (If an error is listed here, the specific update did not occur.)
    public var batchUpdateDetectorErrorEntries: [IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]?

    public init(
        batchUpdateDetectorErrorEntries: [IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]? = nil
    )
    {
        self.batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntries
    }
}

struct BatchUpdateDetectorOutputBody: Swift.Equatable {
    let batchUpdateDetectorErrorEntries: [IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]?
}

extension BatchUpdateDetectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchUpdateDetectorErrorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchUpdateDetectorErrorEntriesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry?].self, forKey: .batchUpdateDetectorErrorEntries)
        var batchUpdateDetectorErrorEntriesDecoded0:[IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]? = nil
        if let batchUpdateDetectorErrorEntriesContainer = batchUpdateDetectorErrorEntriesContainer {
            batchUpdateDetectorErrorEntriesDecoded0 = [IoTEventsDataClientTypes.BatchUpdateDetectorErrorEntry]()
            for structure0 in batchUpdateDetectorErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchUpdateDetectorErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntriesDecoded0
    }
}

enum BatchUpdateDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTEventsDataClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case less
        case lessOrEqual
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .less,
                .lessOrEqual,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .less: return "LESS"
            case .lessOrEqual: return "LESS_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsDataClientTypes.CustomerAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeActionConfiguration
        case actionName
        case disableActionConfiguration
        case enableActionConfiguration
        case resetActionConfiguration
        case snoozeActionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeActionConfiguration = self.acknowledgeActionConfiguration {
            try encodeContainer.encode(acknowledgeActionConfiguration, forKey: .acknowledgeActionConfiguration)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName.rawValue, forKey: .actionName)
        }
        if let disableActionConfiguration = self.disableActionConfiguration {
            try encodeContainer.encode(disableActionConfiguration, forKey: .disableActionConfiguration)
        }
        if let enableActionConfiguration = self.enableActionConfiguration {
            try encodeContainer.encode(enableActionConfiguration, forKey: .enableActionConfiguration)
        }
        if let resetActionConfiguration = self.resetActionConfiguration {
            try encodeContainer.encode(resetActionConfiguration, forKey: .resetActionConfiguration)
        }
        if let snoozeActionConfiguration = self.snoozeActionConfiguration {
            try encodeContainer.encode(snoozeActionConfiguration, forKey: .snoozeActionConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.CustomerActionName.self, forKey: .actionName)
        actionName = actionNameDecoded
        let snoozeActionConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.SnoozeActionConfiguration.self, forKey: .snoozeActionConfiguration)
        snoozeActionConfiguration = snoozeActionConfigurationDecoded
        let enableActionConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.EnableActionConfiguration.self, forKey: .enableActionConfiguration)
        enableActionConfiguration = enableActionConfigurationDecoded
        let disableActionConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.DisableActionConfiguration.self, forKey: .disableActionConfiguration)
        disableActionConfiguration = disableActionConfigurationDecoded
        let acknowledgeActionConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.AcknowledgeActionConfiguration.self, forKey: .acknowledgeActionConfiguration)
        acknowledgeActionConfiguration = acknowledgeActionConfigurationDecoded
        let resetActionConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.ResetActionConfiguration.self, forKey: .resetActionConfiguration)
        resetActionConfiguration = resetActionConfigurationDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains information about the action that you can take to respond to the alarm.
    public struct CustomerAction: Swift.Equatable {
        /// Contains the configuration information of an acknowledge action.
        public var acknowledgeActionConfiguration: IoTEventsDataClientTypes.AcknowledgeActionConfiguration?
        /// The name of the action. The action name can be one of the following values:
        ///
        /// * SNOOZE - When you snooze the alarm, the alarm state changes to SNOOZE_DISABLED.
        ///
        /// * ENABLE - When you enable the alarm, the alarm state changes to NORMAL.
        ///
        /// * DISABLE - When you disable the alarm, the alarm state changes to DISABLED.
        ///
        /// * ACKNOWLEDGE - When you acknowledge the alarm, the alarm state changes to ACKNOWLEDGED.
        ///
        /// * RESET - When you reset the alarm, the alarm state changes to NORMAL.
        ///
        ///
        /// For more information, see the [AlarmState](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_AlarmState.html) API.
        public var actionName: IoTEventsDataClientTypes.CustomerActionName?
        /// Contains the configuration information of a disable action.
        public var disableActionConfiguration: IoTEventsDataClientTypes.DisableActionConfiguration?
        /// Contains the configuration information of an enable action.
        public var enableActionConfiguration: IoTEventsDataClientTypes.EnableActionConfiguration?
        /// Contains the configuration information of a reset action.
        public var resetActionConfiguration: IoTEventsDataClientTypes.ResetActionConfiguration?
        /// Contains the configuration information of a snooze action.
        public var snoozeActionConfiguration: IoTEventsDataClientTypes.SnoozeActionConfiguration?

        public init(
            acknowledgeActionConfiguration: IoTEventsDataClientTypes.AcknowledgeActionConfiguration? = nil,
            actionName: IoTEventsDataClientTypes.CustomerActionName? = nil,
            disableActionConfiguration: IoTEventsDataClientTypes.DisableActionConfiguration? = nil,
            enableActionConfiguration: IoTEventsDataClientTypes.EnableActionConfiguration? = nil,
            resetActionConfiguration: IoTEventsDataClientTypes.ResetActionConfiguration? = nil,
            snoozeActionConfiguration: IoTEventsDataClientTypes.SnoozeActionConfiguration? = nil
        )
        {
            self.acknowledgeActionConfiguration = acknowledgeActionConfiguration
            self.actionName = actionName
            self.disableActionConfiguration = disableActionConfiguration
            self.enableActionConfiguration = enableActionConfiguration
            self.resetActionConfiguration = resetActionConfiguration
            self.snoozeActionConfiguration = snoozeActionConfiguration
        }
    }

}

extension IoTEventsDataClientTypes {
    public enum CustomerActionName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledge
        case disable
        case enable
        case reset
        case snooze
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerActionName] {
            return [
                .acknowledge,
                .disable,
                .enable,
                .reset,
                .snooze,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledge: return "ACKNOWLEDGE"
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .reset: return "RESET"
            case .snooze: return "SNOOZE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerActionName(rawValue: rawValue) ?? CustomerActionName.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsDataClientTypes.DeleteDetectorRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelName
        case keyValue
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information used to delete the detector model.
    public struct DeleteDetectorRequest: Swift.Equatable {
        /// The name of the detector model that was used to create the detector instance.
        /// This member is required.
        public var detectorModelName: Swift.String?
        /// The value of the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateDetectorModel.html#iotevents-CreateDetectorModel-request-key) used to identify the detector.
        public var keyValue: Swift.String?
        /// The ID to assign to the DeleteDetectorRequest. Each "messageId" must be unique within each batch sent.
        /// This member is required.
        public var messageId: Swift.String?

        public init(
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
        }
    }

}

extension DescribeAlarmInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let keyValue = keyValue {
                let keyValueQueryItem = ClientRuntime.URLQueryItem(name: "keyValue".urlPercentEncoding(), value: Swift.String(keyValue).urlPercentEncoding())
                items.append(keyValueQueryItem)
            }
            return items
        }
    }
}

extension DescribeAlarmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let alarmModelName = alarmModelName else {
            return nil
        }
        return "/alarms/\(alarmModelName.urlPercentEncoding())/keyValues"
    }
}

public struct DescribeAlarmInput: Swift.Equatable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
    public var keyValue: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil,
        keyValue: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
    }
}

struct DescribeAlarmInputBody: Swift.Equatable {
}

extension DescribeAlarmInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlarmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAlarmOutputBody = try responseDecoder.decode(responseBody: data)
            self.alarm = output.alarm
        } else {
            self.alarm = nil
        }
    }
}

public struct DescribeAlarmOutput: Swift.Equatable {
    /// Contains information about an alarm.
    public var alarm: IoTEventsDataClientTypes.Alarm?

    public init(
        alarm: IoTEventsDataClientTypes.Alarm? = nil
    )
    {
        self.alarm = alarm
    }
}

struct DescribeAlarmOutputBody: Swift.Equatable {
    let alarm: IoTEventsDataClientTypes.Alarm?
}

extension DescribeAlarmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarm
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.Alarm.self, forKey: .alarm)
        alarm = alarmDecoded
    }
}

enum DescribeAlarmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDetectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let keyValue = keyValue {
                let keyValueQueryItem = ClientRuntime.URLQueryItem(name: "keyValue".urlPercentEncoding(), value: Swift.String(keyValue).urlPercentEncoding())
                items.append(keyValueQueryItem)
            }
            return items
        }
    }
}

extension DescribeDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorModelName = detectorModelName else {
            return nil
        }
        return "/detectors/\(detectorModelName.urlPercentEncoding())/keyValues"
    }
}

public struct DescribeDetectorInput: Swift.Equatable {
    /// The name of the detector model whose detectors (instances) you want information about.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// A filter used to limit results to detectors (instances) created because of the given key ID.
    public var keyValue: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil,
        keyValue: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.keyValue = keyValue
    }
}

struct DescribeDetectorInputBody: Swift.Equatable {
}

extension DescribeDetectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDetectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.detector = output.detector
        } else {
            self.detector = nil
        }
    }
}

public struct DescribeDetectorOutput: Swift.Equatable {
    /// Information about the detector (instance).
    public var detector: IoTEventsDataClientTypes.Detector?

    public init(
        detector: IoTEventsDataClientTypes.Detector? = nil
    )
    {
        self.detector = detector
    }
}

struct DescribeDetectorOutputBody: Swift.Equatable {
    let detector: IoTEventsDataClientTypes.Detector?
}

extension DescribeDetectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detector
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.Detector.self, forKey: .detector)
        detector = detectorDecoded
    }
}

enum DescribeDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTEventsDataClientTypes.Detector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelName
        case detectorModelVersion
        case keyValue
        case lastUpdateTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = self.detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.DetectorState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information about the detector (instance).
    public struct Detector: Swift.Equatable {
        /// The time the detector (instance) was created.
        public var creationTime: ClientRuntime.Date?
        /// The name of the detector model that created this detector (instance).
        public var detectorModelName: Swift.String?
        /// The version of the detector model that created this detector (instance).
        public var detectorModelVersion: Swift.String?
        /// The value of the key (identifying the device or system) that caused the creation of this detector (instance).
        public var keyValue: Swift.String?
        /// The time the detector (instance) was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The current state of the detector (instance).
        public var state: IoTEventsDataClientTypes.DetectorState?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            state: IoTEventsDataClientTypes.DetectorState? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }
    }

}

extension IoTEventsDataClientTypes.DetectorState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateName
        case timers
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = self.stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
        if let timers = timers {
            var timersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timers)
            for timer0 in timers {
                try timersContainer.encode(timer0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variable0 in variables {
                try variablesContainer.encode(variable0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[IoTEventsDataClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTEventsDataClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let timersContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.Timer?].self, forKey: .timers)
        var timersDecoded0:[IoTEventsDataClientTypes.Timer]? = nil
        if let timersContainer = timersContainer {
            timersDecoded0 = [IoTEventsDataClientTypes.Timer]()
            for structure0 in timersContainer {
                if let structure0 = structure0 {
                    timersDecoded0?.append(structure0)
                }
            }
        }
        timers = timersDecoded0
    }
}

extension IoTEventsDataClientTypes {
    /// Information about the current state of the detector instance.
    public struct DetectorState: Swift.Equatable {
        /// The name of the state.
        /// This member is required.
        public var stateName: Swift.String?
        /// The current state of the detector's timers.
        /// This member is required.
        public var timers: [IoTEventsDataClientTypes.Timer]?
        /// The current values of the detector's variables.
        /// This member is required.
        public var variables: [IoTEventsDataClientTypes.Variable]?

        public init(
            stateName: Swift.String? = nil,
            timers: [IoTEventsDataClientTypes.Timer]? = nil,
            variables: [IoTEventsDataClientTypes.Variable]? = nil
        )
        {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }
    }

}

extension IoTEventsDataClientTypes.DetectorStateDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateName
        case timers
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = self.stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
        if let timers = timers {
            var timersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timers)
            for timerdefinition0 in timers {
                try timersContainer.encode(timerdefinition0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variabledefinition0 in variables {
                try variablesContainer.encode(variabledefinition0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.VariableDefinition?].self, forKey: .variables)
        var variablesDecoded0:[IoTEventsDataClientTypes.VariableDefinition]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTEventsDataClientTypes.VariableDefinition]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let timersContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.TimerDefinition?].self, forKey: .timers)
        var timersDecoded0:[IoTEventsDataClientTypes.TimerDefinition]? = nil
        if let timersContainer = timersContainer {
            timersDecoded0 = [IoTEventsDataClientTypes.TimerDefinition]()
            for structure0 in timersContainer {
                if let structure0 = structure0 {
                    timersDecoded0?.append(structure0)
                }
            }
        }
        timers = timersDecoded0
    }
}

extension IoTEventsDataClientTypes {
    /// The new state, variable values, and timer settings of the detector (instance).
    public struct DetectorStateDefinition: Swift.Equatable {
        /// The name of the new state of the detector (instance).
        /// This member is required.
        public var stateName: Swift.String?
        /// The new values of the detector's timers. Any timer whose value isn't specified is cleared, and its timeout event won't occur.
        /// This member is required.
        public var timers: [IoTEventsDataClientTypes.TimerDefinition]?
        /// The new values of the detector's variables. Any variable whose value isn't specified is cleared.
        /// This member is required.
        public var variables: [IoTEventsDataClientTypes.VariableDefinition]?

        public init(
            stateName: Swift.String? = nil,
            timers: [IoTEventsDataClientTypes.TimerDefinition]? = nil,
            variables: [IoTEventsDataClientTypes.VariableDefinition]? = nil
        )
        {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }
    }

}

extension IoTEventsDataClientTypes.DetectorStateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = self.stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information about the detector state.
    public struct DetectorStateSummary: Swift.Equatable {
        /// The name of the state.
        public var stateName: Swift.String?

        public init(
            stateName: Swift.String? = nil
        )
        {
            self.stateName = stateName
        }
    }

}

extension IoTEventsDataClientTypes.DetectorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelName
        case detectorModelVersion
        case keyValue
        case lastUpdateTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = self.detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.DetectorStateSummary.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information about the detector (instance).
    public struct DetectorSummary: Swift.Equatable {
        /// The time the detector (instance) was created.
        public var creationTime: ClientRuntime.Date?
        /// The name of the detector model that created this detector (instance).
        public var detectorModelName: Swift.String?
        /// The version of the detector model that created this detector (instance).
        public var detectorModelVersion: Swift.String?
        /// The value of the key (identifying the device or system) that caused the creation of this detector (instance).
        public var keyValue: Swift.String?
        /// The time the detector (instance) was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The current state of the detector (instance).
        public var state: IoTEventsDataClientTypes.DetectorStateSummary?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            state: IoTEventsDataClientTypes.DetectorStateSummary? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }
    }

}

extension IoTEventsDataClientTypes.DisableActionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains the configuration information of a disable action.
    public struct DisableActionConfiguration: Swift.Equatable {
        /// The note that you can leave when you disable the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IoTEventsDataClientTypes.DisableAlarmActionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information used to disable the alarm.
    public struct DisableAlarmActionRequest: Swift.Equatable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you disable the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension IoTEventsDataClientTypes.EnableActionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains the configuration information of an enable action.
    public struct EnableActionConfiguration: Swift.Equatable {
        /// The note that you can leave when you enable the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IoTEventsDataClientTypes.EnableAlarmActionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information needed to enable the alarm.
    public struct EnableAlarmActionRequest: Swift.Equatable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you enable the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension IoTEventsDataClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalfailureexception
        case invalidrequestexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalfailureexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsDataClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stateChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .stateChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stateChange: return "STATE_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal failure occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was invalid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAlarmsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let alarmModelName = alarmModelName else {
            return nil
        }
        return "/alarms/\(alarmModelName.urlPercentEncoding())"
    }
}

public struct ListAlarmsInput: Swift.Equatable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmsInputBody: Swift.Equatable {
}

extension ListAlarmsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAlarmsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAlarmsOutputBody = try responseDecoder.decode(responseBody: data)
            self.alarmSummaries = output.alarmSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmsOutput: Swift.Equatable {
    /// A list that summarizes each alarm.
    public var alarmSummaries: [IoTEventsDataClientTypes.AlarmSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        alarmSummaries: [IoTEventsDataClientTypes.AlarmSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmSummaries = alarmSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmsOutputBody: Swift.Equatable {
    let alarmSummaries: [IoTEventsDataClientTypes.AlarmSummary]?
    let nextToken: Swift.String?
}

extension ListAlarmsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmSummariesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.AlarmSummary?].self, forKey: .alarmSummaries)
        var alarmSummariesDecoded0:[IoTEventsDataClientTypes.AlarmSummary]? = nil
        if let alarmSummariesContainer = alarmSummariesContainer {
            alarmSummariesDecoded0 = [IoTEventsDataClientTypes.AlarmSummary]()
            for structure0 in alarmSummariesContainer {
                if let structure0 = structure0 {
                    alarmSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmSummaries = alarmSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAlarmsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDetectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let stateName = stateName {
                let stateNameQueryItem = ClientRuntime.URLQueryItem(name: "stateName".urlPercentEncoding(), value: Swift.String(stateName).urlPercentEncoding())
                items.append(stateNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorModelName = detectorModelName else {
            return nil
        }
        return "/detectors/\(detectorModelName.urlPercentEncoding())"
    }
}

public struct ListDetectorsInput: Swift.Equatable {
    /// The name of the detector model whose detectors (instances) are listed.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?
    /// A filter that limits results to those detectors (instances) in the given state.
    public var stateName: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stateName: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateName = stateName
    }
}

struct ListDetectorsInputBody: Swift.Equatable {
}

extension ListDetectorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDetectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.detectorSummaries = output.detectorSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutput: Swift.Equatable {
    /// A list of summary information about the detectors (instances).
    public var detectorSummaries: [IoTEventsDataClientTypes.DetectorSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        detectorSummaries: [IoTEventsDataClientTypes.DetectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorSummaries = detectorSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputBody: Swift.Equatable {
    let detectorSummaries: [IoTEventsDataClientTypes.DetectorSummary]?
    let nextToken: Swift.String?
}

extension ListDetectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorSummariesContainer = try containerValues.decodeIfPresent([IoTEventsDataClientTypes.DetectorSummary?].self, forKey: .detectorSummaries)
        var detectorSummariesDecoded0:[IoTEventsDataClientTypes.DetectorSummary]? = nil
        if let detectorSummariesContainer = detectorSummariesContainer {
            detectorSummariesDecoded0 = [IoTEventsDataClientTypes.DetectorSummary]()
            for structure0 in detectorSummariesContainer {
                if let structure0 = structure0 {
                    detectorSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorSummaries = detectorSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDetectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTEventsDataClientTypes.Message: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
        case messageId
        case payload
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.TimestampValue.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information about a message.
    public struct Message: Swift.Equatable {
        /// The name of the input into which the message payload is transformed.
        /// This member is required.
        public var inputName: Swift.String?
        /// The ID to assign to the message. Within each batch sent, each "messageId" must be unique.
        /// This member is required.
        public var messageId: Swift.String?
        /// The payload of the message. This can be a JSON string or a Base-64-encoded string representing binary data (in which case you must decode it).
        /// This member is required.
        public var payload: ClientRuntime.Data?
        /// The timestamp associated with the message.
        public var timestamp: IoTEventsDataClientTypes.TimestampValue?

        public init(
            inputName: Swift.String? = nil,
            messageId: Swift.String? = nil,
            payload: ClientRuntime.Data? = nil,
            timestamp: IoTEventsDataClientTypes.TimestampValue? = nil
        )
        {
            self.inputName = inputName
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }
    }

}

extension IoTEventsDataClientTypes.ResetActionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains the configuration information of a reset action.
    public struct ResetActionConfiguration: Swift.Equatable {
        /// The note that you can leave when you reset the alarm.
        public var note: Swift.String?

        public init(
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IoTEventsDataClientTypes.ResetAlarmActionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information needed to reset the alarm.
    public struct ResetAlarmActionRequest: Swift.Equatable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you reset the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsDataClientTypes.RuleEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleRuleEvaluation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleRuleEvaluation = self.simpleRuleEvaluation {
            try encodeContainer.encode(simpleRuleEvaluation, forKey: .simpleRuleEvaluation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleRuleEvaluationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.SimpleRuleEvaluation.self, forKey: .simpleRuleEvaluation)
        simpleRuleEvaluation = simpleRuleEvaluationDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information needed to evaluate data.
    public struct RuleEvaluation: Swift.Equatable {
        /// Information needed to compare two values with a comparison operator.
        public var simpleRuleEvaluation: IoTEventsDataClientTypes.SimpleRuleEvaluation?

        public init(
            simpleRuleEvaluation: IoTEventsDataClientTypes.SimpleRuleEvaluation? = nil
        )
        {
            self.simpleRuleEvaluation = simpleRuleEvaluation
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsDataClientTypes.SimpleRuleEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputPropertyValue
        case `operator` = "operator"
        case thresholdValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPropertyValue = self.inputPropertyValue {
            try encodeContainer.encode(inputPropertyValue, forKey: .inputPropertyValue)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let thresholdValue = self.thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPropertyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPropertyValue)
        inputPropertyValue = inputPropertyValueDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.ComparisonOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information needed to compare two values with a comparison operator.
    public struct SimpleRuleEvaluation: Swift.Equatable {
        /// The value of the input property, on the left side of the comparison operator.
        public var inputPropertyValue: Swift.String?
        /// The comparison operator.
        public var `operator`: IoTEventsDataClientTypes.ComparisonOperator?
        /// The threshold value, on the right side of the comparison operator.
        public var thresholdValue: Swift.String?

        public init(
            inputPropertyValue: Swift.String? = nil,
            `operator`: IoTEventsDataClientTypes.ComparisonOperator? = nil,
            thresholdValue: Swift.String? = nil
        )
        {
            self.inputPropertyValue = inputPropertyValue
            self.`operator` = `operator`
            self.thresholdValue = thresholdValue
        }
    }

}

extension IoTEventsDataClientTypes.SnoozeActionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
        case snoozeDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let snoozeDuration = self.snoozeDuration {
            try encodeContainer.encode(snoozeDuration, forKey: .snoozeDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snoozeDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snoozeDuration)
        snoozeDuration = snoozeDurationDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains the configuration information of a snooze action.
    public struct SnoozeActionConfiguration: Swift.Equatable {
        /// The note that you can leave when you snooze the alarm.
        public var note: Swift.String?
        /// The snooze time in seconds. The alarm automatically changes to the NORMAL state after this duration.
        public var snoozeDuration: Swift.Int?

        public init(
            note: Swift.String? = nil,
            snoozeDuration: Swift.Int? = nil
        )
        {
            self.note = note
            self.snoozeDuration = snoozeDuration
        }
    }

}

extension IoTEventsDataClientTypes.SnoozeAlarmActionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
        case snoozeDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let snoozeDuration = self.snoozeDuration {
            try encodeContainer.encode(snoozeDuration, forKey: .snoozeDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
        let snoozeDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snoozeDuration)
        snoozeDuration = snoozeDurationDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information needed to snooze the alarm.
    public struct SnoozeAlarmActionRequest: Swift.Equatable {
        /// The name of the alarm model.
        /// This member is required.
        public var alarmModelName: Swift.String?
        /// The value of the key used as a filter to select only the alarms associated with the [key](https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key).
        public var keyValue: Swift.String?
        /// The note that you can leave when you snooze the alarm.
        public var note: Swift.String?
        /// The request ID. Each ID must be unique within each batch.
        /// This member is required.
        public var requestId: Swift.String?
        /// The snooze time in seconds. The alarm automatically changes to the NORMAL state after this duration.
        /// This member is required.
        public var snoozeDuration: Swift.Int?

        public init(
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil,
            snoozeDuration: Swift.Int? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
            self.snoozeDuration = snoozeDuration
        }
    }

}

extension IoTEventsDataClientTypes.StateChangeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains the configuration information of alarm state changes.
    public struct StateChangeConfiguration: Swift.Equatable {
        /// The trigger type. If the value is SNOOZE_TIMEOUT, the snooze duration ends and the alarm automatically changes to the NORMAL state.
        public var triggerType: IoTEventsDataClientTypes.TriggerType?

        public init(
            triggerType: IoTEventsDataClientTypes.TriggerType? = nil
        )
        {
            self.triggerType = triggerType
        }
    }

}

extension IoTEventsDataClientTypes.SystemEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case stateChangeConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let stateChangeConfiguration = self.stateChangeConfiguration {
            try encodeContainer.encode(stateChangeConfiguration, forKey: .stateChangeConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let stateChangeConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.StateChangeConfiguration.self, forKey: .stateChangeConfiguration)
        stateChangeConfiguration = stateChangeConfigurationDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains information about alarm state changes.
    public struct SystemEvent: Swift.Equatable {
        /// The event type. If the value is STATE_CHANGE, the event contains information about alarm state changes.
        public var eventType: IoTEventsDataClientTypes.EventType?
        /// Contains the configuration information of alarm state changes.
        public var stateChangeConfiguration: IoTEventsDataClientTypes.StateChangeConfiguration?

        public init(
            eventType: IoTEventsDataClientTypes.EventType? = nil,
            stateChangeConfiguration: IoTEventsDataClientTypes.StateChangeConfiguration? = nil
        )
        {
            self.eventType = eventType
            self.stateChangeConfiguration = stateChangeConfiguration
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be completed due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsDataClientTypes.Timer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// The current state of a timer.
    public struct Timer: Swift.Equatable {
        /// The name of the timer.
        /// This member is required.
        public var name: Swift.String?
        /// The expiration time for the timer.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?

        public init(
            name: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.name = name
            self.timestamp = timestamp
        }
    }

}

extension IoTEventsDataClientTypes.TimerDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case seconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let seconds = self.seconds {
            try encodeContainer.encode(seconds, forKey: .seconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let secondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seconds)
        seconds = secondsDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// The new setting of a timer.
    public struct TimerDefinition: Swift.Equatable {
        /// The name of the timer.
        /// This member is required.
        public var name: Swift.String?
        /// The new setting of the timer (the number of seconds before the timer elapses).
        /// This member is required.
        public var seconds: Swift.Int?

        public init(
            name: Swift.String? = nil,
            seconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.seconds = seconds
        }
    }

}

extension IoTEventsDataClientTypes.TimestampValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeInMillis
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeInMillis = self.timeInMillis {
            try encodeContainer.encode(timeInMillis, forKey: .timeInMillis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeInMillis)
        timeInMillis = timeInMillisDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Contains information about a timestamp.
    public struct TimestampValue: Swift.Equatable {
        /// The value of the timestamp, in the Unix epoch format.
        public var timeInMillis: Swift.Int?

        public init(
            timeInMillis: Swift.Int? = nil
        )
        {
            self.timeInMillis = timeInMillis
        }
    }

}

extension IoTEventsDataClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case snoozeTimeout
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .snoozeTimeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .snoozeTimeout: return "SNOOZE_TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsDataClientTypes.UpdateDetectorRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelName
        case keyValue
        case messageId
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTEventsDataClientTypes.DetectorStateDefinition.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// Information used to update the detector (instance).
    public struct UpdateDetectorRequest: Swift.Equatable {
        /// The name of the detector model that created the detectors (instances).
        /// This member is required.
        public var detectorModelName: Swift.String?
        /// The value of the input key attribute (identifying the device or system) that caused the creation of this detector (instance).
        public var keyValue: Swift.String?
        /// The ID to assign to the detector update "message". Each "messageId" must be unique within each batch sent.
        /// This member is required.
        public var messageId: Swift.String?
        /// The new state, variable values, and timer settings of the detector (instance).
        /// This member is required.
        public var state: IoTEventsDataClientTypes.DetectorStateDefinition?

        public init(
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            messageId: Swift.String? = nil,
            state: IoTEventsDataClientTypes.DetectorStateDefinition? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
            self.state = state
        }
    }

}

extension IoTEventsDataClientTypes.Variable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// The current state of the variable.
    public struct Variable: Swift.Equatable {
        /// The name of the variable.
        /// This member is required.
        public var name: Swift.String?
        /// The current value of the variable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTEventsDataClientTypes.VariableDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTEventsDataClientTypes {
    /// The new value of the variable.
    public struct VariableDefinition: Swift.Equatable {
        /// The name of the variable.
        /// This member is required.
        public var name: Swift.String?
        /// The new value of the variable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}
