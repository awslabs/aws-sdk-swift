// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AbortMultipartReadSetUploadInput {

    static func urlPathProvider(_ value: AbortMultipartReadSetUploadInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let uploadId = value.uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/abort"
    }
}

public struct AbortMultipartReadSetUploadInput {
    /// The sequence store ID for the store involved in the multipart upload.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

extension AbortMultipartReadSetUploadOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AbortMultipartReadSetUploadOutput {
        return AbortMultipartReadSetUploadOutput()
    }
}

public struct AbortMultipartReadSetUploadOutput {

    public init() { }
}

enum AbortMultipartReadSetUploadOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotSupportedOperationException": return try NotSupportedOperationException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes {

    public enum Accelerators: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gpu
        case sdkUnknown(Swift.String)

        public static var allCases: [Accelerators] {
            return [
                .gpu,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gpu: return "GPU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AcceptShareInput {

    static func urlPathProvider(_ value: AcceptShareInput) -> Swift.String? {
        guard let shareId = value.shareId else {
            return nil
        }
        return "/share/\(shareId.urlPercentEncoding())"
    }
}

public struct AcceptShareInput {
    /// The ID of the resource share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

extension AcceptShareOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AcceptShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptShareOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct AcceptShareOutput {
    /// The status of the resource share.
    public var status: OmicsClientTypes.ShareStatus?

    public init(
        status: OmicsClientTypes.ShareStatus? = nil
    )
    {
        self.status = status
    }
}

enum AcceptShareOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes.ActivateReadSetFilter {

    static func write(value: OmicsClientTypes.ActivateReadSetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// A read set activation job filter.
    public struct ActivateReadSetFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The filter's status.
        public var status: OmicsClientTypes.ReadSetActivationJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ActivateReadSetJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ActivateReadSetJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ActivateReadSetJobItem()
        value.id = try reader["id"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// A read set activation job.
    public struct ActivateReadSetJobItem {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetActivationJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.ActivateReadSetSourceItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ActivateReadSetSourceItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ActivateReadSetSourceItem()
        value.readSetId = try reader["readSetId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// A source for a read set activation job.
    public struct ActivateReadSetSourceItem {
        /// The source's read set ID.
        /// This member is required.
        public var readSetId: Swift.String?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetActivationJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?

        public init(
            readSetId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetActivationJobItemStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.AnnotationImportItemDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.AnnotationImportItemDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.AnnotationImportItemDetail()
        value.source = try reader["source"].readIfPresent()
        value.jobStatus = try reader["jobStatus"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Details about an imported annotation item.
    public struct AnnotationImportItemDetail {
        /// The item's job status.
        /// This member is required.
        public var jobStatus: OmicsClientTypes.JobStatus?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init(
            jobStatus: OmicsClientTypes.JobStatus? = nil,
            source: Swift.String? = nil
        )
        {
            self.jobStatus = jobStatus
            self.source = source
        }
    }

}

extension OmicsClientTypes.AnnotationImportItemSource {

    static func write(value: OmicsClientTypes.AnnotationImportItemSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
    }
}

extension OmicsClientTypes {
    /// A source for an annotation import job.
    public struct AnnotationImportItemSource {
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init(
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension OmicsClientTypes.AnnotationImportJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.AnnotationImportJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.AnnotationImportJobItem()
        value.id = try reader["id"].readIfPresent()
        value.destinationName = try reader["destinationName"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.runLeftNormalization = try reader["runLeftNormalization"].readIfPresent() ?? false
        value.annotationFields = try reader["annotationFields"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// An annotation import job.
    public struct AnnotationImportJobItem {
        /// The annotation schema generated by the parsed annotation data.
        public var annotationFields: [Swift.String:Swift.String]?
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination annotation store.
        /// This member is required.
        public var destinationName: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's left normalization setting.
        public var runLeftNormalization: Swift.Bool
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.JobStatus?
        /// When the job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?
        /// The name of the annotation store version.
        /// This member is required.
        public var versionName: Swift.String?

        public init(
            annotationFields: [Swift.String:Swift.String]? = nil,
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runLeftNormalization: Swift.Bool = false,
            status: OmicsClientTypes.JobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
            self.versionName = versionName
        }
    }

}

extension OmicsClientTypes.AnnotationStoreItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.AnnotationStoreItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.AnnotationStoreItem()
        value.id = try reader["id"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.storeArn = try reader["storeArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.storeFormat = try reader["storeFormat"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.storeSizeBytes = try reader["storeSizeBytes"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// An annotation store.
    public struct AnnotationStoreItem {
        /// The store's creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        /// This member is required.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        /// This member is required.
        public var name: Swift.String?
        /// The store's genome reference.
        /// This member is required.
        public var reference: OmicsClientTypes.ReferenceItem?
        /// The store's server-side encryption (SSE) settings.
        /// This member is required.
        public var sseConfig: OmicsClientTypes.SseConfig?
        /// The store's status.
        /// This member is required.
        public var status: OmicsClientTypes.StoreStatus?
        /// The store's status message.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store's ARN.
        /// This member is required.
        public var storeArn: Swift.String?
        /// The store's file format.
        /// This member is required.
        public var storeFormat: OmicsClientTypes.StoreFormat?
        /// The store's size in bytes.
        /// This member is required.
        public var storeSizeBytes: Swift.Int?
        /// When the store was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reference: OmicsClientTypes.ReferenceItem? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil,
            status: OmicsClientTypes.StoreStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeArn: Swift.String? = nil,
            storeFormat: OmicsClientTypes.StoreFormat? = nil,
            storeSizeBytes: Swift.Int? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.AnnotationStoreVersionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.AnnotationStoreVersionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.AnnotationStoreVersionItem()
        value.storeId = try reader["storeId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.versionArn = try reader["versionArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.versionSizeBytes = try reader["versionSizeBytes"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Annotation store versions.
    public struct AnnotationStoreVersionItem {
        /// The time stamp for when an annotation store version was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of an annotation store version.
        /// This member is required.
        public var description: Swift.String?
        /// The annotation store version ID.
        /// This member is required.
        public var id: Swift.String?
        /// A name given to an annotation store version to distinguish it from others.
        /// This member is required.
        public var name: Swift.String?
        /// The status of an annotation store version.
        /// This member is required.
        public var status: OmicsClientTypes.VersionStatus?
        /// The status of an annotation store version.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store ID for an annotation store version.
        /// This member is required.
        public var storeId: Swift.String?
        /// The time stamp for when an annotation store version was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?
        /// The Arn for an annotation store version.
        /// This member is required.
        public var versionArn: Swift.String?
        /// The name of an annotation store version.
        /// This member is required.
        public var versionName: Swift.String?
        /// The size of an annotation store version in Bytes.
        /// This member is required.
        public var versionSizeBytes: Swift.Int?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OmicsClientTypes.VersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeId: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil,
            versionArn: Swift.String? = nil,
            versionName: Swift.String? = nil,
            versionSizeBytes: Swift.Int? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.storeId = storeId
            self.updateTime = updateTime
            self.versionArn = versionArn
            self.versionName = versionName
            self.versionSizeBytes = versionSizeBytes
        }
    }

}

extension OmicsClientTypes {

    public enum AnnotationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Contains contig and 1-base position
        case chrPos
        /// Contains contig, 1-base position, ref and alt allele information
        case chrPosRefAlt
        /// Contains contig, start, and end positions. Coordinates are 1-based
        case chrStartEndOneBase
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
        case chrStartEndRefAltOneBase
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
        case chrStartEndRefAltZeroBase
        /// Contains contig, start, and end positions. Coordinates are 0-based
        case chrStartEndZeroBase
        /// Generic text file. No genomic information
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [AnnotationType] {
            return [
                .chrPos,
                .chrPosRefAlt,
                .chrStartEndOneBase,
                .chrStartEndRefAltOneBase,
                .chrStartEndRefAltZeroBase,
                .chrStartEndZeroBase,
                .generic,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chrPos: return "CHR_POS"
            case .chrPosRefAlt: return "CHR_POS_REF_ALT"
            case .chrStartEndOneBase: return "CHR_START_END_ONE_BASE"
            case .chrStartEndRefAltOneBase: return "CHR_START_END_REF_ALT_ONE_BASE"
            case .chrStartEndRefAltZeroBase: return "CHR_START_END_REF_ALT_ZERO_BASE"
            case .chrStartEndZeroBase: return "CHR_START_END_ZERO_BASE"
            case .generic: return "GENERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BatchDeleteReadSetInput {

    static func urlPathProvider(_ value: BatchDeleteReadSetInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/batch/delete"
    }
}

extension BatchDeleteReadSetInput {

    static func write(value: BatchDeleteReadSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ids"].writeList(value.ids, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchDeleteReadSetInput {
    /// The read sets' IDs.
    /// This member is required.
    public var ids: [Swift.String]?
    /// The read sets' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        ids: [Swift.String]? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.ids = ids
        self.sequenceStoreId = sequenceStoreId
    }
}

extension BatchDeleteReadSetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchDeleteReadSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteReadSetOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ReadSetBatchError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchDeleteReadSetOutput {
    /// Errors returned by individual delete operations.
    public var errors: [OmicsClientTypes.ReadSetBatchError]?

    public init(
        errors: [OmicsClientTypes.ReadSetBatchError]? = nil
    )
    {
        self.errors = errors
    }
}

enum BatchDeleteReadSetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CancelAnnotationImportJobInput {

    static func urlPathProvider(_ value: CancelAnnotationImportJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/import/annotation/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelAnnotationImportJobInput {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension CancelAnnotationImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CancelAnnotationImportJobOutput {
        return CancelAnnotationImportJobOutput()
    }
}

public struct CancelAnnotationImportJobOutput {

    public init() { }
}

enum CancelAnnotationImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CancelRunInput {

    static func urlPathProvider(_ value: CancelRunInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/cancel"
    }
}

public struct CancelRunInput {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension CancelRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CancelRunOutput {
        return CancelRunOutput()
    }
}

public struct CancelRunOutput {

    public init() { }
}

enum CancelRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CancelVariantImportJobInput {

    static func urlPathProvider(_ value: CancelVariantImportJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/import/variant/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelVariantImportJobInput {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension CancelVariantImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CancelVariantImportJobOutput {
        return CancelVariantImportJobOutput()
    }
}

public struct CancelVariantImportJobOutput {

    public init() { }
}

enum CancelVariantImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CompleteMultipartReadSetUploadInput {

    static func urlPathProvider(_ value: CompleteMultipartReadSetUploadInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let uploadId = value.uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/complete"
    }
}

extension CompleteMultipartReadSetUploadInput {

    static func write(value: CompleteMultipartReadSetUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parts"].writeList(value.parts, memberWritingClosure: OmicsClientTypes.CompleteReadSetUploadPartListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CompleteMultipartReadSetUploadInput {
    /// The individual uploads or parts of a multipart upload.
    /// This member is required.
    public var parts: [OmicsClientTypes.CompleteReadSetUploadPartListItem]?
    /// The sequence store ID for the store involved in the multipart upload.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        parts: [OmicsClientTypes.CompleteReadSetUploadPartListItem]? = nil,
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.parts = parts
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

extension CompleteMultipartReadSetUploadOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CompleteMultipartReadSetUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CompleteMultipartReadSetUploadOutput()
        value.readSetId = try reader["readSetId"].readIfPresent()
        return value
    }
}

public struct CompleteMultipartReadSetUploadOutput {
    /// The read set ID created for an uploaded read set.
    /// This member is required.
    public var readSetId: Swift.String?

    public init(
        readSetId: Swift.String? = nil
    )
    {
        self.readSetId = readSetId
    }
}

enum CompleteMultipartReadSetUploadOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotSupportedOperationException": return try NotSupportedOperationException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.CompleteReadSetUploadPartListItem {

    static func write(value: OmicsClientTypes.CompleteReadSetUploadPartListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checksum"].write(value.checksum)
        try writer["partNumber"].write(value.partNumber)
        try writer["partSource"].write(value.partSource)
    }
}

extension OmicsClientTypes {
    /// Part of the response to the CompleteReadSetUpload API, including metadata.
    public struct CompleteReadSetUploadPartListItem {
        /// A unique identifier used to confirm that parts are being added to the correct upload.
        /// This member is required.
        public var checksum: Swift.String?
        /// A number identifying the part in a read set upload.
        /// This member is required.
        public var partNumber: Swift.Int?
        /// The source file of the part being uploaded.
        /// This member is required.
        public var partSource: OmicsClientTypes.ReadSetPartSource?

        public init(
            checksum: Swift.String? = nil,
            partNumber: Swift.Int? = nil,
            partSource: OmicsClientTypes.ReadSetPartSource? = nil
        )
        {
            self.checksum = checksum
            self.partNumber = partNumber
            self.partSource = partSource
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request cannot be applied to the target resource in its current state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateAnnotationStoreInput {

    static func urlPathProvider(_ value: CreateAnnotationStoreInput) -> Swift.String? {
        return "/annotationStore"
    }
}

extension CreateAnnotationStoreInput {

    static func write(value: CreateAnnotationStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["reference"].write(value.reference, with: OmicsClientTypes.ReferenceItem.write(value:to:))
        try writer["sseConfig"].write(value.sseConfig, with: OmicsClientTypes.SseConfig.write(value:to:))
        try writer["storeFormat"].write(value.storeFormat)
        try writer["storeOptions"].write(value.storeOptions, with: OmicsClientTypes.StoreOptions.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["versionName"].write(value.versionName)
    }
}

public struct CreateAnnotationStoreInput {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    public var name: Swift.String?
    /// The genome reference for the store's annotations.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The annotation file format of the store.
    /// This member is required.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// File parsing options for the annotation store.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?
    /// The name given to an annotation store version to distinguish it from other versions.
    public var versionName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.tags = tags
        self.versionName = versionName
    }
}

extension CreateAnnotationStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAnnotationStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnnotationStoreOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.storeFormat = try reader["storeFormat"].readIfPresent()
        value.storeOptions = try reader["storeOptions"].readIfPresent(with: OmicsClientTypes.StoreOptions.read(from:))
        value.versionName = try reader["versionName"].readIfPresent()
        return value
    }
}

public struct CreateAnnotationStoreOutput {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference. Required for all stores except TSV format with generic annotations.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The annotation file format of the store.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// The store's file parsing options.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.versionName = versionName
    }
}

enum CreateAnnotationStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAnnotationStoreVersionInput {

    static func urlPathProvider(_ value: CreateAnnotationStoreVersionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/version"
    }
}

extension CreateAnnotationStoreVersionInput {

    static func write(value: CreateAnnotationStoreVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["versionName"].write(value.versionName)
        try writer["versionOptions"].write(value.versionOptions, with: OmicsClientTypes.VersionOptions.write(value:to:))
    }
}

public struct CreateAnnotationStoreVersionInput {
    /// The description of an annotation store version.
    public var description: Swift.String?
    /// The name of an annotation store version from which versions are being created.
    /// This member is required.
    public var name: Swift.String?
    /// Any tags added to annotation store version.
    public var tags: [Swift.String:Swift.String]?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var versionName: Swift.String?
    /// The options for an annotation store version.
    public var versionOptions: OmicsClientTypes.VersionOptions?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        versionName: Swift.String? = nil,
        versionOptions: OmicsClientTypes.VersionOptions? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.versionName = versionName
        self.versionOptions = versionOptions
    }
}

extension CreateAnnotationStoreVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAnnotationStoreVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnnotationStoreVersionOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.storeId = try reader["storeId"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        value.versionOptions = try reader["versionOptions"].readIfPresent(with: OmicsClientTypes.VersionOptions.read(from:))
        return value
    }
}

public struct CreateAnnotationStoreVersionOutput {
    /// The time stamp for the creation of an annotation store version.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A generated ID for the annotation store
    /// This member is required.
    public var id: Swift.String?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var name: Swift.String?
    /// The status of a annotation store version.
    /// This member is required.
    public var status: OmicsClientTypes.VersionStatus?
    /// The ID for the annotation store from which new versions are being created.
    /// This member is required.
    public var storeId: Swift.String?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var versionName: Swift.String?
    /// The options for an annotation store version.
    public var versionOptions: OmicsClientTypes.VersionOptions?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OmicsClientTypes.VersionStatus? = nil,
        storeId: Swift.String? = nil,
        versionName: Swift.String? = nil,
        versionOptions: OmicsClientTypes.VersionOptions? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.status = status
        self.storeId = storeId
        self.versionName = versionName
        self.versionOptions = versionOptions
    }
}

enum CreateAnnotationStoreVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateMultipartReadSetUploadInput {

    static func urlPathProvider(_ value: CreateMultipartReadSetUploadInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload"
    }
}

extension CreateMultipartReadSetUploadInput {

    static func write(value: CreateMultipartReadSetUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["generatedFrom"].write(value.generatedFrom)
        try writer["name"].write(value.name)
        try writer["referenceArn"].write(value.referenceArn)
        try writer["sampleId"].write(value.sampleId)
        try writer["sourceFileType"].write(value.sourceFileType)
        try writer["subjectId"].write(value.subjectId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateMultipartReadSetUploadInput {
    /// An idempotency token that can be used to avoid triggering multiple multipart uploads.
    public var clientToken: Swift.String?
    /// The description of the read set.
    public var description: Swift.String?
    /// Where the source originated.
    public var generatedFrom: Swift.String?
    /// The name of the read set.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the reference.
    public var referenceArn: Swift.String?
    /// The source's sample ID.
    /// This member is required.
    public var sampleId: Swift.String?
    /// The sequence store ID for the store that is the destination of the multipart uploads.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The type of file being uploaded.
    /// This member is required.
    public var sourceFileType: OmicsClientTypes.FileType?
    /// The source's subject ID.
    /// This member is required.
    public var subjectId: Swift.String?
    /// Any tags to add to the read set.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        generatedFrom: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sourceFileType: OmicsClientTypes.FileType? = nil,
        subjectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.generatedFrom = generatedFrom
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceStoreId = sequenceStoreId
        self.sourceFileType = sourceFileType
        self.subjectId = subjectId
        self.tags = tags
    }
}

extension CreateMultipartReadSetUploadOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateMultipartReadSetUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMultipartReadSetUploadOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.generatedFrom = try reader["generatedFrom"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.referenceArn = try reader["referenceArn"].readIfPresent()
        value.sampleId = try reader["sampleId"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.sourceFileType = try reader["sourceFileType"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uploadId = try reader["uploadId"].readIfPresent()
        return value
    }
}

public struct CreateMultipartReadSetUploadOutput {
    /// The creation time of the multipart upload.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description of the read set.
    public var description: Swift.String?
    /// The source of the read set.
    public var generatedFrom: Swift.String?
    /// The name of the read set.
    public var name: Swift.String?
    /// The read set source's reference ARN.
    /// This member is required.
    public var referenceArn: Swift.String?
    /// The source's sample ID.
    /// This member is required.
    public var sampleId: Swift.String?
    /// The sequence store ID for the store that the read set will be created in.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The file type of the read set source.
    /// This member is required.
    public var sourceFileType: OmicsClientTypes.FileType?
    /// The source's subject ID.
    /// This member is required.
    public var subjectId: Swift.String?
    /// The tags to add to the read set.
    public var tags: [Swift.String:Swift.String]?
    /// The ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        generatedFrom: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sourceFileType: OmicsClientTypes.FileType? = nil,
        subjectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.generatedFrom = generatedFrom
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceStoreId = sequenceStoreId
        self.sourceFileType = sourceFileType
        self.subjectId = subjectId
        self.tags = tags
        self.uploadId = uploadId
    }
}

enum CreateMultipartReadSetUploadOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotSupportedOperationException": return try NotSupportedOperationException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateReferenceStoreInput {

    static func urlPathProvider(_ value: CreateReferenceStoreInput) -> Swift.String? {
        return "/referencestore"
    }
}

extension CreateReferenceStoreInput {

    static func write(value: CreateReferenceStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["sseConfig"].write(value.sseConfig, with: OmicsClientTypes.SseConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateReferenceStoreInput {
    /// To ensure that requests don't run multiple times, specify a unique token for each request.
    public var clientToken: Swift.String?
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

extension CreateReferenceStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateReferenceStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReferenceStoreOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        return value
    }
}

public struct CreateReferenceStoreOutput {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's SSE settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

enum CreateReferenceStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateRunGroupInput {

    static func urlPathProvider(_ value: CreateRunGroupInput) -> Swift.String? {
        return "/runGroup"
    }
}

extension CreateRunGroupInput {

    static func write(value: CreateRunGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxCpus"].write(value.maxCpus)
        try writer["maxDuration"].write(value.maxDuration)
        try writer["maxGpus"].write(value.maxGpus)
        try writer["maxRuns"].write(value.maxRuns)
        try writer["name"].write(value.name)
        try writer["requestId"].write(value.requestId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateRunGroupInput {
    /// The maximum number of CPUs to use in the group.
    public var maxCpus: Swift.Int?
    /// A maximum run time for the group in minutes.
    public var maxDuration: Swift.Int?
    /// The maximum GPUs that can be used by a run group.
    public var maxGpus: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// A name for the group.
    public var name: Swift.String?
    /// To ensure that requests don't run multiple times, specify a unique ID for each request.
    /// This member is required.
    public var requestId: Swift.String?
    /// Tags for the group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxGpus: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxGpus = maxGpus
        self.maxRuns = maxRuns
        self.name = name
        self.requestId = requestId
        self.tags = tags
    }
}

extension CreateRunGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateRunGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRunGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct CreateRunGroupOutput {
    /// The group's ARN.
    public var arn: Swift.String?
    /// The group's ID.
    public var id: Swift.String?
    /// Tags for the run group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.tags = tags
    }
}

enum CreateRunGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSequenceStoreInput {

    static func urlPathProvider(_ value: CreateSequenceStoreInput) -> Swift.String? {
        return "/sequencestore"
    }
}

extension CreateSequenceStoreInput {

    static func write(value: CreateSequenceStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["eTagAlgorithmFamily"].write(value.eTagAlgorithmFamily)
        try writer["fallbackLocation"].write(value.fallbackLocation)
        try writer["name"].write(value.name)
        try writer["sseConfig"].write(value.sseConfig, with: OmicsClientTypes.SseConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateSequenceStoreInput {
    /// To ensure that requests don't run multiple times, specify a unique token for each request.
    public var clientToken: Swift.String?
    /// A description for the store.
    public var description: Swift.String?
    /// The ETag algorithm family to use for ingested read sets.
    public var eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily?
    /// An S3 location that is used to store files that have failed a direct upload.
    public var fallbackLocation: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily? = nil,
        fallbackLocation: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.eTagAlgorithmFamily = eTagAlgorithmFamily
        self.fallbackLocation = fallbackLocation
        self.name = name
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

extension CreateSequenceStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSequenceStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSequenceStoreOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.eTagAlgorithmFamily = try reader["eTagAlgorithmFamily"].readIfPresent()
        value.fallbackLocation = try reader["fallbackLocation"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        return value
    }
}

public struct CreateSequenceStoreOutput {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The algorithm family of the ETag.
    public var eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily?
    /// An S3 location that is used to store files that have failed a direct upload.
    public var fallbackLocation: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's SSE settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily? = nil,
        fallbackLocation: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.eTagAlgorithmFamily = eTagAlgorithmFamily
        self.fallbackLocation = fallbackLocation
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

enum CreateSequenceStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateShareInput {

    static func urlPathProvider(_ value: CreateShareInput) -> Swift.String? {
        return "/share"
    }
}

extension CreateShareInput {

    static func write(value: CreateShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["principalSubscriber"].write(value.principalSubscriber)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["shareName"].write(value.shareName)
    }
}

public struct CreateShareInput {
    /// The principal subscriber is the account being offered shared access to the resource.
    /// This member is required.
    public var principalSubscriber: Swift.String?
    /// The ARN of the resource to be shared.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A name that the owner defines for the share.
    public var shareName: Swift.String?

    public init(
        principalSubscriber: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        shareName: Swift.String? = nil
    )
    {
        self.principalSubscriber = principalSubscriber
        self.resourceArn = resourceArn
        self.shareName = shareName
    }
}

extension CreateShareOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateShareOutput()
        value.shareId = try reader["shareId"].readIfPresent()
        value.shareName = try reader["shareName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateShareOutput {
    /// The ID that HealthOmics generates for the share.
    public var shareId: Swift.String?
    /// The name of the share.
    public var shareName: Swift.String?
    /// The status of the share.
    public var status: OmicsClientTypes.ShareStatus?

    public init(
        shareId: Swift.String? = nil,
        shareName: Swift.String? = nil,
        status: OmicsClientTypes.ShareStatus? = nil
    )
    {
        self.shareId = shareId
        self.shareName = shareName
        self.status = status
    }
}

enum CreateShareOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateVariantStoreInput {

    static func urlPathProvider(_ value: CreateVariantStoreInput) -> Swift.String? {
        return "/variantStore"
    }
}

extension CreateVariantStoreInput {

    static func write(value: CreateVariantStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["reference"].write(value.reference, with: OmicsClientTypes.ReferenceItem.write(value:to:))
        try writer["sseConfig"].write(value.sseConfig, with: OmicsClientTypes.SseConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateVariantStoreInput {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    public var name: Swift.String?
    /// The genome reference for the store's variants.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

extension CreateVariantStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateVariantStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVariantStoreOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateVariantStoreOutput {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
    }
}

enum CreateVariantStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/workflow"
    }
}

extension CreateWorkflowInput {

    static func write(value: CreateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accelerators"].write(value.accelerators)
        try writer["definitionUri"].write(value.definitionUri)
        try writer["definitionZip"].write(value.definitionZip)
        try writer["description"].write(value.description)
        try writer["engine"].write(value.engine)
        try writer["main"].write(value.main)
        try writer["name"].write(value.name)
        try writer["parameterTemplate"].writeMap(value.parameterTemplate, valueWritingClosure: OmicsClientTypes.WorkflowParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestId"].write(value.requestId)
        try writer["storageCapacity"].write(value.storageCapacity)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateWorkflowInput {
    /// The computational accelerator specified to run the workflow.
    public var accelerators: OmicsClientTypes.Accelerators?
    /// The URI of a definition for the workflow.
    public var definitionUri: Swift.String?
    /// A ZIP archive for the workflow.
    public var definitionZip: ClientRuntime.Data?
    /// A description for the workflow.
    public var description: Swift.String?
    /// An engine for the workflow.
    public var engine: OmicsClientTypes.WorkflowEngine?
    /// The path of the main definition file for the workflow.
    public var main: Swift.String?
    /// A name for the workflow.
    public var name: Swift.String?
    /// A parameter template for the workflow.
    public var parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    /// To ensure that requests don't run multiple times, specify a unique ID for each request.
    /// This member is required.
    public var requestId: Swift.String?
    /// The storage capacity for the workflow in gibibytes.
    public var storageCapacity: Swift.Int?
    /// Tags for the workflow.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accelerators: OmicsClientTypes.Accelerators? = nil,
        definitionUri: Swift.String? = nil,
        definitionZip: ClientRuntime.Data? = nil,
        description: Swift.String? = nil,
        engine: OmicsClientTypes.WorkflowEngine? = nil,
        main: Swift.String? = nil,
        name: Swift.String? = nil,
        parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil,
        requestId: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accelerators = accelerators
        self.definitionUri = definitionUri
        self.definitionZip = definitionZip
        self.description = description
        self.engine = engine
        self.main = main
        self.name = name
        self.parameterTemplate = parameterTemplate
        self.requestId = requestId
        self.storageCapacity = storageCapacity
        self.tags = tags
    }
}

extension CreateWorkflowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct CreateWorkflowOutput {
    /// The workflow's ARN.
    public var arn: Swift.String?
    /// The workflow's ID.
    public var id: Swift.String?
    /// The workflow's status.
    public var status: OmicsClientTypes.WorkflowStatus?
    /// The workflow's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: OmicsClientTypes.WorkflowStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
        self.tags = tags
    }
}

enum CreateWorkflowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes {

    public enum CreationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `import`
        case upload
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationType] {
            return [
                .import,
                .upload,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .import: return "IMPORT"
            case .upload: return "UPLOAD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeleteAnnotationStoreInput {

    static func queryItemProvider(_ value: DeleteAnnotationStoreInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let force = value.force {
            let forceQueryItem = ClientRuntime.SDKURLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteAnnotationStoreInput {

    static func urlPathProvider(_ value: DeleteAnnotationStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAnnotationStoreInput {
    /// Whether to force deletion.
    public var force: Swift.Bool?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.force = force
        self.name = name
    }
}

extension DeleteAnnotationStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAnnotationStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAnnotationStoreOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteAnnotationStoreOutput {
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init(
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.status = status
    }
}

enum DeleteAnnotationStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAnnotationStoreVersionsInput {

    static func queryItemProvider(_ value: DeleteAnnotationStoreVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let force = value.force {
            let forceQueryItem = ClientRuntime.SDKURLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteAnnotationStoreVersionsInput {

    static func urlPathProvider(_ value: DeleteAnnotationStoreVersionsInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/versions/delete"
    }
}

extension DeleteAnnotationStoreVersionsInput {

    static func write(value: DeleteAnnotationStoreVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["versions"].writeList(value.versions, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct DeleteAnnotationStoreVersionsInput {
    /// Forces the deletion of an annotation store version when imports are in-progress..
    public var force: Swift.Bool?
    /// The name of the annotation store from which versions are being deleted.
    /// This member is required.
    public var name: Swift.String?
    /// The versions of an annotation store to be deleted.
    /// This member is required.
    public var versions: [Swift.String]?

    public init(
        force: Swift.Bool? = nil,
        name: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.force = force
        self.name = name
        self.versions = versions
    }
}

extension DeleteAnnotationStoreVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAnnotationStoreVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAnnotationStoreVersionsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: OmicsClientTypes.VersionDeleteError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct DeleteAnnotationStoreVersionsOutput {
    /// Any errors that occur when attempting to delete an annotation store version.
    public var errors: [OmicsClientTypes.VersionDeleteError]?

    public init(
        errors: [OmicsClientTypes.VersionDeleteError]? = nil
    )
    {
        self.errors = errors
    }
}

enum DeleteAnnotationStoreVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteReferenceInput {

    static func urlPathProvider(_ value: DeleteReferenceInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())"
    }
}

public struct DeleteReferenceInput {
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

extension DeleteReferenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteReferenceOutput {
        return DeleteReferenceOutput()
    }
}

public struct DeleteReferenceOutput {

    public init() { }
}

enum DeleteReferenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteReferenceStoreInput {

    static func urlPathProvider(_ value: DeleteReferenceStoreInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/referencestore/\(id.urlPercentEncoding())"
    }
}

public struct DeleteReferenceStoreInput {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DeleteReferenceStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteReferenceStoreOutput {
        return DeleteReferenceStoreOutput()
    }
}

public struct DeleteReferenceStoreOutput {

    public init() { }
}

enum DeleteReferenceStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRunGroupInput {

    static func urlPathProvider(_ value: DeleteRunGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct DeleteRunGroupInput {
    /// The run group's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DeleteRunGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRunGroupOutput {
        return DeleteRunGroupOutput()
    }
}

public struct DeleteRunGroupOutput {

    public init() { }
}

enum DeleteRunGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRunInput {

    static func urlPathProvider(_ value: DeleteRunInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())"
    }
}

public struct DeleteRunInput {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DeleteRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRunOutput {
        return DeleteRunOutput()
    }
}

public struct DeleteRunOutput {

    public init() { }
}

enum DeleteRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSequenceStoreInput {

    static func urlPathProvider(_ value: DeleteSequenceStoreInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(id.urlPercentEncoding())"
    }
}

public struct DeleteSequenceStoreInput {
    /// The sequence store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DeleteSequenceStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSequenceStoreOutput {
        return DeleteSequenceStoreOutput()
    }
}

public struct DeleteSequenceStoreOutput {

    public init() { }
}

enum DeleteSequenceStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteShareInput {

    static func urlPathProvider(_ value: DeleteShareInput) -> Swift.String? {
        guard let shareId = value.shareId else {
            return nil
        }
        return "/share/\(shareId.urlPercentEncoding())"
    }
}

public struct DeleteShareInput {
    /// The ID for the resource share to be deleted.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

extension DeleteShareOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteShareOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteShareOutput {
    /// The status of the share being deleted.
    public var status: OmicsClientTypes.ShareStatus?

    public init(
        status: OmicsClientTypes.ShareStatus? = nil
    )
    {
        self.status = status
    }
}

enum DeleteShareOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteVariantStoreInput {

    static func queryItemProvider(_ value: DeleteVariantStoreInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let force = value.force {
            let forceQueryItem = ClientRuntime.SDKURLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteVariantStoreInput {

    static func urlPathProvider(_ value: DeleteVariantStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct DeleteVariantStoreInput {
    /// Whether to force deletion.
    public var force: Swift.Bool?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.force = force
        self.name = name
    }
}

extension DeleteVariantStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteVariantStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVariantStoreOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteVariantStoreOutput {
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init(
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.status = status
    }
}

enum DeleteVariantStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowInput {
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteWorkflowOutput {
        return DeleteWorkflowOutput()
    }
}

public struct DeleteWorkflowOutput {

    public init() { }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.ETag {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ETag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ETag()
        value.algorithm = try reader["algorithm"].readIfPresent()
        value.source1 = try reader["source1"].readIfPresent()
        value.source2 = try reader["source2"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// The entity tag (ETag) is a hash of the object representing its semantic content.
    public struct ETag {
        /// The algorithm used to calculate the read set’s ETag(s).
        public var algorithm: OmicsClientTypes.ETagAlgorithm?
        /// The ETag hash calculated on Source1 of the read set.
        public var source1: Swift.String?
        /// The ETag hash calculated on Source2 of the read set.
        public var source2: Swift.String?

        public init(
            algorithm: OmicsClientTypes.ETagAlgorithm? = nil,
            source1: Swift.String? = nil,
            source2: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes {

    public enum ETagAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bamMd5up
        case bamSha256up
        case bamSha512up
        case cramMd5up
        case cramSha256up
        case cramSha512up
        case fastqMd5up
        case fastqSha256up
        case fastqSha512up
        case sdkUnknown(Swift.String)

        public static var allCases: [ETagAlgorithm] {
            return [
                .bamMd5up,
                .bamSha256up,
                .bamSha512up,
                .cramMd5up,
                .cramSha256up,
                .cramSha512up,
                .fastqMd5up,
                .fastqSha256up,
                .fastqSha512up,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bamMd5up: return "BAM_MD5up"
            case .bamSha256up: return "BAM_SHA256up"
            case .bamSha512up: return "BAM_SHA512up"
            case .cramMd5up: return "CRAM_MD5up"
            case .cramSha256up: return "CRAM_SHA256up"
            case .cramSha512up: return "CRAM_SHA512up"
            case .fastqMd5up: return "FASTQ_MD5up"
            case .fastqSha256up: return "FASTQ_SHA256up"
            case .fastqSha512up: return "FASTQ_SHA512up"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ETagAlgorithmFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case md5up
        case sha256up
        case sha512up
        case sdkUnknown(Swift.String)

        public static var allCases: [ETagAlgorithmFamily] {
            return [
                .md5up,
                .sha256up,
                .sha512up,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .md5up: return "MD5up"
            case .sha256up: return "SHA256up"
            case .sha512up: return "SHA512up"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// KMS
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ExportReadSet {

    static func write(value: OmicsClientTypes.ExportReadSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["readSetId"].write(value.readSetId)
    }
}

extension OmicsClientTypes {
    /// A read set.
    public struct ExportReadSet {
        /// The set's ID.
        /// This member is required.
        public var readSetId: Swift.String?

        public init(
            readSetId: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
        }
    }

}

extension OmicsClientTypes.ExportReadSetDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ExportReadSetDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ExportReadSetDetail()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Details about a read set.
    public struct ExportReadSetDetail {
        /// The set's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The set's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetExportJobItemStatus?
        /// The set's status message.
        public var statusMessage: Swift.String?

        public init(
            id: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetExportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.id = id
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.ExportReadSetFilter {

    static func write(value: OmicsClientTypes.ExportReadSetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// An read set export job filter.
    public struct ExportReadSetFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetExportJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetExportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ExportReadSetJobDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ExportReadSetJobDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ExportReadSetJobDetail()
        value.id = try reader["id"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// Details about a read set export job.
    public struct ExportReadSetJobDetail {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination in Amazon S3.
        /// This member is required.
        public var destination: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetExportJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destination: Swift.String? = nil,
            id: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetExportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.FileInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.FileInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.FileInformation()
        value.totalParts = try reader["totalParts"].readIfPresent()
        value.partSize = try reader["partSize"].readIfPresent()
        value.contentLength = try reader["contentLength"].readIfPresent()
        value.s3Access = try reader["s3Access"].readIfPresent(with: OmicsClientTypes.ReadSetS3Access.read(from:))
        return value
    }
}

extension OmicsClientTypes {
    /// Details about a file.
    public struct FileInformation {
        /// The file's content length.
        public var contentLength: Swift.Int?
        /// The file's part size.
        public var partSize: Swift.Int?
        /// The S3 URI metadata of a sequence store.
        public var s3Access: OmicsClientTypes.ReadSetS3Access?
        /// The file's total parts.
        public var totalParts: Swift.Int?

        public init(
            contentLength: Swift.Int? = nil,
            partSize: Swift.Int? = nil,
            s3Access: OmicsClientTypes.ReadSetS3Access? = nil,
            totalParts: Swift.Int? = nil
        )
        {
            self.contentLength = contentLength
            self.partSize = partSize
            self.s3Access = s3Access
            self.totalParts = totalParts
        }
    }

}

extension OmicsClientTypes {

    public enum FileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bam
        case cram
        case fastq
        case ubam
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .bam,
                .cram,
                .fastq,
                .ubam,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bam: return "BAM"
            case .cram: return "CRAM"
            case .fastq: return "FASTQ"
            case .ubam: return "UBAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.Filter {

    static func write(value: OmicsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].writeList(value.status, memberWritingClosure: OmicsClientTypes.ShareStatus.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].writeList(value.type, memberWritingClosure: OmicsClientTypes.ShareResourceType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension OmicsClientTypes {
    /// Use filters to return a subset of resources. You can define filters for specific parameters, such as the resource status.
    public struct Filter {
        /// Filter based on the Amazon Resource Number (ARN) of the resource. You can specify up to 10 values.
        public var resourceArns: [Swift.String]?
        /// Filter based on the resource status. You can specify up to 10 values.
        public var status: [OmicsClientTypes.ShareStatus]?
        /// The type of resources to be filtered. You can specify one or more of the resource types.
        public var type: [OmicsClientTypes.ShareResourceType]?

        public init(
            resourceArns: [Swift.String]? = nil,
            status: [OmicsClientTypes.ShareStatus]? = nil,
            type: [OmicsClientTypes.ShareResourceType]? = nil
        )
        {
            self.resourceArns = resourceArns
            self.status = status
            self.type = type
        }
    }

}

extension OmicsClientTypes.FormatOptions {

    static func write(value: OmicsClientTypes.FormatOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .tsvoptions(tsvoptions):
                try writer["tsvOptions"].write(tsvoptions, with: OmicsClientTypes.TsvOptions.write(value:to:))
            case let .vcfoptions(vcfoptions):
                try writer["vcfOptions"].write(vcfoptions, with: OmicsClientTypes.VcfOptions.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.FormatOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tsvOptions":
                return .tsvoptions(try reader["tsvOptions"].read(with: OmicsClientTypes.TsvOptions.read(from:)))
            case "vcfOptions":
                return .vcfoptions(try reader["vcfOptions"].read(with: OmicsClientTypes.VcfOptions.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension OmicsClientTypes {
    /// Formatting options for a file.
    public enum FormatOptions {
        /// Options for a TSV file.
        case tsvoptions(OmicsClientTypes.TsvOptions)
        /// Options for a VCF file.
        case vcfoptions(OmicsClientTypes.VcfOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {

    public enum FormatToHeaderKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alt
        case chr
        case end
        case pos
        case ref
        case start
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatToHeaderKey] {
            return [
                .alt,
                .chr,
                .end,
                .pos,
                .ref,
                .start,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alt: return "ALT"
            case .chr: return "CHR"
            case .end: return "END"
            case .pos: return "POS"
            case .ref: return "REF"
            case .start: return "START"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetAnnotationImportJobInput {

    static func urlPathProvider(_ value: GetAnnotationImportJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/import/annotation/\(jobId.urlPercentEncoding())"
    }
}

public struct GetAnnotationImportJobInput {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension GetAnnotationImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAnnotationImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnnotationImportJobOutput()
        value.annotationFields = try reader["annotationFields"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.destinationName = try reader["destinationName"].readIfPresent()
        value.formatOptions = try reader["formatOptions"].readIfPresent(with: OmicsClientTypes.FormatOptions.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: OmicsClientTypes.AnnotationImportItemDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.runLeftNormalization = try reader["runLeftNormalization"].readIfPresent() ?? false
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.versionName = try reader["versionName"].readIfPresent()
        return value
    }
}

public struct GetAnnotationImportJobOutput {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// When the job completed.
    /// This member is required.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination annotation store.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Formatting options for a file.
    /// This member is required.
    public var formatOptions: OmicsClientTypes.FormatOptions?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's imported items.
    /// This member is required.
    public var items: [OmicsClientTypes.AnnotationImportItemDetail]?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    /// This member is required.
    public var runLeftNormalization: Swift.Bool
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.JobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// When the job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?
    /// The name of the annotation store version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        formatOptions: OmicsClientTypes.FormatOptions? = nil,
        id: Swift.String? = nil,
        items: [OmicsClientTypes.AnnotationImportItemDetail]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool = false,
        status: OmicsClientTypes.JobStatus? = nil,
        statusMessage: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.annotationFields = annotationFields
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.formatOptions = formatOptions
        self.id = id
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.status = status
        self.statusMessage = statusMessage
        self.updateTime = updateTime
        self.versionName = versionName
    }
}

enum GetAnnotationImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAnnotationStoreInput {

    static func urlPathProvider(_ value: GetAnnotationStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct GetAnnotationStoreInput {
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GetAnnotationStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAnnotationStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnnotationStoreOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.numVersions = try reader["numVersions"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.storeArn = try reader["storeArn"].readIfPresent()
        value.storeFormat = try reader["storeFormat"].readIfPresent()
        value.storeOptions = try reader["storeOptions"].readIfPresent(with: OmicsClientTypes.StoreOptions.read(from:))
        value.storeSizeBytes = try reader["storeSizeBytes"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetAnnotationStoreOutput {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// An integer indicating how many versions of an annotation store exist.
    /// This member is required.
    public var numVersions: Swift.Int?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's server-side encryption (SSE) settings.
    /// This member is required.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// A status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store's ARN.
    /// This member is required.
    public var storeArn: Swift.String?
    /// The store's annotation file format.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// The store's parsing options.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// The store's size in bytes.
    /// This member is required.
    public var storeSizeBytes: Swift.Int?
    /// The store's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        numVersions: Swift.Int? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeArn: Swift.String? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        storeSizeBytes: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.numVersions = numVersions
        self.reference = reference
        self.sseConfig = sseConfig
        self.status = status
        self.statusMessage = statusMessage
        self.storeArn = storeArn
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.storeSizeBytes = storeSizeBytes
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum GetAnnotationStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAnnotationStoreVersionInput {

    static func urlPathProvider(_ value: GetAnnotationStoreVersionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/version/\(versionName.urlPercentEncoding())"
    }
}

public struct GetAnnotationStoreVersionInput {
    /// The name given to an annotation store version to distinguish it from others.
    /// This member is required.
    public var name: Swift.String?
    /// The name given to an annotation store version to distinguish it from others.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.name = name
        self.versionName = versionName
    }
}

extension GetAnnotationStoreVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAnnotationStoreVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnnotationStoreVersionOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.storeId = try reader["storeId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.versionArn = try reader["versionArn"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        value.versionOptions = try reader["versionOptions"].readIfPresent(with: OmicsClientTypes.VersionOptions.read(from:))
        value.versionSizeBytes = try reader["versionSizeBytes"].readIfPresent()
        return value
    }
}

public struct GetAnnotationStoreVersionOutput {
    /// The time stamp for when an annotation store version was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description for an annotation store version.
    /// This member is required.
    public var description: Swift.String?
    /// The annotation store version ID.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// The status of an annotation store version.
    /// This member is required.
    public var status: OmicsClientTypes.VersionStatus?
    /// The status of an annotation store version.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store ID for annotation store version.
    /// This member is required.
    public var storeId: Swift.String?
    /// Any tags associated with an annotation store version.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// The time stamp for when an annotation store version was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?
    /// The Arn for the annotation store.
    /// This member is required.
    public var versionArn: Swift.String?
    /// The name given to an annotation store version to distinguish it from others.
    /// This member is required.
    public var versionName: Swift.String?
    /// The options for an annotation store version.
    public var versionOptions: OmicsClientTypes.VersionOptions?
    /// The size of the annotation store version in Bytes.
    /// This member is required.
    public var versionSizeBytes: Swift.Int?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OmicsClientTypes.VersionStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil,
        versionArn: Swift.String? = nil,
        versionName: Swift.String? = nil,
        versionOptions: OmicsClientTypes.VersionOptions? = nil,
        versionSizeBytes: Swift.Int? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.storeId = storeId
        self.tags = tags
        self.updateTime = updateTime
        self.versionArn = versionArn
        self.versionName = versionName
        self.versionOptions = versionOptions
        self.versionSizeBytes = versionSizeBytes
    }
}

enum GetAnnotationStoreVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReadSetActivationJobInput {

    static func urlPathProvider(_ value: GetReadSetActivationJobInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetActivationJobInput {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

extension GetReadSetActivationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReadSetActivationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReadSetActivationJobOutput()
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ActivateReadSetSourceItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

public struct GetReadSetActivationJobOutput {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    public var sources: [OmicsClientTypes.ActivateReadSetSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetActivationJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ActivateReadSetSourceItem]? = nil,
        status: OmicsClientTypes.ReadSetActivationJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

enum GetReadSetActivationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReadSetExportJobInput {

    static func urlPathProvider(_ value: GetReadSetExportJobInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetExportJobInput {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

extension GetReadSetExportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReadSetExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReadSetExportJobOutput()
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.destination = try reader["destination"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.readSets = try reader["readSets"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ExportReadSetDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

public struct GetReadSetExportJobOutput {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination in Amazon S3.
    /// This member is required.
    public var destination: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's read sets.
    public var readSets: [OmicsClientTypes.ExportReadSetDetail]?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetExportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        id: Swift.String? = nil,
        readSets: [OmicsClientTypes.ExportReadSetDetail]? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetExportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destination = destination
        self.id = id
        self.readSets = readSets
        self.sequenceStoreId = sequenceStoreId
        self.status = status
        self.statusMessage = statusMessage
    }
}

enum GetReadSetExportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReadSetImportJobInput {

    static func urlPathProvider(_ value: GetReadSetImportJobInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetImportJobInput {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

extension GetReadSetImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReadSetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReadSetImportJobOutput()
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ImportReadSetSourceItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

public struct GetReadSetImportJobOutput {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.ImportReadSetSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetImportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ImportReadSetSourceItem]? = nil,
        status: OmicsClientTypes.ReadSetImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

enum GetReadSetImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReadSetInput {

    static func queryItemProvider(_ value: GetReadSetInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let file = value.file {
            let fileQueryItem = ClientRuntime.SDKURLQueryItem(name: "file".urlPercentEncoding(), value: Swift.String(file.rawValue).urlPercentEncoding())
            items.append(fileQueryItem)
        }
        guard let partNumber = value.partNumber else {
            let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let partNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
        items.append(partNumberQueryItem)
        return items
    }
}

extension GetReadSetInput {

    static func urlPathProvider(_ value: GetReadSetInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetInput {
    /// The file to retrieve.
    public var file: OmicsClientTypes.ReadSetFile?
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The part number to retrieve.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        file: OmicsClientTypes.ReadSetFile? = nil,
        id: Swift.String? = nil,
        partNumber: Swift.Int? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.file = file
        self.id = id
        self.partNumber = partNumber
        self.sequenceStoreId = sequenceStoreId
    }
}

extension GetReadSetMetadataInput {

    static func urlPathProvider(_ value: GetReadSetMetadataInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/\(id.urlPercentEncoding())/metadata"
    }
}

public struct GetReadSetMetadataInput {
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

extension GetReadSetMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReadSetMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReadSetMetadataOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.creationType = try reader["creationType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.etag = try reader["etag"].readIfPresent(with: OmicsClientTypes.ETag.read(from:))
        value.fileType = try reader["fileType"].readIfPresent()
        value.files = try reader["files"].readIfPresent(with: OmicsClientTypes.ReadSetFiles.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.referenceArn = try reader["referenceArn"].readIfPresent()
        value.sampleId = try reader["sampleId"].readIfPresent()
        value.sequenceInformation = try reader["sequenceInformation"].readIfPresent(with: OmicsClientTypes.SequenceInformation.read(from:))
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        return value
    }
}

public struct GetReadSetMetadataOutput {
    /// The read set's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the read set was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The creation type of the read set.
    public var creationType: OmicsClientTypes.CreationType?
    /// The read set's description.
    public var description: Swift.String?
    /// The entity tag (ETag) is a hash of the object meant to represent its semantic content.
    public var etag: OmicsClientTypes.ETag?
    /// The read set's file type.
    /// This member is required.
    public var fileType: OmicsClientTypes.FileType?
    /// The read set's files.
    public var files: OmicsClientTypes.ReadSetFiles?
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's name.
    public var name: Swift.String?
    /// The read set's genome reference ARN.
    public var referenceArn: Swift.String?
    /// The read set's sample ID.
    public var sampleId: Swift.String?
    /// The read set's sequence information.
    public var sequenceInformation: OmicsClientTypes.SequenceInformation?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The read set's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetStatus?
    /// The status message for a read set. It provides more detail as to why the read set has a status.
    public var statusMessage: Swift.String?
    /// The read set's subject ID.
    public var subjectId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        creationType: OmicsClientTypes.CreationType? = nil,
        description: Swift.String? = nil,
        etag: OmicsClientTypes.ETag? = nil,
        fileType: OmicsClientTypes.FileType? = nil,
        files: OmicsClientTypes.ReadSetFiles? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceInformation: OmicsClientTypes.SequenceInformation? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetStatus? = nil,
        statusMessage: Swift.String? = nil,
        subjectId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creationType = creationType
        self.description = description
        self.etag = etag
        self.fileType = fileType
        self.files = files
        self.id = id
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceInformation = sequenceInformation
        self.sequenceStoreId = sequenceStoreId
        self.status = status
        self.statusMessage = statusMessage
        self.subjectId = subjectId
    }
}

enum GetReadSetMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReadSetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReadSetOutput {
        var value = GetReadSetOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = .data(data)
        case .stream(let stream):
            value.payload = .stream(stream)
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

public struct GetReadSetOutput {
    /// The read set file payload.
    public var payload: ClientRuntime.ByteStream?

    public init(
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

enum GetReadSetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RangeNotSatisfiableException": return try RangeNotSatisfiableException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReferenceImportJobInput {

    static func urlPathProvider(_ value: GetReferenceImportJobInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceImportJobInput {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

extension GetReferenceImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReferenceImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReferenceImportJobOutput()
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.referenceStoreId = try reader["referenceStoreId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ImportReferenceSourceItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

public struct GetReferenceImportJobOutput {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.ImportReferenceSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReferenceImportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sources: [OmicsClientTypes.ImportReferenceSourceItem]? = nil,
        status: OmicsClientTypes.ReferenceImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

enum GetReferenceImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReferenceInput {

    static func headerProvider(_ value: GetReferenceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let range = value.range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        return items
    }
}

extension GetReferenceInput {

    static func queryItemProvider(_ value: GetReferenceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let file = value.file {
            let fileQueryItem = ClientRuntime.SDKURLQueryItem(name: "file".urlPercentEncoding(), value: Swift.String(file.rawValue).urlPercentEncoding())
            items.append(fileQueryItem)
        }
        guard let partNumber = value.partNumber else {
            let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let partNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
        items.append(partNumberQueryItem)
        return items
    }
}

extension GetReferenceInput {

    static func urlPathProvider(_ value: GetReferenceInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceInput {
    /// The file to retrieve.
    public var file: OmicsClientTypes.ReferenceFile?
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The part number to retrieve.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The range to retrieve.
    public var range: Swift.String?
    /// The reference's store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        file: OmicsClientTypes.ReferenceFile? = nil,
        id: Swift.String? = nil,
        partNumber: Swift.Int? = nil,
        range: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.file = file
        self.id = id
        self.partNumber = partNumber
        self.range = range
        self.referenceStoreId = referenceStoreId
    }
}

extension GetReferenceMetadataInput {

    static func urlPathProvider(_ value: GetReferenceMetadataInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())/metadata"
    }
}

public struct GetReferenceMetadataInput {
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

extension GetReferenceMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReferenceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReferenceMetadataOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.files = try reader["files"].readIfPresent(with: OmicsClientTypes.ReferenceFiles.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.md5 = try reader["md5"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.referenceStoreId = try reader["referenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetReferenceMetadataOutput {
    /// The reference's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the reference was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The reference's description.
    public var description: Swift.String?
    /// The reference's files.
    public var files: OmicsClientTypes.ReferenceFiles?
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's MD5 checksum.
    /// This member is required.
    public var md5: Swift.String?
    /// The reference's name.
    public var name: Swift.String?
    /// The reference's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The reference's status.
    public var status: OmicsClientTypes.ReferenceStatus?
    /// When the reference was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        files: OmicsClientTypes.ReferenceFiles? = nil,
        id: Swift.String? = nil,
        md5: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReferenceStatus? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.files = files
        self.id = id
        self.md5 = md5
        self.name = name
        self.referenceStoreId = referenceStoreId
        self.status = status
        self.updateTime = updateTime
    }
}

enum GetReferenceMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReferenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReferenceOutput {
        var value = GetReferenceOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = .data(data)
        case .stream(let stream):
            value.payload = .stream(stream)
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

public struct GetReferenceOutput {
    /// The reference file payload.
    public var payload: ClientRuntime.ByteStream?

    public init(
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

enum GetReferenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RangeNotSatisfiableException": return try RangeNotSatisfiableException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetReferenceStoreInput {

    static func urlPathProvider(_ value: GetReferenceStoreInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/referencestore/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceStoreInput {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetReferenceStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetReferenceStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReferenceStoreOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        return value
    }
}

public struct GetReferenceStoreOutput {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's server-side encryption (SSE) settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

enum GetReferenceStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRunGroupInput {

    static func urlPathProvider(_ value: GetRunGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct GetRunGroupInput {
    /// The group's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetRunGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRunGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRunGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.maxCpus = try reader["maxCpus"].readIfPresent()
        value.maxDuration = try reader["maxDuration"].readIfPresent()
        value.maxGpus = try reader["maxGpus"].readIfPresent()
        value.maxRuns = try reader["maxRuns"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetRunGroupOutput {
    /// The group's ARN.
    public var arn: Swift.String?
    /// When the group was created.
    public var creationTime: ClientRuntime.Date?
    /// The group's ID.
    public var id: Swift.String?
    /// The group's maximum number of CPUs to use.
    public var maxCpus: Swift.Int?
    /// The group's maximum run time in minutes.
    public var maxDuration: Swift.Int?
    /// The maximum GPUs that can be used by a run group.
    public var maxGpus: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// The group's name.
    public var name: Swift.String?
    /// The group's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxGpus: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.id = id
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxGpus = maxGpus
        self.maxRuns = maxRuns
        self.name = name
        self.tags = tags
    }
}

enum GetRunGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRunInput {

    static func queryItemProvider(_ value: GetRunInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let export = value.export {
            export.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "export".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetRunInput {

    static func urlPathProvider(_ value: GetRunInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())"
    }
}

public struct GetRunInput {
    /// The run's export format.
    public var export: [OmicsClientTypes.RunExport]?
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        export: [OmicsClientTypes.RunExport]? = nil,
        id: Swift.String? = nil
    )
    {
        self.export = export
        self.id = id
    }
}

extension GetRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRunOutput()
        value.accelerators = try reader["accelerators"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.definition = try reader["definition"].readIfPresent()
        value.digest = try reader["digest"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.logLevel = try reader["logLevel"].readIfPresent()
        value.logLocation = try reader["logLocation"].readIfPresent(with: OmicsClientTypes.RunLogLocation.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.outputUri = try reader["outputUri"].readIfPresent()
        value.parameters = try reader["parameters"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.resourceDigests = try reader["resourceDigests"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.retentionMode = try reader["retentionMode"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.runGroupId = try reader["runGroupId"].readIfPresent()
        value.runId = try reader["runId"].readIfPresent()
        value.runOutputUri = try reader["runOutputUri"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.startedBy = try reader["startedBy"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.stopTime = try reader["stopTime"].readTimestampIfPresent(format: .dateTime)
        value.storageCapacity = try reader["storageCapacity"].readIfPresent()
        value.storageType = try reader["storageType"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uuid = try reader["uuid"].readIfPresent()
        value.workflowId = try reader["workflowId"].readIfPresent()
        value.workflowOwnerId = try reader["workflowOwnerId"].readIfPresent()
        value.workflowType = try reader["workflowType"].readIfPresent()
        return value
    }
}

public struct GetRunOutput {
    /// The computational accelerator used to run the workflow.
    public var accelerators: OmicsClientTypes.Accelerators?
    /// The run's ARN.
    public var arn: Swift.String?
    /// When the run was created.
    public var creationTime: ClientRuntime.Date?
    /// The run's definition.
    public var definition: Swift.String?
    /// The run's digest.
    public var digest: Swift.String?
    /// The reason a run has failed.
    public var failureReason: Swift.String?
    /// The run's ID.
    public var id: Swift.String?
    /// The run's log level.
    public var logLevel: OmicsClientTypes.RunLogLevel?
    /// The location of the run log.
    public var logLocation: OmicsClientTypes.RunLogLocation?
    /// The run's name.
    public var name: Swift.String?
    /// The run's output URI.
    public var outputUri: Swift.String?
    /// The run's parameters.
    public var parameters: SmithyReadWrite.Document?
    /// The run's priority.
    public var priority: Swift.Int?
    /// The run's resource digests.
    public var resourceDigests: [Swift.String:Swift.String]?
    /// The run's retention mode.
    public var retentionMode: OmicsClientTypes.RunRetentionMode?
    /// The run's service role ARN.
    public var roleArn: Swift.String?
    /// The run's group ID.
    public var runGroupId: Swift.String?
    /// The run's ID.
    public var runId: Swift.String?
    /// The destination for workflow outputs.
    public var runOutputUri: Swift.String?
    /// When the run started.
    public var startTime: ClientRuntime.Date?
    /// Who started the run.
    public var startedBy: Swift.String?
    /// The run's status.
    public var status: OmicsClientTypes.RunStatus?
    /// The run's status message.
    public var statusMessage: Swift.String?
    /// The run's stop time.
    public var stopTime: ClientRuntime.Date?
    /// The run's storage capacity in gibibytes. For dynamic storage, after the run has completed, this value is the maximum amount of storage used during the run.
    public var storageCapacity: Swift.Int?
    /// The run's storage type.
    public var storageType: OmicsClientTypes.StorageType?
    /// The run's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The universally unique identifier for a run.
    public var uuid: Swift.String?
    /// The run's workflow ID.
    public var workflowId: Swift.String?
    /// The ID of the workflow owner.
    public var workflowOwnerId: Swift.String?
    /// The run's workflow type.
    public var workflowType: OmicsClientTypes.WorkflowType?

    public init(
        accelerators: OmicsClientTypes.Accelerators? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        digest: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        id: Swift.String? = nil,
        logLevel: OmicsClientTypes.RunLogLevel? = nil,
        logLocation: OmicsClientTypes.RunLogLocation? = nil,
        name: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        parameters: SmithyReadWrite.Document? = nil,
        priority: Swift.Int? = nil,
        resourceDigests: [Swift.String:Swift.String]? = nil,
        retentionMode: OmicsClientTypes.RunRetentionMode? = nil,
        roleArn: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        runId: Swift.String? = nil,
        runOutputUri: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        startedBy: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil,
        statusMessage: Swift.String? = nil,
        stopTime: ClientRuntime.Date? = nil,
        storageCapacity: Swift.Int? = nil,
        storageType: OmicsClientTypes.StorageType? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uuid: Swift.String? = nil,
        workflowId: Swift.String? = nil,
        workflowOwnerId: Swift.String? = nil,
        workflowType: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.accelerators = accelerators
        self.arn = arn
        self.creationTime = creationTime
        self.definition = definition
        self.digest = digest
        self.failureReason = failureReason
        self.id = id
        self.logLevel = logLevel
        self.logLocation = logLocation
        self.name = name
        self.outputUri = outputUri
        self.parameters = parameters
        self.priority = priority
        self.resourceDigests = resourceDigests
        self.retentionMode = retentionMode
        self.roleArn = roleArn
        self.runGroupId = runGroupId
        self.runId = runId
        self.runOutputUri = runOutputUri
        self.startTime = startTime
        self.startedBy = startedBy
        self.status = status
        self.statusMessage = statusMessage
        self.stopTime = stopTime
        self.storageCapacity = storageCapacity
        self.storageType = storageType
        self.tags = tags
        self.uuid = uuid
        self.workflowId = workflowId
        self.workflowOwnerId = workflowOwnerId
        self.workflowType = workflowType
    }
}

enum GetRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRunTaskInput {

    static func urlPathProvider(_ value: GetRunTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        guard let taskId = value.taskId else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/task/\(taskId.urlPercentEncoding())"
    }
}

public struct GetRunTaskInput {
    /// The workflow run ID.
    /// This member is required.
    public var id: Swift.String?
    /// The task's ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        id: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.id = id
        self.taskId = taskId
    }
}

extension GetRunTaskOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRunTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRunTaskOutput()
        value.cpus = try reader["cpus"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.gpus = try reader["gpus"].readIfPresent()
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.logStream = try reader["logStream"].readIfPresent()
        value.memory = try reader["memory"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.stopTime = try reader["stopTime"].readTimestampIfPresent(format: .dateTime)
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

public struct GetRunTaskOutput {
    /// The task's CPU usage.
    public var cpus: Swift.Int?
    /// When the task was created.
    public var creationTime: ClientRuntime.Date?
    /// The reason a task has failed.
    public var failureReason: Swift.String?
    /// The number of Graphics Processing Units (GPU) specified in the task.
    public var gpus: Swift.Int?
    /// The instance type for a task.
    public var instanceType: Swift.String?
    /// The task's log stream.
    public var logStream: Swift.String?
    /// The task's memory use in gigabytes.
    public var memory: Swift.Int?
    /// The task's name.
    public var name: Swift.String?
    /// The task's start time.
    public var startTime: ClientRuntime.Date?
    /// The task's status.
    public var status: OmicsClientTypes.TaskStatus?
    /// The task's status message.
    public var statusMessage: Swift.String?
    /// The task's stop time.
    public var stopTime: ClientRuntime.Date?
    /// The task's ID.
    public var taskId: Swift.String?

    public init(
        cpus: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        failureReason: Swift.String? = nil,
        gpus: Swift.Int? = nil,
        instanceType: Swift.String? = nil,
        logStream: Swift.String? = nil,
        memory: Swift.Int? = nil,
        name: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: OmicsClientTypes.TaskStatus? = nil,
        statusMessage: Swift.String? = nil,
        stopTime: ClientRuntime.Date? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.cpus = cpus
        self.creationTime = creationTime
        self.failureReason = failureReason
        self.gpus = gpus
        self.instanceType = instanceType
        self.logStream = logStream
        self.memory = memory
        self.name = name
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
        self.stopTime = stopTime
        self.taskId = taskId
    }
}

enum GetRunTaskOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSequenceStoreInput {

    static func urlPathProvider(_ value: GetSequenceStoreInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/sequencestore/\(id.urlPercentEncoding())"
    }
}

public struct GetSequenceStoreInput {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetSequenceStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSequenceStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSequenceStoreOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.eTagAlgorithmFamily = try reader["eTagAlgorithmFamily"].readIfPresent()
        value.fallbackLocation = try reader["fallbackLocation"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.s3Access = try reader["s3Access"].readIfPresent(with: OmicsClientTypes.SequenceStoreS3Access.read(from:))
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        return value
    }
}

public struct GetSequenceStoreOutput {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The algorithm family of the ETag.
    public var eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily?
    /// An S3 location that is used to store files that have failed a direct upload.
    public var fallbackLocation: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The S3 metadata of a sequence store, including the ARN and S3 URI of the S3 bucket.
    public var s3Access: OmicsClientTypes.SequenceStoreS3Access?
    /// The store's server-side encryption (SSE) settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily? = nil,
        fallbackLocation: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        s3Access: OmicsClientTypes.SequenceStoreS3Access? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.eTagAlgorithmFamily = eTagAlgorithmFamily
        self.fallbackLocation = fallbackLocation
        self.id = id
        self.name = name
        self.s3Access = s3Access
        self.sseConfig = sseConfig
    }
}

enum GetSequenceStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetShareInput {

    static func urlPathProvider(_ value: GetShareInput) -> Swift.String? {
        guard let shareId = value.shareId else {
            return nil
        }
        return "/share/\(shareId.urlPercentEncoding())"
    }
}

public struct GetShareInput {
    /// The ID of the share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

extension GetShareOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetShareOutput()
        value.share = try reader["share"].readIfPresent(with: OmicsClientTypes.ShareDetails.read(from:))
        return value
    }
}

public struct GetShareOutput {
    /// A resource share details object. The object includes the status, the resourceArn, and ownerId.
    public var share: OmicsClientTypes.ShareDetails?

    public init(
        share: OmicsClientTypes.ShareDetails? = nil
    )
    {
        self.share = share
    }
}

enum GetShareOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetVariantImportJobInput {

    static func urlPathProvider(_ value: GetVariantImportJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/import/variant/\(jobId.urlPercentEncoding())"
    }
}

public struct GetVariantImportJobInput {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension GetVariantImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetVariantImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVariantImportJobOutput()
        value.annotationFields = try reader["annotationFields"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.destinationName = try reader["destinationName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: OmicsClientTypes.VariantImportItemDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.runLeftNormalization = try reader["runLeftNormalization"].readIfPresent() ?? false
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetVariantImportJobOutput {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination variant store.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's items.
    /// This member is required.
    public var items: [OmicsClientTypes.VariantImportItemDetail]?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    /// This member is required.
    public var runLeftNormalization: Swift.Bool
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.JobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// When the job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        items: [OmicsClientTypes.VariantImportItemDetail]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool = false,
        status: OmicsClientTypes.JobStatus? = nil,
        statusMessage: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.annotationFields = annotationFields
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.id = id
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.status = status
        self.statusMessage = statusMessage
        self.updateTime = updateTime
    }
}

enum GetVariantImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetVariantStoreInput {

    static func urlPathProvider(_ value: GetVariantStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct GetVariantStoreInput {
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GetVariantStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetVariantStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVariantStoreOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.storeArn = try reader["storeArn"].readIfPresent()
        value.storeSizeBytes = try reader["storeSizeBytes"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetVariantStoreOutput {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's server-side encryption (SSE) settings.
    /// This member is required.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The store's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store's ARN.
    /// This member is required.
    public var storeArn: Swift.String?
    /// The store's size in bytes.
    /// This member is required.
    public var storeSizeBytes: Swift.Int?
    /// The store's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeArn: Swift.String? = nil,
        storeSizeBytes: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.status = status
        self.statusMessage = statusMessage
        self.storeArn = storeArn
        self.storeSizeBytes = storeSizeBytes
        self.tags = tags
        self.updateTime = updateTime
    }
}

enum GetVariantStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetWorkflowInput {

    static func queryItemProvider(_ value: GetWorkflowInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let workflowOwnerId = value.workflowOwnerId {
            let workflowOwnerIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "workflowOwnerId".urlPercentEncoding(), value: Swift.String(workflowOwnerId).urlPercentEncoding())
            items.append(workflowOwnerIdQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let export = value.export {
            export.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "export".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput {
    /// The export format for the workflow.
    public var export: [OmicsClientTypes.WorkflowExport]?
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The workflow's type.
    public var type: OmicsClientTypes.WorkflowType?
    /// The ID of the workflow owner.
    public var workflowOwnerId: Swift.String?

    public init(
        export: [OmicsClientTypes.WorkflowExport]? = nil,
        id: Swift.String? = nil,
        type: OmicsClientTypes.WorkflowType? = nil,
        workflowOwnerId: Swift.String? = nil
    )
    {
        self.export = export
        self.id = id
        self.type = type
        self.workflowOwnerId = workflowOwnerId
    }
}

extension GetWorkflowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowOutput()
        value.accelerators = try reader["accelerators"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.definition = try reader["definition"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.digest = try reader["digest"].readIfPresent()
        value.engine = try reader["engine"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.main = try reader["main"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.parameterTemplate = try reader["parameterTemplate"].readMapIfPresent(valueReadingClosure: OmicsClientTypes.WorkflowParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.storageCapacity = try reader["storageCapacity"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct GetWorkflowOutput {
    /// The computational accelerator specified to run the workflow.
    public var accelerators: OmicsClientTypes.Accelerators?
    /// The workflow's ARN.
    public var arn: Swift.String?
    /// When the workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The workflow's definition.
    public var definition: Swift.String?
    /// The workflow's description.
    public var description: Swift.String?
    /// The workflow's digest.
    public var digest: Swift.String?
    /// The workflow's engine.
    public var engine: OmicsClientTypes.WorkflowEngine?
    /// The workflow's ID.
    public var id: Swift.String?
    /// The path of the main definition file for the workflow.
    public var main: Swift.String?
    /// Gets metadata for workflow.
    public var metadata: [Swift.String:Swift.String]?
    /// The workflow's name.
    public var name: Swift.String?
    /// The workflow's parameter template.
    public var parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    /// The workflow's status.
    public var status: OmicsClientTypes.WorkflowStatus?
    /// The workflow's status message.
    public var statusMessage: Swift.String?
    /// The workflow's storage capacity in gibibytes.
    public var storageCapacity: Swift.Int?
    /// The workflow's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The workflow's type.
    public var type: OmicsClientTypes.WorkflowType?

    public init(
        accelerators: OmicsClientTypes.Accelerators? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        description: Swift.String? = nil,
        digest: Swift.String? = nil,
        engine: OmicsClientTypes.WorkflowEngine? = nil,
        id: Swift.String? = nil,
        main: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil,
        status: OmicsClientTypes.WorkflowStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.accelerators = accelerators
        self.arn = arn
        self.creationTime = creationTime
        self.definition = definition
        self.description = description
        self.digest = digest
        self.engine = engine
        self.id = id
        self.main = main
        self.metadata = metadata
        self.name = name
        self.parameterTemplate = parameterTemplate
        self.status = status
        self.statusMessage = statusMessage
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.type = type
    }
}

enum GetWorkflowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.ImportReadSetFilter {

    static func write(value: OmicsClientTypes.ImportReadSetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// A filter for import read set jobs.
    public struct ImportReadSetFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetImportJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetImportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReadSetJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ImportReadSetJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ImportReadSetJobItem()
        value.id = try reader["id"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// An import read set job.
    public struct ImportReadSetJobItem {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetImportJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetImportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReadSetSourceItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ImportReadSetSourceItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ImportReadSetSourceItem()
        value.sourceFiles = try reader["sourceFiles"].readIfPresent(with: OmicsClientTypes.SourceFiles.read(from:))
        value.sourceFileType = try reader["sourceFileType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.sampleId = try reader["sampleId"].readIfPresent()
        value.generatedFrom = try reader["generatedFrom"].readIfPresent()
        value.referenceArn = try reader["referenceArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// A source for an import read set job.
    public struct ImportReadSetSourceItem {
        /// The source's description.
        public var description: Swift.String?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source's genome reference ARN.
        public var referenceArn: Swift.String?
        /// The source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The source's file type.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The source files' location in Amazon S3.
        /// This member is required.
        public var sourceFiles: OmicsClientTypes.SourceFiles?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetImportJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?
        /// The source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            sourceFiles: OmicsClientTypes.SourceFiles? = nil,
            status: OmicsClientTypes.ReadSetImportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFileType = sourceFileType
            self.sourceFiles = sourceFiles
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
            self.tags = tags
        }
    }

}

extension OmicsClientTypes.ImportReferenceFilter {

    static func write(value: OmicsClientTypes.ImportReferenceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// A filter for import references.
    public struct ImportReferenceFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReferenceImportJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReferenceImportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReferenceJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ImportReferenceJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ImportReferenceJobItem()
        value.id = try reader["id"].readIfPresent()
        value.referenceStoreId = try reader["referenceStoreId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// An import reference job.
    public struct ImportReferenceJobItem {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's reference store ID.
        /// This member is required.
        public var referenceStoreId: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReferenceImportJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            referenceStoreId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceImportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReferenceSourceItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ImportReferenceSourceItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ImportReferenceSourceItem()
        value.sourceFile = try reader["sourceFile"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// An genome reference source.
    public struct ImportReferenceSourceItem {
        /// The source's description.
        public var description: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source file's location in Amazon S3.
        public var sourceFile: Swift.String?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReferenceImportJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceFile: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceImportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An unexpected error occurred. Try the request again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes {

    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The Job was cancelled
        case cancelled
        /// The Job has completed
        case completed
        /// The Job completed with failed runs
        case completedWithFailures
        /// The Job failed
        case failed
        /// The Job is executing
        case inProgress
        /// The Job has been submitted to run
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ListAnnotationImportJobsFilter {

    static func write(value: OmicsClientTypes.ListAnnotationImportJobsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
        try writer["storeName"].write(value.storeName)
    }
}

extension OmicsClientTypes {
    /// A filter for annotation import jobs.
    public struct ListAnnotationImportJobsFilter {
        /// A status to filter on.
        public var status: OmicsClientTypes.JobStatus?
        /// A store name to filter on.
        public var storeName: Swift.String?

        public init(
            status: OmicsClientTypes.JobStatus? = nil,
            storeName: Swift.String? = nil
        )
        {
            self.status = status
            self.storeName = storeName
        }
    }

}

extension ListAnnotationImportJobsInput {

    static func queryItemProvider(_ value: ListAnnotationImportJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAnnotationImportJobsInput {

    static func urlPathProvider(_ value: ListAnnotationImportJobsInput) -> Swift.String? {
        return "/import/annotations"
    }
}

extension ListAnnotationImportJobsInput {

    static func write(value: ListAnnotationImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ListAnnotationImportJobsFilter.write(value:to:))
        try writer["ids"].writeList(value.ids, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct ListAnnotationImportJobsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListAnnotationImportJobsFilter?
    /// IDs of annotation import jobs to retrieve.
    public var ids: [Swift.String]?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListAnnotationImportJobsFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAnnotationImportJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAnnotationImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnnotationImportJobsOutput()
        value.annotationImportJobs = try reader["annotationImportJobs"].readListIfPresent(memberReadingClosure: OmicsClientTypes.AnnotationImportJobItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAnnotationImportJobsOutput {
    /// A list of jobs.
    public var annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationImportJobs = annotationImportJobs
        self.nextToken = nextToken
    }
}

enum ListAnnotationImportJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.ListAnnotationStoreVersionsFilter {

    static func write(value: OmicsClientTypes.ListAnnotationStoreVersionsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// Use filters to focus the returned annotation store versions on a specific parameter, such as the status of the annotation store.
    public struct ListAnnotationStoreVersionsFilter {
        /// The status of an annotation store version.
        public var status: OmicsClientTypes.VersionStatus?

        public init(
            status: OmicsClientTypes.VersionStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListAnnotationStoreVersionsInput {

    static func queryItemProvider(_ value: ListAnnotationStoreVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAnnotationStoreVersionsInput {

    static func urlPathProvider(_ value: ListAnnotationStoreVersionsInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/versions"
    }
}

extension ListAnnotationStoreVersionsInput {

    static func write(value: ListAnnotationStoreVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ListAnnotationStoreVersionsFilter.write(value:to:))
    }
}

public struct ListAnnotationStoreVersionsInput {
    /// A filter to apply to the list of annotation store versions.
    public var filter: OmicsClientTypes.ListAnnotationStoreVersionsFilter?
    /// The maximum number of annotation store versions to return in one page of results.
    public var maxResults: Swift.Int?
    /// The name of an annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListAnnotationStoreVersionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension ListAnnotationStoreVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAnnotationStoreVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnnotationStoreVersionsOutput()
        value.annotationStoreVersions = try reader["annotationStoreVersions"].readListIfPresent(memberReadingClosure: OmicsClientTypes.AnnotationStoreVersionItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAnnotationStoreVersionsOutput {
    /// Lists all versions of an annotation store.
    public var annotationStoreVersions: [OmicsClientTypes.AnnotationStoreVersionItem]?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        annotationStoreVersions: [OmicsClientTypes.AnnotationStoreVersionItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationStoreVersions = annotationStoreVersions
        self.nextToken = nextToken
    }
}

enum ListAnnotationStoreVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.ListAnnotationStoresFilter {

    static func write(value: OmicsClientTypes.ListAnnotationStoresFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// A filter for annotation stores.
    public struct ListAnnotationStoresFilter {
        /// A status to filter on.
        public var status: OmicsClientTypes.StoreStatus?

        public init(
            status: OmicsClientTypes.StoreStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListAnnotationStoresInput {

    static func queryItemProvider(_ value: ListAnnotationStoresInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAnnotationStoresInput {

    static func urlPathProvider(_ value: ListAnnotationStoresInput) -> Swift.String? {
        return "/annotationStores"
    }
}

extension ListAnnotationStoresInput {

    static func write(value: ListAnnotationStoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ListAnnotationStoresFilter.write(value:to:))
        try writer["ids"].writeList(value.ids, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct ListAnnotationStoresInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListAnnotationStoresFilter?
    /// IDs of stores to list.
    public var ids: [Swift.String]?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListAnnotationStoresFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAnnotationStoresOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAnnotationStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnnotationStoresOutput()
        value.annotationStores = try reader["annotationStores"].readListIfPresent(memberReadingClosure: OmicsClientTypes.AnnotationStoreItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAnnotationStoresOutput {
    /// A list of stores.
    public var annotationStores: [OmicsClientTypes.AnnotationStoreItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        annotationStores: [OmicsClientTypes.AnnotationStoreItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationStores = annotationStores
        self.nextToken = nextToken
    }
}

enum ListAnnotationStoresOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListMultipartReadSetUploadsInput {

    static func queryItemProvider(_ value: ListMultipartReadSetUploadsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListMultipartReadSetUploadsInput {

    static func urlPathProvider(_ value: ListMultipartReadSetUploadsInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/uploads"
    }
}

public struct ListMultipartReadSetUploadsInput {
    /// The maximum number of multipart uploads returned in a page.
    public var maxResults: Swift.Int?
    /// Next token returned in the response of a previous ListMultipartReadSetUploads call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The Sequence Store ID used for the multipart uploads.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

extension ListMultipartReadSetUploadsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListMultipartReadSetUploadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMultipartReadSetUploadsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.uploads = try reader["uploads"].readListIfPresent(memberReadingClosure: OmicsClientTypes.MultipartReadSetUploadListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListMultipartReadSetUploadsOutput {
    /// Next token returned in the response of a previous ListMultipartReadSetUploads call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// An array of multipart uploads.
    public var uploads: [OmicsClientTypes.MultipartReadSetUploadListItem]?

    public init(
        nextToken: Swift.String? = nil,
        uploads: [OmicsClientTypes.MultipartReadSetUploadListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.uploads = uploads
    }
}

enum ListMultipartReadSetUploadsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotSupportedOperationException": return try NotSupportedOperationException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReadSetActivationJobsInput {

    static func queryItemProvider(_ value: ListReadSetActivationJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReadSetActivationJobsInput {

    static func urlPathProvider(_ value: ListReadSetActivationJobsInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjobs"
    }
}

extension ListReadSetActivationJobsInput {

    static func write(value: ListReadSetActivationJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ActivateReadSetFilter.write(value:to:))
    }
}

public struct ListReadSetActivationJobsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ActivateReadSetFilter?
    /// The maximum number of read set activation jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ActivateReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

extension ListReadSetActivationJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReadSetActivationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReadSetActivationJobsOutput()
        value.activationJobs = try reader["activationJobs"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ActivateReadSetJobItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListReadSetActivationJobsOutput {
    /// A list of jobs.
    public var activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activationJobs = activationJobs
        self.nextToken = nextToken
    }
}

enum ListReadSetActivationJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReadSetExportJobsInput {

    static func queryItemProvider(_ value: ListReadSetExportJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReadSetExportJobsInput {

    static func urlPathProvider(_ value: ListReadSetExportJobsInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjobs"
    }
}

extension ListReadSetExportJobsInput {

    static func write(value: ListReadSetExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ExportReadSetFilter.write(value:to:))
    }
}

public struct ListReadSetExportJobsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ExportReadSetFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ExportReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

extension ListReadSetExportJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReadSetExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReadSetExportJobsOutput()
        value.exportJobs = try reader["exportJobs"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ExportReadSetJobDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListReadSetExportJobsOutput {
    /// A list of jobs.
    public var exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobs = exportJobs
        self.nextToken = nextToken
    }
}

enum ListReadSetExportJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReadSetImportJobsInput {

    static func queryItemProvider(_ value: ListReadSetImportJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReadSetImportJobsInput {

    static func urlPathProvider(_ value: ListReadSetImportJobsInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjobs"
    }
}

extension ListReadSetImportJobsInput {

    static func write(value: ListReadSetImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ImportReadSetFilter.write(value:to:))
    }
}

public struct ListReadSetImportJobsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ImportReadSetFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ImportReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

extension ListReadSetImportJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReadSetImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReadSetImportJobsOutput()
        value.importJobs = try reader["importJobs"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ImportReadSetJobItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListReadSetImportJobsOutput {
    /// A list of jobs.
    public var importJobs: [OmicsClientTypes.ImportReadSetJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        importJobs: [OmicsClientTypes.ImportReadSetJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

enum ListReadSetImportJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReadSetUploadPartsInput {

    static func queryItemProvider(_ value: ListReadSetUploadPartsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReadSetUploadPartsInput {

    static func urlPathProvider(_ value: ListReadSetUploadPartsInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let uploadId = value.uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/parts"
    }
}

extension ListReadSetUploadPartsInput {

    static func write(value: ListReadSetUploadPartsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ReadSetUploadPartListFilter.write(value:to:))
        try writer["partSource"].write(value.partSource)
    }
}

public struct ListReadSetUploadPartsInput {
    /// Attributes used to filter for a specific subset of read set part uploads.
    public var filter: OmicsClientTypes.ReadSetUploadPartListFilter?
    /// The maximum number of read set upload parts returned in a page.
    public var maxResults: Swift.Int?
    /// Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The source file for the upload part.
    /// This member is required.
    public var partSource: OmicsClientTypes.ReadSetPartSource?
    /// The Sequence Store ID used for the multipart uploads.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        filter: OmicsClientTypes.ReadSetUploadPartListFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partSource: OmicsClientTypes.ReadSetPartSource? = nil,
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partSource = partSource
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

extension ListReadSetUploadPartsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReadSetUploadPartsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReadSetUploadPartsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.parts = try reader["parts"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ReadSetUploadPartListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListReadSetUploadPartsOutput {
    /// Next token returned in the response of a previous ListReadSetUploadParts call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// An array of upload parts.
    public var parts: [OmicsClientTypes.ReadSetUploadPartListItem]?

    public init(
        nextToken: Swift.String? = nil,
        parts: [OmicsClientTypes.ReadSetUploadPartListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.parts = parts
    }
}

enum ListReadSetUploadPartsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotSupportedOperationException": return try NotSupportedOperationException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReadSetsInput {

    static func queryItemProvider(_ value: ListReadSetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReadSetsInput {

    static func urlPathProvider(_ value: ListReadSetsInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readsets"
    }
}

extension ListReadSetsInput {

    static func write(value: ListReadSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ReadSetFilter.write(value:to:))
    }
}

public struct ListReadSetsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReadSetFilter?
    /// The maximum number of read sets to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

extension ListReadSetsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReadSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReadSetsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.readSets = try reader["readSets"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ReadSetListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListReadSetsOutput {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of read sets.
    /// This member is required.
    public var readSets: [OmicsClientTypes.ReadSetListItem]?

    public init(
        nextToken: Swift.String? = nil,
        readSets: [OmicsClientTypes.ReadSetListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.readSets = readSets
    }
}

enum ListReadSetsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReferenceImportJobsInput {

    static func queryItemProvider(_ value: ListReferenceImportJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReferenceImportJobsInput {

    static func urlPathProvider(_ value: ListReferenceImportJobsInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjobs"
    }
}

extension ListReferenceImportJobsInput {

    static func write(value: ListReferenceImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ImportReferenceFilter.write(value:to:))
    }
}

public struct ListReferenceImportJobsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ImportReferenceFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ImportReferenceFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.referenceStoreId = referenceStoreId
    }
}

extension ListReferenceImportJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReferenceImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReferenceImportJobsOutput()
        value.importJobs = try reader["importJobs"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ImportReferenceJobItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListReferenceImportJobsOutput {
    /// A lis of jobs.
    public var importJobs: [OmicsClientTypes.ImportReferenceJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        importJobs: [OmicsClientTypes.ImportReferenceJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

enum ListReferenceImportJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReferenceStoresInput {

    static func queryItemProvider(_ value: ListReferenceStoresInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReferenceStoresInput {

    static func urlPathProvider(_ value: ListReferenceStoresInput) -> Swift.String? {
        return "/referencestores"
    }
}

extension ListReferenceStoresInput {

    static func write(value: ListReferenceStoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ReferenceStoreFilter.write(value:to:))
    }
}

public struct ListReferenceStoresInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReferenceStoreFilter?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ReferenceStoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListReferenceStoresOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReferenceStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReferenceStoresOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.referenceStores = try reader["referenceStores"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ReferenceStoreDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListReferenceStoresOutput {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of reference stores.
    /// This member is required.
    public var referenceStores: [OmicsClientTypes.ReferenceStoreDetail]?

    public init(
        nextToken: Swift.String? = nil,
        referenceStores: [OmicsClientTypes.ReferenceStoreDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.referenceStores = referenceStores
    }
}

enum ListReferenceStoresOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListReferencesInput {

    static func queryItemProvider(_ value: ListReferencesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReferencesInput {

    static func urlPathProvider(_ value: ListReferencesInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/references"
    }
}

extension ListReferencesInput {

    static func write(value: ListReferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ReferenceFilter.write(value:to:))
    }
}

public struct ListReferencesInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReferenceFilter?
    /// The maximum number of references to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The references' reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ReferenceFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.referenceStoreId = referenceStoreId
    }
}

extension ListReferencesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListReferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReferencesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.references = try reader["references"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ReferenceListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListReferencesOutput {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of references.
    /// This member is required.
    public var references: [OmicsClientTypes.ReferenceListItem]?

    public init(
        nextToken: Swift.String? = nil,
        references: [OmicsClientTypes.ReferenceListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.references = references
    }
}

enum ListReferencesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRunGroupsInput {

    static func queryItemProvider(_ value: ListRunGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let startingToken = value.startingToken {
            let startingTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
            items.append(startingTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListRunGroupsInput {

    static func urlPathProvider(_ value: ListRunGroupsInput) -> Swift.String? {
        return "/runGroup"
    }
}

public struct ListRunGroupsInput {
    /// The maximum number of run groups to return in one page of results.
    public var maxResults: Swift.Int?
    /// The run groups' name.
    public var name: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        startingToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.startingToken = startingToken
    }
}

extension ListRunGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRunGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRunGroupsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: OmicsClientTypes.RunGroupListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListRunGroupsOutput {
    /// A list of groups.
    public var items: [OmicsClientTypes.RunGroupListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.RunGroupListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListRunGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRunTasksInput {

    static func queryItemProvider(_ value: ListRunTasksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let startingToken = value.startingToken {
            let startingTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
            items.append(startingTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListRunTasksInput {

    static func urlPathProvider(_ value: ListRunTasksInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/task"
    }
}

public struct ListRunTasksInput {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of run tasks to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// Filter the list by status.
    public var status: OmicsClientTypes.TaskStatus?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        startingToken: Swift.String? = nil,
        status: OmicsClientTypes.TaskStatus? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.startingToken = startingToken
        self.status = status
    }
}

extension ListRunTasksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRunTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRunTasksOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: OmicsClientTypes.TaskListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListRunTasksOutput {
    /// A list of tasks.
    public var items: [OmicsClientTypes.TaskListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.TaskListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListRunTasksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRunsInput {

    static func queryItemProvider(_ value: ListRunsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let startingToken = value.startingToken {
            let startingTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
            items.append(startingTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let runGroupId = value.runGroupId {
            let runGroupIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "runGroupId".urlPercentEncoding(), value: Swift.String(runGroupId).urlPercentEncoding())
            items.append(runGroupIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListRunsInput {

    static func urlPathProvider(_ value: ListRunsInput) -> Swift.String? {
        return "/run"
    }
}

public struct ListRunsInput {
    /// The maximum number of runs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Filter the list by run name.
    public var name: Swift.String?
    /// Filter the list by run group ID.
    public var runGroupId: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// The status of a run.
    public var status: OmicsClientTypes.RunStatus?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        startingToken: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.runGroupId = runGroupId
        self.startingToken = startingToken
        self.status = status
    }
}

extension ListRunsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRunsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: OmicsClientTypes.RunListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListRunsOutput {
    /// A list of runs.
    public var items: [OmicsClientTypes.RunListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.RunListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListRunsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSequenceStoresInput {

    static func queryItemProvider(_ value: ListSequenceStoresInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSequenceStoresInput {

    static func urlPathProvider(_ value: ListSequenceStoresInput) -> Swift.String? {
        return "/sequencestores"
    }
}

extension ListSequenceStoresInput {

    static func write(value: ListSequenceStoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.SequenceStoreFilter.write(value:to:))
    }
}

public struct ListSequenceStoresInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.SequenceStoreFilter?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.SequenceStoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSequenceStoresOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSequenceStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSequenceStoresOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sequenceStores = try reader["sequenceStores"].readListIfPresent(memberReadingClosure: OmicsClientTypes.SequenceStoreDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSequenceStoresOutput {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of sequence stores.
    /// This member is required.
    public var sequenceStores: [OmicsClientTypes.SequenceStoreDetail]?

    public init(
        nextToken: Swift.String? = nil,
        sequenceStores: [OmicsClientTypes.SequenceStoreDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.sequenceStores = sequenceStores
    }
}

enum ListSequenceStoresOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSharesInput {

    static func queryItemProvider(_ value: ListSharesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSharesInput {

    static func urlPathProvider(_ value: ListSharesInput) -> Swift.String? {
        return "/shares"
    }
}

extension ListSharesInput {

    static func write(value: ListSharesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.Filter.write(value:to:))
        try writer["resourceOwner"].write(value.resourceOwner)
    }
}

public struct ListSharesInput {
    /// Attributes that you use to filter for a specific subset of resource shares.
    public var filter: OmicsClientTypes.Filter?
    /// The maximum number of shares to return in one page of results.
    public var maxResults: Swift.Int?
    /// Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The account that owns the resource shares.
    /// This member is required.
    public var resourceOwner: OmicsClientTypes.ResourceOwner?

    public init(
        filter: OmicsClientTypes.Filter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceOwner: OmicsClientTypes.ResourceOwner? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
    }
}

extension ListSharesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSharesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.shares = try reader["shares"].readListIfPresent(memberReadingClosure: OmicsClientTypes.ShareDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSharesOutput {
    /// Next token returned in the response of a previous ListSharesResponse call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The shares available and their metadata details.
    /// This member is required.
    public var shares: [OmicsClientTypes.ShareDetails]?

    public init(
        nextToken: Swift.String? = nil,
        shares: [OmicsClientTypes.ShareDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.shares = shares
    }
}

enum ListSharesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// A list of tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.ListVariantImportJobsFilter {

    static func write(value: OmicsClientTypes.ListVariantImportJobsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
        try writer["storeName"].write(value.storeName)
    }
}

extension OmicsClientTypes {
    /// A filter for variant import jobs.
    public struct ListVariantImportJobsFilter {
        /// A status to filter on.
        public var status: OmicsClientTypes.JobStatus?
        /// A store name to filter on.
        public var storeName: Swift.String?

        public init(
            status: OmicsClientTypes.JobStatus? = nil,
            storeName: Swift.String? = nil
        )
        {
            self.status = status
            self.storeName = storeName
        }
    }

}

extension ListVariantImportJobsInput {

    static func queryItemProvider(_ value: ListVariantImportJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListVariantImportJobsInput {

    static func urlPathProvider(_ value: ListVariantImportJobsInput) -> Swift.String? {
        return "/import/variants"
    }
}

extension ListVariantImportJobsInput {

    static func write(value: ListVariantImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ListVariantImportJobsFilter.write(value:to:))
        try writer["ids"].writeList(value.ids, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct ListVariantImportJobsInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListVariantImportJobsFilter?
    /// A list of job IDs.
    public var ids: [Swift.String]?
    /// The maximum number of import jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListVariantImportJobsFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListVariantImportJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListVariantImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVariantImportJobsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.variantImportJobs = try reader["variantImportJobs"].readListIfPresent(memberReadingClosure: OmicsClientTypes.VariantImportJobItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListVariantImportJobsOutput {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of jobs.
    public var variantImportJobs: [OmicsClientTypes.VariantImportJobItem]?

    public init(
        nextToken: Swift.String? = nil,
        variantImportJobs: [OmicsClientTypes.VariantImportJobItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.variantImportJobs = variantImportJobs
    }
}

enum ListVariantImportJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.ListVariantStoresFilter {

    static func write(value: OmicsClientTypes.ListVariantStoresFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension OmicsClientTypes {
    /// A filter for variant stores.
    public struct ListVariantStoresFilter {
        /// A status to filter on.
        public var status: OmicsClientTypes.StoreStatus?

        public init(
            status: OmicsClientTypes.StoreStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListVariantStoresInput {

    static func queryItemProvider(_ value: ListVariantStoresInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListVariantStoresInput {

    static func urlPathProvider(_ value: ListVariantStoresInput) -> Swift.String? {
        return "/variantStores"
    }
}

extension ListVariantStoresInput {

    static func write(value: ListVariantStoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: OmicsClientTypes.ListVariantStoresFilter.write(value:to:))
        try writer["ids"].writeList(value.ids, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct ListVariantStoresInput {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListVariantStoresFilter?
    /// A list of store IDs.
    public var ids: [Swift.String]?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListVariantStoresFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListVariantStoresOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListVariantStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVariantStoresOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.variantStores = try reader["variantStores"].readListIfPresent(memberReadingClosure: OmicsClientTypes.VariantStoreItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListVariantStoresOutput {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of variant stores.
    public var variantStores: [OmicsClientTypes.VariantStoreItem]?

    public init(
        nextToken: Swift.String? = nil,
        variantStores: [OmicsClientTypes.VariantStoreItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.variantStores = variantStores
    }
}

enum ListVariantStoresOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListWorkflowsInput {

    static func queryItemProvider(_ value: ListWorkflowsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let startingToken = value.startingToken {
            let startingTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
            items.append(startingTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/workflow"
    }
}

public struct ListWorkflowsInput {
    /// The maximum number of workflows to return in one page of results.
    public var maxResults: Swift.Int?
    /// Filter the list by workflow name.
    public var name: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// Filter the list by workflow type.
    public var type: OmicsClientTypes.WorkflowType?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        startingToken: Swift.String? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.startingToken = startingToken
        self.type = type
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: OmicsClientTypes.WorkflowListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListWorkflowsOutput {
    /// A list of workflow items.
    public var items: [OmicsClientTypes.WorkflowListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.WorkflowListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.MultipartReadSetUploadListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.MultipartReadSetUploadListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.MultipartReadSetUploadListItem()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.uploadId = try reader["uploadId"].readIfPresent()
        value.sourceFileType = try reader["sourceFileType"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.sampleId = try reader["sampleId"].readIfPresent()
        value.generatedFrom = try reader["generatedFrom"].readIfPresent()
        value.referenceArn = try reader["referenceArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// Part of the response to ListMultipartReadSetUploads, excluding completed and aborted multipart uploads.
    public struct MultipartReadSetUploadListItem {
        /// The time stamp for when a direct upload was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of a read set.
        public var description: Swift.String?
        /// The source of an uploaded part.
        /// This member is required.
        public var generatedFrom: Swift.String?
        /// The name of a read set.
        public var name: Swift.String?
        /// The source's reference ARN.
        /// This member is required.
        public var referenceArn: Swift.String?
        /// The read set source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The sequence store ID used for the multipart upload.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The type of file the read set originated from.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The read set source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// Any tags you wish to add to a read set.
        public var tags: [Swift.String:Swift.String]?
        /// The ID for the initiated multipart upload.
        /// This member is required.
        public var uploadId: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            uploadId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
            self.uploadId = uploadId
        }
    }

}

extension NotSupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotSupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = NotSupportedOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The operation is not supported by Amazon Omics, or the API does not exist.
public struct NotSupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotSupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum OmicsClientTypes {}

extension RangeNotSatisfiableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RangeNotSatisfiableException {
        let reader = baseError.errorBodyReader
        var value = RangeNotSatisfiableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The ranges specified in the request are not valid.
public struct RangeNotSatisfiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RangeNotSatisfiableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes.ReadOptions {

    static func write(value: OmicsClientTypes.ReadOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["encoding"].write(value.encoding)
        try writer["escape"].write(value.escape)
        try writer["escapeQuotes"].write(value.escapeQuotes)
        try writer["header"].write(value.header)
        try writer["lineSep"].write(value.lineSep)
        try writer["quote"].write(value.quote)
        try writer["quoteAll"].write(value.quoteAll)
        try writer["sep"].write(value.sep)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReadOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReadOptions()
        value.sep = try reader["sep"].readIfPresent()
        value.encoding = try reader["encoding"].readIfPresent()
        value.quote = try reader["quote"].readIfPresent()
        value.quoteAll = try reader["quoteAll"].readIfPresent() ?? false
        value.escape = try reader["escape"].readIfPresent()
        value.escapeQuotes = try reader["escapeQuotes"].readIfPresent() ?? false
        value.comment = try reader["comment"].readIfPresent()
        value.header = try reader["header"].readIfPresent() ?? false
        value.lineSep = try reader["lineSep"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Read options for an annotation import job.
    public struct ReadOptions {
        /// The file's comment character.
        public var comment: Swift.String?
        /// The file's encoding.
        public var encoding: Swift.String?
        /// A character for escaping quotes in the file.
        public var escape: Swift.String?
        /// Whether quotes need to be escaped in the file.
        public var escapeQuotes: Swift.Bool
        /// Whether the file has a header row.
        public var header: Swift.Bool
        /// A line separator for the file.
        public var lineSep: Swift.String?
        /// The file's quote character.
        public var quote: Swift.String?
        /// Whether all values need to be quoted, or just those that contain quotes.
        public var quoteAll: Swift.Bool
        /// The file's field separator.
        public var sep: Swift.String?

        public init(
            comment: Swift.String? = nil,
            encoding: Swift.String? = nil,
            escape: Swift.String? = nil,
            escapeQuotes: Swift.Bool = false,
            header: Swift.Bool = false,
            lineSep: Swift.String? = nil,
            quote: Swift.String? = nil,
            quoteAll: Swift.Bool = false,
            sep: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encoding = encoding
            self.escape = escape
            self.escapeQuotes = escapeQuotes
            self.header = header
            self.lineSep = lineSep
            self.quote = quote
            self.quoteAll = quoteAll
            self.sep = sep
        }
    }

}

extension OmicsClientTypes {

    public enum ReadSetActivationJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetActivationJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ReadSetActivationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetActivationJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReadSetBatchError {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReadSetBatchError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReadSetBatchError()
        value.id = try reader["id"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// An error from a batch read set operation.
    public struct ReadSetBatchError {
        /// The error's code.
        /// This member is required.
        public var code: Swift.String?
        /// The error's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The error's message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.id = id
            self.message = message
        }
    }

}

extension OmicsClientTypes {

    public enum ReadSetExportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetExportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ReadSetExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetExportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ReadSetFile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case index
        case source1
        case source2
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetFile] {
            return [
                .index,
                .source1,
                .source2,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .source1: return "SOURCE1"
            case .source2: return "SOURCE2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReadSetFiles {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReadSetFiles {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReadSetFiles()
        value.source1 = try reader["source1"].readIfPresent(with: OmicsClientTypes.FileInformation.read(from:))
        value.source2 = try reader["source2"].readIfPresent(with: OmicsClientTypes.FileInformation.read(from:))
        value.index = try reader["index"].readIfPresent(with: OmicsClientTypes.FileInformation.read(from:))
        return value
    }
}

extension OmicsClientTypes {
    /// Files in a read set.
    public struct ReadSetFiles {
        /// The files' index.
        public var index: OmicsClientTypes.FileInformation?
        /// The location of the first file in Amazon S3.
        public var source1: OmicsClientTypes.FileInformation?
        /// The location of the second file in Amazon S3.
        public var source2: OmicsClientTypes.FileInformation?

        public init(
            index: OmicsClientTypes.FileInformation? = nil,
            source1: OmicsClientTypes.FileInformation? = nil,
            source2: OmicsClientTypes.FileInformation? = nil
        )
        {
            self.index = index
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes.ReadSetFilter {

    static func write(value: OmicsClientTypes.ReadSetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["creationType"].write(value.creationType)
        try writer["generatedFrom"].write(value.generatedFrom)
        try writer["name"].write(value.name)
        try writer["referenceArn"].write(value.referenceArn)
        try writer["sampleId"].write(value.sampleId)
        try writer["status"].write(value.status)
        try writer["subjectId"].write(value.subjectId)
    }
}

extension OmicsClientTypes {
    /// A filter for read sets.
    public struct ReadSetFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The creation type of the read set.
        public var creationType: OmicsClientTypes.CreationType?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// A name to filter on.
        public var name: Swift.String?
        /// A genome reference ARN to filter on.
        public var referenceArn: Swift.String?
        /// The read set source's sample ID.
        public var sampleId: Swift.String?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetStatus?
        /// The read set source's subject ID.
        public var subjectId: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            creationType: OmicsClientTypes.CreationType? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetStatus? = nil,
            subjectId: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.creationType = creationType
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.status = status
            self.subjectId = subjectId
        }
    }

}

extension OmicsClientTypes {

    public enum ReadSetImportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetImportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ReadSetImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetImportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReadSetListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReadSetListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReadSetListItem()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.subjectId = try reader["subjectId"].readIfPresent()
        value.sampleId = try reader["sampleId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.referenceArn = try reader["referenceArn"].readIfPresent()
        value.fileType = try reader["fileType"].readIfPresent()
        value.sequenceInformation = try reader["sequenceInformation"].readIfPresent(with: OmicsClientTypes.SequenceInformation.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.creationType = try reader["creationType"].readIfPresent()
        value.etag = try reader["etag"].readIfPresent(with: OmicsClientTypes.ETag.read(from:))
        return value
    }
}

extension OmicsClientTypes {
    /// A read set.
    public struct ReadSetListItem {
        /// The read set's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the read set was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The creation type of the read set.
        public var creationType: OmicsClientTypes.CreationType?
        /// The read set's description.
        public var description: Swift.String?
        /// The entity tag (ETag) is a hash of the object representing its semantic content.
        public var etag: OmicsClientTypes.ETag?
        /// The read set's file type.
        /// This member is required.
        public var fileType: OmicsClientTypes.FileType?
        /// The read set's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The read set's name.
        public var name: Swift.String?
        /// The read set's genome reference ARN.
        public var referenceArn: Swift.String?
        /// The read set's sample ID.
        public var sampleId: Swift.String?
        /// Details about a sequence.
        public var sequenceInformation: OmicsClientTypes.SequenceInformation?
        /// The read set's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The read set's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetStatus?
        /// The status for a read set. It provides more detail as to why the read set has a status.
        public var statusMessage: Swift.String?
        /// The read set's subject ID.
        public var subjectId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            creationType: OmicsClientTypes.CreationType? = nil,
            description: Swift.String? = nil,
            etag: OmicsClientTypes.ETag? = nil,
            fileType: OmicsClientTypes.FileType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sequenceInformation: OmicsClientTypes.SequenceInformation? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetStatus? = nil,
            statusMessage: Swift.String? = nil,
            subjectId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.etag = etag
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
        }
    }

}

extension OmicsClientTypes {

    public enum ReadSetPartSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case source1
        case source2
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetPartSource] {
            return [
                .source1,
                .source2,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .source1: return "SOURCE1"
            case .source2: return "SOURCE2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReadSetS3Access {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReadSetS3Access {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReadSetS3Access()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// The S3 URI for each read set file.
    public struct ReadSetS3Access {
        /// The S3 URI for each read set file.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension OmicsClientTypes {

    public enum ReadSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case archived
        case deleted
        case deleting
        case processingUpload
        case uploadFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetStatus] {
            return [
                .activating,
                .active,
                .archived,
                .deleted,
                .deleting,
                .processingUpload,
                .uploadFailed,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .processingUpload: return "PROCESSING_UPLOAD"
            case .uploadFailed: return "UPLOAD_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReadSetUploadPartListFilter {

    static func write(value: OmicsClientTypes.ReadSetUploadPartListFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
    }
}

extension OmicsClientTypes {
    /// Filter settings that select for read set upload parts of interest.
    public struct ReadSetUploadPartListFilter {
        /// Filters for read set uploads after a specified time.
        public var createdAfter: ClientRuntime.Date?
        /// Filters for read set part uploads before a specified time.
        public var createdBefore: ClientRuntime.Date?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
        }
    }

}

extension OmicsClientTypes.ReadSetUploadPartListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReadSetUploadPartListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReadSetUploadPartListItem()
        value.partNumber = try reader["partNumber"].readIfPresent()
        value.partSize = try reader["partSize"].readIfPresent()
        value.partSource = try reader["partSource"].readIfPresent()
        value.checksum = try reader["checksum"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// The metadata of a single part of a file that was added to a multipart upload. A list of these parts is returned in the response to the ListReadSetUploadParts API.
    public struct ReadSetUploadPartListItem {
        /// A unique identifier used to confirm that parts are being added to the correct upload.
        /// This member is required.
        public var checksum: Swift.String?
        /// The time stamp for when a direct upload was created.
        public var creationTime: ClientRuntime.Date?
        /// The time stamp for the most recent update to an uploaded part.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number identifying the part in an upload.
        /// This member is required.
        public var partNumber: Swift.Int?
        /// The size of the the part in an upload.
        /// This member is required.
        public var partSize: Swift.Int?
        /// The origin of the part being direct uploaded.
        /// This member is required.
        public var partSource: OmicsClientTypes.ReadSetPartSource?

        public init(
            checksum: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            partNumber: Swift.Int? = nil,
            partSize: Swift.Int? = nil,
            partSource: OmicsClientTypes.ReadSetPartSource? = nil
        )
        {
            self.checksum = checksum
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.partNumber = partNumber
            self.partSize = partSize
            self.partSource = partSource
        }
    }

}

extension OmicsClientTypes {

    public enum ReferenceFile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case index
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceFile] {
            return [
                .index,
                .source,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReferenceFiles {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReferenceFiles {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReferenceFiles()
        value.source = try reader["source"].readIfPresent(with: OmicsClientTypes.FileInformation.read(from:))
        value.index = try reader["index"].readIfPresent(with: OmicsClientTypes.FileInformation.read(from:))
        return value
    }
}

extension OmicsClientTypes {
    /// A set of genome reference files.
    public struct ReferenceFiles {
        /// The files' index.
        public var index: OmicsClientTypes.FileInformation?
        /// The source file's location in Amazon S3.
        public var source: OmicsClientTypes.FileInformation?

        public init(
            index: OmicsClientTypes.FileInformation? = nil,
            source: OmicsClientTypes.FileInformation? = nil
        )
        {
            self.index = index
            self.source = source
        }
    }

}

extension OmicsClientTypes.ReferenceFilter {

    static func write(value: OmicsClientTypes.ReferenceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["md5"].write(value.md5)
        try writer["name"].write(value.name)
    }
}

extension OmicsClientTypes {
    /// A filter for references.
    public struct ReferenceFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// An MD5 checksum to filter on.
        public var md5: Swift.String?
        /// A name to filter on.
        public var name: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            md5: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.md5 = md5
            self.name = name
        }
    }

}

extension OmicsClientTypes {

    public enum ReferenceImportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceImportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ReferenceImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceImportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReferenceItem {

    static func write(value: OmicsClientTypes.ReferenceItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .referencearn(referencearn):
                try writer["referenceArn"].write(referencearn)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReferenceItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "referenceArn":
                return .referencearn(try reader["referenceArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension OmicsClientTypes {
    /// A genome reference.
    public enum ReferenceItem {
        /// The reference's ARN.
        case referencearn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes.ReferenceListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReferenceListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReferenceListItem()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.referenceStoreId = try reader["referenceStoreId"].readIfPresent()
        value.md5 = try reader["md5"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// A genome reference.
    public struct ReferenceListItem {
        /// The reference's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the reference was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The reference's description.
        public var description: Swift.String?
        /// The reference's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The reference's MD5 checksum.
        /// This member is required.
        public var md5: Swift.String?
        /// The reference's name.
        public var name: Swift.String?
        /// The reference's store ID.
        /// This member is required.
        public var referenceStoreId: Swift.String?
        /// The reference's status.
        public var status: OmicsClientTypes.ReferenceStatus?
        /// When the reference was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            md5: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes {

    public enum ReferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.ReferenceStoreDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ReferenceStoreDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ReferenceStoreDetail()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// Details about a reference store.
    public struct ReferenceStoreDetail {
        /// The store's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        public var name: Swift.String?
        /// The store's server-side encryption (SSE) settings.
        public var sseConfig: OmicsClientTypes.SseConfig?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }
    }

}

extension OmicsClientTypes.ReferenceStoreFilter {

    static func write(value: OmicsClientTypes.ReferenceStoreFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["name"].write(value.name)
    }
}

extension OmicsClientTypes {
    /// A filter for reference stores.
    public struct ReferenceStoreFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The name to filter on.
        public var name: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }
    }

}

extension RequestTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestTimeoutException {
        let reader = baseError.errorBodyReader
        var value = RequestTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request timed out.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The target resource was not found in the current Region.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes {

    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The resource owner is an account other than the caller
        case other
        /// The resource owner is the calling account
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .other,
                .self,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .other: return "OTHER"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum RunExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [RunExport] {
            return [
                .definition,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .definition: return "DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.RunGroupListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.RunGroupListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.RunGroupListItem()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.maxCpus = try reader["maxCpus"].readIfPresent()
        value.maxRuns = try reader["maxRuns"].readIfPresent()
        value.maxDuration = try reader["maxDuration"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.maxGpus = try reader["maxGpus"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// A run group.
    public struct RunGroupListItem {
        /// The group's ARN.
        public var arn: Swift.String?
        /// When the group was created.
        public var creationTime: ClientRuntime.Date?
        /// The group's ID.
        public var id: Swift.String?
        /// The group's maximum CPU count setting.
        public var maxCpus: Swift.Int?
        /// The group's maximum duration setting in minutes.
        public var maxDuration: Swift.Int?
        /// The maximum GPUs that can be used by a run group.
        public var maxGpus: Swift.Int?
        /// The group's maximum concurrent run setting.
        public var maxRuns: Swift.Int?
        /// The group's name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            maxCpus: Swift.Int? = nil,
            maxDuration: Swift.Int? = nil,
            maxGpus: Swift.Int? = nil,
            maxRuns: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
        }
    }

}

extension OmicsClientTypes.RunListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.RunListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.RunListItem()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.workflowId = try reader["workflowId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.storageCapacity = try reader["storageCapacity"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.stopTime = try reader["stopTime"].readTimestampIfPresent(format: .dateTime)
        value.storageType = try reader["storageType"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// A workflow run.
    public struct RunListItem {
        /// The run's ARN.
        public var arn: Swift.String?
        /// When the run was created.
        public var creationTime: ClientRuntime.Date?
        /// The run's ID.
        public var id: Swift.String?
        /// The run's name.
        public var name: Swift.String?
        /// The run's priority.
        public var priority: Swift.Int?
        /// When the run started.
        public var startTime: ClientRuntime.Date?
        /// The run's status.
        public var status: OmicsClientTypes.RunStatus?
        /// When the run stopped.
        public var stopTime: ClientRuntime.Date?
        /// The run's storage capacity in gibibytes. For dynamic storage, after the run has completed, this value is the maximum amount of storage used during the run.
        public var storageCapacity: Swift.Int?
        /// The run's storage type.
        public var storageType: OmicsClientTypes.StorageType?
        /// The run's workflow ID.
        public var workflowId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.RunStatus? = nil,
            stopTime: ClientRuntime.Date? = nil,
            storageCapacity: Swift.Int? = nil,
            storageType: OmicsClientTypes.StorageType? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.priority = priority
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.storageType = storageType
            self.workflowId = workflowId
        }
    }

}

extension OmicsClientTypes {

    public enum RunLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case error
        case fatal
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [RunLogLevel] {
            return [
                .all,
                .error,
                .fatal,
                .off,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.RunLogLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.RunLogLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.RunLogLocation()
        value.engineLogStream = try reader["engineLogStream"].readIfPresent()
        value.runLogStream = try reader["runLogStream"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// The URI for the run log.
    public struct RunLogLocation {
        /// The log stream ARN for the engine log.
        public var engineLogStream: Swift.String?
        /// The log stream ARN for the run log.
        public var runLogStream: Swift.String?

        public init(
            engineLogStream: Swift.String? = nil,
            runLogStream: Swift.String? = nil
        )
        {
            self.engineLogStream = engineLogStream
            self.runLogStream = runLogStream
        }
    }

}

extension OmicsClientTypes {

    public enum RunRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case remove
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [RunRetentionMode] {
            return [
                .remove,
                .retain,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .remove: return "REMOVE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum RunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case deleted
        case failed
        case pending
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [RunStatus] {
            return [
                .cancelled,
                .completed,
                .deleted,
                .failed,
                .pending,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum SchemaValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// BOOLEAN type
        case boolean
        /// DOUBLE type
        case double
        /// FLOAT type
        case float
        /// INT type
        case int
        /// LONG type
        case long
        /// STRING type
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaValueType] {
            return [
                .boolean,
                .double,
                .float,
                .int,
                .long,
                .string,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .int: return "INT"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.SequenceInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.SequenceInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.SequenceInformation()
        value.totalReadCount = try reader["totalReadCount"].readIfPresent()
        value.totalBaseCount = try reader["totalBaseCount"].readIfPresent()
        value.generatedFrom = try reader["generatedFrom"].readIfPresent()
        value.alignment = try reader["alignment"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Details about a sequence.
    public struct SequenceInformation {
        /// The sequence's alignment setting.
        public var alignment: Swift.String?
        /// Where the sequence originated.
        public var generatedFrom: Swift.String?
        /// The sequence's total base count.
        public var totalBaseCount: Swift.Int?
        /// The sequence's total read count.
        public var totalReadCount: Swift.Int?

        public init(
            alignment: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            totalBaseCount: Swift.Int? = nil,
            totalReadCount: Swift.Int? = nil
        )
        {
            self.alignment = alignment
            self.generatedFrom = generatedFrom
            self.totalBaseCount = totalBaseCount
            self.totalReadCount = totalReadCount
        }
    }

}

extension OmicsClientTypes.SequenceStoreDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.SequenceStoreDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.SequenceStoreDetail()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.fallbackLocation = try reader["fallbackLocation"].readIfPresent()
        value.eTagAlgorithmFamily = try reader["eTagAlgorithmFamily"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Details about a sequence store.
    public struct SequenceStoreDetail {
        /// The store's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        public var description: Swift.String?
        /// The algorithm family of the ETag.
        public var eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily?
        /// An S3 location that is used to store files that have failed a direct upload.
        public var fallbackLocation: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        public var name: Swift.String?
        /// The store's server-side encryption (SSE) settings.
        public var sseConfig: OmicsClientTypes.SseConfig?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            eTagAlgorithmFamily: OmicsClientTypes.ETagAlgorithmFamily? = nil,
            fallbackLocation: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.eTagAlgorithmFamily = eTagAlgorithmFamily
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }
    }

}

extension OmicsClientTypes.SequenceStoreFilter {

    static func write(value: OmicsClientTypes.SequenceStoreFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["createdBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["name"].write(value.name)
    }
}

extension OmicsClientTypes {
    /// A filter for a sequence store.
    public struct SequenceStoreFilter {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A name to filter on.
        public var name: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }
    }

}

extension OmicsClientTypes.SequenceStoreS3Access {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.SequenceStoreS3Access {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.SequenceStoreS3Access()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        value.s3AccessPointArn = try reader["s3AccessPointArn"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// The S3 access metadata of the sequence store.
    public struct SequenceStoreS3Access {
        /// This is ARN of the access point associated with the S3 bucket storing read sets.
        public var s3AccessPointArn: Swift.String?
        /// The S3 URI of the sequence store.
        public var s3Uri: Swift.String?

        public init(
            s3AccessPointArn: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.s3AccessPointArn = s3AccessPointArn
            self.s3Uri = s3Uri
        }
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes.ShareDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.ShareDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.ShareDetails()
        value.shareId = try reader["shareId"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.principalSubscriber = try reader["principalSubscriber"].readIfPresent()
        value.ownerId = try reader["ownerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.shareName = try reader["shareName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension OmicsClientTypes {
    /// The details of a resource share.
    public struct ShareDetails {
        /// The timestamp of when the resource share was created.
        public var creationTime: ClientRuntime.Date?
        /// The account ID for the data owner. The owner creates the resource share.
        public var ownerId: Swift.String?
        /// The principal subscriber is the account that is sharing the resource.
        public var principalSubscriber: Swift.String?
        /// The Arn of the shared resource.
        public var resourceArn: Swift.String?
        /// The ID of the shared resource.
        public var resourceId: Swift.String?
        /// The ID of the resource share.
        public var shareId: Swift.String?
        /// The name of the resource share.
        public var shareName: Swift.String?
        /// The status of the share.
        public var status: OmicsClientTypes.ShareStatus?
        /// The status message for a resource share. It provides additional details about the share status.
        public var statusMessage: Swift.String?
        /// The timestamp of the resource share update.
        public var updateTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            ownerId: Swift.String? = nil,
            principalSubscriber: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            shareId: Swift.String? = nil,
            shareName: Swift.String? = nil,
            status: OmicsClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.ownerId = ownerId
            self.principalSubscriber = principalSubscriber
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.shareId = shareId
            self.shareName = shareName
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes {

    public enum ShareResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The share is on an annotation store
        case annotationStore
        /// The share is on a variant store
        case variantStore
        /// The share is on a workflow
        case workflow
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareResourceType] {
            return [
                .annotationStore,
                .variantStore,
                .workflow,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .annotationStore: return "ANNOTATION_STORE"
            case .variantStore: return "VARIANT_STORE"
            case .workflow: return "WORKFLOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The share is activated
        case activating
        /// The share is active and can be used
        case active
        /// The share has been deleted
        case deleted
        /// The share is being deleted
        case deleting
        /// The share has failed to activate or delete
        case failed
        /// The share has been created but is not yet active
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .activating,
                .active,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.SourceFiles {

    static func write(value: OmicsClientTypes.SourceFiles?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source1"].write(value.source1)
        try writer["source2"].write(value.source2)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.SourceFiles {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.SourceFiles()
        value.source1 = try reader["source1"].readIfPresent()
        value.source2 = try reader["source2"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Source files for a sequence.
    public struct SourceFiles {
        /// The location of the first file in Amazon S3.
        /// This member is required.
        public var source1: Swift.String?
        /// The location of the second file in Amazon S3.
        public var source2: Swift.String?

        public init(
            source1: Swift.String? = nil,
            source2: Swift.String? = nil
        )
        {
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes.SseConfig {

    static func write(value: OmicsClientTypes.SseConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyArn"].write(value.keyArn)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.SseConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.SseConfig()
        value.type = try reader["type"].readIfPresent()
        value.keyArn = try reader["keyArn"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Server-side encryption (SSE) settings for a store.
    public struct SseConfig {
        /// An encryption key ARN.
        public var keyArn: Swift.String?
        /// The encryption type.
        /// This member is required.
        public var type: OmicsClientTypes.EncryptionType?

        public init(
            keyArn: Swift.String? = nil,
            type: OmicsClientTypes.EncryptionType? = nil
        )
        {
            self.keyArn = keyArn
            self.type = type
        }
    }

}

extension StartAnnotationImportJobInput {

    static func urlPathProvider(_ value: StartAnnotationImportJobInput) -> Swift.String? {
        return "/import/annotation"
    }
}

extension StartAnnotationImportJobInput {

    static func write(value: StartAnnotationImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["annotationFields"].writeMap(value.annotationFields, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["destinationName"].write(value.destinationName)
        try writer["formatOptions"].write(value.formatOptions, with: OmicsClientTypes.FormatOptions.write(value:to:))
        try writer["items"].writeList(value.items, memberWritingClosure: OmicsClientTypes.AnnotationImportItemSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["runLeftNormalization"].write(value.runLeftNormalization)
        try writer["versionName"].write(value.versionName)
    }
}

public struct StartAnnotationImportJobInput {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// A destination annotation store for the job.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Formatting options for the annotation file.
    public var formatOptions: OmicsClientTypes.FormatOptions?
    /// Items to import.
    /// This member is required.
    public var items: [OmicsClientTypes.AnnotationImportItemSource]?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    public var runLeftNormalization: Swift.Bool?
    /// The name of the annotation store version.
    public var versionName: Swift.String?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        destinationName: Swift.String? = nil,
        formatOptions: OmicsClientTypes.FormatOptions? = nil,
        items: [OmicsClientTypes.AnnotationImportItemSource]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.annotationFields = annotationFields
        self.destinationName = destinationName
        self.formatOptions = formatOptions
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.versionName = versionName
    }
}

extension StartAnnotationImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartAnnotationImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAnnotationImportJobOutput()
        value.jobId = try reader["jobId"].readIfPresent()
        return value
    }
}

public struct StartAnnotationImportJobOutput {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

enum StartAnnotationImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartReadSetActivationJobInput {

    static func urlPathProvider(_ value: StartReadSetActivationJobInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjob"
    }
}

extension StartReadSetActivationJobInput {

    static func write(value: StartReadSetActivationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["sources"].writeList(value.sources, memberWritingClosure: OmicsClientTypes.StartReadSetActivationJobSourceItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct StartReadSetActivationJobInput {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]?

    public init(
        clientToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

extension StartReadSetActivationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartReadSetActivationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReadSetActivationJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct StartReadSetActivationJobOutput {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetActivationJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

enum StartReadSetActivationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.StartReadSetActivationJobSourceItem {

    static func write(value: OmicsClientTypes.StartReadSetActivationJobSourceItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["readSetId"].write(value.readSetId)
    }
}

extension OmicsClientTypes {
    /// A source for a read set activation job.
    public struct StartReadSetActivationJobSourceItem {
        /// The source's read set ID.
        /// This member is required.
        public var readSetId: Swift.String?

        public init(
            readSetId: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
        }
    }

}

extension StartReadSetExportJobInput {

    static func urlPathProvider(_ value: StartReadSetExportJobInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjob"
    }
}

extension StartReadSetExportJobInput {

    static func write(value: StartReadSetExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["destination"].write(value.destination)
        try writer["roleArn"].write(value.roleArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: OmicsClientTypes.ExportReadSet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct StartReadSetExportJobInput {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// A location for exported files in Amazon S3.
    /// This member is required.
    public var destination: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.ExportReadSet]?

    public init(
        clientToken: Swift.String? = nil,
        destination: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ExportReadSet]? = nil
    )
    {
        self.clientToken = clientToken
        self.destination = destination
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

extension StartReadSetExportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartReadSetExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReadSetExportJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.destination = try reader["destination"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct StartReadSetExportJobOutput {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's output location.
    /// This member is required.
    public var destination: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetExportJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetExportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

enum StartReadSetExportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartReadSetImportJobInput {

    static func urlPathProvider(_ value: StartReadSetImportJobInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjob"
    }
}

extension StartReadSetImportJobInput {

    static func write(value: StartReadSetImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["roleArn"].write(value.roleArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: OmicsClientTypes.StartReadSetImportJobSourceItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct StartReadSetImportJobInput {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]?

    public init(
        clientToken: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

extension StartReadSetImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartReadSetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReadSetImportJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.sequenceStoreId = try reader["sequenceStoreId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct StartReadSetImportJobOutput {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetImportJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetImportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

enum StartReadSetImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.StartReadSetImportJobSourceItem {

    static func write(value: OmicsClientTypes.StartReadSetImportJobSourceItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["generatedFrom"].write(value.generatedFrom)
        try writer["name"].write(value.name)
        try writer["referenceArn"].write(value.referenceArn)
        try writer["sampleId"].write(value.sampleId)
        try writer["sourceFileType"].write(value.sourceFileType)
        try writer["sourceFiles"].write(value.sourceFiles, with: OmicsClientTypes.SourceFiles.write(value:to:))
        try writer["subjectId"].write(value.subjectId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension OmicsClientTypes {
    /// A source for a read set import job.
    public struct StartReadSetImportJobSourceItem {
        /// The source's description.
        public var description: Swift.String?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source's reference ARN.
        public var referenceArn: Swift.String?
        /// The source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The source's file type.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The source files' location in Amazon S3.
        /// This member is required.
        public var sourceFiles: OmicsClientTypes.SourceFiles?
        /// The source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            sourceFiles: OmicsClientTypes.SourceFiles? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFileType = sourceFileType
            self.sourceFiles = sourceFiles
            self.subjectId = subjectId
            self.tags = tags
        }
    }

}

extension StartReferenceImportJobInput {

    static func urlPathProvider(_ value: StartReferenceImportJobInput) -> Swift.String? {
        guard let referenceStoreId = value.referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjob"
    }
}

extension StartReferenceImportJobInput {

    static func write(value: StartReferenceImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["roleArn"].write(value.roleArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: OmicsClientTypes.StartReferenceImportJobSourceItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct StartReferenceImportJobInput {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]?

    public init(
        clientToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.sources = sources
    }
}

extension StartReferenceImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartReferenceImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReferenceImportJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.referenceStoreId = try reader["referenceStoreId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct StartReferenceImportJobOutput {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReferenceImportJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: OmicsClientTypes.ReferenceImportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.status = status
    }
}

enum StartReferenceImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.StartReferenceImportJobSourceItem {

    static func write(value: OmicsClientTypes.StartReferenceImportJobSourceItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["sourceFile"].write(value.sourceFile)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension OmicsClientTypes {
    /// A source for a reference import job.
    public struct StartReferenceImportJobSourceItem {
        /// The source's description.
        public var description: Swift.String?
        /// The source's name.
        /// This member is required.
        public var name: Swift.String?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var sourceFile: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceFile: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.tags = tags
        }
    }

}

extension StartRunInput {

    static func urlPathProvider(_ value: StartRunInput) -> Swift.String? {
        return "/run"
    }
}

extension StartRunInput {

    static func write(value: StartRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logLevel"].write(value.logLevel)
        try writer["name"].write(value.name)
        try writer["outputUri"].write(value.outputUri)
        try writer["parameters"].write(value.parameters)
        try writer["priority"].write(value.priority)
        try writer["requestId"].write(value.requestId)
        try writer["retentionMode"].write(value.retentionMode)
        try writer["roleArn"].write(value.roleArn)
        try writer["runGroupId"].write(value.runGroupId)
        try writer["runId"].write(value.runId)
        try writer["storageCapacity"].write(value.storageCapacity)
        try writer["storageType"].write(value.storageType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workflowId"].write(value.workflowId)
        try writer["workflowOwnerId"].write(value.workflowOwnerId)
        try writer["workflowType"].write(value.workflowType)
    }
}

public struct StartRunInput {
    /// A log level for the run.
    public var logLevel: OmicsClientTypes.RunLogLevel?
    /// A name for the run.
    public var name: Swift.String?
    /// An output URI for the run.
    public var outputUri: Swift.String?
    /// Parameters for the run.
    public var parameters: SmithyReadWrite.Document?
    /// A priority for the run.
    public var priority: Swift.Int?
    /// To ensure that requests don't run multiple times, specify a unique ID for each request.
    /// This member is required.
    public var requestId: Swift.String?
    /// The retention mode for the run.
    public var retentionMode: OmicsClientTypes.RunRetentionMode?
    /// A service role for the run.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The run's group ID.
    public var runGroupId: Swift.String?
    /// The ID of a run to duplicate.
    public var runId: Swift.String?
    /// A storage capacity for the run in gibibytes. This field is not required if the storage type is dynamic (the system ignores any value that you enter).
    public var storageCapacity: Swift.Int?
    /// The run's storage type. By default, the run uses STATIC storage type, which allocates a fixed amount of storage. If you set the storage type to DYNAMIC, HealthOmics dynamically scales the storage up or down, based on file system utilization.
    public var storageType: OmicsClientTypes.StorageType?
    /// Tags for the run.
    public var tags: [Swift.String:Swift.String]?
    /// The run's workflow ID.
    public var workflowId: Swift.String?
    /// The ID of the workflow owner.
    public var workflowOwnerId: Swift.String?
    /// The run's workflow type.
    public var workflowType: OmicsClientTypes.WorkflowType?

    public init(
        logLevel: OmicsClientTypes.RunLogLevel? = nil,
        name: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        parameters: SmithyReadWrite.Document? = nil,
        priority: Swift.Int? = nil,
        requestId: Swift.String? = nil,
        retentionMode: OmicsClientTypes.RunRetentionMode? = nil,
        roleArn: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        runId: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        storageType: OmicsClientTypes.StorageType? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowOwnerId: Swift.String? = nil,
        workflowType: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.logLevel = logLevel
        self.name = name
        self.outputUri = outputUri
        self.parameters = parameters
        self.priority = priority
        self.requestId = requestId
        self.retentionMode = retentionMode
        self.roleArn = roleArn
        self.runGroupId = runGroupId
        self.runId = runId
        self.storageCapacity = storageCapacity
        self.storageType = storageType
        self.tags = tags
        self.workflowId = workflowId
        self.workflowOwnerId = workflowOwnerId
        self.workflowType = workflowType
    }
}

extension StartRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRunOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.runOutputUri = try reader["runOutputUri"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.uuid = try reader["uuid"].readIfPresent()
        return value
    }
}

public struct StartRunOutput {
    /// The run's ARN.
    public var arn: Swift.String?
    /// The run's ID.
    public var id: Swift.String?
    /// The destination for workflow outputs.
    public var runOutputUri: Swift.String?
    /// The run's status.
    public var status: OmicsClientTypes.RunStatus?
    /// The run's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The universally unique identifier for a run.
    public var uuid: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        runOutputUri: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.runOutputUri = runOutputUri
        self.status = status
        self.tags = tags
        self.uuid = uuid
    }
}

enum StartRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartVariantImportJobInput {

    static func urlPathProvider(_ value: StartVariantImportJobInput) -> Swift.String? {
        return "/import/variant"
    }
}

extension StartVariantImportJobInput {

    static func write(value: StartVariantImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["annotationFields"].writeMap(value.annotationFields, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["destinationName"].write(value.destinationName)
        try writer["items"].writeList(value.items, memberWritingClosure: OmicsClientTypes.VariantImportItemSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["runLeftNormalization"].write(value.runLeftNormalization)
    }
}

public struct StartVariantImportJobInput {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// The destination variant store for the job.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Items to import.
    /// This member is required.
    public var items: [OmicsClientTypes.VariantImportItemSource]?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    public var runLeftNormalization: Swift.Bool?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        destinationName: Swift.String? = nil,
        items: [OmicsClientTypes.VariantImportItemSource]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool? = nil
    )
    {
        self.annotationFields = annotationFields
        self.destinationName = destinationName
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
    }
}

extension StartVariantImportJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartVariantImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartVariantImportJobOutput()
        value.jobId = try reader["jobId"].readIfPresent()
        return value
    }
}

public struct StartVariantImportJobOutput {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

enum StartVariantImportJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes {

    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum StoreFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// GFF3 Format
        case gff
        /// TSV Format
        case tsv
        /// VCF Format
        case vcf
        case sdkUnknown(Swift.String)

        public static var allCases: [StoreFormat] {
            return [
                .gff,
                .tsv,
                .vcf,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gff: return "GFF"
            case .tsv: return "TSV"
            case .vcf: return "VCF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.StoreOptions {

    static func write(value: OmicsClientTypes.StoreOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .tsvstoreoptions(tsvstoreoptions):
                try writer["tsvStoreOptions"].write(tsvstoreoptions, with: OmicsClientTypes.TsvStoreOptions.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.StoreOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tsvStoreOptions":
                return .tsvstoreoptions(try reader["tsvStoreOptions"].read(with: OmicsClientTypes.TsvStoreOptions.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension OmicsClientTypes {
    /// Settings for a store.
    public enum StoreOptions {
        /// File settings for a TSV store.
        case tsvstoreoptions(OmicsClientTypes.TsvStoreOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {

    public enum StoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The Store is active
        case active
        /// The Store is being created
        case creating
        /// The Store is deleting
        case deleting
        /// The Store creation failed
        case failed
        /// The Store is updating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [StoreStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OmicsClientTypes.TaskListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.TaskListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.TaskListItem()
        value.taskId = try reader["taskId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.cpus = try reader["cpus"].readIfPresent()
        value.memory = try reader["memory"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.stopTime = try reader["stopTime"].readTimestampIfPresent(format: .dateTime)
        value.gpus = try reader["gpus"].readIfPresent()
        value.instanceType = try reader["instanceType"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// A workflow run task.
    public struct TaskListItem {
        /// The task's CPU count.
        public var cpus: Swift.Int?
        /// When the task was created.
        public var creationTime: ClientRuntime.Date?
        /// The number of Graphics Processing Units (GPU) specified for the task.
        public var gpus: Swift.Int?
        /// The instance type for a task.
        public var instanceType: Swift.String?
        /// The task's memory use in gigabyes.
        public var memory: Swift.Int?
        /// The task's name.
        public var name: Swift.String?
        /// When the task started.
        public var startTime: ClientRuntime.Date?
        /// The task's status.
        public var status: OmicsClientTypes.TaskStatus?
        /// When the task stopped.
        public var stopTime: ClientRuntime.Date?
        /// The task's ID.
        public var taskId: Swift.String?

        public init(
            cpus: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            gpus: Swift.Int? = nil,
            instanceType: Swift.String? = nil,
            memory: Swift.Int? = nil,
            name: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.TaskStatus? = nil,
            stopTime: ClientRuntime.Date? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.creationTime = creationTime
            self.gpus = gpus
            self.instanceType = instanceType
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.taskId = taskId
        }
    }

}

extension OmicsClientTypes {

    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case pending
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .pending,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes.TsvOptions {

    static func write(value: OmicsClientTypes.TsvOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["readOptions"].write(value.readOptions, with: OmicsClientTypes.ReadOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.TsvOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.TsvOptions()
        value.readOptions = try reader["readOptions"].readIfPresent(with: OmicsClientTypes.ReadOptions.read(from:))
        return value
    }
}

extension OmicsClientTypes {
    /// Formatting options for a TSV file.
    public struct TsvOptions {
        /// The file's read options.
        public var readOptions: OmicsClientTypes.ReadOptions?

        public init(
            readOptions: OmicsClientTypes.ReadOptions? = nil
        )
        {
            self.readOptions = readOptions
        }
    }

}

extension OmicsClientTypes.TsvStoreOptions {

    static func write(value: OmicsClientTypes.TsvStoreOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["annotationType"].write(value.annotationType)
        try writer["formatToHeader"].writeMap(value.formatToHeader, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["schema"].writeList(value.schema, memberWritingClosure: mapWritingClosure(valueWritingClosure: OmicsClientTypes.SchemaValueType.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.TsvStoreOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.TsvStoreOptions()
        value.annotationType = try reader["annotationType"].readIfPresent()
        value.formatToHeader = try reader["formatToHeader"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.schema = try reader["schema"].readListIfPresent(memberReadingClosure: mapReadingClosure(valueReadingClosure: OmicsClientTypes.SchemaValueType.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// File settings for a TSV store.
    public struct TsvStoreOptions {
        /// The store's annotation type.
        public var annotationType: OmicsClientTypes.AnnotationType?
        /// The store's header key to column name mapping.
        public var formatToHeader: [Swift.String:Swift.String]?
        /// The store's schema.
        public var schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]?

        public init(
            annotationType: OmicsClientTypes.AnnotationType? = nil,
            formatToHeader: [Swift.String:Swift.String]? = nil,
            schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        )
        {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }
    }

}

extension OmicsClientTypes.TsvVersionOptions {

    static func write(value: OmicsClientTypes.TsvVersionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["annotationType"].write(value.annotationType)
        try writer["formatToHeader"].writeMap(value.formatToHeader, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["schema"].writeList(value.schema, memberWritingClosure: mapWritingClosure(valueWritingClosure: OmicsClientTypes.SchemaValueType.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.TsvVersionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.TsvVersionOptions()
        value.annotationType = try reader["annotationType"].readIfPresent()
        value.formatToHeader = try reader["formatToHeader"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.schema = try reader["schema"].readListIfPresent(memberReadingClosure: mapReadingClosure(valueReadingClosure: OmicsClientTypes.SchemaValueType.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// The options for a TSV file.
    public struct TsvVersionOptions {
        /// The store version's annotation type.
        public var annotationType: OmicsClientTypes.AnnotationType?
        /// The annotation store version's header key to column name mapping.
        public var formatToHeader: [Swift.String:Swift.String]?
        /// The TSV schema for an annotation store version.
        public var schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]?

        public init(
            annotationType: OmicsClientTypes.AnnotationType? = nil,
            formatToHeader: [Swift.String:Swift.String]? = nil,
            schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        )
        {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAnnotationStoreInput {

    static func urlPathProvider(_ value: UpdateAnnotationStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

extension UpdateAnnotationStoreInput {

    static func write(value: UpdateAnnotationStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

public struct UpdateAnnotationStoreInput {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

extension UpdateAnnotationStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAnnotationStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnnotationStoreOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.storeFormat = try reader["storeFormat"].readIfPresent()
        value.storeOptions = try reader["storeOptions"].readIfPresent(with: OmicsClientTypes.StoreOptions.read(from:))
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateAnnotationStoreOutput {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The annotation file format of the store.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// Parsing options for the store.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.updateTime = updateTime
    }
}

enum UpdateAnnotationStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAnnotationStoreVersionInput {

    static func urlPathProvider(_ value: UpdateAnnotationStoreVersionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/version/\(versionName.urlPercentEncoding())"
    }
}

extension UpdateAnnotationStoreVersionInput {

    static func write(value: UpdateAnnotationStoreVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

public struct UpdateAnnotationStoreVersionInput {
    /// The description of an annotation store.
    public var description: Swift.String?
    /// The name of an annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// The name of an annotation store version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.versionName = versionName
    }
}

extension UpdateAnnotationStoreVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAnnotationStoreVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnnotationStoreVersionOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.storeId = try reader["storeId"].readIfPresent()
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.versionName = try reader["versionName"].readIfPresent()
        return value
    }
}

public struct UpdateAnnotationStoreVersionOutput {
    /// The time stamp for when an annotation store version was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description of an annotation store version.
    /// This member is required.
    public var description: Swift.String?
    /// The annotation store version ID.
    /// This member is required.
    public var id: Swift.String?
    /// The name of an annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// The status of an annotation store version.
    /// This member is required.
    public var status: OmicsClientTypes.VersionStatus?
    /// The annotation store ID.
    /// This member is required.
    public var storeId: Swift.String?
    /// The time stamp for when an annotation store version was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?
    /// The name of an annotation store version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OmicsClientTypes.VersionStatus? = nil,
        storeId: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.storeId = storeId
        self.updateTime = updateTime
        self.versionName = versionName
    }
}

enum UpdateAnnotationStoreVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateRunGroupInput {

    static func urlPathProvider(_ value: UpdateRunGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

extension UpdateRunGroupInput {

    static func write(value: UpdateRunGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxCpus"].write(value.maxCpus)
        try writer["maxDuration"].write(value.maxDuration)
        try writer["maxGpus"].write(value.maxGpus)
        try writer["maxRuns"].write(value.maxRuns)
        try writer["name"].write(value.name)
    }
}

public struct UpdateRunGroupInput {
    /// The group's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of CPUs to use.
    public var maxCpus: Swift.Int?
    /// A maximum run time for the group in minutes.
    public var maxDuration: Swift.Int?
    /// The maximum GPUs that can be used by a run group.
    public var maxGpus: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// A name for the group.
    public var name: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxGpus: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.id = id
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxGpus = maxGpus
        self.maxRuns = maxRuns
        self.name = name
    }
}

extension UpdateRunGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRunGroupOutput {
        return UpdateRunGroupOutput()
    }
}

public struct UpdateRunGroupOutput {

    public init() { }
}

enum UpdateRunGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateVariantStoreInput {

    static func urlPathProvider(_ value: UpdateVariantStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

extension UpdateVariantStoreInput {

    static func write(value: UpdateVariantStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

public struct UpdateVariantStoreInput {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

extension UpdateVariantStoreOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateVariantStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVariantStoreOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateVariantStoreOutput {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.updateTime = updateTime
    }
}

enum UpdateVariantStoreOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateWorkflowInput {

    static func urlPathProvider(_ value: UpdateWorkflowInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

extension UpdateWorkflowInput {

    static func write(value: UpdateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

public struct UpdateWorkflowInput {
    /// A description for the workflow.
    public var description: Swift.String?
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?
    /// A name for the workflow.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

extension UpdateWorkflowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateWorkflowOutput {
        return UpdateWorkflowOutput()
    }
}

public struct UpdateWorkflowOutput {

    public init() { }
}

enum UpdateWorkflowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UploadReadSetPartInput {

    static func queryItemProvider(_ value: UploadReadSetPartInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let partSource = value.partSource else {
            let message = "Creating a URL Query Item failed. partSource is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let partSourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "partSource".urlPercentEncoding(), value: Swift.String(partSource.rawValue).urlPercentEncoding())
        items.append(partSourceQueryItem)
        guard let partNumber = value.partNumber else {
            let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let partNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
        items.append(partNumberQueryItem)
        return items
    }
}

extension UploadReadSetPartInput {

    static func urlPathProvider(_ value: UploadReadSetPartInput) -> Swift.String? {
        guard let sequenceStoreId = value.sequenceStoreId else {
            return nil
        }
        guard let uploadId = value.uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/part"
    }
}

extension UploadReadSetPartInput {

    static func write(value: UploadReadSetPartInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

public struct UploadReadSetPartInput {
    /// The number of the part being uploaded.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The source file for an upload part.
    /// This member is required.
    public var partSource: OmicsClientTypes.ReadSetPartSource?
    /// The read set data to upload for a part.
    /// This member is required.
    public var payload: ClientRuntime.ByteStream?
    /// The Sequence Store ID used for the multipart upload.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        partNumber: Swift.Int? = nil,
        partSource: OmicsClientTypes.ReadSetPartSource? = nil,
        payload: ClientRuntime.ByteStream? = nil,
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.partNumber = partNumber
        self.partSource = partSource
        self.payload = payload
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

extension UploadReadSetPartOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UploadReadSetPartOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UploadReadSetPartOutput()
        value.checksum = try reader["checksum"].readIfPresent()
        return value
    }
}

public struct UploadReadSetPartOutput {
    /// An identifier used to confirm that parts are being added to the intended upload.
    /// This member is required.
    public var checksum: Swift.String?

    public init(
        checksum: Swift.String? = nil
    )
    {
        self.checksum = checksum
    }
}

enum UploadReadSetPartOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotSupportedOperationException": return try NotSupportedOperationException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OmicsClientTypes.VariantImportItemDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.VariantImportItemDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.VariantImportItemDetail()
        value.source = try reader["source"].readIfPresent()
        value.jobStatus = try reader["jobStatus"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Details about an imported variant item.
    public struct VariantImportItemDetail {
        /// The item's job status.
        /// This member is required.
        public var jobStatus: OmicsClientTypes.JobStatus?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?
        /// A message that provides additional context about a job
        public var statusMessage: Swift.String?

        public init(
            jobStatus: OmicsClientTypes.JobStatus? = nil,
            source: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.jobStatus = jobStatus
            self.source = source
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.VariantImportItemSource {

    static func write(value: OmicsClientTypes.VariantImportItemSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source)
    }
}

extension OmicsClientTypes {
    /// A imported variant item's source.
    public struct VariantImportItemSource {
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init(
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension OmicsClientTypes.VariantImportJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.VariantImportJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.VariantImportJobItem()
        value.id = try reader["id"].readIfPresent()
        value.destinationName = try reader["destinationName"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: .dateTime)
        value.runLeftNormalization = try reader["runLeftNormalization"].readIfPresent() ?? false
        value.annotationFields = try reader["annotationFields"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// A variant import job.
    public struct VariantImportJobItem {
        /// The annotation schema generated by the parsed annotation data.
        public var annotationFields: [Swift.String:Swift.String]?
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination variant store.
        /// This member is required.
        public var destinationName: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's left normalization setting.
        public var runLeftNormalization: Swift.Bool
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.JobStatus?
        /// When the job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            annotationFields: [Swift.String:Swift.String]? = nil,
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runLeftNormalization: Swift.Bool = false,
            status: OmicsClientTypes.JobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.VariantStoreItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.VariantStoreItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.VariantStoreItem()
        value.id = try reader["id"].readIfPresent()
        value.reference = try reader["reference"].readIfPresent(with: OmicsClientTypes.ReferenceItem.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.storeArn = try reader["storeArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.sseConfig = try reader["sseConfig"].readIfPresent(with: OmicsClientTypes.SseConfig.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: .dateTime)
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.storeSizeBytes = try reader["storeSizeBytes"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// A variant store.
    public struct VariantStoreItem {
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        /// This member is required.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        /// This member is required.
        public var name: Swift.String?
        /// The store's genome reference.
        /// This member is required.
        public var reference: OmicsClientTypes.ReferenceItem?
        /// The store's server-side encryption (SSE) settings.
        /// This member is required.
        public var sseConfig: OmicsClientTypes.SseConfig?
        /// The store's status.
        /// This member is required.
        public var status: OmicsClientTypes.StoreStatus?
        /// The store's status message.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store's ARN.
        /// This member is required.
        public var storeArn: Swift.String?
        /// The store's size in bytes.
        /// This member is required.
        public var storeSizeBytes: Swift.Int?
        /// When the store was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reference: OmicsClientTypes.ReferenceItem? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil,
            status: OmicsClientTypes.StoreStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeArn: Swift.String? = nil,
            storeSizeBytes: Swift.Int? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.VcfOptions {

    static func write(value: OmicsClientTypes.VcfOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ignoreFilterField"].write(value.ignoreFilterField)
        try writer["ignoreQualField"].write(value.ignoreQualField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.VcfOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.VcfOptions()
        value.ignoreQualField = try reader["ignoreQualField"].readIfPresent()
        value.ignoreFilterField = try reader["ignoreFilterField"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// Formatting options for a VCF file.
    public struct VcfOptions {
        /// The file's ignore filter field setting.
        public var ignoreFilterField: Swift.Bool?
        /// The file's ignore qual field setting.
        public var ignoreQualField: Swift.Bool?

        public init(
            ignoreFilterField: Swift.Bool? = nil,
            ignoreQualField: Swift.Bool? = nil
        )
        {
            self.ignoreFilterField = ignoreFilterField
            self.ignoreQualField = ignoreQualField
        }
    }

}

extension OmicsClientTypes.VersionDeleteError {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.VersionDeleteError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.VersionDeleteError()
        value.versionName = try reader["versionName"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// The error preventing deletion of the annotation store version.
    public struct VersionDeleteError {
        /// The message explaining the error in annotation store deletion.
        /// This member is required.
        public var message: Swift.String?
        /// The name given to an annotation store version.
        /// This member is required.
        public var versionName: Swift.String?

        public init(
            message: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.message = message
            self.versionName = versionName
        }
    }

}

extension OmicsClientTypes.VersionOptions {

    static func write(value: OmicsClientTypes.VersionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .tsvversionoptions(tsvversionoptions):
                try writer["tsvVersionOptions"].write(tsvversionoptions, with: OmicsClientTypes.TsvVersionOptions.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.VersionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tsvVersionOptions":
                return .tsvversionoptions(try reader["tsvVersionOptions"].read(with: OmicsClientTypes.TsvVersionOptions.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension OmicsClientTypes {
    /// The options for an annotation store version.
    public enum VersionOptions {
        /// File settings for a version of a TSV store.
        case tsvversionoptions(OmicsClientTypes.TsvVersionOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {

    public enum VersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The Version is active
        case active
        /// The Version is being created
        case creating
        /// The Version is deleting
        case deleting
        /// The Version creation failed
        case failed
        /// The Version is updating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum WorkflowEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cwl
        case nextflow
        case wdl
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowEngine] {
            return [
                .cwl,
                .nextflow,
                .wdl,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cwl: return "CWL"
            case .nextflow: return "NEXTFLOW"
            case .wdl: return "WDL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum WorkflowExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowExport] {
            return [
                .definition,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .definition: return "DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes.WorkflowListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.WorkflowListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.WorkflowListItem()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.digest = try reader["digest"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OmicsClientTypes {
    /// A workflow.
    public struct WorkflowListItem {
        /// The workflow's ARN.
        public var arn: Swift.String?
        /// When the workflow was created.
        public var creationTime: ClientRuntime.Date?
        /// The workflow's digest.
        public var digest: Swift.String?
        /// The workflow's ID.
        public var id: Swift.String?
        /// Any metadata available for workflow. The information listed may vary depending on the workflow, and there may also be no metadata to return.
        public var metadata: [Swift.String:Swift.String]?
        /// The workflow's name.
        public var name: Swift.String?
        /// The workflow's status.
        public var status: OmicsClientTypes.WorkflowStatus?
        /// The workflow's type.
        public var type: OmicsClientTypes.WorkflowType?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            digest: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            status: OmicsClientTypes.WorkflowStatus? = nil,
            type: OmicsClientTypes.WorkflowType? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.digest = digest
            self.id = id
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension OmicsClientTypes.WorkflowParameter {

    static func write(value: OmicsClientTypes.WorkflowParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["optional"].write(value.`optional`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OmicsClientTypes.WorkflowParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OmicsClientTypes.WorkflowParameter()
        value.description = try reader["description"].readIfPresent()
        value.`optional` = try reader["optional"].readIfPresent()
        return value
    }
}

extension OmicsClientTypes {
    /// A workflow parameter.
    public struct WorkflowParameter {
        /// The parameter's description.
        public var description: Swift.String?
        /// Whether the parameter is optional.
        public var `optional`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `optional`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`optional` = `optional`
        }
    }

}

extension OmicsClientTypes {

    public enum WorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case failed
        case inactive
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .failed,
                .inactive,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OmicsClientTypes {

    public enum WorkflowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case ready2run
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .private,
                .ready2run,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .ready2run: return "READY2RUN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
