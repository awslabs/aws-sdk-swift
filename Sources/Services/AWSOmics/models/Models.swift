// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortMultipartReadSetUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/abort"
    }
}

public struct AbortMultipartReadSetUploadInput: Swift.Equatable {
    /// The sequence store ID for the store involved in the multipart upload.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

struct AbortMultipartReadSetUploadInputBody: Swift.Equatable {
}

extension AbortMultipartReadSetUploadInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AbortMultipartReadSetUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AbortMultipartReadSetUploadOutput: Swift.Equatable {

    public init() { }
}

enum AbortMultipartReadSetUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotSupportedOperationException": return try await NotSupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes {
    public enum Accelerators: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gpu
        case sdkUnknown(Swift.String)

        public static var allCases: [Accelerators] {
            return [
                .gpu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gpu: return "GPU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Accelerators(rawValue: rawValue) ?? Accelerators.sdkUnknown(rawValue)
        }
    }
}

extension AcceptShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let shareId = shareId else {
            return nil
        }
        return "/share/\(shareId.urlPercentEncoding())"
    }
}

public struct AcceptShareInput: Swift.Equatable {
    /// The ID for a share offer for analytics store data.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

struct AcceptShareInputBody: Swift.Equatable {
}

extension AcceptShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AcceptShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct AcceptShareOutput: Swift.Equatable {
    /// The status of an analytics store share.
    public var status: OmicsClientTypes.ShareStatus?

    public init(
        status: OmicsClientTypes.ShareStatus? = nil
    )
    {
        self.status = status
    }
}

struct AcceptShareOutputBody: Swift.Equatable {
    let status: OmicsClientTypes.ShareStatus?
}

extension AcceptShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum AcceptShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.ActivateReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A read set activation job filter.
    public struct ActivateReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The filter's status.
        public var status: OmicsClientTypes.ReadSetActivationJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ActivateReadSetJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case sequenceStoreId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A read set activation job.
    public struct ActivateReadSetJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetActivationJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.ActivateReadSetSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readSetId = self.readSetId {
            try encodeContainer.encode(readSetId, forKey: .readSetId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension OmicsClientTypes {
    /// A source for a read set activation job.
    public struct ActivateReadSetSourceItem: Swift.Equatable {
        /// The source's read set ID.
        /// This member is required.
        public var readSetId: Swift.String?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetActivationJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?

        public init(
            readSetId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetActivationJobItemStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.AnnotationImportItemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatus
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension OmicsClientTypes {
    /// Details about an imported annotation item.
    public struct AnnotationImportItemDetail: Swift.Equatable {
        /// The item's job status.
        /// This member is required.
        public var jobStatus: OmicsClientTypes.JobStatus?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init(
            jobStatus: OmicsClientTypes.JobStatus? = nil,
            source: Swift.String? = nil
        )
        {
            self.jobStatus = jobStatus
            self.source = source
        }
    }

}

extension OmicsClientTypes.AnnotationImportItemSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension OmicsClientTypes {
    /// A source for an annotation import job.
    public struct AnnotationImportItemSource: Swift.Equatable {
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init(
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension OmicsClientTypes.AnnotationImportJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case completionTime
        case creationTime
        case destinationName
        case id
        case roleArn
        case runLeftNormalization
        case status
        case updateTime
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationFields = annotationFields {
            var annotationFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .annotationFields)
            for (dictKey0, annotationFieldMap0) in annotationFields {
                try annotationFieldsContainer.encode(annotationFieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if runLeftNormalization != false {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
        let annotationFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .annotationFields)
        var annotationFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let annotationFieldsContainer = annotationFieldsContainer {
            annotationFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in annotationFieldsContainer {
                if let string0 = string0 {
                    annotationFieldsDecoded0?[key0] = string0
                }
            }
        }
        annotationFields = annotationFieldsDecoded0
    }
}

extension OmicsClientTypes {
    /// An annotation import job.
    public struct AnnotationImportJobItem: Swift.Equatable {
        /// The annotation schema generated by the parsed annotation data.
        public var annotationFields: [Swift.String:Swift.String]?
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination annotation store.
        /// This member is required.
        public var destinationName: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's left normalization setting.
        public var runLeftNormalization: Swift.Bool
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.JobStatus?
        /// When the job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?
        /// The name of the annotation store version.
        /// This member is required.
        public var versionName: Swift.String?

        public init(
            annotationFields: [Swift.String:Swift.String]? = nil,
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runLeftNormalization: Swift.Bool = false,
            status: OmicsClientTypes.JobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
            self.versionName = versionName
        }
    }

}

extension OmicsClientTypes.AnnotationStoreItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeFormat
        case storeSizeBytes
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let storeArn = self.storeArn {
            try encodeContainer.encode(storeArn, forKey: .storeArn)
        }
        if let storeFormat = self.storeFormat {
            try encodeContainer.encode(storeFormat.rawValue, forKey: .storeFormat)
        }
        if let storeSizeBytes = self.storeSizeBytes {
            try encodeContainer.encode(storeSizeBytes, forKey: .storeSizeBytes)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

extension OmicsClientTypes {
    /// An annotation store.
    public struct AnnotationStoreItem: Swift.Equatable {
        /// The store's creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        /// This member is required.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        /// This member is required.
        public var name: Swift.String?
        /// The store's genome reference.
        /// This member is required.
        public var reference: OmicsClientTypes.ReferenceItem?
        /// The store's server-side encryption (SSE) settings.
        /// This member is required.
        public var sseConfig: OmicsClientTypes.SseConfig?
        /// The store's status.
        /// This member is required.
        public var status: OmicsClientTypes.StoreStatus?
        /// The store's status message.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store's ARN.
        /// This member is required.
        public var storeArn: Swift.String?
        /// The store's file format.
        /// This member is required.
        public var storeFormat: OmicsClientTypes.StoreFormat?
        /// The store's size in bytes.
        /// This member is required.
        public var storeSizeBytes: Swift.Int?
        /// When the store was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reference: OmicsClientTypes.ReferenceItem? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil,
            status: OmicsClientTypes.StoreStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeArn: Swift.String? = nil,
            storeFormat: OmicsClientTypes.StoreFormat? = nil,
            storeSizeBytes: Swift.Int? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.AnnotationStoreVersionItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case status
        case statusMessage
        case storeId
        case updateTime
        case versionArn
        case versionName
        case versionSizeBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let storeId = self.storeId {
            try encodeContainer.encode(storeId, forKey: .storeId)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
        if let versionArn = self.versionArn {
            try encodeContainer.encode(versionArn, forKey: .versionArn)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
        if let versionSizeBytes = self.versionSizeBytes {
            try encodeContainer.encode(versionSizeBytes, forKey: .versionSizeBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeId)
        storeId = storeIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionStatus.self, forKey: .status)
        status = statusDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let versionSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionSizeBytes)
        versionSizeBytes = versionSizeBytesDecoded
    }
}

extension OmicsClientTypes {
    /// Annotation store versions.
    public struct AnnotationStoreVersionItem: Swift.Equatable {
        /// The time stamp for when an annotation store version was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of an annotation store version.
        /// This member is required.
        public var description: Swift.String?
        /// The annotation store version ID.
        /// This member is required.
        public var id: Swift.String?
        /// A name given to an annotation store version to distinguish it from others.
        /// This member is required.
        public var name: Swift.String?
        /// The status of an annotation store version.
        /// This member is required.
        public var status: OmicsClientTypes.VersionStatus?
        /// The status of an annotation store version.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store ID for an annotation store version.
        /// This member is required.
        public var storeId: Swift.String?
        /// The time stamp for when an annotation store version was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?
        /// The Arn for an annotation store version.
        /// This member is required.
        public var versionArn: Swift.String?
        /// The name of an annotation store version.
        /// This member is required.
        public var versionName: Swift.String?
        /// The size of an annotation store version in Bytes.
        /// This member is required.
        public var versionSizeBytes: Swift.Int?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OmicsClientTypes.VersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeId: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil,
            versionArn: Swift.String? = nil,
            versionName: Swift.String? = nil,
            versionSizeBytes: Swift.Int? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.storeId = storeId
            self.updateTime = updateTime
            self.versionArn = versionArn
            self.versionName = versionName
            self.versionSizeBytes = versionSizeBytes
        }
    }

}

extension OmicsClientTypes {
    public enum AnnotationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Contains contig and 1-base position
        case chrPos
        /// Contains contig, 1-base position, ref and alt allele information
        case chrPosRefAlt
        /// Contains contig, start, and end positions. Coordinates are 1-based
        case chrStartEndOneBase
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
        case chrStartEndRefAltOneBase
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
        case chrStartEndRefAltZeroBase
        /// Contains contig, start, and end positions. Coordinates are 0-based
        case chrStartEndZeroBase
        /// Generic text file. No genomic information
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [AnnotationType] {
            return [
                .chrPos,
                .chrPosRefAlt,
                .chrStartEndOneBase,
                .chrStartEndRefAltOneBase,
                .chrStartEndRefAltZeroBase,
                .chrStartEndZeroBase,
                .generic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chrPos: return "CHR_POS"
            case .chrPosRefAlt: return "CHR_POS_REF_ALT"
            case .chrStartEndOneBase: return "CHR_START_END_ONE_BASE"
            case .chrStartEndRefAltOneBase: return "CHR_START_END_REF_ALT_ONE_BASE"
            case .chrStartEndRefAltZeroBase: return "CHR_START_END_REF_ALT_ZERO_BASE"
            case .chrStartEndZeroBase: return "CHR_START_END_ZERO_BASE"
            case .generic: return "GENERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnnotationType(rawValue: rawValue) ?? AnnotationType.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteReadSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for readsetid0 in ids {
                try idsContainer.encode(readsetid0)
            }
        }
    }
}

extension BatchDeleteReadSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/batch/delete"
    }
}

public struct BatchDeleteReadSetInput: Swift.Equatable {
    /// The read sets' IDs.
    /// This member is required.
    public var ids: [Swift.String]?
    /// The read sets' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        ids: [Swift.String]? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.ids = ids
        self.sequenceStoreId = sequenceStoreId
    }
}

struct BatchDeleteReadSetInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchDeleteReadSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchDeleteReadSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteReadSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteReadSetOutput: Swift.Equatable {
    /// Errors returned by individual delete operations.
    public var errors: [OmicsClientTypes.ReadSetBatchError]?

    public init(
        errors: [OmicsClientTypes.ReadSetBatchError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteReadSetOutputBody: Swift.Equatable {
    let errors: [OmicsClientTypes.ReadSetBatchError]?
}

extension BatchDeleteReadSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReadSetBatchError?].self, forKey: .errors)
        var errorsDecoded0:[OmicsClientTypes.ReadSetBatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [OmicsClientTypes.ReadSetBatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDeleteReadSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelAnnotationImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/annotation/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelAnnotationImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelAnnotationImportJobInputBody: Swift.Equatable {
}

extension CancelAnnotationImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelAnnotationImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelAnnotationImportJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelAnnotationImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/cancel"
    }
}

public struct CancelRunInput: Swift.Equatable {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelRunInputBody: Swift.Equatable {
}

extension CancelRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelRunOutput: Swift.Equatable {

    public init() { }
}

enum CancelRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelVariantImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/variant/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelVariantImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelVariantImportJobInputBody: Swift.Equatable {
}

extension CancelVariantImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelVariantImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelVariantImportJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelVariantImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CompleteMultipartReadSetUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parts = parts {
            var partsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parts)
            for completereadsetuploadpartlistitem0 in parts {
                try partsContainer.encode(completereadsetuploadpartlistitem0)
            }
        }
    }
}

extension CompleteMultipartReadSetUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/complete"
    }
}

public struct CompleteMultipartReadSetUploadInput: Swift.Equatable {
    /// The individual uploads or parts of a multipart upload.
    /// This member is required.
    public var parts: [OmicsClientTypes.CompleteReadSetUploadPartListItem]?
    /// The sequence store ID for the store involved in the multipart upload.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        parts: [OmicsClientTypes.CompleteReadSetUploadPartListItem]? = nil,
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.parts = parts
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

struct CompleteMultipartReadSetUploadInputBody: Swift.Equatable {
    let parts: [OmicsClientTypes.CompleteReadSetUploadPartListItem]?
}

extension CompleteMultipartReadSetUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.CompleteReadSetUploadPartListItem?].self, forKey: .parts)
        var partsDecoded0:[OmicsClientTypes.CompleteReadSetUploadPartListItem]? = nil
        if let partsContainer = partsContainer {
            partsDecoded0 = [OmicsClientTypes.CompleteReadSetUploadPartListItem]()
            for structure0 in partsContainer {
                if let structure0 = structure0 {
                    partsDecoded0?.append(structure0)
                }
            }
        }
        parts = partsDecoded0
    }
}

extension CompleteMultipartReadSetUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CompleteMultipartReadSetUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.readSetId = output.readSetId
        } else {
            self.readSetId = nil
        }
    }
}

public struct CompleteMultipartReadSetUploadOutput: Swift.Equatable {
    /// The read set ID created for an uploaded read set.
    /// This member is required.
    public var readSetId: Swift.String?

    public init(
        readSetId: Swift.String? = nil
    )
    {
        self.readSetId = readSetId
    }
}

struct CompleteMultipartReadSetUploadOutputBody: Swift.Equatable {
    let readSetId: Swift.String?
}

extension CompleteMultipartReadSetUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
    }
}

enum CompleteMultipartReadSetUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotSupportedOperationException": return try await NotSupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.CompleteReadSetUploadPartListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum
        case partNumber
        case partSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checksum = self.checksum {
            try encodeContainer.encode(checksum, forKey: .checksum)
        }
        if let partNumber = self.partNumber {
            try encodeContainer.encode(partNumber, forKey: .partNumber)
        }
        if let partSource = self.partSource {
            try encodeContainer.encode(partSource.rawValue, forKey: .partSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partNumber)
        partNumber = partNumberDecoded
        let partSourceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetPartSource.self, forKey: .partSource)
        partSource = partSourceDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
    }
}

extension OmicsClientTypes {
    /// Part of the response to the CompleteReadSetUpload API, including metadata.
    public struct CompleteReadSetUploadPartListItem: Swift.Equatable {
        /// A unique identifier used to confirm that parts are being added to the correct upload.
        /// This member is required.
        public var checksum: Swift.String?
        /// A number identifying the part in a read set upload.
        /// This member is required.
        public var partNumber: Swift.Int?
        /// The source file of the part being uploaded.
        /// This member is required.
        public var partSource: OmicsClientTypes.ReadSetPartSource?

        public init(
            checksum: Swift.String? = nil,
            partNumber: Swift.Int? = nil,
            partSource: OmicsClientTypes.ReadSetPartSource? = nil
        )
        {
            self.checksum = checksum
            self.partNumber = partNumber
            self.partSource = partSource
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request cannot be applied to the target resource in its current state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAnnotationStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case storeFormat
        case storeOptions
        case tags
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let storeFormat = self.storeFormat {
            try encodeContainer.encode(storeFormat.rawValue, forKey: .storeFormat)
        }
        if let storeOptions = self.storeOptions {
            try encodeContainer.encode(storeOptions, forKey: .storeOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension CreateAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/annotationStore"
    }
}

public struct CreateAnnotationStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    public var name: Swift.String?
    /// The genome reference for the store's annotations.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The annotation file format of the store.
    /// This member is required.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// File parsing options for the annotation store.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?
    /// The name given to an annotation store version to distinguish it from other versions.
    public var versionName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.tags = tags
        self.versionName = versionName
    }
}

struct CreateAnnotationStoreInputBody: Swift.Equatable {
    let reference: OmicsClientTypes.ReferenceItem?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let versionName: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let storeFormat: OmicsClientTypes.StoreFormat?
    let storeOptions: OmicsClientTypes.StoreOptions?
}

extension CreateAnnotationStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case storeFormat
        case storeOptions
        case tags
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
    }
}

extension CreateAnnotationStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAnnotationStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
            self.storeFormat = output.storeFormat
            self.storeOptions = output.storeOptions
            self.versionName = output.versionName
        } else {
            self.creationTime = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
            self.storeFormat = nil
            self.storeOptions = nil
            self.versionName = nil
        }
    }
}

public struct CreateAnnotationStoreOutput: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference. Required for all stores except TSV format with generic annotations.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The annotation file format of the store.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// The store's file parsing options.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.versionName = versionName
    }
}

struct CreateAnnotationStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let storeFormat: OmicsClientTypes.StoreFormat?
    let storeOptions: OmicsClientTypes.StoreOptions?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let versionName: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateAnnotationStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case name
        case reference
        case status
        case storeFormat
        case storeOptions
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateAnnotationStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAnnotationStoreVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case versionName
        case versionOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
        if let versionOptions = self.versionOptions {
            try encodeContainer.encode(versionOptions, forKey: .versionOptions)
        }
    }
}

extension CreateAnnotationStoreVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/version"
    }
}

public struct CreateAnnotationStoreVersionInput: Swift.Equatable {
    /// The description of an annotation store version.
    public var description: Swift.String?
    /// The name of an annotation store version from which versions are being created.
    /// This member is required.
    public var name: Swift.String?
    /// Any tags added to annotation store version.
    public var tags: [Swift.String:Swift.String]?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var versionName: Swift.String?
    /// The options for an annotation store version.
    public var versionOptions: OmicsClientTypes.VersionOptions?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        versionName: Swift.String? = nil,
        versionOptions: OmicsClientTypes.VersionOptions? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.versionName = versionName
        self.versionOptions = versionOptions
    }
}

struct CreateAnnotationStoreVersionInputBody: Swift.Equatable {
    let versionName: Swift.String?
    let description: Swift.String?
    let versionOptions: OmicsClientTypes.VersionOptions?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAnnotationStoreVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case versionName
        case versionOptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let versionOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionOptions.self, forKey: .versionOptions)
        versionOptions = versionOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAnnotationStoreVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAnnotationStoreVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.storeId = output.storeId
            self.versionName = output.versionName
            self.versionOptions = output.versionOptions
        } else {
            self.creationTime = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.storeId = nil
            self.versionName = nil
            self.versionOptions = nil
        }
    }
}

public struct CreateAnnotationStoreVersionOutput: Swift.Equatable {
    /// The time stamp for the creation of an annotation store version.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A generated ID for the annotation store
    /// This member is required.
    public var id: Swift.String?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var name: Swift.String?
    /// The status of a annotation store version.
    /// This member is required.
    public var status: OmicsClientTypes.VersionStatus?
    /// The ID for the annotation store from which new versions are being created.
    /// This member is required.
    public var storeId: Swift.String?
    /// The name given to an annotation store version to distinguish it from other versions.
    /// This member is required.
    public var versionName: Swift.String?
    /// The options for an annotation store version.
    public var versionOptions: OmicsClientTypes.VersionOptions?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OmicsClientTypes.VersionStatus? = nil,
        storeId: Swift.String? = nil,
        versionName: Swift.String? = nil,
        versionOptions: OmicsClientTypes.VersionOptions? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.status = status
        self.storeId = storeId
        self.versionName = versionName
        self.versionOptions = versionOptions
    }
}

struct CreateAnnotationStoreVersionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let versionName: Swift.String?
    let storeId: Swift.String?
    let versionOptions: OmicsClientTypes.VersionOptions?
    let name: Swift.String?
    let status: OmicsClientTypes.VersionStatus?
    let creationTime: ClientRuntime.Date?
}

extension CreateAnnotationStoreVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case name
        case status
        case storeId
        case versionName
        case versionOptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let storeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeId)
        storeId = storeIdDecoded
        let versionOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionOptions.self, forKey: .versionOptions)
        versionOptions = versionOptionsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateAnnotationStoreVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMultipartReadSetUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sourceFileType
        case subjectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sourceFileType = self.sourceFileType {
            try encodeContainer.encode(sourceFileType.rawValue, forKey: .sourceFileType)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMultipartReadSetUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload"
    }
}

public struct CreateMultipartReadSetUploadInput: Swift.Equatable {
    /// An idempotency token that can be used to avoid triggering multiple multipart uploads.
    public var clientToken: Swift.String?
    /// The description of the read set.
    public var description: Swift.String?
    /// Where the source originated.
    public var generatedFrom: Swift.String?
    /// The name of the read set.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the reference.
    /// This member is required.
    public var referenceArn: Swift.String?
    /// The source's sample ID.
    /// This member is required.
    public var sampleId: Swift.String?
    /// The sequence store ID for the store that is the destination of the multipart uploads.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The type of file being uploaded.
    /// This member is required.
    public var sourceFileType: OmicsClientTypes.FileType?
    /// The source's subject ID.
    /// This member is required.
    public var subjectId: Swift.String?
    /// Any tags to add to the read set.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        generatedFrom: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sourceFileType: OmicsClientTypes.FileType? = nil,
        subjectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.generatedFrom = generatedFrom
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceStoreId = sequenceStoreId
        self.sourceFileType = sourceFileType
        self.subjectId = subjectId
        self.tags = tags
    }
}

struct CreateMultipartReadSetUploadInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let sourceFileType: OmicsClientTypes.FileType?
    let subjectId: Swift.String?
    let sampleId: Swift.String?
    let generatedFrom: Swift.String?
    let referenceArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMultipartReadSetUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sourceFileType
        case subjectId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMultipartReadSetUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMultipartReadSetUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.generatedFrom = output.generatedFrom
            self.name = output.name
            self.referenceArn = output.referenceArn
            self.sampleId = output.sampleId
            self.sequenceStoreId = output.sequenceStoreId
            self.sourceFileType = output.sourceFileType
            self.subjectId = output.subjectId
            self.tags = output.tags
            self.uploadId = output.uploadId
        } else {
            self.creationTime = nil
            self.description = nil
            self.generatedFrom = nil
            self.name = nil
            self.referenceArn = nil
            self.sampleId = nil
            self.sequenceStoreId = nil
            self.sourceFileType = nil
            self.subjectId = nil
            self.tags = nil
            self.uploadId = nil
        }
    }
}

public struct CreateMultipartReadSetUploadOutput: Swift.Equatable {
    /// The creation time of the multipart upload.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description of the read set.
    public var description: Swift.String?
    /// The source of the read set.
    public var generatedFrom: Swift.String?
    /// The name of the read set.
    public var name: Swift.String?
    /// The read set source's reference ARN.
    /// This member is required.
    public var referenceArn: Swift.String?
    /// The source's sample ID.
    /// This member is required.
    public var sampleId: Swift.String?
    /// The sequence store ID for the store that the read set will be created in.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The file type of the read set source.
    /// This member is required.
    public var sourceFileType: OmicsClientTypes.FileType?
    /// The source's subject ID.
    /// This member is required.
    public var subjectId: Swift.String?
    /// The tags to add to the read set.
    public var tags: [Swift.String:Swift.String]?
    /// he ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        generatedFrom: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sourceFileType: OmicsClientTypes.FileType? = nil,
        subjectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.generatedFrom = generatedFrom
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceStoreId = sequenceStoreId
        self.sourceFileType = sourceFileType
        self.subjectId = subjectId
        self.tags = tags
        self.uploadId = uploadId
    }
}

struct CreateMultipartReadSetUploadOutputBody: Swift.Equatable {
    let sequenceStoreId: Swift.String?
    let uploadId: Swift.String?
    let sourceFileType: OmicsClientTypes.FileType?
    let subjectId: Swift.String?
    let sampleId: Swift.String?
    let generatedFrom: Swift.String?
    let referenceArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let creationTime: ClientRuntime.Date?
}

extension CreateMultipartReadSetUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sequenceStoreId
        case sourceFileType
        case subjectId
        case tags
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateMultipartReadSetUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotSupportedOperationException": return try await NotSupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReferenceStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case sseConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateReferenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/referencestore"
    }
}

public struct CreateReferenceStoreInput: Swift.Equatable {
    /// To ensure that requests don't run multiple times, specify a unique token for each request.
    public var clientToken: Swift.String?
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

struct CreateReferenceStoreInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateReferenceStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case sseConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateReferenceStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReferenceStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct CreateReferenceStoreOutput: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's SSE settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct CreateReferenceStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
}

extension CreateReferenceStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateReferenceStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRunGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxGpus
        case maxRuns
        case name
        case requestId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxCpus = self.maxCpus {
            try encodeContainer.encode(maxCpus, forKey: .maxCpus)
        }
        if let maxDuration = self.maxDuration {
            try encodeContainer.encode(maxDuration, forKey: .maxDuration)
        }
        if let maxGpus = self.maxGpus {
            try encodeContainer.encode(maxGpus, forKey: .maxGpus)
        }
        if let maxRuns = self.maxRuns {
            try encodeContainer.encode(maxRuns, forKey: .maxRuns)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/runGroup"
    }
}

public struct CreateRunGroupInput: Swift.Equatable {
    /// The maximum number of CPUs to use in the group.
    public var maxCpus: Swift.Int?
    /// A maximum run time for the group in minutes.
    public var maxDuration: Swift.Int?
    /// The maximum GPUs that can be used by a run group.
    public var maxGpus: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// A name for the group.
    public var name: Swift.String?
    /// To ensure that requests don't run multiple times, specify a unique ID for each request.
    /// This member is required.
    public var requestId: Swift.String?
    /// Tags for the group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxGpus: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxGpus = maxGpus
        self.maxRuns = maxRuns
        self.name = name
        self.requestId = requestId
        self.tags = tags
    }
}

struct CreateRunGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxCpus: Swift.Int?
    let maxRuns: Swift.Int?
    let maxDuration: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let requestId: Swift.String?
    let maxGpus: Swift.Int?
}

extension CreateRunGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxGpus
        case maxRuns
        case name
        case requestId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let maxGpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxGpus)
        maxGpus = maxGpusDecoded
    }
}

extension CreateRunGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRunGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct CreateRunGroupOutput: Swift.Equatable {
    /// The group's ARN.
    public var arn: Swift.String?
    /// The group's ID.
    public var id: Swift.String?
    /// Tags for the run group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.tags = tags
    }
}

struct CreateRunGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRunGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateRunGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSequenceStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case fallbackLocation
        case name
        case sseConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fallbackLocation = self.fallbackLocation {
            try encodeContainer.encode(fallbackLocation, forKey: .fallbackLocation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSequenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sequencestore"
    }
}

public struct CreateSequenceStoreInput: Swift.Equatable {
    /// To ensure that requests don't run multiple times, specify a unique token for each request.
    public var clientToken: Swift.String?
    /// A description for the store.
    public var description: Swift.String?
    /// An S3 location that is used to store files that have failed a direct upload.
    public var fallbackLocation: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fallbackLocation: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.fallbackLocation = fallbackLocation
        self.name = name
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

struct CreateSequenceStoreInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let fallbackLocation: Swift.String?
}

extension CreateSequenceStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case fallbackLocation
        case name
        case sseConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let fallbackLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallbackLocation)
        fallbackLocation = fallbackLocationDecoded
    }
}

extension CreateSequenceStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSequenceStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.fallbackLocation = output.fallbackLocation
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.fallbackLocation = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct CreateSequenceStoreOutput: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// An S3 location that is used to store files that have failed a direct upload.
    public var fallbackLocation: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's SSE settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        fallbackLocation: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.fallbackLocation = fallbackLocation
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct CreateSequenceStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
    let fallbackLocation: Swift.String?
}

extension CreateSequenceStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case fallbackLocation
        case id
        case name
        case sseConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fallbackLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallbackLocation)
        fallbackLocation = fallbackLocationDecoded
    }
}

enum CreateSequenceStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalSubscriber
        case resourceArn
        case shareName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalSubscriber = self.principalSubscriber {
            try encodeContainer.encode(principalSubscriber, forKey: .principalSubscriber)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let shareName = self.shareName {
            try encodeContainer.encode(shareName, forKey: .shareName)
        }
    }
}

extension CreateShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/share"
    }
}

public struct CreateShareInput: Swift.Equatable {
    /// The principal subscriber is the account being given access to the analytics store data through the share offer.
    /// This member is required.
    public var principalSubscriber: Swift.String?
    /// The resource ARN for the analytics store to be shared.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A name given to the share.
    public var shareName: Swift.String?

    public init(
        principalSubscriber: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        shareName: Swift.String? = nil
    )
    {
        self.principalSubscriber = principalSubscriber
        self.resourceArn = resourceArn
        self.shareName = shareName
    }
}

struct CreateShareInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let principalSubscriber: Swift.String?
    let shareName: Swift.String?
}

extension CreateShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalSubscriber
        case resourceArn
        case shareName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalSubscriberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalSubscriber)
        principalSubscriber = principalSubscriberDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareName)
        shareName = shareNameDecoded
    }
}

extension CreateShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
            self.shareName = output.shareName
            self.status = output.status
        } else {
            self.shareId = nil
            self.shareName = nil
            self.status = nil
        }
    }
}

public struct CreateShareOutput: Swift.Equatable {
    /// An ID generated for the share.
    public var shareId: Swift.String?
    /// A name given to the share.
    public var shareName: Swift.String?
    /// The status of a share.
    public var status: OmicsClientTypes.ShareStatus?

    public init(
        shareId: Swift.String? = nil,
        shareName: Swift.String? = nil,
        status: OmicsClientTypes.ShareStatus? = nil
    )
    {
        self.shareId = shareId
        self.shareName = shareName
        self.status = status
    }
}

struct CreateShareOutputBody: Swift.Equatable {
    let shareId: Swift.String?
    let status: OmicsClientTypes.ShareStatus?
    let shareName: Swift.String?
}

extension CreateShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId
        case shareName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareName)
        shareName = shareNameDecoded
    }
}

enum CreateShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVariantStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/variantStore"
    }
}

public struct CreateVariantStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    public var name: Swift.String?
    /// The genome reference for the store's variants.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

struct CreateVariantStoreInputBody: Swift.Equatable {
    let reference: OmicsClientTypes.ReferenceItem?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let sseConfig: OmicsClientTypes.SseConfig?
}

extension CreateVariantStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
    }
}

extension CreateVariantStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVariantStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
        }
    }
}

public struct CreateVariantStoreOutput: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
    }
}

struct CreateVariantStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateVariantStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case name
        case reference
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum CreateVariantStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators
        case definitionUri
        case definitionZip
        case description
        case engine
        case main
        case name
        case parameterTemplate
        case requestId
        case storageCapacity
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accelerators = self.accelerators {
            try encodeContainer.encode(accelerators.rawValue, forKey: .accelerators)
        }
        if let definitionUri = self.definitionUri {
            try encodeContainer.encode(definitionUri, forKey: .definitionUri)
        }
        if let definitionZip = self.definitionZip {
            try encodeContainer.encode(definitionZip.base64EncodedString(), forKey: .definitionZip)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let main = self.main {
            try encodeContainer.encode(main, forKey: .main)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterTemplate = parameterTemplate {
            var parameterTemplateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameterTemplate)
            for (dictKey0, workflowParameterTemplate0) in parameterTemplate {
                try parameterTemplateContainer.encode(workflowParameterTemplate0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let storageCapacity = self.storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflow"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// The computational accelerator specified to run the workflow.
    public var accelerators: OmicsClientTypes.Accelerators?
    /// The URI of a definition for the workflow.
    public var definitionUri: Swift.String?
    /// A ZIP archive for the workflow.
    public var definitionZip: ClientRuntime.Data?
    /// A description for the workflow.
    public var description: Swift.String?
    /// An engine for the workflow.
    public var engine: OmicsClientTypes.WorkflowEngine?
    /// The path of the main definition file for the workflow.
    public var main: Swift.String?
    /// A name for the workflow.
    public var name: Swift.String?
    /// A parameter template for the workflow.
    public var parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    /// To ensure that requests don't run multiple times, specify a unique ID for each request.
    /// This member is required.
    public var requestId: Swift.String?
    /// A storage capacity for the workflow in gigabytes.
    public var storageCapacity: Swift.Int?
    /// Tags for the workflow.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accelerators: OmicsClientTypes.Accelerators? = nil,
        definitionUri: Swift.String? = nil,
        definitionZip: ClientRuntime.Data? = nil,
        description: Swift.String? = nil,
        engine: OmicsClientTypes.WorkflowEngine? = nil,
        main: Swift.String? = nil,
        name: Swift.String? = nil,
        parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil,
        requestId: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accelerators = accelerators
        self.definitionUri = definitionUri
        self.definitionZip = definitionZip
        self.description = description
        self.engine = engine
        self.main = main
        self.name = name
        self.parameterTemplate = parameterTemplate
        self.requestId = requestId
        self.storageCapacity = storageCapacity
        self.tags = tags
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let engine: OmicsClientTypes.WorkflowEngine?
    let definitionZip: ClientRuntime.Data?
    let definitionUri: Swift.String?
    let main: Swift.String?
    let parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    let storageCapacity: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let requestId: Swift.String?
    let accelerators: OmicsClientTypes.Accelerators?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators
        case definitionUri
        case definitionZip
        case description
        case engine
        case main
        case name
        case parameterTemplate
        case requestId
        case storageCapacity
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowEngine.self, forKey: .engine)
        engine = engineDecoded
        let definitionZipDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .definitionZip)
        definitionZip = definitionZipDecoded
        let definitionUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definitionUri)
        definitionUri = definitionUriDecoded
        let mainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .main)
        main = mainDecoded
        let parameterTemplateContainer = try containerValues.decodeIfPresent([Swift.String: OmicsClientTypes.WorkflowParameter?].self, forKey: .parameterTemplate)
        var parameterTemplateDecoded0: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil
        if let parameterTemplateContainer = parameterTemplateContainer {
            parameterTemplateDecoded0 = [Swift.String:OmicsClientTypes.WorkflowParameter]()
            for (key0, workflowparameter0) in parameterTemplateContainer {
                if let workflowparameter0 = workflowparameter0 {
                    parameterTemplateDecoded0?[key0] = workflowparameter0
                }
            }
        }
        parameterTemplate = parameterTemplateDecoded0
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let acceleratorsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.Accelerators.self, forKey: .accelerators)
        accelerators = acceleratorsDecoded
    }
}

extension CreateWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateWorkflowOutput: Swift.Equatable {
    /// The workflow's ARN.
    public var arn: Swift.String?
    /// The workflow's ID.
    public var id: Swift.String?
    /// The workflow's status.
    public var status: OmicsClientTypes.WorkflowStatus?
    /// The workflow's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: OmicsClientTypes.WorkflowStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
        self.tags = tags
    }
}

struct CreateWorkflowOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.WorkflowStatus?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes {
    public enum CreationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `import`
        case upload
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationType] {
            return [
                .import,
                .upload,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .import: return "IMPORT"
            case .upload: return "UPLOAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreationType(rawValue: rawValue) ?? CreationType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAnnotationStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAnnotationStoreInput: Swift.Equatable {
    /// Whether to force deletion.
    public var force: Swift.Bool?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.force = force
        self.name = name
    }
}

struct DeleteAnnotationStoreInputBody: Swift.Equatable {
}

extension DeleteAnnotationStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnnotationStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAnnotationStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteAnnotationStoreOutput: Swift.Equatable {
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init(
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeleteAnnotationStoreOutputBody: Swift.Equatable {
    let status: OmicsClientTypes.StoreStatus?
}

extension DeleteAnnotationStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteAnnotationStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAnnotationStoreVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for versionname0 in versions {
                try versionsContainer.encode(versionname0)
            }
        }
    }
}

extension DeleteAnnotationStoreVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteAnnotationStoreVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/versions/delete"
    }
}

public struct DeleteAnnotationStoreVersionsInput: Swift.Equatable {
    /// Forces the deletion of an annotation store version when imports are in-progress..
    public var force: Swift.Bool?
    /// The name of the annotation store from which versions are being deleted.
    /// This member is required.
    public var name: Swift.String?
    /// The versions of an annotation store to be deleted.
    /// This member is required.
    public var versions: [Swift.String]?

    public init(
        force: Swift.Bool? = nil,
        name: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.force = force
        self.name = name
        self.versions = versions
    }
}

struct DeleteAnnotationStoreVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
}

extension DeleteAnnotationStoreVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension DeleteAnnotationStoreVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAnnotationStoreVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct DeleteAnnotationStoreVersionsOutput: Swift.Equatable {
    /// Any errors that occur when attempting to delete an annotation store version.
    public var errors: [OmicsClientTypes.VersionDeleteError]?

    public init(
        errors: [OmicsClientTypes.VersionDeleteError]? = nil
    )
    {
        self.errors = errors
    }
}

struct DeleteAnnotationStoreVersionsOutputBody: Swift.Equatable {
    let errors: [OmicsClientTypes.VersionDeleteError]?
}

extension DeleteAnnotationStoreVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VersionDeleteError?].self, forKey: .errors)
        var errorsDecoded0:[OmicsClientTypes.VersionDeleteError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [OmicsClientTypes.VersionDeleteError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum DeleteAnnotationStoreVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())"
    }
}

public struct DeleteReferenceInput: Swift.Equatable {
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

struct DeleteReferenceInputBody: Swift.Equatable {
}

extension DeleteReferenceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReferenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReferenceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReferenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReferenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(id.urlPercentEncoding())"
    }
}

public struct DeleteReferenceStoreInput: Swift.Equatable {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteReferenceStoreInputBody: Swift.Equatable {
}

extension DeleteReferenceStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReferenceStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReferenceStoreOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReferenceStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct DeleteRunGroupInput: Swift.Equatable {
    /// The run group's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteRunGroupInputBody: Swift.Equatable {
}

extension DeleteRunGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRunGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRunGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRunGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())"
    }
}

public struct DeleteRunInput: Swift.Equatable {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteRunInputBody: Swift.Equatable {
}

extension DeleteRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRunOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSequenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(id.urlPercentEncoding())"
    }
}

public struct DeleteSequenceStoreInput: Swift.Equatable {
    /// The sequence store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSequenceStoreInputBody: Swift.Equatable {
}

extension DeleteSequenceStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSequenceStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSequenceStoreOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSequenceStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let shareId = shareId else {
            return nil
        }
        return "/share/\(shareId.urlPercentEncoding())"
    }
}

public struct DeleteShareInput: Swift.Equatable {
    /// The ID for the share request to be deleted.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

struct DeleteShareInputBody: Swift.Equatable {
}

extension DeleteShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteShareOutput: Swift.Equatable {
    /// The status of the share being deleted.
    public var status: OmicsClientTypes.ShareStatus?

    public init(
        status: OmicsClientTypes.ShareStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeleteShareOutputBody: Swift.Equatable {
    let status: OmicsClientTypes.ShareStatus?
}

extension DeleteShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVariantStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct DeleteVariantStoreInput: Swift.Equatable {
    /// Whether to force deletion.
    public var force: Swift.Bool?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.force = force
        self.name = name
    }
}

struct DeleteVariantStoreInputBody: Swift.Equatable {
}

extension DeleteVariantStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVariantStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVariantStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteVariantStoreOutput: Swift.Equatable {
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init(
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeleteVariantStoreOutputBody: Swift.Equatable {
    let status: OmicsClientTypes.StoreStatus?
}

extension DeleteVariantStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteVariantStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
}

extension DeleteWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkflowOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.ETag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm
        case source1
        case source2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = self.algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let source1 = self.source1 {
            try encodeContainer.encode(source1, forKey: .source1)
        }
        if let source2 = self.source2 {
            try encodeContainer.encode(source2, forKey: .source2)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ETagAlgorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let source1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source1)
        source1 = source1Decoded
        let source2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source2)
        source2 = source2Decoded
    }
}

extension OmicsClientTypes {
    /// The entity tag (ETag) is a hash of the object representing its semantic content.
    public struct ETag: Swift.Equatable {
        /// The algorithm used to calculate the read sets ETag(s).
        public var algorithm: OmicsClientTypes.ETagAlgorithm?
        /// The ETag hash calculated on Source1 of the read set.
        public var source1: Swift.String?
        /// The ETag hash calculated on Source2 of the read set.
        public var source2: Swift.String?

        public init(
            algorithm: OmicsClientTypes.ETagAlgorithm? = nil,
            source1: Swift.String? = nil,
            source2: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes {
    public enum ETagAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bamMd5up
        case cramMd5up
        case fastqMd5up
        case sdkUnknown(Swift.String)

        public static var allCases: [ETagAlgorithm] {
            return [
                .bamMd5up,
                .cramMd5up,
                .fastqMd5up,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bamMd5up: return "BAM_MD5up"
            case .cramMd5up: return "CRAM_MD5up"
            case .fastqMd5up: return "FASTQ_MD5up"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ETagAlgorithm(rawValue: rawValue) ?? ETagAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// KMS
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ExportReadSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readSetId = self.readSetId {
            try encodeContainer.encode(readSetId, forKey: .readSetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
    }
}

extension OmicsClientTypes {
    /// A read set.
    public struct ExportReadSet: Swift.Equatable {
        /// The set's ID.
        /// This member is required.
        public var readSetId: Swift.String?

        public init(
            readSetId: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
        }
    }

}

extension OmicsClientTypes.ExportReadSetDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a read set.
    public struct ExportReadSetDetail: Swift.Equatable {
        /// The set's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The set's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetExportJobItemStatus?
        /// The set's status message.
        public var statusMessage: Swift.String?

        public init(
            id: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetExportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.id = id
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.ExportReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// An read set export job filter.
    public struct ExportReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetExportJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetExportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ExportReadSetJobDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destination
        case id
        case sequenceStoreId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a read set export job.
    public struct ExportReadSetJobDetail: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination in Amazon S3.
        /// This member is required.
        public var destination: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetExportJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destination: Swift.String? = nil,
            id: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetExportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.FileInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentLength
        case partSize
        case totalParts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentLength = self.contentLength {
            try encodeContainer.encode(contentLength, forKey: .contentLength)
        }
        if let partSize = self.partSize {
            try encodeContainer.encode(partSize, forKey: .partSize)
        }
        if let totalParts = self.totalParts {
            try encodeContainer.encode(totalParts, forKey: .totalParts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalPartsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalParts)
        totalParts = totalPartsDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
        let contentLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentLength)
        contentLength = contentLengthDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a file.
    public struct FileInformation: Swift.Equatable {
        /// The file's content length.
        public var contentLength: Swift.Int?
        /// The file's part size.
        public var partSize: Swift.Int?
        /// The file's total parts.
        public var totalParts: Swift.Int?

        public init(
            contentLength: Swift.Int? = nil,
            partSize: Swift.Int? = nil,
            totalParts: Swift.Int? = nil
        )
        {
            self.contentLength = contentLength
            self.partSize = partSize
            self.totalParts = totalParts
        }
    }

}

extension OmicsClientTypes {
    public enum FileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bam
        case cram
        case fastq
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .bam,
                .cram,
                .fastq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bam: return "BAM"
            case .cram: return "CRAM"
            case .fastq: return "FASTQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileType(rawValue: rawValue) ?? FileType.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArns
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let status = status {
            var statusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .status)
            for sharestatus0 in status {
                try statusContainer.encode(sharestatus0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let statusContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ShareStatus?].self, forKey: .status)
        var statusDecoded0:[OmicsClientTypes.ShareStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [OmicsClientTypes.ShareStatus]()
            for string0 in statusContainer {
                if let string0 = string0 {
                    statusDecoded0?.append(string0)
                }
            }
        }
        status = statusDecoded0
    }
}

extension OmicsClientTypes {
    /// Use filters to focus the returned annotation store versions on a specific parameter, such as the status of the annotation store.
    public struct Filter: Swift.Equatable {
        /// The Amazon Resource Number (Arn) for an analytics store.
        public var resourceArns: [Swift.String]?
        /// The status of an annotation store version.
        public var status: [OmicsClientTypes.ShareStatus]?

        public init(
            resourceArns: [Swift.String]? = nil,
            status: [OmicsClientTypes.ShareStatus]? = nil
        )
        {
            self.resourceArns = resourceArns
            self.status = status
        }
    }

}

extension OmicsClientTypes.FormatOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tsvoptions = "tsvOptions"
        case vcfoptions = "vcfOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tsvoptions(tsvoptions):
                try container.encode(tsvoptions, forKey: .tsvoptions)
            case let .vcfoptions(vcfoptions):
                try container.encode(vcfoptions, forKey: .vcfoptions)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tsvoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.TsvOptions.self, forKey: .tsvoptions)
        if let tsvoptions = tsvoptionsDecoded {
            self = .tsvoptions(tsvoptions)
            return
        }
        let vcfoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.VcfOptions.self, forKey: .vcfoptions)
        if let vcfoptions = vcfoptionsDecoded {
            self = .vcfoptions(vcfoptions)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// Formatting options for a file.
    public enum FormatOptions: Swift.Equatable {
        /// Options for a TSV file.
        case tsvoptions(OmicsClientTypes.TsvOptions)
        /// Options for a VCF file.
        case vcfoptions(OmicsClientTypes.VcfOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {
    public enum FormatToHeaderKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alt
        case chr
        case end
        case pos
        case ref
        case start
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatToHeaderKey] {
            return [
                .alt,
                .chr,
                .end,
                .pos,
                .ref,
                .start,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alt: return "ALT"
            case .chr: return "CHR"
            case .end: return "END"
            case .pos: return "POS"
            case .ref: return "REF"
            case .start: return "START"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormatToHeaderKey(rawValue: rawValue) ?? FormatToHeaderKey.sdkUnknown(rawValue)
        }
    }
}

extension GetAnnotationImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/annotation/\(jobId.urlPercentEncoding())"
    }
}

public struct GetAnnotationImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetAnnotationImportJobInputBody: Swift.Equatable {
}

extension GetAnnotationImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAnnotationImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnnotationImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.annotationFields = output.annotationFields
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.destinationName = output.destinationName
            self.formatOptions = output.formatOptions
            self.id = output.id
            self.items = output.items
            self.roleArn = output.roleArn
            self.runLeftNormalization = output.runLeftNormalization
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.updateTime = output.updateTime
            self.versionName = output.versionName
        } else {
            self.annotationFields = nil
            self.completionTime = nil
            self.creationTime = nil
            self.destinationName = nil
            self.formatOptions = nil
            self.id = nil
            self.items = nil
            self.roleArn = nil
            self.runLeftNormalization = false
            self.status = nil
            self.statusMessage = nil
            self.updateTime = nil
            self.versionName = nil
        }
    }
}

public struct GetAnnotationImportJobOutput: Swift.Equatable {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// When the job completed.
    /// This member is required.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination annotation store.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Formatting options for a file.
    /// This member is required.
    public var formatOptions: OmicsClientTypes.FormatOptions?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's imported items.
    /// This member is required.
    public var items: [OmicsClientTypes.AnnotationImportItemDetail]?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    /// This member is required.
    public var runLeftNormalization: Swift.Bool
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.JobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// When the job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?
    /// The name of the annotation store version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        formatOptions: OmicsClientTypes.FormatOptions? = nil,
        id: Swift.String? = nil,
        items: [OmicsClientTypes.AnnotationImportItemDetail]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool = false,
        status: OmicsClientTypes.JobStatus? = nil,
        statusMessage: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.annotationFields = annotationFields
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.formatOptions = formatOptions
        self.id = id
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.status = status
        self.statusMessage = statusMessage
        self.updateTime = updateTime
        self.versionName = versionName
    }
}

struct GetAnnotationImportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let destinationName: Swift.String?
    let versionName: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.JobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let items: [OmicsClientTypes.AnnotationImportItemDetail]?
    let runLeftNormalization: Swift.Bool
    let formatOptions: OmicsClientTypes.FormatOptions?
    let annotationFields: [Swift.String:Swift.String]?
}

extension GetAnnotationImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case completionTime
        case creationTime
        case destinationName
        case formatOptions
        case id
        case items
        case roleArn
        case runLeftNormalization
        case status
        case statusMessage
        case updateTime
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationImportItemDetail?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.AnnotationImportItemDetail]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.AnnotationImportItemDetail]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let annotationFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .annotationFields)
        var annotationFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let annotationFieldsContainer = annotationFieldsContainer {
            annotationFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in annotationFieldsContainer {
                if let string0 = string0 {
                    annotationFieldsDecoded0?[key0] = string0
                }
            }
        }
        annotationFields = annotationFieldsDecoded0
    }
}

enum GetAnnotationImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct GetAnnotationStoreInput: Swift.Equatable {
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetAnnotationStoreInputBody: Swift.Equatable {
}

extension GetAnnotationStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAnnotationStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnnotationStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.numVersions = output.numVersions
            self.reference = output.reference
            self.sseConfig = output.sseConfig
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storeArn = output.storeArn
            self.storeFormat = output.storeFormat
            self.storeOptions = output.storeOptions
            self.storeSizeBytes = output.storeSizeBytes
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.numVersions = nil
            self.reference = nil
            self.sseConfig = nil
            self.status = nil
            self.statusMessage = nil
            self.storeArn = nil
            self.storeFormat = nil
            self.storeOptions = nil
            self.storeSizeBytes = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetAnnotationStoreOutput: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// An integer indicating how many versions of an annotation store exist.
    /// This member is required.
    public var numVersions: Swift.Int?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's server-side encryption (SSE) settings.
    /// This member is required.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// A status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store's ARN.
    /// This member is required.
    public var storeArn: Swift.String?
    /// The store's annotation file format.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// The store's parsing options.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// The store's size in bytes.
    /// This member is required.
    public var storeSizeBytes: Swift.Int?
    /// The store's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        numVersions: Swift.Int? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeArn: Swift.String? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        storeSizeBytes: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.numVersions = numVersions
        self.reference = reference
        self.sseConfig = sseConfig
        self.status = status
        self.statusMessage = statusMessage
        self.storeArn = storeArn
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.storeSizeBytes = storeSizeBytes
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetAnnotationStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let storeArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let storeOptions: OmicsClientTypes.StoreOptions?
    let storeFormat: OmicsClientTypes.StoreFormat?
    let statusMessage: Swift.String?
    let storeSizeBytes: Swift.Int?
    let numVersions: Swift.Int?
}

extension GetAnnotationStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case numVersions
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeFormat
        case storeOptions
        case storeSizeBytes
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
        let numVersionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numVersions)
        numVersions = numVersionsDecoded
    }
}

enum GetAnnotationStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAnnotationStoreVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        guard let versionName = versionName else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/version/\(versionName.urlPercentEncoding())"
    }
}

public struct GetAnnotationStoreVersionInput: Swift.Equatable {
    /// The name given to an annotation store version to distinguish it from others.
    /// This member is required.
    public var name: Swift.String?
    /// The name given to an annotation store version to distinguish it from others.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.name = name
        self.versionName = versionName
    }
}

struct GetAnnotationStoreVersionInputBody: Swift.Equatable {
}

extension GetAnnotationStoreVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAnnotationStoreVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnnotationStoreVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storeId = output.storeId
            self.tags = output.tags
            self.updateTime = output.updateTime
            self.versionArn = output.versionArn
            self.versionName = output.versionName
            self.versionOptions = output.versionOptions
            self.versionSizeBytes = output.versionSizeBytes
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.storeId = nil
            self.tags = nil
            self.updateTime = nil
            self.versionArn = nil
            self.versionName = nil
            self.versionOptions = nil
            self.versionSizeBytes = nil
        }
    }
}

public struct GetAnnotationStoreVersionOutput: Swift.Equatable {
    /// The time stamp for when an annotation store version was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description for an annotation store version.
    /// This member is required.
    public var description: Swift.String?
    /// The annotation store version ID.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// The status of an annotation store version.
    /// This member is required.
    public var status: OmicsClientTypes.VersionStatus?
    /// The status of an annotation store version.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store ID for annotation store version.
    /// This member is required.
    public var storeId: Swift.String?
    /// Any tags associated with an annotation store version.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// The time stamp for when an annotation store version was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?
    /// The Arn for the annotation store.
    /// This member is required.
    public var versionArn: Swift.String?
    /// The name given to an annotation store version to distinguish it from others.
    /// This member is required.
    public var versionName: Swift.String?
    /// The options for an annotation store version.
    public var versionOptions: OmicsClientTypes.VersionOptions?
    /// The size of the annotation store version in Bytes.
    /// This member is required.
    public var versionSizeBytes: Swift.Int?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OmicsClientTypes.VersionStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil,
        versionArn: Swift.String? = nil,
        versionName: Swift.String? = nil,
        versionOptions: OmicsClientTypes.VersionOptions? = nil,
        versionSizeBytes: Swift.Int? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.storeId = storeId
        self.tags = tags
        self.updateTime = updateTime
        self.versionArn = versionArn
        self.versionName = versionName
        self.versionOptions = versionOptions
        self.versionSizeBytes = versionSizeBytes
    }
}

struct GetAnnotationStoreVersionOutputBody: Swift.Equatable {
    let storeId: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.VersionStatus?
    let versionArn: Swift.String?
    let name: Swift.String?
    let versionName: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let versionOptions: OmicsClientTypes.VersionOptions?
    let statusMessage: Swift.String?
    let versionSizeBytes: Swift.Int?
}

extension GetAnnotationStoreVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case status
        case statusMessage
        case storeId
        case tags
        case updateTime
        case versionArn
        case versionName
        case versionOptions
        case versionSizeBytes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeId)
        storeId = storeIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionStatus.self, forKey: .status)
        status = statusDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let versionOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionOptions.self, forKey: .versionOptions)
        versionOptions = versionOptionsDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let versionSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionSizeBytes)
        versionSizeBytes = versionSizeBytesDecoded
    }
}

enum GetAnnotationStoreVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadSetActivationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetActivationJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetActivationJobInputBody: Swift.Equatable {
}

extension GetReadSetActivationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetActivationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadSetActivationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.id = output.id
            self.sequenceStoreId = output.sequenceStoreId
            self.sources = output.sources
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.id = nil
            self.sequenceStoreId = nil
            self.sources = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReadSetActivationJobOutput: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    public var sources: [OmicsClientTypes.ActivateReadSetSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetActivationJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ActivateReadSetSourceItem]? = nil,
        status: OmicsClientTypes.ReadSetActivationJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReadSetActivationJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let status: OmicsClientTypes.ReadSetActivationJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let sources: [OmicsClientTypes.ActivateReadSetSourceItem]?
}

extension GetReadSetActivationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case sequenceStoreId
        case sources
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ActivateReadSetSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ActivateReadSetSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ActivateReadSetSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

enum GetReadSetActivationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadSetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetExportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetExportJobInputBody: Swift.Equatable {
}

extension GetReadSetExportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadSetExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.id = output.id
            self.readSets = output.readSets
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.destination = nil
            self.id = nil
            self.readSets = nil
            self.sequenceStoreId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReadSetExportJobOutput: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination in Amazon S3.
    /// This member is required.
    public var destination: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's read sets.
    public var readSets: [OmicsClientTypes.ExportReadSetDetail]?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetExportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        id: Swift.String? = nil,
        readSets: [OmicsClientTypes.ExportReadSetDetail]? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetExportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destination = destination
        self.id = id
        self.readSets = readSets
        self.sequenceStoreId = sequenceStoreId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReadSetExportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let destination: Swift.String?
    let status: OmicsClientTypes.ReadSetExportJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let readSets: [OmicsClientTypes.ExportReadSetDetail]?
}

extension GetReadSetExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destination
        case id
        case readSets
        case sequenceStoreId
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let readSetsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ExportReadSetDetail?].self, forKey: .readSets)
        var readSetsDecoded0:[OmicsClientTypes.ExportReadSetDetail]? = nil
        if let readSetsContainer = readSetsContainer {
            readSetsDecoded0 = [OmicsClientTypes.ExportReadSetDetail]()
            for structure0 in readSetsContainer {
                if let structure0 = structure0 {
                    readSetsDecoded0?.append(structure0)
                }
            }
        }
        readSets = readSetsDecoded0
    }
}

enum GetReadSetExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadSetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetImportJobInputBody: Swift.Equatable {
}

extension GetReadSetImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadSetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.id = output.id
            self.roleArn = output.roleArn
            self.sequenceStoreId = output.sequenceStoreId
            self.sources = output.sources
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.id = nil
            self.roleArn = nil
            self.sequenceStoreId = nil
            self.sources = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReadSetImportJobOutput: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.ImportReadSetSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetImportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ImportReadSetSourceItem]? = nil,
        status: OmicsClientTypes.ReadSetImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReadSetImportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReadSetImportJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let sources: [OmicsClientTypes.ImportReadSetSourceItem]?
}

extension GetReadSetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case roleArn
        case sequenceStoreId
        case sources
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReadSetSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ImportReadSetSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ImportReadSetSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

enum GetReadSetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let file = file {
                let fileQueryItem = ClientRuntime.URLQueryItem(name: "file".urlPercentEncoding(), value: Swift.String(file.rawValue).urlPercentEncoding())
                items.append(fileQueryItem)
            }
            guard let partNumber = partNumber else {
                let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
            return items
        }
    }
}

extension GetReadSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetInput: Swift.Equatable {
    /// The file to retrieve.
    public var file: OmicsClientTypes.ReadSetFile?
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The part number to retrieve.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        file: OmicsClientTypes.ReadSetFile? = nil,
        id: Swift.String? = nil,
        partNumber: Swift.Int? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.file = file
        self.id = id
        self.partNumber = partNumber
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetInputBody: Swift.Equatable {
}

extension GetReadSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/\(id.urlPercentEncoding())/metadata"
    }
}

public struct GetReadSetMetadataInput: Swift.Equatable {
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetMetadataInputBody: Swift.Equatable {
}

extension GetReadSetMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadSetMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.creationType = output.creationType
            self.description = output.description
            self.etag = output.etag
            self.fileType = output.fileType
            self.files = output.files
            self.id = output.id
            self.name = output.name
            self.referenceArn = output.referenceArn
            self.sampleId = output.sampleId
            self.sequenceInformation = output.sequenceInformation
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.subjectId = output.subjectId
        } else {
            self.arn = nil
            self.creationTime = nil
            self.creationType = nil
            self.description = nil
            self.etag = nil
            self.fileType = nil
            self.files = nil
            self.id = nil
            self.name = nil
            self.referenceArn = nil
            self.sampleId = nil
            self.sequenceInformation = nil
            self.sequenceStoreId = nil
            self.status = nil
            self.statusMessage = nil
            self.subjectId = nil
        }
    }
}

public struct GetReadSetMetadataOutput: Swift.Equatable {
    /// The read set's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the read set was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The creation type of the read set.
    public var creationType: OmicsClientTypes.CreationType?
    /// The read set's description.
    public var description: Swift.String?
    /// The entity tag (ETag) is a hash of the object meant to represent its semantic content.
    public var etag: OmicsClientTypes.ETag?
    /// The read set's file type.
    /// This member is required.
    public var fileType: OmicsClientTypes.FileType?
    /// The read set's files.
    public var files: OmicsClientTypes.ReadSetFiles?
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's name.
    public var name: Swift.String?
    /// The read set's genome reference ARN.
    public var referenceArn: Swift.String?
    /// The read set's sample ID.
    public var sampleId: Swift.String?
    /// The read set's sequence information.
    public var sequenceInformation: OmicsClientTypes.SequenceInformation?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The read set's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetStatus?
    /// The status message for a read set. It provides more detail as to why the read set has a status.
    public var statusMessage: Swift.String?
    /// The read set's subject ID.
    public var subjectId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        creationType: OmicsClientTypes.CreationType? = nil,
        description: Swift.String? = nil,
        etag: OmicsClientTypes.ETag? = nil,
        fileType: OmicsClientTypes.FileType? = nil,
        files: OmicsClientTypes.ReadSetFiles? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceInformation: OmicsClientTypes.SequenceInformation? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetStatus? = nil,
        statusMessage: Swift.String? = nil,
        subjectId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creationType = creationType
        self.description = description
        self.etag = etag
        self.fileType = fileType
        self.files = files
        self.id = id
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceInformation = sequenceInformation
        self.sequenceStoreId = sequenceStoreId
        self.status = status
        self.statusMessage = statusMessage
        self.subjectId = subjectId
    }
}

struct GetReadSetMetadataOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let sequenceStoreId: Swift.String?
    let subjectId: Swift.String?
    let sampleId: Swift.String?
    let status: OmicsClientTypes.ReadSetStatus?
    let name: Swift.String?
    let description: Swift.String?
    let fileType: OmicsClientTypes.FileType?
    let creationTime: ClientRuntime.Date?
    let sequenceInformation: OmicsClientTypes.SequenceInformation?
    let referenceArn: Swift.String?
    let files: OmicsClientTypes.ReadSetFiles?
    let statusMessage: Swift.String?
    let creationType: OmicsClientTypes.CreationType?
    let etag: OmicsClientTypes.ETag?
}

extension GetReadSetMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case creationType
        case description
        case etag
        case fileType
        case files
        case id
        case name
        case referenceArn
        case sampleId
        case sequenceInformation
        case sequenceStoreId
        case status
        case statusMessage
        case subjectId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let fileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let sequenceInformationDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SequenceInformation.self, forKey: .sequenceInformation)
        sequenceInformation = sequenceInformationDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let filesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetFiles.self, forKey: .files)
        files = filesDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.CreationType.self, forKey: .creationType)
        creationType = creationTypeDecoded
        let etagDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ETag.self, forKey: .etag)
        etag = etagDecoded
    }
}

enum GetReadSetMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.payload = .data(data)
        case .stream(let stream):
            self.payload = .stream(stream)
        case .none:
            self.payload = nil
        }
    }
}

public struct GetReadSetOutput: Swift.Equatable {
    /// The read set file payload.
    public var payload: ClientRuntime.ByteStream?

    public init(
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

struct GetReadSetOutputBody: Swift.Equatable {
    let payload: ClientRuntime.ByteStream?
}

extension GetReadSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetReadSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RangeNotSatisfiableException": return try await RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReferenceImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

struct GetReferenceImportJobInputBody: Swift.Equatable {
}

extension GetReferenceImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReferenceImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.id = output.id
            self.referenceStoreId = output.referenceStoreId
            self.roleArn = output.roleArn
            self.sources = output.sources
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.id = nil
            self.referenceStoreId = nil
            self.roleArn = nil
            self.sources = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReferenceImportJobOutput: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.ImportReferenceSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReferenceImportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sources: [OmicsClientTypes.ImportReferenceSourceItem]? = nil,
        status: OmicsClientTypes.ReferenceImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReferenceImportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let referenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReferenceImportJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let sources: [OmicsClientTypes.ImportReferenceSourceItem]?
}

extension GetReferenceImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case referenceStoreId
        case roleArn
        case sources
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReferenceSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ImportReferenceSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ImportReferenceSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

enum GetReferenceImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReferenceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        return items
    }
}

extension GetReferenceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let file = file {
                let fileQueryItem = ClientRuntime.URLQueryItem(name: "file".urlPercentEncoding(), value: Swift.String(file.rawValue).urlPercentEncoding())
                items.append(fileQueryItem)
            }
            guard let partNumber = partNumber else {
                let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
            return items
        }
    }
}

extension GetReferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceInput: Swift.Equatable {
    /// The file to retrieve.
    public var file: OmicsClientTypes.ReferenceFile?
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The part number to retrieve.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The range to retrieve.
    public var range: Swift.String?
    /// The reference's store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        file: OmicsClientTypes.ReferenceFile? = nil,
        id: Swift.String? = nil,
        partNumber: Swift.Int? = nil,
        range: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.file = file
        self.id = id
        self.partNumber = partNumber
        self.range = range
        self.referenceStoreId = referenceStoreId
    }
}

struct GetReferenceInputBody: Swift.Equatable {
}

extension GetReferenceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())/metadata"
    }
}

public struct GetReferenceMetadataInput: Swift.Equatable {
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

struct GetReferenceMetadataInputBody: Swift.Equatable {
}

extension GetReferenceMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReferenceMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.files = output.files
            self.id = output.id
            self.md5 = output.md5
            self.name = output.name
            self.referenceStoreId = output.referenceStoreId
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.files = nil
            self.id = nil
            self.md5 = nil
            self.name = nil
            self.referenceStoreId = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetReferenceMetadataOutput: Swift.Equatable {
    /// The reference's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the reference was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The reference's description.
    public var description: Swift.String?
    /// The reference's files.
    public var files: OmicsClientTypes.ReferenceFiles?
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's MD5 checksum.
    /// This member is required.
    public var md5: Swift.String?
    /// The reference's name.
    public var name: Swift.String?
    /// The reference's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The reference's status.
    public var status: OmicsClientTypes.ReferenceStatus?
    /// When the reference was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        files: OmicsClientTypes.ReferenceFiles? = nil,
        id: Swift.String? = nil,
        md5: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReferenceStatus? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.files = files
        self.id = id
        self.md5 = md5
        self.name = name
        self.referenceStoreId = referenceStoreId
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetReferenceMetadataOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let referenceStoreId: Swift.String?
    let md5: Swift.String?
    let status: OmicsClientTypes.ReferenceStatus?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let files: OmicsClientTypes.ReferenceFiles?
}

extension GetReferenceMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case files
        case id
        case md5
        case name
        case referenceStoreId
        case status
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let md5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5)
        md5 = md5Decoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let filesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceFiles.self, forKey: .files)
        files = filesDecoded
    }
}

enum GetReferenceMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReferenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.payload = .data(data)
        case .stream(let stream):
            self.payload = .stream(stream)
        case .none:
            self.payload = nil
        }
    }
}

public struct GetReferenceOutput: Swift.Equatable {
    /// The reference file payload.
    public var payload: ClientRuntime.ByteStream?

    public init(
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

struct GetReferenceOutputBody: Swift.Equatable {
    let payload: ClientRuntime.ByteStream?
}

extension GetReferenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetReferenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RangeNotSatisfiableException": return try await RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReferenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceStoreInput: Swift.Equatable {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetReferenceStoreInputBody: Swift.Equatable {
}

extension GetReferenceStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReferenceStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct GetReferenceStoreOutput: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's server-side encryption (SSE) settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct GetReferenceStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
}

extension GetReferenceStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum GetReferenceStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct GetRunGroupInput: Swift.Equatable {
    /// The group's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetRunGroupInputBody: Swift.Equatable {
}

extension GetRunGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRunGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRunGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.id = output.id
            self.maxCpus = output.maxCpus
            self.maxDuration = output.maxDuration
            self.maxGpus = output.maxGpus
            self.maxRuns = output.maxRuns
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.id = nil
            self.maxCpus = nil
            self.maxDuration = nil
            self.maxGpus = nil
            self.maxRuns = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetRunGroupOutput: Swift.Equatable {
    /// The group's ARN.
    public var arn: Swift.String?
    /// When the group was created.
    public var creationTime: ClientRuntime.Date?
    /// The group's ID.
    public var id: Swift.String?
    /// The group's maximum number of CPUs to use.
    public var maxCpus: Swift.Int?
    /// The group's maximum run time in minutes.
    public var maxDuration: Swift.Int?
    /// The maximum GPUs that can be used by a run group.
    public var maxGpus: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// The group's name.
    public var name: Swift.String?
    /// The group's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxGpus: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.id = id
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxGpus = maxGpus
        self.maxRuns = maxRuns
        self.name = name
        self.tags = tags
    }
}

struct GetRunGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let maxCpus: Swift.Int?
    let maxRuns: Swift.Int?
    let maxDuration: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let maxGpus: Swift.Int?
}

extension GetRunGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case id
        case maxCpus
        case maxDuration
        case maxGpus
        case maxRuns
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let maxGpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxGpus)
        maxGpus = maxGpusDecoded
    }
}

enum GetRunGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRunInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let export = export {
                export.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "export".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())"
    }
}

public struct GetRunInput: Swift.Equatable {
    /// The run's export format.
    public var export: [OmicsClientTypes.RunExport]?
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        export: [OmicsClientTypes.RunExport]? = nil,
        id: Swift.String? = nil
    )
    {
        self.export = export
        self.id = id
    }
}

struct GetRunInputBody: Swift.Equatable {
}

extension GetRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.definition = output.definition
            self.digest = output.digest
            self.id = output.id
            self.logLevel = output.logLevel
            self.name = output.name
            self.outputUri = output.outputUri
            self.parameters = output.parameters
            self.priority = output.priority
            self.resourceDigests = output.resourceDigests
            self.retentionMode = output.retentionMode
            self.roleArn = output.roleArn
            self.runGroupId = output.runGroupId
            self.runId = output.runId
            self.startTime = output.startTime
            self.startedBy = output.startedBy
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.stopTime = output.stopTime
            self.storageCapacity = output.storageCapacity
            self.tags = output.tags
            self.workflowId = output.workflowId
            self.workflowType = output.workflowType
        } else {
            self.accelerators = nil
            self.arn = nil
            self.creationTime = nil
            self.definition = nil
            self.digest = nil
            self.id = nil
            self.logLevel = nil
            self.name = nil
            self.outputUri = nil
            self.parameters = nil
            self.priority = nil
            self.resourceDigests = nil
            self.retentionMode = nil
            self.roleArn = nil
            self.runGroupId = nil
            self.runId = nil
            self.startTime = nil
            self.startedBy = nil
            self.status = nil
            self.statusMessage = nil
            self.stopTime = nil
            self.storageCapacity = nil
            self.tags = nil
            self.workflowId = nil
            self.workflowType = nil
        }
    }
}

public struct GetRunOutput: Swift.Equatable {
    /// The computational accelerator used to run the workflow.
    public var accelerators: OmicsClientTypes.Accelerators?
    /// The run's ARN.
    public var arn: Swift.String?
    /// When the run was created.
    public var creationTime: ClientRuntime.Date?
    /// The run's definition.
    public var definition: Swift.String?
    /// The run's digest.
    public var digest: Swift.String?
    /// The run's ID.
    public var id: Swift.String?
    /// The run's log level.
    public var logLevel: OmicsClientTypes.RunLogLevel?
    /// The run's name.
    public var name: Swift.String?
    /// The run's output URI.
    public var outputUri: Swift.String?
    /// The run's parameters.
    public var parameters: ClientRuntime.Document?
    /// The run's priority.
    public var priority: Swift.Int?
    /// The run's resource digests.
    public var resourceDigests: [Swift.String:Swift.String]?
    /// The run's retention mode.
    public var retentionMode: OmicsClientTypes.RunRetentionMode?
    /// The run's service role ARN.
    public var roleArn: Swift.String?
    /// The run's group ID.
    public var runGroupId: Swift.String?
    /// The run's ID.
    public var runId: Swift.String?
    /// When the run started.
    public var startTime: ClientRuntime.Date?
    /// Who started the run.
    public var startedBy: Swift.String?
    /// The run's status.
    public var status: OmicsClientTypes.RunStatus?
    /// The run's status message.
    public var statusMessage: Swift.String?
    /// The run's stop time.
    public var stopTime: ClientRuntime.Date?
    /// The run's storage capacity in gigabytes.
    public var storageCapacity: Swift.Int?
    /// The run's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The run's workflow ID.
    public var workflowId: Swift.String?
    /// The run's workflow type.
    public var workflowType: OmicsClientTypes.WorkflowType?

    public init(
        accelerators: OmicsClientTypes.Accelerators? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        digest: Swift.String? = nil,
        id: Swift.String? = nil,
        logLevel: OmicsClientTypes.RunLogLevel? = nil,
        name: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        parameters: ClientRuntime.Document? = nil,
        priority: Swift.Int? = nil,
        resourceDigests: [Swift.String:Swift.String]? = nil,
        retentionMode: OmicsClientTypes.RunRetentionMode? = nil,
        roleArn: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        runId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        startedBy: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil,
        statusMessage: Swift.String? = nil,
        stopTime: ClientRuntime.Date? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowType: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.accelerators = accelerators
        self.arn = arn
        self.creationTime = creationTime
        self.definition = definition
        self.digest = digest
        self.id = id
        self.logLevel = logLevel
        self.name = name
        self.outputUri = outputUri
        self.parameters = parameters
        self.priority = priority
        self.resourceDigests = resourceDigests
        self.retentionMode = retentionMode
        self.roleArn = roleArn
        self.runGroupId = runGroupId
        self.runId = runId
        self.startTime = startTime
        self.startedBy = startedBy
        self.status = status
        self.statusMessage = statusMessage
        self.stopTime = stopTime
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

struct GetRunOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.RunStatus?
    let workflowId: Swift.String?
    let workflowType: OmicsClientTypes.WorkflowType?
    let runId: Swift.String?
    let roleArn: Swift.String?
    let name: Swift.String?
    let runGroupId: Swift.String?
    let priority: Swift.Int?
    let definition: Swift.String?
    let digest: Swift.String?
    let parameters: ClientRuntime.Document?
    let storageCapacity: Swift.Int?
    let outputUri: Swift.String?
    let logLevel: OmicsClientTypes.RunLogLevel?
    let resourceDigests: [Swift.String:Swift.String]?
    let startedBy: Swift.String?
    let creationTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let accelerators: OmicsClientTypes.Accelerators?
    let retentionMode: OmicsClientTypes.RunRetentionMode?
}

extension GetRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators
        case arn
        case creationTime
        case definition
        case digest
        case id
        case logLevel
        case name
        case outputUri
        case parameters
        case priority
        case resourceDigests
        case retentionMode
        case roleArn
        case runGroupId
        case runId
        case startTime
        case startedBy
        case status
        case statusMessage
        case stopTime
        case storageCapacity
        case tags
        case workflowId
        case workflowType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunStatus.self, forKey: .status)
        status = statusDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let runGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runGroupId)
        runGroupId = runGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .parameters)
        parameters = parametersDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunLogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let resourceDigestsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceDigests)
        var resourceDigestsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceDigestsContainer = resourceDigestsContainer {
            resourceDigestsDecoded0 = [Swift.String:Swift.String]()
            for (key0, runresourcedigest0) in resourceDigestsContainer {
                if let runresourcedigest0 = runresourcedigest0 {
                    resourceDigestsDecoded0?[key0] = runresourcedigest0
                }
            }
        }
        resourceDigests = resourceDigestsDecoded0
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let acceleratorsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.Accelerators.self, forKey: .accelerators)
        accelerators = acceleratorsDecoded
        let retentionModeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunRetentionMode.self, forKey: .retentionMode)
        retentionMode = retentionModeDecoded
    }
}

enum GetRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRunTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let taskId = taskId else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/task/\(taskId.urlPercentEncoding())"
    }
}

public struct GetRunTaskInput: Swift.Equatable {
    /// The task's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The task's ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        id: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.id = id
        self.taskId = taskId
    }
}

struct GetRunTaskInputBody: Swift.Equatable {
}

extension GetRunTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRunTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRunTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.cpus = output.cpus
            self.creationTime = output.creationTime
            self.gpus = output.gpus
            self.instanceType = output.instanceType
            self.logStream = output.logStream
            self.memory = output.memory
            self.name = output.name
            self.startTime = output.startTime
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.stopTime = output.stopTime
            self.taskId = output.taskId
        } else {
            self.cpus = nil
            self.creationTime = nil
            self.gpus = nil
            self.instanceType = nil
            self.logStream = nil
            self.memory = nil
            self.name = nil
            self.startTime = nil
            self.status = nil
            self.statusMessage = nil
            self.stopTime = nil
            self.taskId = nil
        }
    }
}

public struct GetRunTaskOutput: Swift.Equatable {
    /// The task's CPU usage.
    public var cpus: Swift.Int?
    /// When the task was created.
    public var creationTime: ClientRuntime.Date?
    /// The number of Graphics Processing Units (GPU) specified in the task.
    public var gpus: Swift.Int?
    /// The instance type for a task.
    public var instanceType: Swift.String?
    /// The task's log stream.
    public var logStream: Swift.String?
    /// The task's memory use in gigabytes.
    public var memory: Swift.Int?
    /// The task's name.
    public var name: Swift.String?
    /// The task's start time.
    public var startTime: ClientRuntime.Date?
    /// The task's status.
    public var status: OmicsClientTypes.TaskStatus?
    /// The task's status message.
    public var statusMessage: Swift.String?
    /// The task's stop time.
    public var stopTime: ClientRuntime.Date?
    /// The task's ID.
    public var taskId: Swift.String?

    public init(
        cpus: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        gpus: Swift.Int? = nil,
        instanceType: Swift.String? = nil,
        logStream: Swift.String? = nil,
        memory: Swift.Int? = nil,
        name: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: OmicsClientTypes.TaskStatus? = nil,
        statusMessage: Swift.String? = nil,
        stopTime: ClientRuntime.Date? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.cpus = cpus
        self.creationTime = creationTime
        self.gpus = gpus
        self.instanceType = instanceType
        self.logStream = logStream
        self.memory = memory
        self.name = name
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
        self.stopTime = stopTime
        self.taskId = taskId
    }
}

struct GetRunTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
    let status: OmicsClientTypes.TaskStatus?
    let name: Swift.String?
    let cpus: Swift.Int?
    let memory: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
    let statusMessage: Swift.String?
    let logStream: Swift.String?
    let gpus: Swift.Int?
    let instanceType: Swift.String?
}

extension GetRunTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case creationTime
        case gpus
        case instanceType
        case logStream
        case memory
        case name
        case startTime
        case status
        case statusMessage
        case stopTime
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.TaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let cpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpus)
        cpus = cpusDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let logStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStream)
        logStream = logStreamDecoded
        let gpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gpus)
        gpus = gpusDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

enum GetRunTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSequenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(id.urlPercentEncoding())"
    }
}

public struct GetSequenceStoreInput: Swift.Equatable {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSequenceStoreInputBody: Swift.Equatable {
}

extension GetSequenceStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSequenceStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSequenceStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.fallbackLocation = output.fallbackLocation
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.fallbackLocation = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct GetSequenceStoreOutput: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// An S3 location that is used to store files that have failed a direct upload.
    public var fallbackLocation: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's server-side encryption (SSE) settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        fallbackLocation: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.fallbackLocation = fallbackLocation
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct GetSequenceStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
    let fallbackLocation: Swift.String?
}

extension GetSequenceStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case fallbackLocation
        case id
        case name
        case sseConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fallbackLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallbackLocation)
        fallbackLocation = fallbackLocationDecoded
    }
}

enum GetSequenceStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let shareId = shareId else {
            return nil
        }
        return "/share/\(shareId.urlPercentEncoding())"
    }
}

public struct GetShareInput: Swift.Equatable {
    /// The generated ID for a share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

struct GetShareInputBody: Swift.Equatable {
}

extension GetShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.share = output.share
        } else {
            self.share = nil
        }
    }
}

public struct GetShareOutput: Swift.Equatable {
    /// An analytic store share details object. contains status, resourceArn, ownerId, etc.
    public var share: OmicsClientTypes.ShareDetails?

    public init(
        share: OmicsClientTypes.ShareDetails? = nil
    )
    {
        self.share = share
    }
}

struct GetShareOutputBody: Swift.Equatable {
    let share: OmicsClientTypes.ShareDetails?
}

extension GetShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case share
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ShareDetails.self, forKey: .share)
        share = shareDecoded
    }
}

enum GetShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVariantImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/variant/\(jobId.urlPercentEncoding())"
    }
}

public struct GetVariantImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetVariantImportJobInputBody: Swift.Equatable {
}

extension GetVariantImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVariantImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVariantImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.annotationFields = output.annotationFields
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.destinationName = output.destinationName
            self.id = output.id
            self.items = output.items
            self.roleArn = output.roleArn
            self.runLeftNormalization = output.runLeftNormalization
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.updateTime = output.updateTime
        } else {
            self.annotationFields = nil
            self.completionTime = nil
            self.creationTime = nil
            self.destinationName = nil
            self.id = nil
            self.items = nil
            self.roleArn = nil
            self.runLeftNormalization = false
            self.status = nil
            self.statusMessage = nil
            self.updateTime = nil
        }
    }
}

public struct GetVariantImportJobOutput: Swift.Equatable {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination variant store.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's items.
    /// This member is required.
    public var items: [OmicsClientTypes.VariantImportItemDetail]?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    /// This member is required.
    public var runLeftNormalization: Swift.Bool
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.JobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// When the job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        items: [OmicsClientTypes.VariantImportItemDetail]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool = false,
        status: OmicsClientTypes.JobStatus? = nil,
        statusMessage: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.annotationFields = annotationFields
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.id = id
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.status = status
        self.statusMessage = statusMessage
        self.updateTime = updateTime
    }
}

struct GetVariantImportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.JobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let items: [OmicsClientTypes.VariantImportItemDetail]?
    let runLeftNormalization: Swift.Bool
    let annotationFields: [Swift.String:Swift.String]?
}

extension GetVariantImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case completionTime
        case creationTime
        case destinationName
        case id
        case items
        case roleArn
        case runLeftNormalization
        case status
        case statusMessage
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantImportItemDetail?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.VariantImportItemDetail]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.VariantImportItemDetail]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
        let annotationFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .annotationFields)
        var annotationFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let annotationFieldsContainer = annotationFieldsContainer {
            annotationFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in annotationFieldsContainer {
                if let string0 = string0 {
                    annotationFieldsDecoded0?[key0] = string0
                }
            }
        }
        annotationFields = annotationFieldsDecoded0
    }
}

enum GetVariantImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct GetVariantStoreInput: Swift.Equatable {
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetVariantStoreInputBody: Swift.Equatable {
}

extension GetVariantStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVariantStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVariantStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.sseConfig = output.sseConfig
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storeArn = output.storeArn
            self.storeSizeBytes = output.storeSizeBytes
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.sseConfig = nil
            self.status = nil
            self.statusMessage = nil
            self.storeArn = nil
            self.storeSizeBytes = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetVariantStoreOutput: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's server-side encryption (SSE) settings.
    /// This member is required.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The store's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store's ARN.
    /// This member is required.
    public var storeArn: Swift.String?
    /// The store's size in bytes.
    /// This member is required.
    public var storeSizeBytes: Swift.Int?
    /// The store's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeArn: Swift.String? = nil,
        storeSizeBytes: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.status = status
        self.statusMessage = statusMessage
        self.storeArn = storeArn
        self.storeSizeBytes = storeSizeBytes
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetVariantStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let storeArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let statusMessage: Swift.String?
    let storeSizeBytes: Swift.Int?
}

extension GetVariantStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeSizeBytes
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

enum GetVariantStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let export = export {
                export.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "export".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput: Swift.Equatable {
    /// The export format for the workflow.
    public var export: [OmicsClientTypes.WorkflowExport]?
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The workflow's type.
    public var type: OmicsClientTypes.WorkflowType?

    public init(
        export: [OmicsClientTypes.WorkflowExport]? = nil,
        id: Swift.String? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.export = export
        self.id = id
        self.type = type
    }
}

struct GetWorkflowInputBody: Swift.Equatable {
}

extension GetWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.definition = output.definition
            self.description = output.description
            self.digest = output.digest
            self.engine = output.engine
            self.id = output.id
            self.main = output.main
            self.metadata = output.metadata
            self.name = output.name
            self.parameterTemplate = output.parameterTemplate
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storageCapacity = output.storageCapacity
            self.tags = output.tags
            self.type = output.type
        } else {
            self.accelerators = nil
            self.arn = nil
            self.creationTime = nil
            self.definition = nil
            self.description = nil
            self.digest = nil
            self.engine = nil
            self.id = nil
            self.main = nil
            self.metadata = nil
            self.name = nil
            self.parameterTemplate = nil
            self.status = nil
            self.statusMessage = nil
            self.storageCapacity = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct GetWorkflowOutput: Swift.Equatable {
    /// The computational accelerator specified to run the workflow.
    public var accelerators: OmicsClientTypes.Accelerators?
    /// The workflow's ARN.
    public var arn: Swift.String?
    /// When the workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The workflow's definition.
    public var definition: Swift.String?
    /// The workflow's description.
    public var description: Swift.String?
    /// The workflow's digest.
    public var digest: Swift.String?
    /// The workflow's engine.
    public var engine: OmicsClientTypes.WorkflowEngine?
    /// The workflow's ID.
    public var id: Swift.String?
    /// The path of the main definition file for the workflow.
    public var main: Swift.String?
    /// Gets metadata for workflow.
    public var metadata: [Swift.String:Swift.String]?
    /// The workflow's name.
    public var name: Swift.String?
    /// The workflow's parameter template.
    public var parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    /// The workflow's status.
    public var status: OmicsClientTypes.WorkflowStatus?
    /// The workflow's status message.
    public var statusMessage: Swift.String?
    /// The workflow's storage capacity in gigabytes.
    public var storageCapacity: Swift.Int?
    /// The workflow's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The workflow's type.
    public var type: OmicsClientTypes.WorkflowType?

    public init(
        accelerators: OmicsClientTypes.Accelerators? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        description: Swift.String? = nil,
        digest: Swift.String? = nil,
        engine: OmicsClientTypes.WorkflowEngine? = nil,
        id: Swift.String? = nil,
        main: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil,
        status: OmicsClientTypes.WorkflowStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.accelerators = accelerators
        self.arn = arn
        self.creationTime = creationTime
        self.definition = definition
        self.description = description
        self.digest = digest
        self.engine = engine
        self.id = id
        self.main = main
        self.metadata = metadata
        self.name = name
        self.parameterTemplate = parameterTemplate
        self.status = status
        self.statusMessage = statusMessage
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.type = type
    }
}

struct GetWorkflowOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.WorkflowStatus?
    let type: OmicsClientTypes.WorkflowType?
    let name: Swift.String?
    let description: Swift.String?
    let engine: OmicsClientTypes.WorkflowEngine?
    let definition: Swift.String?
    let main: Swift.String?
    let digest: Swift.String?
    let parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    let storageCapacity: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let metadata: [Swift.String:Swift.String]?
    let accelerators: OmicsClientTypes.Accelerators?
}

extension GetWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators
        case arn
        case creationTime
        case definition
        case description
        case digest
        case engine
        case id
        case main
        case metadata
        case name
        case parameterTemplate
        case status
        case statusMessage
        case storageCapacity
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowEngine.self, forKey: .engine)
        engine = engineDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let mainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .main)
        main = mainDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let parameterTemplateContainer = try containerValues.decodeIfPresent([Swift.String: OmicsClientTypes.WorkflowParameter?].self, forKey: .parameterTemplate)
        var parameterTemplateDecoded0: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil
        if let parameterTemplateContainer = parameterTemplateContainer {
            parameterTemplateDecoded0 = [Swift.String:OmicsClientTypes.WorkflowParameter]()
            for (key0, workflowparameter0) in parameterTemplateContainer {
                if let workflowparameter0 = workflowparameter0 {
                    parameterTemplateDecoded0?[key0] = workflowparameter0
                }
            }
        }
        parameterTemplate = parameterTemplateDecoded0
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, workflowmetadatavalue0) in metadataContainer {
                if let workflowmetadatavalue0 = workflowmetadatavalue0 {
                    metadataDecoded0?[key0] = workflowmetadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let acceleratorsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.Accelerators.self, forKey: .accelerators)
        accelerators = acceleratorsDecoded
    }
}

enum GetWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.ImportReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for import read set jobs.
    public struct ImportReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetImportJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetImportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReadSetJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case roleArn
        case sequenceStoreId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// An import read set job.
    public struct ImportReadSetJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetImportJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetImportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReadSetSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sourceFileType
        case sourceFiles
        case status
        case statusMessage
        case subjectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sourceFileType = self.sourceFileType {
            try encodeContainer.encode(sourceFileType.rawValue, forKey: .sourceFileType)
        }
        if let sourceFiles = self.sourceFiles {
            try encodeContainer.encode(sourceFiles, forKey: .sourceFiles)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFilesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SourceFiles.self, forKey: .sourceFiles)
        sourceFiles = sourceFilesDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// A source for an import read set job.
    public struct ImportReadSetSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source's genome reference ARN.
        public var referenceArn: Swift.String?
        /// The source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The source's file type.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The source files' location in Amazon S3.
        /// This member is required.
        public var sourceFiles: OmicsClientTypes.SourceFiles?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetImportJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?
        /// The source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            sourceFiles: OmicsClientTypes.SourceFiles? = nil,
            status: OmicsClientTypes.ReadSetImportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFileType = sourceFileType
            self.sourceFiles = sourceFiles
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
            self.tags = tags
        }
    }

}

extension OmicsClientTypes.ImportReferenceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for import references.
    public struct ImportReferenceFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReferenceImportJobStatus?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReferenceImportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReferenceJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case referenceStoreId
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let referenceStoreId = self.referenceStoreId {
            try encodeContainer.encode(referenceStoreId, forKey: .referenceStoreId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// An import reference job.
    public struct ImportReferenceJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's reference store ID.
        /// This member is required.
        public var referenceStoreId: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReferenceImportJobStatus?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            referenceStoreId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceImportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReferenceSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case sourceFile
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFile = self.sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// An genome reference source.
    public struct ImportReferenceSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source file's location in Amazon S3.
        public var sourceFile: Swift.String?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReferenceImportJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceFile: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceImportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred. Try the request again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The Job was cancelled
        case cancelled
        /// The Job has completed
        case completed
        /// The Job completed with failed runs
        case completedWithFailures
        /// The Job failed
        case failed
        /// The Job is executing
        case inProgress
        /// The Job has been submitted to run
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ListAnnotationImportJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case storeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storeName = self.storeName {
            try encodeContainer.encode(storeName, forKey: .storeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let storeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeName)
        storeName = storeNameDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for annotation import jobs.
    public struct ListAnnotationImportJobsFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.JobStatus?
        /// A store name to filter on.
        public var storeName: Swift.String?

        public init(
            status: OmicsClientTypes.JobStatus? = nil,
            storeName: Swift.String? = nil
        )
        {
            self.status = status
            self.storeName = storeName
        }
    }

}

extension ListAnnotationImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListAnnotationImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAnnotationImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/annotations"
    }
}

public struct ListAnnotationImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListAnnotationImportJobsFilter?
    /// IDs of annotation import jobs to retrieve.
    public var ids: [Swift.String]?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListAnnotationImportJobsFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnnotationImportJobsInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListAnnotationImportJobsFilter?
}

extension ListAnnotationImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListAnnotationImportJobsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAnnotationImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnnotationImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.annotationImportJobs = output.annotationImportJobs
            self.nextToken = output.nextToken
        } else {
            self.annotationImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnnotationImportJobsOutput: Swift.Equatable {
    /// A list of jobs.
    public var annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationImportJobs = annotationImportJobs
        self.nextToken = nextToken
    }
}

struct ListAnnotationImportJobsOutputBody: Swift.Equatable {
    let annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]?
    let nextToken: Swift.String?
}

extension ListAnnotationImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationImportJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationImportJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationImportJobItem?].self, forKey: .annotationImportJobs)
        var annotationImportJobsDecoded0:[OmicsClientTypes.AnnotationImportJobItem]? = nil
        if let annotationImportJobsContainer = annotationImportJobsContainer {
            annotationImportJobsDecoded0 = [OmicsClientTypes.AnnotationImportJobItem]()
            for structure0 in annotationImportJobsContainer {
                if let structure0 = structure0 {
                    annotationImportJobsDecoded0?.append(structure0)
                }
            }
        }
        annotationImportJobs = annotationImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnnotationImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.ListAnnotationStoreVersionsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OmicsClientTypes {
    /// Use filters to focus the returned annotation store versions on a specific parameter, such as the status of the annotation store.
    public struct ListAnnotationStoreVersionsFilter: Swift.Equatable {
        /// The status of an annotation store version.
        public var status: OmicsClientTypes.VersionStatus?

        public init(
            status: OmicsClientTypes.VersionStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListAnnotationStoreVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListAnnotationStoreVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAnnotationStoreVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/versions"
    }
}

public struct ListAnnotationStoreVersionsInput: Swift.Equatable {
    /// A filter to apply to the list of annotation store versions.
    public var filter: OmicsClientTypes.ListAnnotationStoreVersionsFilter?
    /// The maximum number of annotation store versions to return in one page of results.
    public var maxResults: Swift.Int?
    /// The name of an annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListAnnotationStoreVersionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListAnnotationStoreVersionsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ListAnnotationStoreVersionsFilter?
}

extension ListAnnotationStoreVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListAnnotationStoreVersionsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAnnotationStoreVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnnotationStoreVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.annotationStoreVersions = output.annotationStoreVersions
            self.nextToken = output.nextToken
        } else {
            self.annotationStoreVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnnotationStoreVersionsOutput: Swift.Equatable {
    /// Lists all versions of an annotation store.
    public var annotationStoreVersions: [OmicsClientTypes.AnnotationStoreVersionItem]?
    /// Specifies the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        annotationStoreVersions: [OmicsClientTypes.AnnotationStoreVersionItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationStoreVersions = annotationStoreVersions
        self.nextToken = nextToken
    }
}

struct ListAnnotationStoreVersionsOutputBody: Swift.Equatable {
    let annotationStoreVersions: [OmicsClientTypes.AnnotationStoreVersionItem]?
    let nextToken: Swift.String?
}

extension ListAnnotationStoreVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationStoreVersions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationStoreVersionsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationStoreVersionItem?].self, forKey: .annotationStoreVersions)
        var annotationStoreVersionsDecoded0:[OmicsClientTypes.AnnotationStoreVersionItem]? = nil
        if let annotationStoreVersionsContainer = annotationStoreVersionsContainer {
            annotationStoreVersionsDecoded0 = [OmicsClientTypes.AnnotationStoreVersionItem]()
            for structure0 in annotationStoreVersionsContainer {
                if let structure0 = structure0 {
                    annotationStoreVersionsDecoded0?.append(structure0)
                }
            }
        }
        annotationStoreVersions = annotationStoreVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnnotationStoreVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.ListAnnotationStoresFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for annotation stores.
    public struct ListAnnotationStoresFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.StoreStatus?

        public init(
            status: OmicsClientTypes.StoreStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListAnnotationStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListAnnotationStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAnnotationStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/annotationStores"
    }
}

public struct ListAnnotationStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListAnnotationStoresFilter?
    /// IDs of stores to list.
    public var ids: [Swift.String]?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListAnnotationStoresFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnnotationStoresInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListAnnotationStoresFilter?
}

extension ListAnnotationStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListAnnotationStoresFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAnnotationStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnnotationStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.annotationStores = output.annotationStores
            self.nextToken = output.nextToken
        } else {
            self.annotationStores = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnnotationStoresOutput: Swift.Equatable {
    /// A list of stores.
    public var annotationStores: [OmicsClientTypes.AnnotationStoreItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        annotationStores: [OmicsClientTypes.AnnotationStoreItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationStores = annotationStores
        self.nextToken = nextToken
    }
}

struct ListAnnotationStoresOutputBody: Swift.Equatable {
    let annotationStores: [OmicsClientTypes.AnnotationStoreItem]?
    let nextToken: Swift.String?
}

extension ListAnnotationStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationStores
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationStoreItem?].self, forKey: .annotationStores)
        var annotationStoresDecoded0:[OmicsClientTypes.AnnotationStoreItem]? = nil
        if let annotationStoresContainer = annotationStoresContainer {
            annotationStoresDecoded0 = [OmicsClientTypes.AnnotationStoreItem]()
            for structure0 in annotationStoresContainer {
                if let structure0 = structure0 {
                    annotationStoresDecoded0?.append(structure0)
                }
            }
        }
        annotationStores = annotationStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnnotationStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMultipartReadSetUploadsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListMultipartReadSetUploadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/uploads"
    }
}

public struct ListMultipartReadSetUploadsInput: Swift.Equatable {
    /// The maximum number of multipart uploads returned in a page.
    public var maxResults: Swift.Int?
    /// Next token returned in the response of a previous ListMultipartReadSetUploads call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The Sequence Store ID used for the multipart uploads.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListMultipartReadSetUploadsInputBody: Swift.Equatable {
}

extension ListMultipartReadSetUploadsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMultipartReadSetUploadsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMultipartReadSetUploadsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.uploads = output.uploads
        } else {
            self.nextToken = nil
            self.uploads = nil
        }
    }
}

public struct ListMultipartReadSetUploadsOutput: Swift.Equatable {
    /// Next token returned in the response of a previous ListMultipartReadSetUploads call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// An array of multipart uploads.
    public var uploads: [OmicsClientTypes.MultipartReadSetUploadListItem]?

    public init(
        nextToken: Swift.String? = nil,
        uploads: [OmicsClientTypes.MultipartReadSetUploadListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.uploads = uploads
    }
}

struct ListMultipartReadSetUploadsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let uploads: [OmicsClientTypes.MultipartReadSetUploadListItem]?
}

extension ListMultipartReadSetUploadsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case uploads
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let uploadsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.MultipartReadSetUploadListItem?].self, forKey: .uploads)
        var uploadsDecoded0:[OmicsClientTypes.MultipartReadSetUploadListItem]? = nil
        if let uploadsContainer = uploadsContainer {
            uploadsDecoded0 = [OmicsClientTypes.MultipartReadSetUploadListItem]()
            for structure0 in uploadsContainer {
                if let structure0 = structure0 {
                    uploadsDecoded0?.append(structure0)
                }
            }
        }
        uploads = uploadsDecoded0
    }
}

enum ListMultipartReadSetUploadsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotSupportedOperationException": return try await NotSupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReadSetActivationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetActivationJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetActivationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjobs"
    }
}

public struct ListReadSetActivationJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ActivateReadSetFilter?
    /// The maximum number of read set activation jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ActivateReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetActivationJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ActivateReadSetFilter?
}

extension ListReadSetActivationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ActivateReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetActivationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReadSetActivationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.activationJobs = output.activationJobs
            self.nextToken = output.nextToken
        } else {
            self.activationJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReadSetActivationJobsOutput: Swift.Equatable {
    /// A list of jobs.
    public var activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activationJobs = activationJobs
        self.nextToken = nextToken
    }
}

struct ListReadSetActivationJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]?
}

extension ListReadSetActivationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let activationJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ActivateReadSetJobItem?].self, forKey: .activationJobs)
        var activationJobsDecoded0:[OmicsClientTypes.ActivateReadSetJobItem]? = nil
        if let activationJobsContainer = activationJobsContainer {
            activationJobsDecoded0 = [OmicsClientTypes.ActivateReadSetJobItem]()
            for structure0 in activationJobsContainer {
                if let structure0 = structure0 {
                    activationJobsDecoded0?.append(structure0)
                }
            }
        }
        activationJobs = activationJobsDecoded0
    }
}

enum ListReadSetActivationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReadSetExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetExportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjobs"
    }
}

public struct ListReadSetExportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ExportReadSetFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ExportReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetExportJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ExportReadSetFilter?
}

extension ListReadSetExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ExportReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReadSetExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportJobs = output.exportJobs
            self.nextToken = output.nextToken
        } else {
            self.exportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReadSetExportJobsOutput: Swift.Equatable {
    /// A list of jobs.
    public var exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobs = exportJobs
        self.nextToken = nextToken
    }
}

struct ListReadSetExportJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]?
}

extension ListReadSetExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let exportJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ExportReadSetJobDetail?].self, forKey: .exportJobs)
        var exportJobsDecoded0:[OmicsClientTypes.ExportReadSetJobDetail]? = nil
        if let exportJobsContainer = exportJobsContainer {
            exportJobsDecoded0 = [OmicsClientTypes.ExportReadSetJobDetail]()
            for structure0 in exportJobsContainer {
                if let structure0 = structure0 {
                    exportJobsDecoded0?.append(structure0)
                }
            }
        }
        exportJobs = exportJobsDecoded0
    }
}

enum ListReadSetExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReadSetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjobs"
    }
}

public struct ListReadSetImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ImportReadSetFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ImportReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetImportJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ImportReadSetFilter?
}

extension ListReadSetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ImportReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReadSetImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.importJobs = output.importJobs
            self.nextToken = output.nextToken
        } else {
            self.importJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReadSetImportJobsOutput: Swift.Equatable {
    /// A list of jobs.
    public var importJobs: [OmicsClientTypes.ImportReadSetJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        importJobs: [OmicsClientTypes.ImportReadSetJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

struct ListReadSetImportJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let importJobs: [OmicsClientTypes.ImportReadSetJobItem]?
}

extension ListReadSetImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let importJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReadSetJobItem?].self, forKey: .importJobs)
        var importJobsDecoded0:[OmicsClientTypes.ImportReadSetJobItem]? = nil
        if let importJobsContainer = importJobsContainer {
            importJobsDecoded0 = [OmicsClientTypes.ImportReadSetJobItem]()
            for structure0 in importJobsContainer {
                if let structure0 = structure0 {
                    importJobsDecoded0?.append(structure0)
                }
            }
        }
        importJobs = importJobsDecoded0
    }
}

enum ListReadSetImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReadSetUploadPartsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case partSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let partSource = self.partSource {
            try encodeContainer.encode(partSource.rawValue, forKey: .partSource)
        }
    }
}

extension ListReadSetUploadPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetUploadPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/parts"
    }
}

public struct ListReadSetUploadPartsInput: Swift.Equatable {
    /// Attributes used to filter for a specific subset of read set part uploads.
    public var filter: OmicsClientTypes.ReadSetUploadPartListFilter?
    /// The maximum number of read set upload parts returned in a page.
    public var maxResults: Swift.Int?
    /// Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The source file for the upload part.
    /// This member is required.
    public var partSource: OmicsClientTypes.ReadSetPartSource?
    /// The Sequence Store ID used for the multipart uploads.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        filter: OmicsClientTypes.ReadSetUploadPartListFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partSource: OmicsClientTypes.ReadSetPartSource? = nil,
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partSource = partSource
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

struct ListReadSetUploadPartsInputBody: Swift.Equatable {
    let partSource: OmicsClientTypes.ReadSetPartSource?
    let filter: OmicsClientTypes.ReadSetUploadPartListFilter?
}

extension ListReadSetUploadPartsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case partSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partSourceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetPartSource.self, forKey: .partSource)
        partSource = partSourceDecoded
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetUploadPartListFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetUploadPartsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReadSetUploadPartsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parts = output.parts
        } else {
            self.nextToken = nil
            self.parts = nil
        }
    }
}

public struct ListReadSetUploadPartsOutput: Swift.Equatable {
    /// Next token returned in the response of a previous ListReadSetUploadParts call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// An array of upload parts.
    public var parts: [OmicsClientTypes.ReadSetUploadPartListItem]?

    public init(
        nextToken: Swift.String? = nil,
        parts: [OmicsClientTypes.ReadSetUploadPartListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.parts = parts
    }
}

struct ListReadSetUploadPartsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let parts: [OmicsClientTypes.ReadSetUploadPartListItem]?
}

extension ListReadSetUploadPartsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case parts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let partsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReadSetUploadPartListItem?].self, forKey: .parts)
        var partsDecoded0:[OmicsClientTypes.ReadSetUploadPartListItem]? = nil
        if let partsContainer = partsContainer {
            partsDecoded0 = [OmicsClientTypes.ReadSetUploadPartListItem]()
            for structure0 in partsContainer {
                if let structure0 = structure0 {
                    partsDecoded0?.append(structure0)
                }
            }
        }
        parts = partsDecoded0
    }
}

enum ListReadSetUploadPartsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotSupportedOperationException": return try await NotSupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReadSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readsets"
    }
}

public struct ListReadSetsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReadSetFilter?
    /// The maximum number of read sets to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ReadSetFilter?
}

extension ListReadSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReadSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readSets = output.readSets
        } else {
            self.nextToken = nil
            self.readSets = nil
        }
    }
}

public struct ListReadSetsOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of read sets.
    /// This member is required.
    public var readSets: [OmicsClientTypes.ReadSetListItem]?

    public init(
        nextToken: Swift.String? = nil,
        readSets: [OmicsClientTypes.ReadSetListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.readSets = readSets
    }
}

struct ListReadSetsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readSets: [OmicsClientTypes.ReadSetListItem]?
}

extension ListReadSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case readSets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readSetsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReadSetListItem?].self, forKey: .readSets)
        var readSetsDecoded0:[OmicsClientTypes.ReadSetListItem]? = nil
        if let readSetsContainer = readSetsContainer {
            readSetsDecoded0 = [OmicsClientTypes.ReadSetListItem]()
            for structure0 in readSetsContainer {
                if let structure0 = structure0 {
                    readSetsDecoded0?.append(structure0)
                }
            }
        }
        readSets = readSetsDecoded0
    }
}

enum ListReadSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReferenceImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReferenceImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReferenceImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjobs"
    }
}

public struct ListReferenceImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ImportReferenceFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ImportReferenceFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.referenceStoreId = referenceStoreId
    }
}

struct ListReferenceImportJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ImportReferenceFilter?
}

extension ListReferenceImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ImportReferenceFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReferenceImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReferenceImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.importJobs = output.importJobs
            self.nextToken = output.nextToken
        } else {
            self.importJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReferenceImportJobsOutput: Swift.Equatable {
    /// A lis of jobs.
    public var importJobs: [OmicsClientTypes.ImportReferenceJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        importJobs: [OmicsClientTypes.ImportReferenceJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

struct ListReferenceImportJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let importJobs: [OmicsClientTypes.ImportReferenceJobItem]?
}

extension ListReferenceImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let importJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReferenceJobItem?].self, forKey: .importJobs)
        var importJobsDecoded0:[OmicsClientTypes.ImportReferenceJobItem]? = nil
        if let importJobsContainer = importJobsContainer {
            importJobsDecoded0 = [OmicsClientTypes.ImportReferenceJobItem]()
            for structure0 in importJobsContainer {
                if let structure0 = structure0 {
                    importJobsDecoded0?.append(structure0)
                }
            }
        }
        importJobs = importJobsDecoded0
    }
}

enum ListReferenceImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReferenceStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReferenceStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReferenceStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/referencestores"
    }
}

public struct ListReferenceStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReferenceStoreFilter?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ReferenceStoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReferenceStoresInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ReferenceStoreFilter?
}

extension ListReferenceStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceStoreFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReferenceStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReferenceStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.referenceStores = output.referenceStores
        } else {
            self.nextToken = nil
            self.referenceStores = nil
        }
    }
}

public struct ListReferenceStoresOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of reference stores.
    /// This member is required.
    public var referenceStores: [OmicsClientTypes.ReferenceStoreDetail]?

    public init(
        nextToken: Swift.String? = nil,
        referenceStores: [OmicsClientTypes.ReferenceStoreDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.referenceStores = referenceStores
    }
}

struct ListReferenceStoresOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let referenceStores: [OmicsClientTypes.ReferenceStoreDetail]?
}

extension ListReferenceStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case referenceStores
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let referenceStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReferenceStoreDetail?].self, forKey: .referenceStores)
        var referenceStoresDecoded0:[OmicsClientTypes.ReferenceStoreDetail]? = nil
        if let referenceStoresContainer = referenceStoresContainer {
            referenceStoresDecoded0 = [OmicsClientTypes.ReferenceStoreDetail]()
            for structure0 in referenceStoresContainer {
                if let structure0 = structure0 {
                    referenceStoresDecoded0?.append(structure0)
                }
            }
        }
        referenceStores = referenceStoresDecoded0
    }
}

enum ListReferenceStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReferencesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/references"
    }
}

public struct ListReferencesInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReferenceFilter?
    /// The maximum number of references to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The references' reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init(
        filter: OmicsClientTypes.ReferenceFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.referenceStoreId = referenceStoreId
    }
}

struct ListReferencesInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ReferenceFilter?
}

extension ListReferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.references = output.references
        } else {
            self.nextToken = nil
            self.references = nil
        }
    }
}

public struct ListReferencesOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of references.
    /// This member is required.
    public var references: [OmicsClientTypes.ReferenceListItem]?

    public init(
        nextToken: Swift.String? = nil,
        references: [OmicsClientTypes.ReferenceListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.references = references
    }
}

struct ListReferencesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let references: [OmicsClientTypes.ReferenceListItem]?
}

extension ListReferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case references
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let referencesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReferenceListItem?].self, forKey: .references)
        var referencesDecoded0:[OmicsClientTypes.ReferenceListItem]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [OmicsClientTypes.ReferenceListItem]()
            for structure0 in referencesContainer {
                if let structure0 = structure0 {
                    referencesDecoded0?.append(structure0)
                }
            }
        }
        references = referencesDecoded0
    }
}

enum ListReferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRunGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListRunGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/runGroup"
    }
}

public struct ListRunGroupsInput: Swift.Equatable {
    /// The maximum number of run groups to return in one page of results.
    public var maxResults: Swift.Int?
    /// The run groups' name.
    public var name: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        startingToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.startingToken = startingToken
    }
}

struct ListRunGroupsInputBody: Swift.Equatable {
}

extension ListRunGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRunGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRunGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRunGroupsOutput: Swift.Equatable {
    /// A list of groups.
    public var items: [OmicsClientTypes.RunGroupListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.RunGroupListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRunGroupsOutputBody: Swift.Equatable {
    let items: [OmicsClientTypes.RunGroupListItem]?
    let nextToken: Swift.String?
}

extension ListRunGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.RunGroupListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.RunGroupListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.RunGroupListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRunGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRunTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListRunTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/task"
    }
}

public struct ListRunTasksInput: Swift.Equatable {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of run tasks to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// Filter the list by status.
    public var status: OmicsClientTypes.TaskStatus?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        startingToken: Swift.String? = nil,
        status: OmicsClientTypes.TaskStatus? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.startingToken = startingToken
        self.status = status
    }
}

struct ListRunTasksInputBody: Swift.Equatable {
}

extension ListRunTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRunTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRunTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRunTasksOutput: Swift.Equatable {
    /// A list of tasks.
    public var items: [OmicsClientTypes.TaskListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.TaskListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRunTasksOutputBody: Swift.Equatable {
    let items: [OmicsClientTypes.TaskListItem]?
    let nextToken: Swift.String?
}

extension ListRunTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.TaskListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.TaskListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.TaskListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRunTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let runGroupId = runGroupId {
                let runGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "runGroupId".urlPercentEncoding(), value: Swift.String(runGroupId).urlPercentEncoding())
                items.append(runGroupIdQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/run"
    }
}

public struct ListRunsInput: Swift.Equatable {
    /// The maximum number of runs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Filter the list by run name.
    public var name: Swift.String?
    /// Filter the list by run group ID.
    public var runGroupId: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// The status of a run.
    public var status: OmicsClientTypes.RunStatus?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        startingToken: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.runGroupId = runGroupId
        self.startingToken = startingToken
        self.status = status
    }
}

struct ListRunsInputBody: Swift.Equatable {
}

extension ListRunsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRunsOutput: Swift.Equatable {
    /// A list of runs.
    public var items: [OmicsClientTypes.RunListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.RunListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRunsOutputBody: Swift.Equatable {
    let items: [OmicsClientTypes.RunListItem]?
    let nextToken: Swift.String?
}

extension ListRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.RunListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.RunListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.RunListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSequenceStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListSequenceStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSequenceStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sequencestores"
    }
}

public struct ListSequenceStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.SequenceStoreFilter?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.SequenceStoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSequenceStoresInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.SequenceStoreFilter?
}

extension ListSequenceStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SequenceStoreFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListSequenceStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSequenceStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sequenceStores = output.sequenceStores
        } else {
            self.nextToken = nil
            self.sequenceStores = nil
        }
    }
}

public struct ListSequenceStoresOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of sequence stores.
    /// This member is required.
    public var sequenceStores: [OmicsClientTypes.SequenceStoreDetail]?

    public init(
        nextToken: Swift.String? = nil,
        sequenceStores: [OmicsClientTypes.SequenceStoreDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.sequenceStores = sequenceStores
    }
}

struct ListSequenceStoresOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sequenceStores: [OmicsClientTypes.SequenceStoreDetail]?
}

extension ListSequenceStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sequenceStores
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sequenceStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.SequenceStoreDetail?].self, forKey: .sequenceStores)
        var sequenceStoresDecoded0:[OmicsClientTypes.SequenceStoreDetail]? = nil
        if let sequenceStoresContainer = sequenceStoresContainer {
            sequenceStoresDecoded0 = [OmicsClientTypes.SequenceStoreDetail]()
            for structure0 in sequenceStoresContainer {
                if let structure0 = structure0 {
                    sequenceStoresDecoded0?.append(structure0)
                }
            }
        }
        sequenceStores = sequenceStoresDecoded0
    }
}

enum ListSequenceStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case resourceOwner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
    }
}

extension ListSharesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/shares"
    }
}

public struct ListSharesInput: Swift.Equatable {
    /// Attributes used to filter for a specific subset of shares.
    public var filter: OmicsClientTypes.Filter?
    /// The maximum number of shares to return in one page of results.
    public var maxResults: Swift.Int?
    /// Next token returned in the response of a previous ListReadSetUploadPartsRequest call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The account that owns the analytics store shared.
    /// This member is required.
    public var resourceOwner: OmicsClientTypes.ResourceOwner?

    public init(
        filter: OmicsClientTypes.Filter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceOwner: OmicsClientTypes.ResourceOwner? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
    }
}

struct ListSharesInputBody: Swift.Equatable {
    let resourceOwner: OmicsClientTypes.ResourceOwner?
    let filter: OmicsClientTypes.Filter?
}

extension ListSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case resourceOwner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.shares = output.shares
        } else {
            self.nextToken = nil
            self.shares = nil
        }
    }
}

public struct ListSharesOutput: Swift.Equatable {
    /// Next token returned in the response of a previous ListSharesResponse call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// The shares available and their meta details.
    /// This member is required.
    public var shares: [OmicsClientTypes.ShareDetails]?

    public init(
        nextToken: Swift.String? = nil,
        shares: [OmicsClientTypes.ShareDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.shares = shares
    }
}

struct ListSharesOutputBody: Swift.Equatable {
    let shares: [OmicsClientTypes.ShareDetails]?
    let nextToken: Swift.String?
}

extension ListSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case shares
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ShareDetails?].self, forKey: .shares)
        var sharesDecoded0:[OmicsClientTypes.ShareDetails]? = nil
        if let sharesContainer = sharesContainer {
            sharesDecoded0 = [OmicsClientTypes.ShareDetails]()
            for structure0 in sharesContainer {
                if let structure0 = structure0 {
                    sharesDecoded0?.append(structure0)
                }
            }
        }
        shares = sharesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.ListVariantImportJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case storeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storeName = self.storeName {
            try encodeContainer.encode(storeName, forKey: .storeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let storeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeName)
        storeName = storeNameDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for variant import jobs.
    public struct ListVariantImportJobsFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.JobStatus?
        /// A store name to filter on.
        public var storeName: Swift.String?

        public init(
            status: OmicsClientTypes.JobStatus? = nil,
            storeName: Swift.String? = nil
        )
        {
            self.status = status
            self.storeName = storeName
        }
    }

}

extension ListVariantImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListVariantImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListVariantImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/variants"
    }
}

public struct ListVariantImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListVariantImportJobsFilter?
    /// A list of job IDs.
    public var ids: [Swift.String]?
    /// The maximum number of import jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListVariantImportJobsFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVariantImportJobsInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListVariantImportJobsFilter?
}

extension ListVariantImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListVariantImportJobsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListVariantImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVariantImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.variantImportJobs = output.variantImportJobs
        } else {
            self.nextToken = nil
            self.variantImportJobs = nil
        }
    }
}

public struct ListVariantImportJobsOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of jobs.
    public var variantImportJobs: [OmicsClientTypes.VariantImportJobItem]?

    public init(
        nextToken: Swift.String? = nil,
        variantImportJobs: [OmicsClientTypes.VariantImportJobItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.variantImportJobs = variantImportJobs
    }
}

struct ListVariantImportJobsOutputBody: Swift.Equatable {
    let variantImportJobs: [OmicsClientTypes.VariantImportJobItem]?
    let nextToken: Swift.String?
}

extension ListVariantImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case variantImportJobs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantImportJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantImportJobItem?].self, forKey: .variantImportJobs)
        var variantImportJobsDecoded0:[OmicsClientTypes.VariantImportJobItem]? = nil
        if let variantImportJobsContainer = variantImportJobsContainer {
            variantImportJobsDecoded0 = [OmicsClientTypes.VariantImportJobItem]()
            for structure0 in variantImportJobsContainer {
                if let structure0 = structure0 {
                    variantImportJobsDecoded0?.append(structure0)
                }
            }
        }
        variantImportJobs = variantImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVariantImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.ListVariantStoresFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for variant stores.
    public struct ListVariantStoresFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.StoreStatus?

        public init(
            status: OmicsClientTypes.StoreStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListVariantStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListVariantStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListVariantStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/variantStores"
    }
}

public struct ListVariantStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListVariantStoresFilter?
    /// A list of store IDs.
    public var ids: [Swift.String]?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: OmicsClientTypes.ListVariantStoresFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVariantStoresInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListVariantStoresFilter?
}

extension ListVariantStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListVariantStoresFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListVariantStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVariantStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.variantStores = output.variantStores
        } else {
            self.nextToken = nil
            self.variantStores = nil
        }
    }
}

public struct ListVariantStoresOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of variant stores.
    public var variantStores: [OmicsClientTypes.VariantStoreItem]?

    public init(
        nextToken: Swift.String? = nil,
        variantStores: [OmicsClientTypes.VariantStoreItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.variantStores = variantStores
    }
}

struct ListVariantStoresOutputBody: Swift.Equatable {
    let variantStores: [OmicsClientTypes.VariantStoreItem]?
    let nextToken: Swift.String?
}

extension ListVariantStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case variantStores
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantStoreItem?].self, forKey: .variantStores)
        var variantStoresDecoded0:[OmicsClientTypes.VariantStoreItem]? = nil
        if let variantStoresContainer = variantStoresContainer {
            variantStoresDecoded0 = [OmicsClientTypes.VariantStoreItem]()
            for structure0 in variantStoresContainer {
                if let structure0 = structure0 {
                    variantStoresDecoded0?.append(structure0)
                }
            }
        }
        variantStores = variantStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVariantStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflow"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// The maximum number of workflows to return in one page of results.
    public var maxResults: Swift.Int?
    /// The workflows' name.
    public var name: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// The workflows' type.
    public var type: OmicsClientTypes.WorkflowType?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        startingToken: Swift.String? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.startingToken = startingToken
        self.type = type
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
}

extension ListWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowsOutput: Swift.Equatable {
    /// The workflows' items.
    public var items: [OmicsClientTypes.WorkflowListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        items: [OmicsClientTypes.WorkflowListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWorkflowsOutputBody: Swift.Equatable {
    let items: [OmicsClientTypes.WorkflowListItem]?
    let nextToken: Swift.String?
}

extension ListWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.WorkflowListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.WorkflowListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.WorkflowListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.MultipartReadSetUploadListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sequenceStoreId
        case sourceFileType
        case subjectId
        case tags
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let sourceFileType = self.sourceFileType {
            try encodeContainer.encode(sourceFileType.rawValue, forKey: .sourceFileType)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// Part of the response to ListMultipartReadSetUploads, excluding completed and aborted multipart uploads.
    public struct MultipartReadSetUploadListItem: Swift.Equatable {
        /// The time stamp for when a direct upload was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of a read set.
        public var description: Swift.String?
        /// The source of an uploaded part.
        /// This member is required.
        public var generatedFrom: Swift.String?
        /// The name of a read set.
        public var name: Swift.String?
        /// The source's reference ARN.
        /// This member is required.
        public var referenceArn: Swift.String?
        /// The read set source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The sequence store ID used for the multipart upload.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The type of file the read set originated from.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The read set source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// Any tags you wish to add to a read set.
        public var tags: [Swift.String:Swift.String]?
        /// The ID for the initiated multipart upload.
        /// This member is required.
        public var uploadId: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            uploadId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceStoreId = sequenceStoreId
            self.sourceFileType = sourceFileType
            self.subjectId = subjectId
            self.tags = tags
            self.uploadId = uploadId
        }
    }

}

extension NotSupportedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotSupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation is not supported by Amazon Omics, or the API does not exist.
public struct NotSupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotSupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotSupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotSupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RangeNotSatisfiableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RangeNotSatisfiableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The ranges specified in the request are not valid.
public struct RangeNotSatisfiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RangeNotSatisfiableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RangeNotSatisfiableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RangeNotSatisfiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.ReadOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case encoding
        case escape
        case escapeQuotes
        case header
        case lineSep
        case quote
        case quoteAll
        case sep
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let escape = self.escape {
            try encodeContainer.encode(escape, forKey: .escape)
        }
        if escapeQuotes != false {
            try encodeContainer.encode(escapeQuotes, forKey: .escapeQuotes)
        }
        if header != false {
            try encodeContainer.encode(header, forKey: .header)
        }
        if let lineSep = self.lineSep {
            try encodeContainer.encode(lineSep, forKey: .lineSep)
        }
        if let quote = self.quote {
            try encodeContainer.encode(quote, forKey: .quote)
        }
        if quoteAll != false {
            try encodeContainer.encode(quoteAll, forKey: .quoteAll)
        }
        if let sep = self.sep {
            try encodeContainer.encode(sep, forKey: .sep)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sep)
        sep = sepDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
        let quoteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quote)
        quote = quoteDecoded
        let quoteAllDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .quoteAll) ?? false
        quoteAll = quoteAllDecoded
        let escapeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .escape)
        escape = escapeDecoded
        let escapeQuotesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .escapeQuotes) ?? false
        escapeQuotes = escapeQuotesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let headerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .header) ?? false
        header = headerDecoded
        let lineSepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lineSep)
        lineSep = lineSepDecoded
    }
}

extension OmicsClientTypes {
    /// Read options for an annotation import job.
    public struct ReadOptions: Swift.Equatable {
        /// The file's comment character.
        public var comment: Swift.String?
        /// The file's encoding.
        public var encoding: Swift.String?
        /// A character for escaping quotes in the file.
        public var escape: Swift.String?
        /// Whether quotes need to be escaped in the file.
        public var escapeQuotes: Swift.Bool
        /// Whether the file has a header row.
        public var header: Swift.Bool
        /// A line separator for the file.
        public var lineSep: Swift.String?
        /// The file's quote character.
        public var quote: Swift.String?
        /// Whether all values need to be quoted, or just those that contain quotes.
        public var quoteAll: Swift.Bool
        /// The file's field separator.
        public var sep: Swift.String?

        public init(
            comment: Swift.String? = nil,
            encoding: Swift.String? = nil,
            escape: Swift.String? = nil,
            escapeQuotes: Swift.Bool = false,
            header: Swift.Bool = false,
            lineSep: Swift.String? = nil,
            quote: Swift.String? = nil,
            quoteAll: Swift.Bool = false,
            sep: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encoding = encoding
            self.escape = escape
            self.escapeQuotes = escapeQuotes
            self.header = header
            self.lineSep = lineSep
            self.quote = quote
            self.quoteAll = quoteAll
            self.sep = sep
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetActivationJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetActivationJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetActivationJobItemStatus(rawValue: rawValue) ?? ReadSetActivationJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetActivationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetActivationJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetActivationJobStatus(rawValue: rawValue) ?? ReadSetActivationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetBatchError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case id
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    /// An error from a batch read set operation.
    public struct ReadSetBatchError: Swift.Equatable {
        /// The error's code.
        /// This member is required.
        public var code: Swift.String?
        /// The error's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The error's message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.id = id
            self.message = message
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetExportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetExportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetExportJobItemStatus(rawValue: rawValue) ?? ReadSetExportJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetExportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetExportJobStatus(rawValue: rawValue) ?? ReadSetExportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetFile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case index
        case source1
        case source2
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetFile] {
            return [
                .index,
                .source1,
                .source2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .source1: return "SOURCE1"
            case .source2: return "SOURCE2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetFile(rawValue: rawValue) ?? ReadSetFile.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetFiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case source1
        case source2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = self.index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let source1 = self.source1 {
            try encodeContainer.encode(source1, forKey: .source1)
        }
        if let source2 = self.source2 {
            try encodeContainer.encode(source2, forKey: .source2)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let source1Decoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .source1)
        source1 = source1Decoded
        let source2Decoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .source2)
        source2 = source2Decoded
        let indexDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .index)
        index = indexDecoded
    }
}

extension OmicsClientTypes {
    /// Files in a read set.
    public struct ReadSetFiles: Swift.Equatable {
        /// The files' index.
        public var index: OmicsClientTypes.FileInformation?
        /// The location of the first file in Amazon S3.
        public var source1: OmicsClientTypes.FileInformation?
        /// The location of the second file in Amazon S3.
        public var source2: OmicsClientTypes.FileInformation?

        public init(
            index: OmicsClientTypes.FileInformation? = nil,
            source1: OmicsClientTypes.FileInformation? = nil,
            source2: OmicsClientTypes.FileInformation? = nil
        )
        {
            self.index = index
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes.ReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case creationType
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case status
        case subjectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let creationType = self.creationType {
            try encodeContainer.encode(creationType.rawValue, forKey: .creationType)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetStatus.self, forKey: .status)
        status = statusDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let creationTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.CreationType.self, forKey: .creationType)
        creationType = creationTypeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for read sets.
    public struct ReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The creation type of the read set.
        public var creationType: OmicsClientTypes.CreationType?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// A name to filter on.
        public var name: Swift.String?
        /// A genome reference ARN to filter on.
        public var referenceArn: Swift.String?
        /// The read set source's sample ID.
        public var sampleId: Swift.String?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetStatus?
        /// The read set source's subject ID.
        public var subjectId: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            creationType: OmicsClientTypes.CreationType? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetStatus? = nil,
            subjectId: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.creationType = creationType
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.status = status
            self.subjectId = subjectId
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetImportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetImportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetImportJobItemStatus(rawValue: rawValue) ?? ReadSetImportJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetImportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetImportJobStatus(rawValue: rawValue) ?? ReadSetImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case creationType
        case description
        case etag
        case fileType
        case id
        case name
        case referenceArn
        case sampleId
        case sequenceInformation
        case sequenceStoreId
        case status
        case statusMessage
        case subjectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let creationType = self.creationType {
            try encodeContainer.encode(creationType.rawValue, forKey: .creationType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let fileType = self.fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sequenceInformation = self.sequenceInformation {
            try encodeContainer.encode(sequenceInformation, forKey: .sequenceInformation)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let fileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let sequenceInformationDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SequenceInformation.self, forKey: .sequenceInformation)
        sequenceInformation = sequenceInformationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.CreationType.self, forKey: .creationType)
        creationType = creationTypeDecoded
        let etagDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ETag.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension OmicsClientTypes {
    /// A read set.
    public struct ReadSetListItem: Swift.Equatable {
        /// The read set's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the read set was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The creation type of the read set.
        public var creationType: OmicsClientTypes.CreationType?
        /// The read set's description.
        public var description: Swift.String?
        /// The entity tag (ETag) is a hash of the object representing its semantic content.
        public var etag: OmicsClientTypes.ETag?
        /// The read set's file type.
        /// This member is required.
        public var fileType: OmicsClientTypes.FileType?
        /// The read set's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The read set's name.
        public var name: Swift.String?
        /// The read set's genome reference ARN.
        public var referenceArn: Swift.String?
        /// The read set's sample ID.
        public var sampleId: Swift.String?
        /// Details about a sequence.
        public var sequenceInformation: OmicsClientTypes.SequenceInformation?
        /// The read set's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The read set's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetStatus?
        /// The status for a read set. It provides more detail as to why the read set has a status.
        public var statusMessage: Swift.String?
        /// The read set's subject ID.
        public var subjectId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            creationType: OmicsClientTypes.CreationType? = nil,
            description: Swift.String? = nil,
            etag: OmicsClientTypes.ETag? = nil,
            fileType: OmicsClientTypes.FileType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sequenceInformation: OmicsClientTypes.SequenceInformation? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetStatus? = nil,
            statusMessage: Swift.String? = nil,
            subjectId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creationType = creationType
            self.description = description
            self.etag = etag
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetPartSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case source1
        case source2
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetPartSource] {
            return [
                .source1,
                .source2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .source1: return "SOURCE1"
            case .source2: return "SOURCE2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetPartSource(rawValue: rawValue) ?? ReadSetPartSource.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case archived
        case deleted
        case deleting
        case processingUpload
        case uploadFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetStatus] {
            return [
                .activating,
                .active,
                .archived,
                .deleted,
                .deleting,
                .processingUpload,
                .uploadFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .processingUpload: return "PROCESSING_UPLOAD"
            case .uploadFailed: return "UPLOAD_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetStatus(rawValue: rawValue) ?? ReadSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetUploadPartListFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// Filter settings that select for read set upload parts of interest.
    public struct ReadSetUploadPartListFilter: Swift.Equatable {
        /// Filters for read set uploads after a specified time.
        public var createdAfter: ClientRuntime.Date?
        /// Filters for read set part uploads before a specified time.
        public var createdBefore: ClientRuntime.Date?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
        }
    }

}

extension OmicsClientTypes.ReadSetUploadPartListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum
        case creationTime
        case lastUpdatedTime
        case partNumber
        case partSize
        case partSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checksum = self.checksum {
            try encodeContainer.encode(checksum, forKey: .checksum)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let partNumber = self.partNumber {
            try encodeContainer.encode(partNumber, forKey: .partNumber)
        }
        if let partSize = self.partSize {
            try encodeContainer.encode(partSize, forKey: .partSize)
        }
        if let partSource = self.partSource {
            try encodeContainer.encode(partSource.rawValue, forKey: .partSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partNumber)
        partNumber = partNumberDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
        let partSourceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetPartSource.self, forKey: .partSource)
        partSource = partSourceDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension OmicsClientTypes {
    /// The metadata of a single part of a file that was added to a multipart upload. A list of these parts is returned in the response to the ListReadSetUploadParts API.
    public struct ReadSetUploadPartListItem: Swift.Equatable {
        /// A unique identifier used to confirm that parts are being added to the correct upload.
        /// This member is required.
        public var checksum: Swift.String?
        /// The time stamp for when a direct upload was created.
        public var creationTime: ClientRuntime.Date?
        /// The time stamp for the most recent update to an uploaded part.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The number identifying the part in an upload.
        /// This member is required.
        public var partNumber: Swift.Int?
        /// The size of the the part in an upload.
        /// This member is required.
        public var partSize: Swift.Int?
        /// The origin of the part being direct uploaded.
        /// This member is required.
        public var partSource: OmicsClientTypes.ReadSetPartSource?

        public init(
            checksum: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            partNumber: Swift.Int? = nil,
            partSize: Swift.Int? = nil,
            partSource: OmicsClientTypes.ReadSetPartSource? = nil
        )
        {
            self.checksum = checksum
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.partNumber = partNumber
            self.partSize = partSize
            self.partSource = partSource
        }
    }

}

extension OmicsClientTypes {
    public enum ReferenceFile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case index
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceFile] {
            return [
                .index,
                .source,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceFile(rawValue: rawValue) ?? ReferenceFile.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReferenceFiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = self.index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .source)
        source = sourceDecoded
        let indexDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .index)
        index = indexDecoded
    }
}

extension OmicsClientTypes {
    /// A set of genome reference files.
    public struct ReferenceFiles: Swift.Equatable {
        /// The files' index.
        public var index: OmicsClientTypes.FileInformation?
        /// The source file's location in Amazon S3.
        public var source: OmicsClientTypes.FileInformation?

        public init(
            index: OmicsClientTypes.FileInformation? = nil,
            source: OmicsClientTypes.FileInformation? = nil
        )
        {
            self.index = index
            self.source = source
        }
    }

}

extension OmicsClientTypes.ReferenceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case md5
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let md5 = self.md5 {
            try encodeContainer.encode(md5, forKey: .md5)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let md5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5)
        md5 = md5Decoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for references.
    public struct ReferenceFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// An MD5 checksum to filter on.
        public var md5: Swift.String?
        /// A name to filter on.
        public var name: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            md5: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.md5 = md5
            self.name = name
        }
    }

}

extension OmicsClientTypes {
    public enum ReferenceImportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceImportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceImportJobItemStatus(rawValue: rawValue) ?? ReferenceImportJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReferenceImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceImportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceImportJobStatus(rawValue: rawValue) ?? ReferenceImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReferenceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referencearn = "referenceArn"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .referencearn(referencearn):
                try container.encode(referencearn, forKey: .referencearn)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let referencearnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .referencearn)
        if let referencearn = referencearnDecoded {
            self = .referencearn(referencearn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// A genome reference.
    public enum ReferenceItem: Swift.Equatable {
        /// The reference's ARN.
        case referencearn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes.ReferenceListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case md5
        case name
        case referenceStoreId
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let md5 = self.md5 {
            try encodeContainer.encode(md5, forKey: .md5)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceStoreId = self.referenceStoreId {
            try encodeContainer.encode(referenceStoreId, forKey: .referenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let md5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5)
        md5 = md5Decoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A genome reference.
    public struct ReferenceListItem: Swift.Equatable {
        /// The reference's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the reference was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The reference's description.
        public var description: Swift.String?
        /// The reference's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The reference's MD5 checksum.
        /// This member is required.
        public var md5: Swift.String?
        /// The reference's name.
        public var name: Swift.String?
        /// The reference's store ID.
        /// This member is required.
        public var referenceStoreId: Swift.String?
        /// The reference's status.
        public var status: OmicsClientTypes.ReferenceStatus?
        /// When the reference was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            md5: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes {
    public enum ReferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceStatus(rawValue: rawValue) ?? ReferenceStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReferenceStoreDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a reference store.
    public struct ReferenceStoreDetail: Swift.Equatable {
        /// The store's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        public var name: Swift.String?
        /// The store's server-side encryption (SSE) settings.
        public var sseConfig: OmicsClientTypes.SseConfig?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }
    }

}

extension OmicsClientTypes.ReferenceStoreFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for reference stores.
    public struct ReferenceStoreFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The name to filter on.
        public var name: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }
    }

}

extension RequestTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request timed out.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The target resource was not found in the current Region.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The resource owner is an account other than the caller
        case other
        /// The resource owner is the calling account
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .other,
                .self,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .other: return "OTHER"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum RunExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [RunExport] {
            return [
                .definition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .definition: return "DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunExport(rawValue: rawValue) ?? RunExport.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.RunGroupListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case id
        case maxCpus
        case maxDuration
        case maxGpus
        case maxRuns
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxCpus = self.maxCpus {
            try encodeContainer.encode(maxCpus, forKey: .maxCpus)
        }
        if let maxDuration = self.maxDuration {
            try encodeContainer.encode(maxDuration, forKey: .maxDuration)
        }
        if let maxGpus = self.maxGpus {
            try encodeContainer.encode(maxGpus, forKey: .maxGpus)
        }
        if let maxRuns = self.maxRuns {
            try encodeContainer.encode(maxRuns, forKey: .maxRuns)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let maxGpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxGpus)
        maxGpus = maxGpusDecoded
    }
}

extension OmicsClientTypes {
    /// A run group.
    public struct RunGroupListItem: Swift.Equatable {
        /// The group's ARN.
        public var arn: Swift.String?
        /// When the group was created.
        public var creationTime: ClientRuntime.Date?
        /// The group's ID.
        public var id: Swift.String?
        /// The group's maximum CPU count setting.
        public var maxCpus: Swift.Int?
        /// The group's maximum duration setting in minutes.
        public var maxDuration: Swift.Int?
        /// The maximum GPUs that can be used by a run group.
        public var maxGpus: Swift.Int?
        /// The group's maximum concurrent run setting.
        public var maxRuns: Swift.Int?
        /// The group's name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            maxCpus: Swift.Int? = nil,
            maxDuration: Swift.Int? = nil,
            maxGpus: Swift.Int? = nil,
            maxRuns: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxGpus = maxGpus
            self.maxRuns = maxRuns
            self.name = name
        }
    }

}

extension OmicsClientTypes.RunListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case id
        case name
        case priority
        case startTime
        case status
        case stopTime
        case storageCapacity
        case workflowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .dateTime, forKey: .stopTime)
        }
        if let storageCapacity = self.storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunStatus.self, forKey: .status)
        status = statusDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow run.
    public struct RunListItem: Swift.Equatable {
        /// The run's ARN.
        public var arn: Swift.String?
        /// When the run was created.
        public var creationTime: ClientRuntime.Date?
        /// The run's ID.
        public var id: Swift.String?
        /// The run's name.
        public var name: Swift.String?
        /// The run's priority.
        public var priority: Swift.Int?
        /// When the run started.
        public var startTime: ClientRuntime.Date?
        /// The run's status.
        public var status: OmicsClientTypes.RunStatus?
        /// When the run stopped.
        public var stopTime: ClientRuntime.Date?
        /// The run's storage capacity.
        public var storageCapacity: Swift.Int?
        /// The run's workflow ID.
        public var workflowId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.RunStatus? = nil,
            stopTime: ClientRuntime.Date? = nil,
            storageCapacity: Swift.Int? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.priority = priority
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.workflowId = workflowId
        }
    }

}

extension OmicsClientTypes {
    public enum RunLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case error
        case fatal
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [RunLogLevel] {
            return [
                .all,
                .error,
                .fatal,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunLogLevel(rawValue: rawValue) ?? RunLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum RunRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case remove
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [RunRetentionMode] {
            return [
                .remove,
                .retain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .remove: return "REMOVE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunRetentionMode(rawValue: rawValue) ?? RunRetentionMode.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum RunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case deleted
        case failed
        case pending
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [RunStatus] {
            return [
                .cancelled,
                .completed,
                .deleted,
                .failed,
                .pending,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunStatus(rawValue: rawValue) ?? RunStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum SchemaValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// BOOLEAN type
        case boolean
        /// DOUBLE type
        case double
        /// FLOAT type
        case float
        /// INT type
        case int
        /// LONG type
        case long
        /// STRING type
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaValueType] {
            return [
                .boolean,
                .double,
                .float,
                .int,
                .long,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .int: return "INT"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaValueType(rawValue: rawValue) ?? SchemaValueType.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.SequenceInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignment
        case generatedFrom
        case totalBaseCount
        case totalReadCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alignment = self.alignment {
            try encodeContainer.encode(alignment, forKey: .alignment)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let totalBaseCount = self.totalBaseCount {
            try encodeContainer.encode(totalBaseCount, forKey: .totalBaseCount)
        }
        if let totalReadCount = self.totalReadCount {
            try encodeContainer.encode(totalReadCount, forKey: .totalReadCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalReadCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalReadCount)
        totalReadCount = totalReadCountDecoded
        let totalBaseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBaseCount)
        totalBaseCount = totalBaseCountDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let alignmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alignment)
        alignment = alignmentDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a sequence.
    public struct SequenceInformation: Swift.Equatable {
        /// The sequence's alignment setting.
        public var alignment: Swift.String?
        /// Where the sequence originated.
        public var generatedFrom: Swift.String?
        /// The sequence's total base count.
        public var totalBaseCount: Swift.Int?
        /// The sequence's total read count.
        public var totalReadCount: Swift.Int?

        public init(
            alignment: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            totalBaseCount: Swift.Int? = nil,
            totalReadCount: Swift.Int? = nil
        )
        {
            self.alignment = alignment
            self.generatedFrom = generatedFrom
            self.totalBaseCount = totalBaseCount
            self.totalReadCount = totalReadCount
        }
    }

}

extension OmicsClientTypes.SequenceStoreDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case fallbackLocation
        case id
        case name
        case sseConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fallbackLocation = self.fallbackLocation {
            try encodeContainer.encode(fallbackLocation, forKey: .fallbackLocation)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fallbackLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallbackLocation)
        fallbackLocation = fallbackLocationDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a sequence store.
    public struct SequenceStoreDetail: Swift.Equatable {
        /// The store's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        public var description: Swift.String?
        /// An S3 location that is used to store files that have failed a direct upload.
        public var fallbackLocation: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        public var name: Swift.String?
        /// The store's server-side encryption (SSE) settings.
        public var sseConfig: OmicsClientTypes.SseConfig?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            fallbackLocation: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.fallbackLocation = fallbackLocation
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }
    }

}

extension OmicsClientTypes.SequenceStoreFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for a sequence store.
    public struct SequenceStoreFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A name to filter on.
        public var name: Swift.String?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.ShareDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case ownerId
        case principalSubscriber
        case resourceArn
        case shareId
        case shareName
        case status
        case statusMessage
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let principalSubscriber = self.principalSubscriber {
            try encodeContainer.encode(principalSubscriber, forKey: .principalSubscriber)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let shareName = self.shareName {
            try encodeContainer.encode(shareName, forKey: .shareName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalSubscriberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalSubscriber)
        principalSubscriber = principalSubscriberDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareName)
        shareName = shareNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension OmicsClientTypes {
    /// The details of a share.
    public struct ShareDetails: Swift.Equatable {
        /// The timestamp for when the share was created.
        public var creationTime: ClientRuntime.Date?
        /// The account ID for the data owner. The owner creates the share offer.
        public var ownerId: Swift.String?
        /// The principal subscriber is the account the analytics store data is being shared with.
        public var principalSubscriber: Swift.String?
        /// The resource Arn of the analytics store being shared.
        public var resourceArn: Swift.String?
        /// The ID for a share offer for an analytics store .
        public var shareId: Swift.String?
        /// The name of the share.
        public var shareName: Swift.String?
        /// The status of a share.
        public var status: OmicsClientTypes.ShareStatus?
        /// The status message for a share. It provides more details on the status of the share.
        public var statusMessage: Swift.String?
        /// The timestamp of the share update.
        public var updateTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            ownerId: Swift.String? = nil,
            principalSubscriber: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            shareId: Swift.String? = nil,
            shareName: Swift.String? = nil,
            status: OmicsClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.ownerId = ownerId
            self.principalSubscriber = principalSubscriber
            self.resourceArn = resourceArn
            self.shareId = shareId
            self.shareName = shareName
            self.status = status
            self.statusMessage = statusMessage
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes {
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The share is activated
        case activating
        /// The share is active and can be used
        case active
        /// The share has been deleted
        case deleted
        /// The share is being deleted
        case deleting
        /// The share has failed to activate or delete
        case failed
        /// The share has been created but is not yet active
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .activating,
                .active,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.SourceFiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source1
        case source2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source1 = self.source1 {
            try encodeContainer.encode(source1, forKey: .source1)
        }
        if let source2 = self.source2 {
            try encodeContainer.encode(source2, forKey: .source2)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let source1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source1)
        source1 = source1Decoded
        let source2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source2)
        source2 = source2Decoded
    }
}

extension OmicsClientTypes {
    /// Source files for a sequence.
    public struct SourceFiles: Swift.Equatable {
        /// The location of the first file in Amazon S3.
        /// This member is required.
        public var source1: Swift.String?
        /// The location of the second file in Amazon S3.
        public var source2: Swift.String?

        public init(
            source1: Swift.String? = nil,
            source2: Swift.String? = nil
        )
        {
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes.SseConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = self.keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
    }
}

extension OmicsClientTypes {
    /// Server-side encryption (SSE) settings for a store.
    public struct SseConfig: Swift.Equatable {
        /// An encryption key ARN.
        public var keyArn: Swift.String?
        /// The encryption type.
        /// This member is required.
        public var type: OmicsClientTypes.EncryptionType?

        public init(
            keyArn: Swift.String? = nil,
            type: OmicsClientTypes.EncryptionType? = nil
        )
        {
            self.keyArn = keyArn
            self.type = type
        }
    }

}

extension StartAnnotationImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case destinationName
        case formatOptions
        case items
        case roleArn
        case runLeftNormalization
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationFields = annotationFields {
            var annotationFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .annotationFields)
            for (dictKey0, annotationFieldMap0) in annotationFields {
                try annotationFieldsContainer.encode(annotationFieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let formatOptions = self.formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for annotationimportitemsource0 in items {
                try itemsContainer.encode(annotationimportitemsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runLeftNormalization = self.runLeftNormalization {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension StartAnnotationImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/annotation"
    }
}

public struct StartAnnotationImportJobInput: Swift.Equatable {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// A destination annotation store for the job.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Formatting options for the annotation file.
    public var formatOptions: OmicsClientTypes.FormatOptions?
    /// Items to import.
    /// This member is required.
    public var items: [OmicsClientTypes.AnnotationImportItemSource]?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    public var runLeftNormalization: Swift.Bool?
    /// The name of the annotation store version.
    public var versionName: Swift.String?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        destinationName: Swift.String? = nil,
        formatOptions: OmicsClientTypes.FormatOptions? = nil,
        items: [OmicsClientTypes.AnnotationImportItemSource]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.annotationFields = annotationFields
        self.destinationName = destinationName
        self.formatOptions = formatOptions
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.versionName = versionName
    }
}

struct StartAnnotationImportJobInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let items: [OmicsClientTypes.AnnotationImportItemSource]?
    let versionName: Swift.String?
    let formatOptions: OmicsClientTypes.FormatOptions?
    let runLeftNormalization: Swift.Bool?
    let annotationFields: [Swift.String:Swift.String]?
}

extension StartAnnotationImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case destinationName
        case formatOptions
        case items
        case roleArn
        case runLeftNormalization
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationImportItemSource?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.AnnotationImportItemSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.AnnotationImportItemSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization)
        runLeftNormalization = runLeftNormalizationDecoded
        let annotationFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .annotationFields)
        var annotationFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let annotationFieldsContainer = annotationFieldsContainer {
            annotationFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in annotationFieldsContainer {
                if let string0 = string0 {
                    annotationFieldsDecoded0?[key0] = string0
                }
            }
        }
        annotationFields = annotationFieldsDecoded0
    }
}

extension StartAnnotationImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAnnotationImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartAnnotationImportJobOutput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartAnnotationImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartAnnotationImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartAnnotationImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReadSetActivationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for startreadsetactivationjobsourceitem0 in sources {
                try sourcesContainer.encode(startreadsetactivationjobsourceitem0)
            }
        }
    }
}

extension StartReadSetActivationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjob"
    }
}

public struct StartReadSetActivationJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]?

    public init(
        clientToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

struct StartReadSetActivationJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]?
}

extension StartReadSetActivationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.StartReadSetActivationJobSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.StartReadSetActivationJobSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.StartReadSetActivationJobSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReadSetActivationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReadSetActivationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.sequenceStoreId = nil
            self.status = nil
        }
    }
}

public struct StartReadSetActivationJobOutput: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetActivationJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

struct StartReadSetActivationJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let status: OmicsClientTypes.ReadSetActivationJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReadSetActivationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case sequenceStoreId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum StartReadSetActivationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.StartReadSetActivationJobSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readSetId = self.readSetId {
            try encodeContainer.encode(readSetId, forKey: .readSetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
    }
}

extension OmicsClientTypes {
    /// A source for a read set activation job.
    public struct StartReadSetActivationJobSourceItem: Swift.Equatable {
        /// The source's read set ID.
        /// This member is required.
        public var readSetId: Swift.String?

        public init(
            readSetId: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
        }
    }

}

extension StartReadSetExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destination
        case roleArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for exportreadset0 in sources {
                try sourcesContainer.encode(exportreadset0)
            }
        }
    }
}

extension StartReadSetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjob"
    }
}

public struct StartReadSetExportJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// A location for exported files in Amazon S3.
    /// This member is required.
    public var destination: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.ExportReadSet]?

    public init(
        clientToken: Swift.String? = nil,
        destination: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ExportReadSet]? = nil
    )
    {
        self.clientToken = clientToken
        self.destination = destination
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

struct StartReadSetExportJobInputBody: Swift.Equatable {
    let destination: Swift.String?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.ExportReadSet]?
}

extension StartReadSetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destination
        case roleArn
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ExportReadSet?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ExportReadSet]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ExportReadSet]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReadSetExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReadSetExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.id = output.id
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.id = nil
            self.sequenceStoreId = nil
            self.status = nil
        }
    }
}

public struct StartReadSetExportJobOutput: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's output location.
    /// This member is required.
    public var destination: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetExportJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetExportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

struct StartReadSetExportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let destination: Swift.String?
    let status: OmicsClientTypes.ReadSetExportJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReadSetExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case destination
        case id
        case sequenceStoreId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum StartReadSetExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReadSetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for startreadsetimportjobsourceitem0 in sources {
                try sourcesContainer.encode(startreadsetimportjobsourceitem0)
            }
        }
    }
}

extension StartReadSetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjob"
    }
}

public struct StartReadSetImportJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]?

    public init(
        clientToken: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

struct StartReadSetImportJobInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]?
}

extension StartReadSetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.StartReadSetImportJobSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.StartReadSetImportJobSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.StartReadSetImportJobSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReadSetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReadSetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.roleArn = output.roleArn
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.roleArn = nil
            self.sequenceStoreId = nil
            self.status = nil
        }
    }
}

public struct StartReadSetImportJobOutput: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetImportJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetImportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

struct StartReadSetImportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReadSetImportJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReadSetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case roleArn
        case sequenceStoreId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum StartReadSetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.StartReadSetImportJobSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sourceFileType
        case sourceFiles
        case subjectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sourceFileType = self.sourceFileType {
            try encodeContainer.encode(sourceFileType.rawValue, forKey: .sourceFileType)
        }
        if let sourceFiles = self.sourceFiles {
            try encodeContainer.encode(sourceFiles, forKey: .sourceFiles)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFilesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SourceFiles.self, forKey: .sourceFiles)
        sourceFiles = sourceFilesDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// A source for a read set import job.
    public struct StartReadSetImportJobSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source's reference ARN.
        /// This member is required.
        public var referenceArn: Swift.String?
        /// The source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The source's file type.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The source files' location in Amazon S3.
        /// This member is required.
        public var sourceFiles: OmicsClientTypes.SourceFiles?
        /// The source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            sourceFiles: OmicsClientTypes.SourceFiles? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFileType = sourceFileType
            self.sourceFiles = sourceFiles
            self.subjectId = subjectId
            self.tags = tags
        }
    }

}

extension StartReferenceImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for startreferenceimportjobsourceitem0 in sources {
                try sourcesContainer.encode(startreferenceimportjobsourceitem0)
            }
        }
    }
}

extension StartReferenceImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjob"
    }
}

public struct StartReferenceImportJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's source files.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]?

    public init(
        clientToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.sources = sources
    }
}

struct StartReferenceImportJobInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]?
}

extension StartReferenceImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.StartReferenceImportJobSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.StartReferenceImportJobSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.StartReferenceImportJobSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReferenceImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReferenceImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.referenceStoreId = output.referenceStoreId
            self.roleArn = output.roleArn
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.referenceStoreId = nil
            self.roleArn = nil
            self.status = nil
        }
    }
}

public struct StartReferenceImportJobOutput: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReferenceImportJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: OmicsClientTypes.ReferenceImportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.status = status
    }
}

struct StartReferenceImportJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let referenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReferenceImportJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReferenceImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case referenceStoreId
        case roleArn
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum StartReferenceImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.StartReferenceImportJobSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case sourceFile
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFile = self.sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// A source for a reference import job.
    public struct StartReferenceImportJobSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// The source's name.
        /// This member is required.
        public var name: Swift.String?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var sourceFile: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceFile: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.tags = tags
        }
    }

}

extension StartRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case name
        case outputUri
        case parameters
        case priority
        case requestId
        case retentionMode
        case roleArn
        case runGroupId
        case runId
        case storageCapacity
        case tags
        case workflowId
        case workflowType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputUri = self.outputUri {
            try encodeContainer.encode(outputUri, forKey: .outputUri)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let retentionMode = self.retentionMode {
            try encodeContainer.encode(retentionMode.rawValue, forKey: .retentionMode)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runGroupId = self.runGroupId {
            try encodeContainer.encode(runGroupId, forKey: .runGroupId)
        }
        if let runId = self.runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let storageCapacity = self.storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowType = self.workflowType {
            try encodeContainer.encode(workflowType.rawValue, forKey: .workflowType)
        }
    }
}

extension StartRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/run"
    }
}

public struct StartRunInput: Swift.Equatable {
    /// A log level for the run.
    public var logLevel: OmicsClientTypes.RunLogLevel?
    /// A name for the run.
    public var name: Swift.String?
    /// An output URI for the run.
    public var outputUri: Swift.String?
    /// Parameters for the run.
    public var parameters: ClientRuntime.Document?
    /// A priority for the run.
    public var priority: Swift.Int?
    /// To ensure that requests don't run multiple times, specify a unique ID for each request.
    /// This member is required.
    public var requestId: Swift.String?
    /// The retention mode for the run.
    public var retentionMode: OmicsClientTypes.RunRetentionMode?
    /// A service role for the run.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The run's group ID.
    public var runGroupId: Swift.String?
    /// The ID of a run to duplicate.
    public var runId: Swift.String?
    /// A storage capacity for the run in gigabytes.
    public var storageCapacity: Swift.Int?
    /// Tags for the run.
    public var tags: [Swift.String:Swift.String]?
    /// The run's workflow ID.
    public var workflowId: Swift.String?
    /// The run's workflow type.
    public var workflowType: OmicsClientTypes.WorkflowType?

    public init(
        logLevel: OmicsClientTypes.RunLogLevel? = nil,
        name: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        parameters: ClientRuntime.Document? = nil,
        priority: Swift.Int? = nil,
        requestId: Swift.String? = nil,
        retentionMode: OmicsClientTypes.RunRetentionMode? = nil,
        roleArn: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        runId: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowType: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.logLevel = logLevel
        self.name = name
        self.outputUri = outputUri
        self.parameters = parameters
        self.priority = priority
        self.requestId = requestId
        self.retentionMode = retentionMode
        self.roleArn = roleArn
        self.runGroupId = runGroupId
        self.runId = runId
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

struct StartRunInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let workflowType: OmicsClientTypes.WorkflowType?
    let runId: Swift.String?
    let roleArn: Swift.String?
    let name: Swift.String?
    let runGroupId: Swift.String?
    let priority: Swift.Int?
    let parameters: ClientRuntime.Document?
    let storageCapacity: Swift.Int?
    let outputUri: Swift.String?
    let logLevel: OmicsClientTypes.RunLogLevel?
    let tags: [Swift.String:Swift.String]?
    let requestId: Swift.String?
    let retentionMode: OmicsClientTypes.RunRetentionMode?
}

extension StartRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case name
        case outputUri
        case parameters
        case priority
        case requestId
        case retentionMode
        case roleArn
        case runGroupId
        case runId
        case storageCapacity
        case tags
        case workflowId
        case workflowType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let runGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runGroupId)
        runGroupId = runGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .parameters)
        parameters = parametersDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunLogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let retentionModeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunRetentionMode.self, forKey: .retentionMode)
        retentionMode = retentionModeDecoded
    }
}

extension StartRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartRunOutput: Swift.Equatable {
    /// The run's ARN.
    public var arn: Swift.String?
    /// The run's ID.
    public var id: Swift.String?
    /// The run's status.
    public var status: OmicsClientTypes.RunStatus?
    /// The run's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
        self.tags = tags
    }
}

struct StartRunOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.RunStatus?
    let tags: [Swift.String:Swift.String]?
}

extension StartRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum StartRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartVariantImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case destinationName
        case items
        case roleArn
        case runLeftNormalization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationFields = annotationFields {
            var annotationFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .annotationFields)
            for (dictKey0, annotationFieldMap0) in annotationFields {
                try annotationFieldsContainer.encode(annotationFieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for variantimportitemsource0 in items {
                try itemsContainer.encode(variantimportitemsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runLeftNormalization = self.runLeftNormalization {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
    }
}

extension StartVariantImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/variant"
    }
}

public struct StartVariantImportJobInput: Swift.Equatable {
    /// The annotation schema generated by the parsed annotation data.
    public var annotationFields: [Swift.String:Swift.String]?
    /// The destination variant store for the job.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Items to import.
    /// This member is required.
    public var items: [OmicsClientTypes.VariantImportItemSource]?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    public var runLeftNormalization: Swift.Bool?

    public init(
        annotationFields: [Swift.String:Swift.String]? = nil,
        destinationName: Swift.String? = nil,
        items: [OmicsClientTypes.VariantImportItemSource]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool? = nil
    )
    {
        self.annotationFields = annotationFields
        self.destinationName = destinationName
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
    }
}

struct StartVariantImportJobInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let items: [OmicsClientTypes.VariantImportItemSource]?
    let runLeftNormalization: Swift.Bool?
    let annotationFields: [Swift.String:Swift.String]?
}

extension StartVariantImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case destinationName
        case items
        case roleArn
        case runLeftNormalization
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantImportItemSource?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.VariantImportItemSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.VariantImportItemSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization)
        runLeftNormalization = runLeftNormalizationDecoded
        let annotationFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .annotationFields)
        var annotationFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let annotationFieldsContainer = annotationFieldsContainer {
            annotationFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in annotationFieldsContainer {
                if let string0 = string0 {
                    annotationFieldsDecoded0?[key0] = string0
                }
            }
        }
        annotationFields = annotationFieldsDecoded0
    }
}

extension StartVariantImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartVariantImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartVariantImportJobOutput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartVariantImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartVariantImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartVariantImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes {
    public enum StoreFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// GFF3 Format
        case gff
        /// TSV Format
        case tsv
        /// VCF Format
        case vcf
        case sdkUnknown(Swift.String)

        public static var allCases: [StoreFormat] {
            return [
                .gff,
                .tsv,
                .vcf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gff: return "GFF"
            case .tsv: return "TSV"
            case .vcf: return "VCF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StoreFormat(rawValue: rawValue) ?? StoreFormat.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.StoreOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tsvstoreoptions = "tsvStoreOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tsvstoreoptions(tsvstoreoptions):
                try container.encode(tsvstoreoptions, forKey: .tsvstoreoptions)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tsvstoreoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.TsvStoreOptions.self, forKey: .tsvstoreoptions)
        if let tsvstoreoptions = tsvstoreoptionsDecoded {
            self = .tsvstoreoptions(tsvstoreoptions)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// Settings for a store.
    public enum StoreOptions: Swift.Equatable {
        /// File settings for a TSV store.
        case tsvstoreoptions(OmicsClientTypes.TsvStoreOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {
    public enum StoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The Store is active
        case active
        /// The Store is being created
        case creating
        /// The Store is deleting
        case deleting
        /// The Store creation failed
        case failed
        /// The Store is updating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [StoreStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StoreStatus(rawValue: rawValue) ?? StoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OmicsClientTypes.TaskListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case creationTime
        case gpus
        case instanceType
        case memory
        case name
        case startTime
        case status
        case stopTime
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = self.cpus {
            try encodeContainer.encode(cpus, forKey: .cpus)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let gpus = self.gpus {
            try encodeContainer.encode(gpus, forKey: .gpus)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .dateTime, forKey: .stopTime)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.TaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let cpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpus)
        cpus = cpusDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let gpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gpus)
        gpus = gpusDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow run task.
    public struct TaskListItem: Swift.Equatable {
        /// The task's CPU count.
        public var cpus: Swift.Int?
        /// When the task was created.
        public var creationTime: ClientRuntime.Date?
        /// The number of Graphics Processing Units (GPU) specified for the task.
        public var gpus: Swift.Int?
        /// The instance type for a task.
        public var instanceType: Swift.String?
        /// The task's memory use in gigabyes.
        public var memory: Swift.Int?
        /// The task's name.
        public var name: Swift.String?
        /// When the task started.
        public var startTime: ClientRuntime.Date?
        /// The task's status.
        public var status: OmicsClientTypes.TaskStatus?
        /// When the task stopped.
        public var stopTime: ClientRuntime.Date?
        /// The task's ID.
        public var taskId: Swift.String?

        public init(
            cpus: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            gpus: Swift.Int? = nil,
            instanceType: Swift.String? = nil,
            memory: Swift.Int? = nil,
            name: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.TaskStatus? = nil,
            stopTime: ClientRuntime.Date? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.creationTime = creationTime
            self.gpus = gpus
            self.instanceType = instanceType
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.taskId = taskId
        }
    }

}

extension OmicsClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case pending
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .pending,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.TsvOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readOptions = self.readOptions {
            try encodeContainer.encode(readOptions, forKey: .readOptions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadOptions.self, forKey: .readOptions)
        readOptions = readOptionsDecoded
    }
}

extension OmicsClientTypes {
    /// Formatting options for a TSV file.
    public struct TsvOptions: Swift.Equatable {
        /// The file's read options.
        public var readOptions: OmicsClientTypes.ReadOptions?

        public init(
            readOptions: OmicsClientTypes.ReadOptions? = nil
        )
        {
            self.readOptions = readOptions
        }
    }

}

extension OmicsClientTypes.TsvStoreOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationType
        case formatToHeader
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationType = self.annotationType {
            try encodeContainer.encode(annotationType.rawValue, forKey: .annotationType)
        }
        if let formatToHeader = formatToHeader {
            var formatToHeaderContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatToHeader)
            for (dictKey0, formatToHeader0) in formatToHeader {
                try formatToHeaderContainer.encode(formatToHeader0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for schemaitem0 in schema {
                var schemaitem0Container = schemaContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, schemaItem1) in schemaitem0 {
                    try schemaitem0Container.encode(schemaItem1.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.AnnotationType.self, forKey: .annotationType)
        annotationType = annotationTypeDecoded
        let formatToHeaderContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatToHeader)
        var formatToHeaderDecoded0: [Swift.String:Swift.String]? = nil
        if let formatToHeaderContainer = formatToHeaderContainer {
            formatToHeaderDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in formatToHeaderContainer {
                if let string0 = string0 {
                    formatToHeaderDecoded0?[key0] = string0
                }
            }
        }
        formatToHeader = formatToHeaderDecoded0
        let schemaContainer = try containerValues.decodeIfPresent([[Swift.String: OmicsClientTypes.SchemaValueType?]?].self, forKey: .schema)
        var schemaDecoded0:[[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [[Swift.String:OmicsClientTypes.SchemaValueType]]()
            for map0 in schemaContainer {
                var schemaContainerDecoded0: [Swift.String: OmicsClientTypes.SchemaValueType]? = nil
                if let map0 = map0 {
                    schemaContainerDecoded0 = [Swift.String: OmicsClientTypes.SchemaValueType]()
                    for (key1, schemavaluetype1) in map0 {
                        if let schemavaluetype1 = schemavaluetype1 {
                            schemaContainerDecoded0?[key1] = schemavaluetype1
                        }
                    }
                }
                if let schemaContainerDecoded0 = schemaContainerDecoded0 {
                    schemaDecoded0?.append(schemaContainerDecoded0)
                }
            }
        }
        schema = schemaDecoded0
    }
}

extension OmicsClientTypes {
    /// File settings for a TSV store.
    public struct TsvStoreOptions: Swift.Equatable {
        /// The store's annotation type.
        public var annotationType: OmicsClientTypes.AnnotationType?
        /// The store's header key to column name mapping.
        public var formatToHeader: [Swift.String:Swift.String]?
        /// The store's schema.
        public var schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]?

        public init(
            annotationType: OmicsClientTypes.AnnotationType? = nil,
            formatToHeader: [Swift.String:Swift.String]? = nil,
            schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        )
        {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }
    }

}

extension OmicsClientTypes.TsvVersionOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationType
        case formatToHeader
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationType = self.annotationType {
            try encodeContainer.encode(annotationType.rawValue, forKey: .annotationType)
        }
        if let formatToHeader = formatToHeader {
            var formatToHeaderContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatToHeader)
            for (dictKey0, formatToHeader0) in formatToHeader {
                try formatToHeaderContainer.encode(formatToHeader0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for schemaitem0 in schema {
                var schemaitem0Container = schemaContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, schemaItem1) in schemaitem0 {
                    try schemaitem0Container.encode(schemaItem1.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.AnnotationType.self, forKey: .annotationType)
        annotationType = annotationTypeDecoded
        let formatToHeaderContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatToHeader)
        var formatToHeaderDecoded0: [Swift.String:Swift.String]? = nil
        if let formatToHeaderContainer = formatToHeaderContainer {
            formatToHeaderDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in formatToHeaderContainer {
                if let string0 = string0 {
                    formatToHeaderDecoded0?[key0] = string0
                }
            }
        }
        formatToHeader = formatToHeaderDecoded0
        let schemaContainer = try containerValues.decodeIfPresent([[Swift.String: OmicsClientTypes.SchemaValueType?]?].self, forKey: .schema)
        var schemaDecoded0:[[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [[Swift.String:OmicsClientTypes.SchemaValueType]]()
            for map0 in schemaContainer {
                var schemaContainerDecoded0: [Swift.String: OmicsClientTypes.SchemaValueType]? = nil
                if let map0 = map0 {
                    schemaContainerDecoded0 = [Swift.String: OmicsClientTypes.SchemaValueType]()
                    for (key1, schemavaluetype1) in map0 {
                        if let schemavaluetype1 = schemavaluetype1 {
                            schemaContainerDecoded0?[key1] = schemavaluetype1
                        }
                    }
                }
                if let schemaContainerDecoded0 = schemaContainerDecoded0 {
                    schemaDecoded0?.append(schemaContainerDecoded0)
                }
            }
        }
        schema = schemaDecoded0
    }
}

extension OmicsClientTypes {
    /// The options for a TSV file.
    public struct TsvVersionOptions: Swift.Equatable {
        /// The store version's annotation type.
        public var annotationType: OmicsClientTypes.AnnotationType?
        /// The annotation store version's header key to column name mapping.
        public var formatToHeader: [Swift.String:Swift.String]?
        /// The TSV schema for an annotation store version.
        public var schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]?

        public init(
            annotationType: OmicsClientTypes.AnnotationType? = nil,
            formatToHeader: [Swift.String:Swift.String]? = nil,
            schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        )
        {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAnnotationStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct UpdateAnnotationStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateAnnotationStoreInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateAnnotationStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAnnotationStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAnnotationStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
            self.storeFormat = output.storeFormat
            self.storeOptions = output.storeOptions
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
            self.storeFormat = nil
            self.storeOptions = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateAnnotationStoreOutput: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The annotation file format of the store.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// Parsing options for the store.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.updateTime = updateTime
    }
}

struct UpdateAnnotationStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let storeOptions: OmicsClientTypes.StoreOptions?
    let storeFormat: OmicsClientTypes.StoreFormat?
}

extension UpdateAnnotationStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case status
        case storeFormat
        case storeOptions
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
    }
}

enum UpdateAnnotationStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAnnotationStoreVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateAnnotationStoreVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        guard let versionName = versionName else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())/version/\(versionName.urlPercentEncoding())"
    }
}

public struct UpdateAnnotationStoreVersionInput: Swift.Equatable {
    /// The description of an annotation store.
    public var description: Swift.String?
    /// The name of an annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// The name of an annotation store version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.versionName = versionName
    }
}

struct UpdateAnnotationStoreVersionInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateAnnotationStoreVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAnnotationStoreVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAnnotationStoreVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.storeId = output.storeId
            self.updateTime = output.updateTime
            self.versionName = output.versionName
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.storeId = nil
            self.updateTime = nil
            self.versionName = nil
        }
    }
}

public struct UpdateAnnotationStoreVersionOutput: Swift.Equatable {
    /// The time stamp for when an annotation store version was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description of an annotation store version.
    /// This member is required.
    public var description: Swift.String?
    /// The annotation store version ID.
    /// This member is required.
    public var id: Swift.String?
    /// The name of an annotation store.
    /// This member is required.
    public var name: Swift.String?
    /// The status of an annotation store version.
    /// This member is required.
    public var status: OmicsClientTypes.VersionStatus?
    /// The annotation store ID.
    /// This member is required.
    public var storeId: Swift.String?
    /// The time stamp for when an annotation store version was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?
    /// The name of an annotation store version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OmicsClientTypes.VersionStatus? = nil,
        storeId: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.storeId = storeId
        self.updateTime = updateTime
        self.versionName = versionName
    }
}

struct UpdateAnnotationStoreVersionOutputBody: Swift.Equatable {
    let storeId: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.VersionStatus?
    let name: Swift.String?
    let versionName: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension UpdateAnnotationStoreVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case status
        case storeId
        case updateTime
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeId)
        storeId = storeIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.VersionStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateAnnotationStoreVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRunGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxGpus
        case maxRuns
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxCpus = self.maxCpus {
            try encodeContainer.encode(maxCpus, forKey: .maxCpus)
        }
        if let maxDuration = self.maxDuration {
            try encodeContainer.encode(maxDuration, forKey: .maxDuration)
        }
        if let maxGpus = self.maxGpus {
            try encodeContainer.encode(maxGpus, forKey: .maxGpus)
        }
        if let maxRuns = self.maxRuns {
            try encodeContainer.encode(maxRuns, forKey: .maxRuns)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct UpdateRunGroupInput: Swift.Equatable {
    /// The group's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of CPUs to use.
    public var maxCpus: Swift.Int?
    /// A maximum run time for the group in minutes.
    public var maxDuration: Swift.Int?
    /// The maximum GPUs that can be used by a run group.
    public var maxGpus: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// A name for the group.
    public var name: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxGpus: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.id = id
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxGpus = maxGpus
        self.maxRuns = maxRuns
        self.name = name
    }
}

struct UpdateRunGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxCpus: Swift.Int?
    let maxRuns: Swift.Int?
    let maxDuration: Swift.Int?
    let maxGpus: Swift.Int?
}

extension UpdateRunGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxGpus
        case maxRuns
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let maxGpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxGpus)
        maxGpus = maxGpusDecoded
    }
}

extension UpdateRunGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRunGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRunGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVariantStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct UpdateVariantStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateVariantStoreInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateVariantStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateVariantStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVariantStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateVariantStoreOutput: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.updateTime = updateTime
    }
}

struct UpdateVariantStoreOutputBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension UpdateVariantStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case status
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateVariantStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowInput: Swift.Equatable {
    /// A description for the workflow.
    public var description: Swift.String?
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?
    /// A name for the workflow.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWorkflowOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct UploadReadSetPartInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadReadSetPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadReadSetPartInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UploadReadSetPartOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let payload = input.operationInput.payload {
            let payloadBody = ClientRuntime.HttpBody(byteStream: payload)
            input.builder.withBody(payloadBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadReadSetPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadReadSetPartOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UploadReadSetPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }
}

extension UploadReadSetPartInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partSource = partSource else {
                let message = "Creating a URL Query Item failed. partSource is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partSourceQueryItem = ClientRuntime.URLQueryItem(name: "partSource".urlPercentEncoding(), value: Swift.String(partSource.rawValue).urlPercentEncoding())
            items.append(partSourceQueryItem)
            guard let partNumber = partNumber else {
                let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
            return items
        }
    }
}

extension UploadReadSetPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/upload/\(uploadId.urlPercentEncoding())/part"
    }
}

public struct UploadReadSetPartInput: Swift.Equatable {
    /// The number of the part being uploaded.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The source file for an upload part.
    /// This member is required.
    public var partSource: OmicsClientTypes.ReadSetPartSource?
    /// The read set data to upload for a part.
    /// This member is required.
    public var payload: ClientRuntime.ByteStream?
    /// The Sequence Store ID used for the multipart upload.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The ID for the initiated multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        partNumber: Swift.Int? = nil,
        partSource: OmicsClientTypes.ReadSetPartSource? = nil,
        payload: ClientRuntime.ByteStream? = nil,
        sequenceStoreId: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.partNumber = partNumber
        self.partSource = partSource
        self.payload = payload
        self.sequenceStoreId = sequenceStoreId
        self.uploadId = uploadId
    }
}

struct UploadReadSetPartInputBody: Swift.Equatable {
    let payload: ClientRuntime.ByteStream?
}

extension UploadReadSetPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension UploadReadSetPartOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadReadSetPartOutputBody = try responseDecoder.decode(responseBody: data)
            self.checksum = output.checksum
        } else {
            self.checksum = nil
        }
    }
}

public struct UploadReadSetPartOutput: Swift.Equatable {
    /// An identifier used to confirm that parts are being added to the intended upload.
    /// This member is required.
    public var checksum: Swift.String?

    public init(
        checksum: Swift.String? = nil
    )
    {
        self.checksum = checksum
    }
}

struct UploadReadSetPartOutputBody: Swift.Equatable {
    let checksum: Swift.String?
}

extension UploadReadSetPartOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
    }
}

enum UploadReadSetPartOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotSupportedOperationException": return try await NotSupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.VariantImportItemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatus
        case source
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension OmicsClientTypes {
    /// Details about an imported variant item.
    public struct VariantImportItemDetail: Swift.Equatable {
        /// The item's job status.
        /// This member is required.
        public var jobStatus: OmicsClientTypes.JobStatus?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?
        /// A message that provides additional context about a job
        public var statusMessage: Swift.String?

        public init(
            jobStatus: OmicsClientTypes.JobStatus? = nil,
            source: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.jobStatus = jobStatus
            self.source = source
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.VariantImportItemSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension OmicsClientTypes {
    /// A imported variant item's source.
    public struct VariantImportItemSource: Swift.Equatable {
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init(
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension OmicsClientTypes.VariantImportJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationFields
        case completionTime
        case creationTime
        case destinationName
        case id
        case roleArn
        case runLeftNormalization
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationFields = annotationFields {
            var annotationFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .annotationFields)
            for (dictKey0, annotationFieldMap0) in annotationFields {
                try annotationFieldsContainer.encode(annotationFieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if runLeftNormalization != false {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
        let annotationFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .annotationFields)
        var annotationFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let annotationFieldsContainer = annotationFieldsContainer {
            annotationFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in annotationFieldsContainer {
                if let string0 = string0 {
                    annotationFieldsDecoded0?[key0] = string0
                }
            }
        }
        annotationFields = annotationFieldsDecoded0
    }
}

extension OmicsClientTypes {
    /// A variant import job.
    public struct VariantImportJobItem: Swift.Equatable {
        /// The annotation schema generated by the parsed annotation data.
        public var annotationFields: [Swift.String:Swift.String]?
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination variant store.
        /// This member is required.
        public var destinationName: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's left normalization setting.
        public var runLeftNormalization: Swift.Bool
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.JobStatus?
        /// When the job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            annotationFields: [Swift.String:Swift.String]? = nil,
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runLeftNormalization: Swift.Bool = false,
            status: OmicsClientTypes.JobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.annotationFields = annotationFields
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.VariantStoreItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeSizeBytes
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let storeArn = self.storeArn {
            try encodeContainer.encode(storeArn, forKey: .storeArn)
        }
        if let storeSizeBytes = self.storeSizeBytes {
            try encodeContainer.encode(storeSizeBytes, forKey: .storeSizeBytes)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

extension OmicsClientTypes {
    /// A variant store.
    public struct VariantStoreItem: Swift.Equatable {
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        /// This member is required.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        /// This member is required.
        public var name: Swift.String?
        /// The store's genome reference.
        /// This member is required.
        public var reference: OmicsClientTypes.ReferenceItem?
        /// The store's server-side encryption (SSE) settings.
        /// This member is required.
        public var sseConfig: OmicsClientTypes.SseConfig?
        /// The store's status.
        /// This member is required.
        public var status: OmicsClientTypes.StoreStatus?
        /// The store's status message.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store's ARN.
        /// This member is required.
        public var storeArn: Swift.String?
        /// The store's size in bytes.
        /// This member is required.
        public var storeSizeBytes: Swift.Int?
        /// When the store was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reference: OmicsClientTypes.ReferenceItem? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil,
            status: OmicsClientTypes.StoreStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeArn: Swift.String? = nil,
            storeSizeBytes: Swift.Int? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.VcfOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignoreFilterField
        case ignoreQualField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignoreFilterField = self.ignoreFilterField {
            try encodeContainer.encode(ignoreFilterField, forKey: .ignoreFilterField)
        }
        if let ignoreQualField = self.ignoreQualField {
            try encodeContainer.encode(ignoreQualField, forKey: .ignoreQualField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignoreQualFieldDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreQualField)
        ignoreQualField = ignoreQualFieldDecoded
        let ignoreFilterFieldDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreFilterField)
        ignoreFilterField = ignoreFilterFieldDecoded
    }
}

extension OmicsClientTypes {
    /// Formatting options for a VCF file.
    public struct VcfOptions: Swift.Equatable {
        /// The file's ignore filter field setting.
        public var ignoreFilterField: Swift.Bool?
        /// The file's ignore qual field setting.
        public var ignoreQualField: Swift.Bool?

        public init(
            ignoreFilterField: Swift.Bool? = nil,
            ignoreQualField: Swift.Bool? = nil
        )
        {
            self.ignoreFilterField = ignoreFilterField
            self.ignoreQualField = ignoreQualField
        }
    }

}

extension OmicsClientTypes.VersionDeleteError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    /// The error preventing deletion of the annotation store version.
    public struct VersionDeleteError: Swift.Equatable {
        /// The message explaining the error in annotation store deletion.
        /// This member is required.
        public var message: Swift.String?
        /// The name given to an annotation store version.
        /// This member is required.
        public var versionName: Swift.String?

        public init(
            message: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.message = message
            self.versionName = versionName
        }
    }

}

extension OmicsClientTypes.VersionOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tsvversionoptions = "tsvVersionOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tsvversionoptions(tsvversionoptions):
                try container.encode(tsvversionoptions, forKey: .tsvversionoptions)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tsvversionoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.TsvVersionOptions.self, forKey: .tsvversionoptions)
        if let tsvversionoptions = tsvversionoptionsDecoded {
            self = .tsvversionoptions(tsvversionoptions)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// The options for an annotation store version.
    public enum VersionOptions: Swift.Equatable {
        /// File settings for a version of a TSV store.
        case tsvversionoptions(OmicsClientTypes.TsvVersionOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {
    public enum VersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The Version is active
        case active
        /// The Version is being created
        case creating
        /// The Version is deleting
        case deleting
        /// The Version creation failed
        case failed
        /// The Version is updating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VersionStatus(rawValue: rawValue) ?? VersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum WorkflowEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cwl
        case nextflow
        case wdl
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowEngine] {
            return [
                .cwl,
                .nextflow,
                .wdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cwl: return "CWL"
            case .nextflow: return "NEXTFLOW"
            case .wdl: return "WDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowEngine(rawValue: rawValue) ?? WorkflowEngine.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum WorkflowExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowExport] {
            return [
                .definition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .definition: return "DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowExport(rawValue: rawValue) ?? WorkflowExport.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.WorkflowListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case digest
        case id
        case metadata
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let digest = self.digest {
            try encodeContainer.encode(digest, forKey: .digest)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, workflowMetadata0) in metadata {
                try metadataContainer.encode(workflowMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .type)
        type = typeDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, workflowmetadatavalue0) in metadataContainer {
                if let workflowmetadatavalue0 = workflowmetadatavalue0 {
                    metadataDecoded0?[key0] = workflowmetadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension OmicsClientTypes {
    /// A workflow.
    public struct WorkflowListItem: Swift.Equatable {
        /// The workflow's ARN.
        public var arn: Swift.String?
        /// When the workflow was created.
        public var creationTime: ClientRuntime.Date?
        /// The workflow's digest.
        public var digest: Swift.String?
        /// The workflow's ID.
        public var id: Swift.String?
        /// Any metadata available for workflow. The information listed may vary depending on the workflow, and there may also be no metadata to return.
        public var metadata: [Swift.String:Swift.String]?
        /// The workflow's name.
        public var name: Swift.String?
        /// The workflow's status.
        public var status: OmicsClientTypes.WorkflowStatus?
        /// The workflow's type.
        public var type: OmicsClientTypes.WorkflowType?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            digest: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            status: OmicsClientTypes.WorkflowStatus? = nil,
            type: OmicsClientTypes.WorkflowType? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.digest = digest
            self.id = id
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension OmicsClientTypes.WorkflowParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `optional` = "optional"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let `optional` = self.`optional` {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let optionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optional)
        `optional` = optionalDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow parameter.
    public struct WorkflowParameter: Swift.Equatable {
        /// The parameter's description.
        public var description: Swift.String?
        /// Whether the parameter is optional.
        public var `optional`: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            `optional`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`optional` = `optional`
        }
    }

}

extension OmicsClientTypes {
    public enum WorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case failed
        case inactive
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .failed,
                .inactive,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStatus(rawValue: rawValue) ?? WorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum WorkflowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case ready2run
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .private,
                .ready2run,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .ready2run: return "READY2RUN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowType(rawValue: rawValue) ?? WorkflowType.sdkUnknown(rawValue)
        }
    }
}
