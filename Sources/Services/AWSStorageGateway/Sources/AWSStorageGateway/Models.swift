//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox

extension StorageGatewayClientTypes {

    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activationkeyexpired
        case activationkeyinvalid
        case activationkeynotfound
        case authenticationfailure
        case bandwidththrottleschedulenotfound
        case blocked
        case cannotexportsnapshot
        case chapcredentialnotfound
        case diskalreadyallocated
        case diskdoesnotexist
        case disksizegreaterthanvolumemaxsize
        case disksizelessthanvolumesize
        case disksizenotgigaligned
        case duplicatecertificateinfo
        case duplicateschedule
        case endpointnotfound
        case gatewayinternalerror
        case gatewaynotconnected
        case gatewaynotfound
        case gatewayproxynetworkconnectionbusy
        case iamnotsupported
        case initiatorinvalid
        case initiatornotfound
        case internalerror
        case invalidendpoint
        case invalidgateway
        case invalidparameters
        case invalidschedule
        case joindomaininprogress
        case localstoragelimitexceeded
        case lunalreadyallocated
        case luninvalid
        case maximumcontentlengthexceeded
        case maximumtapecartridgecountexceeded
        case maximumvolumecountexceeded
        case networkconfigurationchanged
        case nodisksavailable
        case notimplemented
        case notsupported
        case operationaborted
        case outdatedgateway
        case parametersnotimplemented
        case regioninvalid
        case requesttimeout
        case serviceunavailable
        case snapshotdeleted
        case snapshotidinvalid
        case snapshotinprogress
        case snapshotnotfound
        case snapshotschedulenotfound
        case stagingareafull
        case storagefailure
        case tapecartridgenotfound
        case targetalreadyexists
        case targetinvalid
        case targetnotfound
        case unauthorizedoperation
        case volumealreadyexists
        case volumeidinvalid
        case volumeinuse
        case volumenotfound
        case volumenotready
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .activationkeyexpired,
                .activationkeyinvalid,
                .activationkeynotfound,
                .authenticationfailure,
                .bandwidththrottleschedulenotfound,
                .blocked,
                .cannotexportsnapshot,
                .chapcredentialnotfound,
                .diskalreadyallocated,
                .diskdoesnotexist,
                .disksizegreaterthanvolumemaxsize,
                .disksizelessthanvolumesize,
                .disksizenotgigaligned,
                .duplicatecertificateinfo,
                .duplicateschedule,
                .endpointnotfound,
                .gatewayinternalerror,
                .gatewaynotconnected,
                .gatewaynotfound,
                .gatewayproxynetworkconnectionbusy,
                .iamnotsupported,
                .initiatorinvalid,
                .initiatornotfound,
                .internalerror,
                .invalidendpoint,
                .invalidgateway,
                .invalidparameters,
                .invalidschedule,
                .joindomaininprogress,
                .localstoragelimitexceeded,
                .lunalreadyallocated,
                .luninvalid,
                .maximumcontentlengthexceeded,
                .maximumtapecartridgecountexceeded,
                .maximumvolumecountexceeded,
                .networkconfigurationchanged,
                .nodisksavailable,
                .notimplemented,
                .notsupported,
                .operationaborted,
                .outdatedgateway,
                .parametersnotimplemented,
                .regioninvalid,
                .requesttimeout,
                .serviceunavailable,
                .snapshotdeleted,
                .snapshotidinvalid,
                .snapshotinprogress,
                .snapshotnotfound,
                .snapshotschedulenotfound,
                .stagingareafull,
                .storagefailure,
                .tapecartridgenotfound,
                .targetalreadyexists,
                .targetinvalid,
                .targetnotfound,
                .unauthorizedoperation,
                .volumealreadyexists,
                .volumeidinvalid,
                .volumeinuse,
                .volumenotfound,
                .volumenotready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activationkeyexpired: return "ActivationKeyExpired"
            case .activationkeyinvalid: return "ActivationKeyInvalid"
            case .activationkeynotfound: return "ActivationKeyNotFound"
            case .authenticationfailure: return "AuthenticationFailure"
            case .bandwidththrottleschedulenotfound: return "BandwidthThrottleScheduleNotFound"
            case .blocked: return "Blocked"
            case .cannotexportsnapshot: return "CannotExportSnapshot"
            case .chapcredentialnotfound: return "ChapCredentialNotFound"
            case .diskalreadyallocated: return "DiskAlreadyAllocated"
            case .diskdoesnotexist: return "DiskDoesNotExist"
            case .disksizegreaterthanvolumemaxsize: return "DiskSizeGreaterThanVolumeMaxSize"
            case .disksizelessthanvolumesize: return "DiskSizeLessThanVolumeSize"
            case .disksizenotgigaligned: return "DiskSizeNotGigAligned"
            case .duplicatecertificateinfo: return "DuplicateCertificateInfo"
            case .duplicateschedule: return "DuplicateSchedule"
            case .endpointnotfound: return "EndpointNotFound"
            case .gatewayinternalerror: return "GatewayInternalError"
            case .gatewaynotconnected: return "GatewayNotConnected"
            case .gatewaynotfound: return "GatewayNotFound"
            case .gatewayproxynetworkconnectionbusy: return "GatewayProxyNetworkConnectionBusy"
            case .iamnotsupported: return "IAMNotSupported"
            case .initiatorinvalid: return "InitiatorInvalid"
            case .initiatornotfound: return "InitiatorNotFound"
            case .internalerror: return "InternalError"
            case .invalidendpoint: return "InvalidEndpoint"
            case .invalidgateway: return "InvalidGateway"
            case .invalidparameters: return "InvalidParameters"
            case .invalidschedule: return "InvalidSchedule"
            case .joindomaininprogress: return "JoinDomainInProgress"
            case .localstoragelimitexceeded: return "LocalStorageLimitExceeded"
            case .lunalreadyallocated: return "LunAlreadyAllocated "
            case .luninvalid: return "LunInvalid"
            case .maximumcontentlengthexceeded: return "MaximumContentLengthExceeded"
            case .maximumtapecartridgecountexceeded: return "MaximumTapeCartridgeCountExceeded"
            case .maximumvolumecountexceeded: return "MaximumVolumeCountExceeded"
            case .networkconfigurationchanged: return "NetworkConfigurationChanged"
            case .nodisksavailable: return "NoDisksAvailable"
            case .notimplemented: return "NotImplemented"
            case .notsupported: return "NotSupported"
            case .operationaborted: return "OperationAborted"
            case .outdatedgateway: return "OutdatedGateway"
            case .parametersnotimplemented: return "ParametersNotImplemented"
            case .regioninvalid: return "RegionInvalid"
            case .requesttimeout: return "RequestTimeout"
            case .serviceunavailable: return "ServiceUnavailable"
            case .snapshotdeleted: return "SnapshotDeleted"
            case .snapshotidinvalid: return "SnapshotIdInvalid"
            case .snapshotinprogress: return "SnapshotInProgress"
            case .snapshotnotfound: return "SnapshotNotFound"
            case .snapshotschedulenotfound: return "SnapshotScheduleNotFound"
            case .stagingareafull: return "StagingAreaFull"
            case .storagefailure: return "StorageFailure"
            case .tapecartridgenotfound: return "TapeCartridgeNotFound"
            case .targetalreadyexists: return "TargetAlreadyExists"
            case .targetinvalid: return "TargetInvalid"
            case .targetnotfound: return "TargetNotFound"
            case .unauthorizedoperation: return "UnauthorizedOperation"
            case .volumealreadyexists: return "VolumeAlreadyExists"
            case .volumeidinvalid: return "VolumeIdInvalid"
            case .volumeinuse: return "VolumeInUse"
            case .volumenotfound: return "VolumeNotFound"
            case .volumenotready: return "VolumeNotReady"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Provides additional information about an error that was returned by the service. See the errorCode and errorDetails members for more information about the error.
    public struct StorageGatewayError {
        /// Additional information about the error.
        public var errorCode: StorageGatewayClientTypes.ErrorCode?
        /// Human-readable text that provides detail about the error that occurred.
        public var errorDetails: [Swift.String: Swift.String]?

        public init(
            errorCode: StorageGatewayClientTypes.ErrorCode? = nil,
            errorDetails: [Swift.String: Swift.String]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
        }
    }

}

/// An internal server error has occurred during the request. For more information, see the error and message fields.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A [StorageGatewayError] that provides more information about the cause of the error.
        public internal(set) var error: StorageGatewayClientTypes.StorageGatewayError? = nil
        /// A human-readable message describing the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.message = message
    }
}

/// An exception occurred because an invalid gateway request was issued to the service. For more information, see the error and message fields.
public struct InvalidGatewayRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A [StorageGatewayError] that provides more detail about the cause of the error.
        public internal(set) var error: StorageGatewayClientTypes.StorageGatewayError? = nil
        /// A human-readable message describing the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGatewayRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.message = message
    }
}

extension StorageGatewayClientTypes {
    /// A key-value pair that helps you manage, filter, and search for your resource. Allowed characters: letters, white space, and numbers, representable in UTF-8, and the following characters: + - = . _ : /.
    public struct Tag {
        /// Tag key. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

/// A JSON object containing one or more of the following fields:
///
/// * [ActivateGatewayInput$ActivationKey]
///
/// * [ActivateGatewayInput$GatewayName]
///
/// * [ActivateGatewayInput$GatewayRegion]
///
/// * [ActivateGatewayInput$GatewayTimezone]
///
/// * [ActivateGatewayInput$GatewayType]
///
/// * [ActivateGatewayInput$MediumChangerType]
///
/// * [ActivateGatewayInput$TapeDriveType]
public struct ActivateGatewayInput {
    /// Your gateway activation key. You can obtain the activation key by sending an HTTP GET request with redirects enabled to the gateway IP address (port 80). The redirect URL returned in the response provides you the activation key for your gateway in the query string parameter activationKey. It may also include other activation-related parameters, however, these are merely defaults -- the arguments you pass to the ActivateGateway API call determine the actual configuration of your gateway. For more information, see [Getting activation key](https://docs.aws.amazon.com/storagegateway/latest/userguide/get-activation-key.html) in the Storage Gateway User Guide.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The name you configured for your gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// A value that indicates the Amazon Web Services Region where you want to store your data. The gateway Amazon Web Services Region specified must be the same Amazon Web Services Region as the Amazon Web Services Region in your Host header in the request. For more information about available Amazon Web Services Regions and endpoints for Storage Gateway, see [ Storage Gateway endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/sg.html) in the Amazon Web Services General Reference. Valid Values: See [ Storage Gateway endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/sg.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var gatewayRegion: Swift.String?
    /// A value that indicates the time zone you want to set for the gateway. The time zone is of the format "GMT", "GMT-hr:mm", or "GMT+hr:mm". For example, GMT indicates Greenwich Mean Time without any offset. GMT-4:00 indicates the time is 4 hours behind GMT. GMT+2:00 indicates the time is 2 hours ahead of GMT. The time zone is used, for example, for scheduling snapshots and your gateway's maintenance schedule.
    /// This member is required.
    public var gatewayTimezone: Swift.String?
    /// A value that defines the type of gateway to activate. The type specified is critical to all later functions of the gateway and cannot be changed after activation. The default value is CACHED. Valid Values: STORED | CACHED | VTL | FILE_S3 | FILE_FSX_SMB
    public var gatewayType: Swift.String?
    /// The value that indicates the type of medium changer to use for tape gateway. This field is optional. Valid Values: STK-L700 | AWS-Gateway-VTL | IBM-03584L32-0402
    public var mediumChangerType: Swift.String?
    /// A list of up to 50 tags that you can assign to the gateway. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers that can be represented in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256 characters.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The value that indicates the type of tape drive to use for tape gateway. This field is optional. Valid Values: IBM-ULT3580-TD5
    public var tapeDriveType: Swift.String?

    public init(
        activationKey: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayRegion: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil,
        gatewayType: Swift.String? = nil,
        mediumChangerType: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeDriveType: Swift.String? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayName = gatewayName
        self.gatewayRegion = gatewayRegion
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.mediumChangerType = mediumChangerType
        self.tags = tags
        self.tapeDriveType = tapeDriveType
    }
}

/// Storage Gateway returns the Amazon Resource Name (ARN) of the activated gateway. It is a string made of information such as your account, gateway name, and Amazon Web Services Region. This ARN is used to reference the gateway in other API operations as well as resource-based authorization. For gateways activated prior to September 02, 2015, the gateway ARN contains the gateway name rather than the gateway ID. Changing the name of the gateway has no effect on the gateway ARN.
public struct ActivateGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

extension StorageGatewayClientTypes {

    public enum ActiveDirectoryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case detached
        case joined
        case joining
        case networkError
        case timeout
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveDirectoryStatus] {
            return [
                .accessDenied,
                .detached,
                .joined,
                .joining,
                .networkError,
                .timeout,
                .unknownError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .detached: return "DETACHED"
            case .joined: return "JOINED"
            case .joining: return "JOINING"
            case .networkError: return "NETWORK_ERROR"
            case .timeout: return "TIMEOUT"
            case .unknownError: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AddCacheInput {
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

public struct AddCacheOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// AddTagsToResourceInput
public struct AddTagsToResourceInput {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value pair that represents the tag you want to add to the resource. The value can be an empty string. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    /// This member is required.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

/// AddTagsToResourceOutput
public struct AddTagsToResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct AddUploadBufferInput {
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

public struct AddUploadBufferOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [AddWorkingStorageInput$DiskIds]
public struct AddWorkingStorageInput {
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway for which working storage was configured.
public struct AddWorkingStorageOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct AssignTapePoolInput {
    /// Set permissions to bypass governance retention. If the lock type of the archived tape is Governance, the tape's archived age is not older than RetentionLockInDays, and the user does not already have BypassGovernanceRetention, setting this to TRUE enables the user to bypass the retention lock. This parameter is set to true by default for calls from the console. Valid values: TRUE | FALSE
    public var bypassGovernanceRetention: Swift.Bool?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    /// This member is required.
    public var poolId: Swift.String?
    /// The unique Amazon Resource Name (ARN) of the virtual tape that you want to add to the tape pool.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        bypassGovernanceRetention: Swift.Bool? = false,
        poolId: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.poolId = poolId
        self.tapeARN = tapeARN
    }
}

public struct AssignTapePoolOutput {
    /// The unique Amazon Resource Names (ARN) of the virtual tape that was added to the tape pool.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

extension StorageGatewayClientTypes {
    /// The refresh cache information for the file share or FSx file systems.
    public struct CacheAttributes {
        /// Refreshes a file share's cache by using Time To Live (TTL). TTL is the length of time since the last refresh after which access to the directory would cause the file gateway to first refresh that directory's contents from the Amazon S3 bucket or Amazon FSx file system. The TTL duration is in seconds. Valid Values:0, 300 to 2,592,000 seconds (5 minutes to 30 days)
        public var cacheStaleTimeoutInSeconds: Swift.Int?

        public init(
            cacheStaleTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds
        }
    }

}

extension StorageGatewayClientTypes {
    /// Specifies network configuration information for the gateway associated with the Amazon FSx file system.
    public struct EndpointNetworkConfiguration {
        /// A list of gateway IP addresses on which the associated Amazon FSx file system is available. If multiple file systems are associated with this gateway, this field is required.
        public var ipAddresses: [Swift.String]?

        public init(
            ipAddresses: [Swift.String]? = nil
        )
        {
            self.ipAddresses = ipAddresses
        }
    }

}

public struct AssociateFileSystemInput {
    /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
    public var auditDestinationARN: Swift.String?
    /// The refresh cache information for the file share or FSx file systems.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// A unique string value that you supply that is used by the FSx File Gateway to ensure idempotent file system association creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Specifies the network configuration information for the gateway associated with the Amazon FSx file system. If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
    public var endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon FSx file system to associate with the FSx File Gateway.
    /// This member is required.
    public var locationARN: Swift.String?
    /// The password of the user credential.
    /// This member is required.
    public var password: Swift.String?
    /// A list of up to 50 tags that can be assigned to the file system association. Each tag is a key-value pair.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The user name of the user credential that has permission to access the root share D$ of the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin user group.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientToken: Swift.String? = nil,
        endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration? = nil,
        gatewayARN: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.clientToken = clientToken
        self.endpointNetworkConfiguration = endpointNetworkConfiguration
        self.gatewayARN = gatewayARN
        self.locationARN = locationARN
        self.password = password
        self.tags = tags
        self.userName = userName
    }
}

extension AssociateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFileSystemInput(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), clientToken: \(Swift.String(describing: clientToken)), endpointNetworkConfiguration: \(Swift.String(describing: endpointNetworkConfiguration)), gatewayARN: \(Swift.String(describing: gatewayARN)), locationARN: \(Swift.String(describing: locationARN)), tags: \(Swift.String(describing: tags)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

public struct AssociateFileSystemOutput {
    /// The ARN of the newly created file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init(
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

/// AttachVolumeInput
public struct AttachVolumeInput {
    /// The unique device ID or other distinguishing data that identifies the local disk used to create the volume. This value is only required when you are attaching a stored volume.
    public var diskId: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway that you want to attach the volume to.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use [DescribeGatewayInformation] to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
    public var targetName: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume to attach to the specified gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        diskId: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        targetName: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.networkInterfaceId = networkInterfaceId
        self.targetName = targetName
        self.volumeARN = volumeARN
    }
}

/// AttachVolumeOutput
public struct AttachVolumeOutput {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name for the initiator that was used to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume that was attached to the gateway.
    public var volumeARN: Swift.String?

    public init(
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

extension StorageGatewayClientTypes {
    /// An automatic tape creation policy consists of automatic tape creation rules where each rule defines when and how to create new tapes. For more information about automatic tape creation, see [Creating Tapes Automatically](https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically).
    public struct AutomaticTapeCreationRule {
        /// The minimum number of available virtual tapes that the gateway maintains at all times. If the number of tapes on the gateway goes below this value, the gateway creates as many new tapes as are needed to have MinimumNumTapes on the gateway. For more information about automatic tape creation, see [Creating Tapes Automatically](https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically).
        /// This member is required.
        public var minimumNumTapes: Swift.Int?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the Amazon S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// A prefix that you append to the barcode of the virtual tape that you are creating. This prefix makes the barcode unique. The prefix must be 1-4 characters in length and must be one of the uppercase letters from A to Z.
        /// This member is required.
        public var tapeBarcodePrefix: Swift.String?
        /// The size, in bytes, of the virtual tape capacity.
        /// This member is required.
        public var tapeSizeInBytes: Swift.Int?
        /// Set to true to indicate that tapes are to be archived as write-once-read-many (WORM). Set to false when WORM is not enabled for tapes.
        public var worm: Swift.Bool

        public init(
            minimumNumTapes: Swift.Int? = nil,
            poolId: Swift.String? = nil,
            tapeBarcodePrefix: Swift.String? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            worm: Swift.Bool = false
        )
        {
            self.minimumNumTapes = minimumNumTapes
            self.poolId = poolId
            self.tapeBarcodePrefix = tapeBarcodePrefix
            self.tapeSizeInBytes = tapeSizeInBytes
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes {
    /// Information about the gateway's automatic tape creation policies, including the automatic tape creation rules and the gateway that is using the policies.
    public struct AutomaticTapeCreationPolicyInfo {
        /// An automatic tape creation policy consists of a list of automatic tape creation rules. This returns the rules that determine when and how to automatically create new tapes.
        public var automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?

        public init(
            automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.automaticTapeCreationRules = automaticTapeCreationRules
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {

    public enum AutomaticUpdatePolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allVersions
        case emergencyVersionsOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomaticUpdatePolicy] {
            return [
                .allVersions,
                .emergencyVersionsOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allVersions: return "ALL_VERSIONS"
            case .emergencyVersionsOnly: return "EMERGENCY_VERSIONS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {

    public enum AvailabilityMonitorTestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityMonitorTestStatus] {
            return [
                .complete,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Describes a bandwidth rate limit interval for a gateway. A bandwidth rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit interval defines a period of time on one or more days of the week, during which bandwidth rate limits are specified for uploading, downloading, or both.
    public struct BandwidthRateLimitInterval {
        /// The average download rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the download rate limit is not set.
        public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
        /// The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set. For Tape Gateway and Volume Gateway, the minimum value is 51200. For S3 File Gateway and FSx File Gateway, the minimum value is 104857600.
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        /// The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        /// The hour of the day to end the bandwidth rate limit interval.
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        /// The minute of the hour to end the bandwidth rate limit interval. The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        /// The hour of the day to start the bandwidth rate limit interval.
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        /// The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init(
            averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

extension StorageGatewayClientTypes {
    /// Lists iSCSI information about a volume.
    public struct VolumeiSCSIAttributes {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public var chapEnabled: Swift.Bool
        /// The logical disk number.
        public var lunNumber: Swift.Int?
        /// The network interface identifier.
        public var networkInterfaceId: Swift.String?
        /// The port used to communicate with iSCSI targets.
        public var networkInterfacePort: Swift.Int
        /// The Amazon Resource Name (ARN) of the volume target.
        public var targetARN: Swift.String?

        public init(
            chapEnabled: Swift.Bool = false,
            lunNumber: Swift.Int? = nil,
            networkInterfaceId: Swift.String? = nil,
            networkInterfacePort: Swift.Int = 0,
            targetARN: Swift.String? = nil
        )
        {
            self.chapEnabled = chapEnabled
            self.lunNumber = lunNumber
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }
    }

}

extension StorageGatewayClientTypes {
    /// Describes an iSCSI cached volume.
    public struct CachediSCSIVolume {
        /// The date the volume was created. Volumes created prior to March 28, 2017 don’t have this timestamp.
        public var createdDate: Foundation.Date?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public var kmsKey: Swift.String?
        /// If the cached volume was created from a snapshot, this field contains the snapshot ID used, e.g., snap-78e22663. Otherwise, this field is not included.
        public var sourceSnapshotId: Swift.String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public var targetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public var volumeARN: Swift.String?
        /// A value that indicates whether a storage volume is attached to or detached from a gateway. For more information, see [Moving your volumes to a different gateway](https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume).
        public var volumeAttachmentStatus: Swift.String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public var volumeId: Swift.String?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the cached volume is not restoring or bootstrapping.
        public var volumeProgress: Swift.Double?
        /// The size, in bytes, of the volume capacity.
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeStatus: Swift.String?
        /// One of the VolumeType enumeration values that describes the type of the volume.
        public var volumeType: Swift.String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on the number of blocks that are touched, instead of the actual amount of data written. This value can be useful for sequential write patterns but less accurate for random write patterns. VolumeUsedInBytes is different from the compressed size of the volume, which is the value that is used to calculate your bill. This value is not available for volumes created prior to May 13, 2015, until you store data on the volume. If you use a delete tool that overwrites the data on your volume with random data, your usage will not be reduced. This is because the random data is not compressible. If you want to reduce the amount of billed storage on your volume, we recommend overwriting your files with zeros to compress the data to a negligible amount of actual storage.
        public var volumeUsedInBytes: Swift.Int?
        /// An [VolumeiSCSIAttributes] object that represents a collection of iSCSI attributes for one stored volume.
        public var volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes?

        public init(
            createdDate: Foundation.Date? = nil,
            kmsKey: Swift.String? = nil,
            sourceSnapshotId: Swift.String? = nil,
            targetName: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeProgress: Swift.Double? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil,
            volumeUsedInBytes: Swift.Int? = nil,
            volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes? = nil
        )
        {
            self.createdDate = createdDate
            self.kmsKey = kmsKey
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
        }
    }

}

/// CancelArchivalInput
public struct CancelArchivalInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel archiving for.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

/// CancelArchivalOutput
public struct CancelArchivalOutput {
    /// The Amazon Resource Name (ARN) of the virtual tape for which archiving was canceled.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

/// CancelRetrievalInput
public struct CancelRetrievalInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel retrieval for.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

/// CancelRetrievalOutput
public struct CancelRetrievalOutput {
    /// The Amazon Resource Name (ARN) of the virtual tape for which retrieval was canceled.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

extension StorageGatewayClientTypes {

    public enum CaseSensitivity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case casesensitive
        case clientspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [CaseSensitivity] {
            return [
                .casesensitive,
                .clientspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .casesensitive: return "CaseSensitive"
            case .clientspecified: return "ClientSpecified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Describes Challenge-Handshake Authentication Protocol (CHAP) information that supports authentication between your gateway and iSCSI initiators.
    public struct ChapInfo {
        /// The iSCSI initiator that connects to the target.
        public var initiatorName: Swift.String?
        /// The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.
        public var secretToAuthenticateInitiator: Swift.String?
        /// The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g., Windows client).
        public var secretToAuthenticateTarget: Swift.String?
        /// The Amazon Resource Name (ARN) of the volume. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var targetARN: Swift.String?

        public init(
            initiatorName: Swift.String? = nil,
            secretToAuthenticateInitiator: Swift.String? = nil,
            secretToAuthenticateTarget: Swift.String? = nil,
            targetARN: Swift.String? = nil
        )
        {
            self.initiatorName = initiatorName
            self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
            self.secretToAuthenticateTarget = secretToAuthenticateTarget
            self.targetARN = targetARN
        }
    }

}

extension StorageGatewayClientTypes.ChapInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChapInfo(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)), secretToAuthenticateInitiator: \"CONTENT_REDACTED\", secretToAuthenticateTarget: \"CONTENT_REDACTED\")"}
}

public struct CreateCachediSCSIVolumeInput {
    /// A unique identifier that you use to retry a request. If you retry a request, use the same ClientToken you specified in the initial request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use [DescribeGatewayInformation] to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// The snapshot ID (e.g. "snap-1122aabb") of the snapshot to restore as the new cached volume. Specify this field if you want to create the iSCSI storage volume from a snapshot; otherwise, do not include this field. To list snapshots for your account use [DescribeSnapshots](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html) in the Amazon Elastic Compute Cloud API Reference.
    public var snapshotId: Swift.String?
    /// The ARN for an existing volume. Specifying this ARN makes the new volume into an exact copy of the specified existing volume's latest recovery point. The VolumeSizeInBytes value for this new volume must be equal to or larger than the size of the existing volume, in bytes.
    public var sourceVolumeARN: Swift.String?
    /// A list of up to 50 tags that you can assign to a cached volume. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers that you can represent in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256 characters.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
    /// This member is required.
    public var targetName: Swift.String?
    /// The size of the volume in bytes.
    /// This member is required.
    public var volumeSizeInBytes: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        sourceVolumeARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        targetName: Swift.String? = nil,
        volumeSizeInBytes: Swift.Int? = 0
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.networkInterfaceId = networkInterfaceId
        self.snapshotId = snapshotId
        self.sourceVolumeARN = sourceVolumeARN
        self.tags = tags
        self.targetName = targetName
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

public struct CreateCachediSCSIVolumeOutput {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that initiators can use to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured volume.
    public var volumeARN: Swift.String?

    public init(
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

extension StorageGatewayClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dssekms
        case ssekms
        case sses3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .dssekms,
                .ssekms,
                .sses3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dssekms: return "DsseKms"
            case .ssekms: return "SseKms"
            case .sses3: return "SseS3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Describes Network File System (NFS) file share default values. Files and folders stored as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that represent files and folders are assigned these default Unix permissions. This operation is only supported for S3 File Gateways.
    public struct NFSFileShareDefaults {
        /// The Unix directory mode in the form "nnnn". For example, 0666 represents the default access mode for all directories inside the file share. The default value is 0777.
        public var directoryMode: Swift.String?
        /// The Unix file mode in the form "nnnn". For example, 0666 represents the default file mode inside the file share. The default value is 0666.
        public var fileMode: Swift.String?
        /// The default group ID for the file share (unless the files have another group ID specified). The default value is nfsnobody.
        public var groupId: Swift.Int?
        /// The default owner ID for files in the file share (unless the files have another owner ID specified). The default value is nfsnobody.
        public var ownerId: Swift.Int?

        public init(
            directoryMode: Swift.String? = nil,
            fileMode: Swift.String? = nil,
            groupId: Swift.Int? = nil,
            ownerId: Swift.Int? = nil
        )
        {
            self.directoryMode = directoryMode
            self.fileMode = fileMode
            self.groupId = groupId
            self.ownerId = ownerId
        }
    }

}

extension StorageGatewayClientTypes {

    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that an S3 File Gateway puts objects into. The default value is private.
    public enum ObjectACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectACL] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// CreateNFSFileShareInput
public struct CreateNFSFileShareInput {
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies the Region of the S3 bucket where the NFS file share stores files. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var bucketRegion: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
    public var clientList: [Swift.String]?
    /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent file share creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
    public var encryptionType: StorageGatewayClientTypes.EncryptionType?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 File Gateway on which you want to create a file share.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true. Valid Values: true | false
    @available(*, deprecated, message: "KMSEncrypted is deprecated, use EncryptionType instead.")
    public var kmsEncrypted: Swift.Bool?
    /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
    public var kmsKey: Swift.String?
    /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
    /// This member is required.
    public var locationARN: Swift.String?
    /// File share default values. Optional.
    public var nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {\"Upload\": {\"SettlingTimeInSeconds\": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes when it accesses the underlying storage.
    /// This member is required.
    public var role: Swift.String?
    /// A value that maps a user to anonymous user. Valid values are the following:
    ///
    /// * RootSquash: Only root is mapped to anonymous user.
    ///
    /// * NoSquash: No one is mapped to anonymous user.
    ///
    /// * AllSquash: Everyone is mapped to anonymous user.
    public var squash: Swift.String?
    /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var vpcEndpointDNSName: Swift.String?

    public init(
        auditDestinationARN: Swift.String? = nil,
        bucketRegion: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientList: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultStorageClass: Swift.String? = nil,
        encryptionType: StorageGatewayClientTypes.EncryptionType? = nil,
        fileShareName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        role: Swift.String? = nil,
        squash: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vpcEndpointDNSName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.bucketRegion = bucketRegion
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.encryptionType = encryptionType
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.locationARN = locationARN
        self.nfsFileShareDefaults = nfsFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.squash = squash
        self.tags = tags
        self.vpcEndpointDNSName = vpcEndpointDNSName
    }
}

/// CreateNFSFileShareOutput
public struct CreateNFSFileShareOutput {
    /// The Amazon Resource Name (ARN) of the newly created file share.
    public var fileShareARN: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

/// CreateSMBFileShareInput
public struct CreateSMBFileShareInput {
    /// The files and folders on this share will only be visible to users with read access.
    public var accessBasedEnumeration: Swift.Bool?
    /// A list of users or groups in the Active Directory that will be granted administrator privileges on the file share. These users can do all file operations as the super-user. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Use this option very carefully, because any user in this list can do anything they like on the file share, regardless of file permissions.
    public var adminUserList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// The authentication method that users use to access the file share. The default is ActiveDirectory. Valid Values: ActiveDirectory | GuestAccess
    public var authentication: Swift.String?
    /// Specifies the Region of the S3 bucket where the SMB file share stores files. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var bucketRegion: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
    public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent file share creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
    public var encryptionType: StorageGatewayClientTypes.EncryptionType?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// The ARN of the S3 File Gateway on which you want to create a file share.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var invalidUserList: [Swift.String]?
    /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true. Valid Values: true | false
    @available(*, deprecated, message: "KMSEncrypted is deprecated, use EncryptionType instead.")
    public var kmsEncrypted: Swift.Bool?
    /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
    public var kmsKey: Swift.String?
    /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
    /// This member is required.
    public var locationARN: Swift.String?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {\"Upload\": {\"SettlingTimeInSeconds\": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// Specifies whether opportunistic locking is enabled for the SMB file share. Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case. Valid Values: true | false
    public var oplocksEnabled: Swift.Bool?
    /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes when it accesses the underlying storage.
    /// This member is required.
    public var role: Swift.String?
    /// Set this value to true to enable access control list (ACL) on the SMB file share. Set it to false to map file and directory permissions to the POSIX permissions. For more information, see [Using Windows ACLs to limit SMB file share access](https://docs.aws.amazon.com/filegateway/latest/files3/smb-acl.html) in the Amazon S3 File Gateway User Guide. Valid Values: true | false
    public var smbaclEnabled: Swift.Bool?
    /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A list of users or groups in the Active Directory that are allowed to access the file [ share. A group must be prefixed with the @ character. Acceptable formats include: ]DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var validUserList: [Swift.String]?
    /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var vpcEndpointDNSName: Swift.String?

    public init(
        accessBasedEnumeration: Swift.Bool? = nil,
        adminUserList: [Swift.String]? = nil,
        auditDestinationARN: Swift.String? = nil,
        authentication: Swift.String? = nil,
        bucketRegion: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
        clientToken: Swift.String? = nil,
        defaultStorageClass: Swift.String? = nil,
        encryptionType: StorageGatewayClientTypes.EncryptionType? = nil,
        fileShareName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        invalidUserList: [Swift.String]? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        oplocksEnabled: Swift.Bool? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        role: Swift.String? = nil,
        smbaclEnabled: Swift.Bool? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        validUserList: [Swift.String]? = nil,
        vpcEndpointDNSName: Swift.String? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.authentication = authentication
        self.bucketRegion = bucketRegion
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.encryptionType = encryptionType
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.locationARN = locationARN
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.oplocksEnabled = oplocksEnabled
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.smbaclEnabled = smbaclEnabled
        self.tags = tags
        self.validUserList = validUserList
        self.vpcEndpointDNSName = vpcEndpointDNSName
    }
}

/// CreateSMBFileShareOutput
public struct CreateSMBFileShareOutput {
    /// The Amazon Resource Name (ARN) of the newly created file share.
    public var fileShareARN: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

/// An internal server error has occurred because the service is unavailable. For more information, see the error and message fields.
public struct ServiceUnavailableError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A [StorageGatewayError] that provides more information about the cause of the error.
        public internal(set) var error: StorageGatewayClientTypes.StorageGatewayError? = nil
        /// A human-readable message describing the error that occurred.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.message = message
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [CreateSnapshotInput$SnapshotDescription]
///
/// * [CreateSnapshotInput$VolumeARN]
public struct CreateSnapshotInput {
    /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic Block Store snapshots panel in the Description field, and in the Storage Gateway snapshot Details pane, Description field.
    /// This member is required.
    public var snapshotDescription: Swift.String?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        snapshotDescription: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

/// A JSON object containing the following fields:
public struct CreateSnapshotOutput {
    /// The snapshot ID that is used to refer to the snapshot in future operations such as describing snapshots (Amazon Elastic Compute Cloud API DescribeSnapshots) or creating a volume from a snapshot ([CreateStorediSCSIVolume]).
    public var snapshotId: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume of which the snapshot was taken.
    public var volumeARN: Swift.String?

    public init(
        snapshotId: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointInput {
    /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic Block Store snapshots panel in the Description field, and in the Storage Gateway snapshot Details pane, Description field.
    /// This member is required.
    public var snapshotDescription: Swift.String?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        snapshotDescription: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointOutput {
    /// The ID of the snapshot.
    public var snapshotId: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    public var volumeARN: Swift.String?
    /// The time the volume was created from the recovery point.
    public var volumeRecoveryPointTime: Swift.String?

    public init(
        snapshotId: Swift.String? = nil,
        volumeARN: Swift.String? = nil,
        volumeRecoveryPointTime: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
        self.volumeRecoveryPointTime = volumeRecoveryPointTime
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [CreateStorediSCSIVolumeInput$DiskId]
///
/// * [CreateStorediSCSIVolumeInput$NetworkInterfaceId]
///
/// * [CreateStorediSCSIVolumeInput$PreserveExistingData]
///
/// * [CreateStorediSCSIVolumeInput$SnapshotId]
///
/// * [CreateStorediSCSIVolumeInput$TargetName]
public struct CreateStorediSCSIVolumeInput {
    /// The unique identifier for the gateway local disk that is configured as a stored volume. Use [ListLocalDisks](https://docs.aws.amazon.com/storagegateway/latest/userguide/API_ListLocalDisks.html) to list disk IDs for a gateway.
    /// This member is required.
    public var diskId: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use [DescribeGatewayInformation] to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// Set to true if you want to preserve the data on the local disk. Otherwise, set to false to create an empty volume. Valid Values: true | false
    /// This member is required.
    public var preserveExistingData: Swift.Bool?
    /// The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as the new stored volume. Specify this field if you want to create the iSCSI storage volume from a snapshot; otherwise, do not include this field. To list snapshots for your account use [DescribeSnapshots](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html) in the Amazon Elastic Compute Cloud API Reference.
    public var snapshotId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a stored volume. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
    /// This member is required.
    public var targetName: Swift.String?

    public init(
        diskId: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        preserveExistingData: Swift.Bool? = false,
        snapshotId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.networkInterfaceId = networkInterfaceId
        self.preserveExistingData = preserveExistingData
        self.snapshotId = snapshotId
        self.tags = tags
        self.targetName = targetName
    }
}

/// A JSON object containing the following fields:
public struct CreateStorediSCSIVolumeOutput {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that initiators can use to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured volume.
    public var volumeARN: Swift.String?
    /// The size of the volume in bytes.
    public var volumeSizeInBytes: Swift.Int

    public init(
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil,
        volumeSizeInBytes: Swift.Int = 0
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

extension StorageGatewayClientTypes {

    public enum RetentionLockType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliance
        case governance
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionLockType] {
            return [
                .compliance,
                .governance,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {

    public enum TapeStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deepArchive
        case glacier
        case sdkUnknown(Swift.String)

        public static var allCases: [TapeStorageClass] {
            return [
                .deepArchive,
                .glacier
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTapePoolInput {
    /// The name of the new custom tape pool.
    /// This member is required.
    public var poolName: Swift.String?
    /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to 100 years (36,500 days).
    public var retentionLockTimeInDays: Swift.Int?
    /// Tape retention lock can be configured in two modes. When configured in governance mode, Amazon Web Services accounts with specific IAM permissions are authorized to remove the tape retention lock from archived virtual tapes. When configured in compliance mode, the tape retention lock cannot be removed by any user, including the root Amazon Web Services account.
    public var retentionLockType: StorageGatewayClientTypes.RetentionLockType?
    /// The storage class that is associated with the new custom pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    /// This member is required.
    public var storageClass: StorageGatewayClientTypes.TapeStorageClass?
    /// A list of up to 50 tags that can be assigned to tape pool. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init(
        poolName: Swift.String? = nil,
        retentionLockTimeInDays: Swift.Int? = nil,
        retentionLockType: StorageGatewayClientTypes.RetentionLockType? = nil,
        storageClass: StorageGatewayClientTypes.TapeStorageClass? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.poolName = poolName
        self.retentionLockTimeInDays = retentionLockTimeInDays
        self.retentionLockType = retentionLockType
        self.storageClass = storageClass
        self.tags = tags
    }
}

public struct CreateTapePoolOutput {
    /// The unique Amazon Resource Name (ARN) that represents the custom tape pool. Use the [ListTapePools] operation to return a list of tape pools for your account and Amazon Web Services Region.
    public var poolARN: Swift.String?

    public init(
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

/// CreateTapesInput
public struct CreateTapesInput {
    /// A unique identifier that you use to retry a request. If you retry a request, use the same ClientToken you specified in the initial request. Using the same ClientToken prevents creating the tape multiple times.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tapes with. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The number of virtual tapes that you want to create.
    /// This member is required.
    public var numTapesToCreate: Swift.Int?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    public var poolId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A prefix that you append to the barcode of the virtual tape you are creating. This prefix makes the barcode unique. The prefix must be 1-4 characters in length and must be one of the uppercase letters from A to Z.
    /// This member is required.
    public var tapeBarcodePrefix: Swift.String?
    /// The size, in bytes, of the virtual tapes that you want to create. The size must be aligned by gigabyte (1024*1024*1024 bytes).
    /// This member is required.
    public var tapeSizeInBytes: Swift.Int?
    /// Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM) tape.
    public var worm: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        numTapesToCreate: Swift.Int? = nil,
        poolId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeBarcodePrefix: Swift.String? = nil,
        tapeSizeInBytes: Swift.Int? = nil,
        worm: Swift.Bool? = false
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.numTapesToCreate = numTapesToCreate
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcodePrefix = tapeBarcodePrefix
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

/// CreateTapeOutput
public struct CreateTapesOutput {
    /// A list of unique Amazon Resource Names (ARNs) that represents the virtual tapes that were created.
    public var tapeARNs: [Swift.String]?

    public init(
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.tapeARNs = tapeARNs
    }
}

/// CreateTapeWithBarcodeInput
public struct CreateTapeWithBarcodeInput {
    /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tape with. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Deep Archive) that corresponds to the pool.
    public var poolId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a virtual tape that has a barcode. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The barcode that you want to assign to the tape. Barcodes cannot be reused. This includes barcodes used for tapes that have been deleted.
    /// This member is required.
    public var tapeBarcode: Swift.String?
    /// The size, in bytes, of the virtual tape that you want to create. The size must be aligned by gigabyte (1024*1024*1024 bytes).
    /// This member is required.
    public var tapeSizeInBytes: Swift.Int?
    /// Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM) tape.
    public var worm: Swift.Bool?

    public init(
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        poolId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeBarcode: Swift.String? = nil,
        tapeSizeInBytes: Swift.Int? = nil,
        worm: Swift.Bool? = false
    )
    {
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcode = tapeBarcode
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

/// CreateTapeOutput
public struct CreateTapeWithBarcodeOutput {
    /// A unique Amazon Resource Name (ARN) that represents the virtual tape that was created.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

public struct DeleteAutomaticTapeCreationPolicyInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DeleteAutomaticTapeCreationPolicyOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the following fields:
///
/// * [DeleteBandwidthRateLimitInput$BandwidthType]
public struct DeleteBandwidthRateLimitInput {
    /// One of the BandwidthType values that indicates the gateway bandwidth rate limit to delete. Valid Values: UPLOAD | DOWNLOAD | ALL
    /// This member is required.
    public var bandwidthType: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        bandwidthType: Swift.String? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthType = bandwidthType
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose bandwidth rate information was deleted.
public struct DeleteBandwidthRateLimitOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [DeleteChapCredentialsInput$InitiatorName]
///
/// * [DeleteChapCredentialsInput$TargetARN]
public struct DeleteChapCredentialsInput {
    /// The iSCSI initiator that connects to the target.
    /// This member is required.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init(
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

/// A JSON object containing the following fields:
public struct DeleteChapCredentialsOutput {
    /// The iSCSI initiator that connects to the target.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the target.
    public var targetARN: Swift.String?

    public init(
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

/// DeleteFileShareInput
public struct DeleteFileShareInput {
    /// The Amazon Resource Name (ARN) of the file share to be deleted.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// If this value is set to true, the operation deletes a file share immediately and aborts all data uploads to Amazon Web Services. Otherwise, the file share is not deleted until all data is uploaded to Amazon Web Services. This process aborts the data upload process, and the file share enters the FORCE_DELETING status. Valid Values: true | false
    public var forceDelete: Swift.Bool?

    public init(
        fileShareARN: Swift.String? = nil,
        forceDelete: Swift.Bool? = false
    )
    {
        self.fileShareARN = fileShareARN
        self.forceDelete = forceDelete
    }
}

/// DeleteFileShareOutput
public struct DeleteFileShareOutput {
    /// The Amazon Resource Name (ARN) of the deleted file share.
    public var fileShareARN: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

/// A JSON object containing the ID of the gateway to delete.
public struct DeleteGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the ID of the deleted gateway.
public struct DeleteGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DeleteSnapshotScheduleInput {
    /// The volume which snapshot schedule to delete.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

public struct DeleteSnapshotScheduleOutput {
    /// The volume which snapshot schedule was deleted.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

/// DeleteTapeInput
public struct DeleteTapeInput {
    /// Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock. Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes with tape retention lock set to compliance can't be deleted.
    public var bypassGovernanceRetention: Swift.Bool?
    /// The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is associated with. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape to delete.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        bypassGovernanceRetention: Swift.Bool? = false,
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

/// DeleteTapeOutput
public struct DeleteTapeOutput {
    /// The Amazon Resource Name (ARN) of the deleted virtual tape.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

/// DeleteTapeArchiveInput
public struct DeleteTapeArchiveInput {
    /// Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock. Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes with tape retention lock set to compliance can't be deleted.
    public var bypassGovernanceRetention: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the virtual tape to delete from the virtual tape shelf (VTS).
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        bypassGovernanceRetention: Swift.Bool? = false,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.tapeARN = tapeARN
    }
}

/// DeleteTapeArchiveOutput
public struct DeleteTapeArchiveOutput {
    /// The Amazon Resource Name (ARN) of the virtual tape that was deleted from the virtual tape shelf (VTS).
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

public struct DeleteTapePoolInput {
    /// The Amazon Resource Name (ARN) of the custom tape pool to delete.
    /// This member is required.
    public var poolARN: Swift.String?

    public init(
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

public struct DeleteTapePoolOutput {
    /// The Amazon Resource Name (ARN) of the custom tape pool being deleted.
    public var poolARN: Swift.String?

    public init(
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

/// A JSON object containing the [DeleteVolumeInput$VolumeARN] to delete.
public struct DeleteVolumeInput {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the storage volume that was deleted.
public struct DeleteVolumeOutput {
    /// The Amazon Resource Name (ARN) of the storage volume that was deleted. It is the same ARN you provided in the request.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

public struct DescribeAvailabilityMonitorTestInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeAvailabilityMonitorTestOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The time the high availability monitoring test was started. If a test hasn't been performed, the value of this field is null.
    public var startTime: Foundation.Date?
    /// The status of the high availability monitoring test. If a test hasn't been performed, the value of this field is null.
    public var status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus?

    public init(
        gatewayARN: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.startTime = startTime
        self.status = status
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeBandwidthRateLimitInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the following fields:
public struct DescribeBandwidthRateLimitOutput {
    /// The average download bandwidth rate limit in bits per second. This field does not appear in the response if the download rate limit is not set.
    public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
    /// The average upload bandwidth rate limit in bits per second. This field does not appear in the response if the upload rate limit is not set.
    public var averageUploadRateLimitInBitsPerSec: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
        averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeBandwidthRateLimitScheduleInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeBandwidthRateLimitScheduleOutput {
    /// An array that contains the bandwidth rate limit intervals for a tape or volume gateway.
    public var bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeCacheInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeCacheOutput {
    /// The amount of cache in bytes allocated to a gateway.
    public var cacheAllocatedInBytes: Swift.Int
    /// The file share's contribution to the overall percentage of the gateway's cache that has not been persisted to Amazon Web Services. The sample is taken at the end of the reporting period.
    public var cacheDirtyPercentage: Swift.Double
    /// Percent of application read operations from the file shares that are served from cache. The sample is taken at the end of the reporting period.
    public var cacheHitPercentage: Swift.Double
    /// Percent of application read operations from the file shares that are not served from cache. The sample is taken at the end of the reporting period.
    public var cacheMissPercentage: Swift.Double
    /// Percent use of the gateway's cache storage. This metric applies only to the gateway-cached volume setup. The sample is taken at the end of the reporting period.
    public var cacheUsedPercentage: Swift.Double
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        cacheAllocatedInBytes: Swift.Int = 0,
        cacheDirtyPercentage: Swift.Double = 0.0,
        cacheHitPercentage: Swift.Double = 0.0,
        cacheMissPercentage: Swift.Double = 0.0,
        cacheUsedPercentage: Swift.Double = 0.0,
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.cacheAllocatedInBytes = cacheAllocatedInBytes
        self.cacheDirtyPercentage = cacheDirtyPercentage
        self.cacheHitPercentage = cacheHitPercentage
        self.cacheMissPercentage = cacheMissPercentage
        self.cacheUsedPercentage = cacheUsedPercentage
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeCachediSCSIVolumesInput {
    /// An array of strings where each string represents the Amazon Resource Name (ARN) of a cached volume. All of the specified cached volumes must be from the same gateway. Use [ListVolumes] to get volume ARNs for a gateway.
    /// This member is required.
    public var volumeARNs: [Swift.String]?

    public init(
        volumeARNs: [Swift.String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

/// A JSON object containing the following fields:
public struct DescribeCachediSCSIVolumesOutput {
    /// An array of objects where each object contains metadata about one cached volume.
    public var cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]?

    public init(
        cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]? = nil
    )
    {
        self.cachediSCSIVolumes = cachediSCSIVolumes
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the iSCSI volume target.
public struct DescribeChapCredentialsInput {
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init(
        targetARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
    }
}

/// A JSON object containing the following fields:
public struct DescribeChapCredentialsOutput {
    /// An array of [ChapInfo] objects that represent CHAP credentials. Each object in the array contains CHAP credential information for one target-initiator pair. If no CHAP credentials are set, an empty array is returned. CHAP credential information is provided in a JSON object with the following fields:
    ///
    /// * InitiatorName: The iSCSI initiator that connects to the target.
    ///
    /// * SecretToAuthenticateInitiator: The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.
    ///
    /// * SecretToAuthenticateTarget: The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g. Windows client).
    ///
    /// * TargetARN: The Amazon Resource Name (ARN) of the storage volume.
    public var chapCredentials: [StorageGatewayClientTypes.ChapInfo]?

    public init(
        chapCredentials: [StorageGatewayClientTypes.ChapInfo]? = nil
    )
    {
        self.chapCredentials = chapCredentials
    }
}

public struct DescribeFileSystemAssociationsInput {
    /// An array containing the Amazon Resource Name (ARN) of each file system association to be described.
    /// This member is required.
    public var fileSystemAssociationARNList: [Swift.String]?

    public init(
        fileSystemAssociationARNList: [Swift.String]? = nil
    )
    {
        self.fileSystemAssociationARNList = fileSystemAssociationARNList
    }
}

extension StorageGatewayClientTypes {
    /// Detailed information on file system association status.
    public struct FileSystemAssociationStatusDetail {
        /// The error code for a given file system association status.
        public var errorCode: Swift.String?

        public init(
            errorCode: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
        }
    }

}

extension StorageGatewayClientTypes {
    /// Describes the object returned by DescribeFileSystemAssociations that describes a created file system association.
    public struct FileSystemAssociationInfo {
        /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
        public var auditDestinationARN: Swift.String?
        /// The refresh cache information for the file share or FSx file systems.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// Specifies network configuration information for the gateway associated with the Amazon FSx file system. If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
        public var endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the file system association.
        public var fileSystemAssociationARN: Swift.String?
        /// The status of the file system association. Valid Values: AVAILABLE | CREATING | DELETING | FORCE_DELETING | UPDATING | ERROR
        public var fileSystemAssociationStatus: Swift.String?
        /// An array containing the FileSystemAssociationStatusDetail data type, which provides detailed information on file system association status.
        public var fileSystemAssociationStatusDetails: [StorageGatewayClientTypes.FileSystemAssociationStatusDetail]?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The ARN of the backend Amazon FSx file system used for storing file data. For information, see [FileSystem](https://docs.aws.amazon.com/fsx/latest/APIReference/API_FileSystem.html) in the Amazon FSx API Reference.
        public var locationARN: Swift.String?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair.
        public var tags: [StorageGatewayClientTypes.Tag]?

        public init(
            auditDestinationARN: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration? = nil,
            fileSystemAssociationARN: Swift.String? = nil,
            fileSystemAssociationStatus: Swift.String? = nil,
            fileSystemAssociationStatusDetails: [StorageGatewayClientTypes.FileSystemAssociationStatusDetail]? = nil,
            gatewayARN: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil
        )
        {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.endpointNetworkConfiguration = endpointNetworkConfiguration
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.fileSystemAssociationStatusDetails = fileSystemAssociationStatusDetails
            self.gatewayARN = gatewayARN
            self.locationARN = locationARN
            self.tags = tags
        }
    }

}

public struct DescribeFileSystemAssociationsOutput {
    /// An array containing the FileSystemAssociationInfo data type of each file system association to be described.
    public var fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]?

    public init(
        fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]? = nil
    )
    {
        self.fileSystemAssociationInfoList = fileSystemAssociationInfoList
    }
}

/// A JSON object containing the ID of the gateway.
public struct DescribeGatewayInformationInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

extension StorageGatewayClientTypes {

    public enum GatewayCapacity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayCapacity] {
            return [
                .large,
                .medium,
                .small
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "Large"
            case .medium: return "Medium"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Describes a gateway's network interface.
    public struct NetworkInterface {
        /// The Internet Protocol version 4 (IPv4) address of the interface.
        public var ipv4Address: Swift.String?
        /// The Internet Protocol version 6 (IPv6) address of the interface. Currently not supported.
        public var ipv6Address: Swift.String?
        /// The Media Access Control (MAC) address of the interface. This is currently unsupported and will not be returned in output.
        public var macAddress: Swift.String?

        public init(
            ipv4Address: Swift.String? = nil,
            ipv6Address: Swift.String? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ipv4Address = ipv4Address
            self.ipv6Address = ipv6Address
            self.macAddress = macAddress
        }
    }

}

extension StorageGatewayClientTypes.NetworkInterface: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension StorageGatewayClientTypes {

    public enum HostEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2
        case hyperV
        case kvm
        case other
        case snowball
        case vmware
        case sdkUnknown(Swift.String)

        public static var allCases: [HostEnvironment] {
            return [
                .ec2,
                .hyperV,
                .kvm,
                .other,
                .snowball,
                .vmware
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .hyperV: return "HYPER-V"
            case .kvm: return "KVM"
            case .other: return "OTHER"
            case .snowball: return "SNOWBALL"
            case .vmware: return "VMWARE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeGatewayInformationOutput {
    /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to monitor events in the gateway. This field only only exist and returns once it have been chosen and set by the SGW service, based on the OS version of the gateway VM
    public var cloudWatchLogGroupARN: Swift.String?
    /// Date after which this gateway will not receive software updates for new features and bug fixes.
    public var deprecationDate: Swift.String?
    /// The ID of the Amazon EC2 instance that was used to launch the gateway.
    public var ec2InstanceId: Swift.String?
    /// The Amazon Web Services Region where the Amazon EC2 instance is located.
    public var ec2InstanceRegion: Swift.String?
    /// The type of endpoint for your gateway. Valid Values: STANDARD | FIPS
    public var endpointType: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// Specifies the size of the gateway's metadata cache.
    public var gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations.
    public var gatewayId: Swift.String?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?
    /// A [NetworkInterface] array that contains descriptions of the gateway network interfaces.
    public var gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]?
    /// A value that indicates the operating state of the gateway.
    public var gatewayState: Swift.String?
    /// A value that indicates the time zone configured for the gateway.
    public var gatewayTimezone: Swift.String?
    /// The type of the gateway.
    public var gatewayType: Swift.String?
    /// The type of hardware or software platform on which the gateway is running. Tape Gateway is no longer available on Snow Family devices.
    public var hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
    /// A unique identifier for the specific instance of the host platform running the gateway. This value is only available for certain host environments, and its format depends on the host environment type.
    public var hostEnvironmentId: Swift.String?
    /// The date on which the last software update was applied to the gateway. If the gateway has never been updated, this field does not return a value in the response. This only only exist and returns once it have been chosen and set by the SGW service, based on the OS version of the gateway VM
    public var lastSoftwareUpdate: Swift.String?
    /// The date on which an update to the gateway is available. This date is in the time zone of the gateway. If the gateway is not available for an update this field is not returned in the response.
    public var nextUpdateAvailabilityDate: Swift.String?
    /// Date after which this gateway will not receive software updates for new features.
    public var softwareUpdatesEndDate: Swift.String?
    /// The version number of the software running on the gateway appliance.
    public var softwareVersion: Swift.String?
    /// A list of the metadata cache sizes that the gateway can support based on its current hardware specifications.
    public var supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]?
    /// A list of up to 50 tags assigned to the gateway, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The configuration settings for the virtual private cloud (VPC) endpoint for your gateway.
    public var vpcEndpoint: Swift.String?

    public init(
        cloudWatchLogGroupARN: Swift.String? = nil,
        deprecationDate: Swift.String? = nil,
        ec2InstanceId: Swift.String? = nil,
        ec2InstanceRegion: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]? = nil,
        gatewayState: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil,
        gatewayType: Swift.String? = nil,
        hostEnvironment: StorageGatewayClientTypes.HostEnvironment? = nil,
        hostEnvironmentId: Swift.String? = nil,
        lastSoftwareUpdate: Swift.String? = nil,
        nextUpdateAvailabilityDate: Swift.String? = nil,
        softwareUpdatesEndDate: Swift.String? = nil,
        softwareVersion: Swift.String? = nil,
        supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vpcEndpoint: Swift.String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.deprecationDate = deprecationDate
        self.ec2InstanceId = ec2InstanceId
        self.ec2InstanceRegion = ec2InstanceRegion
        self.endpointType = endpointType
        self.gatewayARN = gatewayARN
        self.gatewayCapacity = gatewayCapacity
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayNetworkInterfaces = gatewayNetworkInterfaces
        self.gatewayState = gatewayState
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.hostEnvironment = hostEnvironment
        self.hostEnvironmentId = hostEnvironmentId
        self.lastSoftwareUpdate = lastSoftwareUpdate
        self.nextUpdateAvailabilityDate = nextUpdateAvailabilityDate
        self.softwareUpdatesEndDate = softwareUpdatesEndDate
        self.softwareVersion = softwareVersion
        self.supportedGatewayCapacities = supportedGatewayCapacities
        self.tags = tags
        self.vpcEndpoint = vpcEndpoint
    }
}

extension DescribeGatewayInformationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayInformationOutput(cloudWatchLogGroupARN: \(Swift.String(describing: cloudWatchLogGroupARN)), deprecationDate: \(Swift.String(describing: deprecationDate)), ec2InstanceId: \(Swift.String(describing: ec2InstanceId)), ec2InstanceRegion: \(Swift.String(describing: ec2InstanceRegion)), endpointType: \(Swift.String(describing: endpointType)), gatewayARN: \(Swift.String(describing: gatewayARN)), gatewayCapacity: \(Swift.String(describing: gatewayCapacity)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayState: \(Swift.String(describing: gatewayState)), gatewayTimezone: \(Swift.String(describing: gatewayTimezone)), gatewayType: \(Swift.String(describing: gatewayType)), hostEnvironment: \(Swift.String(describing: hostEnvironment)), hostEnvironmentId: \(Swift.String(describing: hostEnvironmentId)), lastSoftwareUpdate: \(Swift.String(describing: lastSoftwareUpdate)), nextUpdateAvailabilityDate: \(Swift.String(describing: nextUpdateAvailabilityDate)), softwareUpdatesEndDate: \(Swift.String(describing: softwareUpdatesEndDate)), softwareVersion: \(Swift.String(describing: softwareVersion)), supportedGatewayCapacities: \(Swift.String(describing: supportedGatewayCapacities)), tags: \(Swift.String(describing: tags)), vpcEndpoint: \(Swift.String(describing: vpcEndpoint)), gatewayNetworkInterfaces: \"CONTENT_REDACTED\")"}
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeMaintenanceStartTimeInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

extension StorageGatewayClientTypes {
    /// A set of variables indicating the software update preferences for the gateway.
    public struct SoftwareUpdatePreferences {
        /// Indicates the automatic update policy for a gateway. ALL_VERSIONS - Enables regular gateway maintenance updates. EMERGENCY_VERSIONS_ONLY - Disables regular gateway maintenance updates. The gateway will still receive emergency version updates on rare occasions if necessary to remedy highly critical security or durability issues. You will be notified before an emergency version update is applied. These updates are applied during your gateway's scheduled maintenance window.
        public var automaticUpdatePolicy: StorageGatewayClientTypes.AutomaticUpdatePolicy?

        public init(
            automaticUpdatePolicy: StorageGatewayClientTypes.AutomaticUpdatePolicy? = nil
        )
        {
            self.automaticUpdatePolicy = automaticUpdatePolicy
        }
    }

}

/// A JSON object containing the following fields:
///
/// * [DescribeMaintenanceStartTimeOutput$SoftwareUpdatePreferences]
///
/// * [DescribeMaintenanceStartTimeOutput$DayOfMonth]
///
/// * [DescribeMaintenanceStartTimeOutput$DayOfWeek]
///
/// * [DescribeMaintenanceStartTimeOutput$HourOfDay]
///
/// * [DescribeMaintenanceStartTimeOutput$MinuteOfHour]
///
/// * [DescribeMaintenanceStartTimeOutput$Timezone]
public struct DescribeMaintenanceStartTimeOutput {
    /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month. It is not possible to set the maintenance schedule to start on days 29 through 31.
    public var dayOfMonth: Swift.Int?
    /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
    public var hourOfDay: Swift.Int?
    /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
    public var minuteOfHour: Swift.Int?
    /// A set of variables indicating the software update preferences for the gateway. Includes AutomaticUpdatePolicy parameter with the following inputs: ALL_VERSIONS - Enables regular gateway maintenance updates. EMERGENCY_VERSIONS_ONLY - Disables regular gateway maintenance updates. The gateway will still receive emergency version updates on rare occasions if necessary to remedy highly critical security or durability issues. You will be notified before an emergency version update is applied. These updates are applied during your gateway's scheduled maintenance window.
    public var softwareUpdatePreferences: StorageGatewayClientTypes.SoftwareUpdatePreferences?
    /// A value that indicates the time zone that is set for the gateway. The start time and day of week specified should be in the time zone of the gateway.
    public var timezone: Swift.String?

    public init(
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil,
        softwareUpdatePreferences: StorageGatewayClientTypes.SoftwareUpdatePreferences? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
        self.softwareUpdatePreferences = softwareUpdatePreferences
        self.timezone = timezone
    }
}

/// DescribeNFSFileSharesInput
public struct DescribeNFSFileSharesInput {
    /// An array containing the Amazon Resource Name (ARN) of each file share to be described.
    /// This member is required.
    public var fileShareARNList: [Swift.String]?

    public init(
        fileShareARNList: [Swift.String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

extension StorageGatewayClientTypes {
    /// The Unix file permissions and ownership information assigned, by default, to native S3 objects when an S3 File Gateway discovers them in S3 buckets. This operation is only supported in S3 File Gateways.
    public struct NFSFileShareInfo {
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public var auditDestinationARN: Swift.String?
        /// Specifies the Region of the S3 bucket where the NFS file share stores files. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var bucketRegion: Swift.String?
        /// Refresh cache information for the file share.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
        public var clientList: [Swift.String]?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public var defaultStorageClass: Swift.String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public var encryptionType: StorageGatewayClientTypes.EncryptionType?
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
        public var fileShareName: Swift.String?
        /// The status of the file share. Valid Values: CREATING | UPDATING | AVAILABLE | DELETING
        public var fileShareStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public var guessMIMETypeEnabled: Swift.Bool?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true. Valid Values: true | false
        @available(*, deprecated, message: "KMSEncrypted is deprecated, use EncryptionType instead.")
        public var kmsEncrypted: Swift.Bool
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public var kmsKey: Swift.String?
        /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
        public var locationARN: Swift.String?
        /// Describes Network File System (NFS) file share default values. Files and folders stored as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that represent files and folders are assigned these default Unix permissions. This operation is only supported for S3 File Gateways.
        public var nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {\"Upload\": {\"SettlingTimeInSeconds\": 60}} The following example sets NotificationPolicy off. {}
        public var notificationPolicy: Swift.String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that an S3 File Gateway puts objects into. The default value is private.
        public var objectACL: StorageGatewayClientTypes.ObjectACL?
        /// The file share path used by the NFS client to identify the mount point.
        public var path: Swift.String?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public var readOnly: Swift.Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
        public var requesterPays: Swift.Bool?
        /// The ARN of the IAM role that an S3 File Gateway assumes when it accesses the underlying storage.
        public var role: Swift.String?
        /// The user mapped to anonymous user. Valid options are the following:
        ///
        /// * RootSquash: Only root is mapped to anonymous user.
        ///
        /// * NoSquash: No one is mapped to anonymous user.
        ///
        /// * AllSquash: Everyone is mapped to anonymous user.
        public var squash: Swift.String?
        /// A list of up to 50 tags assigned to the NFS file share, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public var tags: [StorageGatewayClientTypes.Tag]?
        /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var vpcEndpointDNSName: Swift.String?

        public init(
            auditDestinationARN: Swift.String? = nil,
            bucketRegion: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            clientList: [Swift.String]? = nil,
            defaultStorageClass: Swift.String? = nil,
            encryptionType: StorageGatewayClientTypes.EncryptionType? = nil,
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareName: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            guessMIMETypeEnabled: Swift.Bool? = nil,
            kmsEncrypted: Swift.Bool = false,
            kmsKey: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
            notificationPolicy: Swift.String? = nil,
            objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
            path: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            requesterPays: Swift.Bool? = nil,
            role: Swift.String? = nil,
            squash: Swift.String? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil,
            vpcEndpointDNSName: Swift.String? = nil
        )
        {
            self.auditDestinationARN = auditDestinationARN
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }
    }

}

/// DescribeNFSFileSharesOutput
public struct DescribeNFSFileSharesOutput {
    /// An array containing a description for each requested file share.
    public var nfsFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]?

    public init(
        nfsFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]? = nil
    )
    {
        self.nfsFileShareInfoList = nfsFileShareInfoList
    }
}

/// DescribeSMBFileSharesInput
public struct DescribeSMBFileSharesInput {
    /// An array containing the Amazon Resource Name (ARN) of each file share to be described.
    /// This member is required.
    public var fileShareARNList: [Swift.String]?

    public init(
        fileShareARNList: [Swift.String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

extension StorageGatewayClientTypes {
    /// The Windows file permissions and ownership information assigned, by default, to native S3 objects when S3 File Gateway discovers them in S3 buckets. This operation is only supported for S3 File Gateways.
    public struct SMBFileShareInfo {
        /// Indicates whether AccessBasedEnumeration is enabled.
        public var accessBasedEnumeration: Swift.Bool?
        /// A list of users or groups in the Active Directory that have administrator rights to the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public var adminUserList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public var auditDestinationARN: Swift.String?
        /// The authentication method of the file share. The default is ActiveDirectory. Valid Values: ActiveDirectory | GuestAccess
        public var authentication: Swift.String?
        /// Specifies the Region of the S3 bucket where the SMB file share stores files. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var bucketRegion: Swift.String?
        /// Refresh cache information for the file share.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
        public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public var defaultStorageClass: Swift.String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public var encryptionType: StorageGatewayClientTypes.EncryptionType?
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
        public var fileShareName: Swift.String?
        /// The status of the file share. Valid Values: CREATING | UPDATING | AVAILABLE | DELETING
        public var fileShareStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public var guessMIMETypeEnabled: Swift.Bool?
        /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public var invalidUserList: [Swift.String]?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true. Valid Values: true | false
        @available(*, deprecated, message: "KMSEncrypted is deprecated, use EncryptionType instead.")
        public var kmsEncrypted: Swift.Bool
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public var kmsKey: Swift.String?
        /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
        public var locationARN: Swift.String?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {\"Upload\": {\"SettlingTimeInSeconds\": 60}} The following example sets NotificationPolicy off. {}
        public var notificationPolicy: Swift.String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that an S3 File Gateway puts objects into. The default value is private.
        public var objectACL: StorageGatewayClientTypes.ObjectACL?
        /// Specifies whether opportunistic locking is enabled for the SMB file share. Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case. Valid Values: true | false
        public var oplocksEnabled: Swift.Bool?
        /// The file share path used by the SMB client to identify the mount point.
        public var path: Swift.String?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public var readOnly: Swift.Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
        public var requesterPays: Swift.Bool?
        /// The ARN of the IAM role that an S3 File Gateway assumes when it accesses the underlying storage.
        public var role: Swift.String?
        /// If this value is set to true, it indicates that access control list (ACL) is enabled on the SMB file share. If it is set to false, it indicates that file and directory permissions are mapped to the POSIX permission. For more information, see [Using Windows ACLs to limit SMB file share access](https://docs.aws.amazon.com/filegateway/latest/files3/smb-acl.html) in the Amazon S3 File Gateway User Guide.
        public var smbaclEnabled: Swift.Bool?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public var tags: [StorageGatewayClientTypes.Tag]?
        /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public var validUserList: [Swift.String]?
        /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var vpcEndpointDNSName: Swift.String?

        public init(
            accessBasedEnumeration: Swift.Bool? = nil,
            adminUserList: [Swift.String]? = nil,
            auditDestinationARN: Swift.String? = nil,
            authentication: Swift.String? = nil,
            bucketRegion: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
            defaultStorageClass: Swift.String? = nil,
            encryptionType: StorageGatewayClientTypes.EncryptionType? = nil,
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareName: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            guessMIMETypeEnabled: Swift.Bool? = nil,
            invalidUserList: [Swift.String]? = nil,
            kmsEncrypted: Swift.Bool = false,
            kmsKey: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            notificationPolicy: Swift.String? = nil,
            objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
            oplocksEnabled: Swift.Bool? = nil,
            path: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            requesterPays: Swift.Bool? = nil,
            role: Swift.String? = nil,
            smbaclEnabled: Swift.Bool? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil,
            validUserList: [Swift.String]? = nil,
            vpcEndpointDNSName: Swift.String? = nil
        )
        {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.smbaclEnabled = smbaclEnabled
            self.tags = tags
            self.validUserList = validUserList
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }
    }

}

/// DescribeSMBFileSharesOutput
public struct DescribeSMBFileSharesOutput {
    /// An array containing a description for each requested file share.
    public var smbFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]?

    public init(
        smbFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]? = nil
    )
    {
        self.smbFileShareInfoList = smbFileShareInfoList
    }
}

public struct DescribeSMBSettingsInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

extension StorageGatewayClientTypes {
    /// A list of Active Directory users and groups that have special permissions for SMB file shares on the gateway.
    public struct SMBLocalGroups {
        /// A list of Active Directory users and groups that have local Gateway Admin permissions. Acceptable formats include: DOMAIN\User1, user1, DOMAIN\group1, and group1. Gateway Admins can use the Shared Folders Microsoft Management Console snap-in to force-close files that are open and locked.
        public var gatewayAdmins: [Swift.String]?

        public init(
            gatewayAdmins: [Swift.String]? = nil
        )
        {
            self.gatewayAdmins = gatewayAdmins
        }
    }

}

extension StorageGatewayClientTypes {

    public enum SMBSecurityStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clientspecified
        case mandatoryencryption
        case mandatoryencryptionnoaes128
        case mandatorysigning
        case sdkUnknown(Swift.String)

        public static var allCases: [SMBSecurityStrategy] {
            return [
                .clientspecified,
                .mandatoryencryption,
                .mandatoryencryptionnoaes128,
                .mandatorysigning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clientspecified: return "ClientSpecified"
            case .mandatoryencryption: return "MandatoryEncryption"
            case .mandatoryencryptionnoaes128: return "MandatoryEncryptionNoAes128"
            case .mandatorysigning: return "MandatorySigning"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeSMBSettingsOutput {
    /// Indicates the status of a gateway that is a member of the Active Directory domain.
    ///
    /// * ACCESS_DENIED: Indicates that the JoinDomain operation failed due to an authentication error.
    ///
    /// * DETACHED: Indicates that gateway is not joined to a domain.
    ///
    /// * JOINED: Indicates that the gateway has successfully joined a domain.
    ///
    /// * JOINING: Indicates that a JoinDomain operation is in progress.
    ///
    /// * NETWORK_ERROR: Indicates that JoinDomain operation failed due to a network or connectivity error.
    ///
    /// * TIMEOUT: Indicates that the JoinDomain operation failed because the operation didn't complete within the allotted time.
    ///
    /// * UNKNOWN_ERROR: Indicates that the JoinDomain operation failed due to another type of error.
    public var activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    /// The name of the domain that the gateway is joined to.
    public var domainName: Swift.String?
    /// The shares on this gateway appear when listing shares. Only supported for S3 File Gateways.
    public var fileSharesVisible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// This value is true if a password for the guest user smbguest is set, otherwise false. Only supported for S3 File Gateways. Valid Values: true | false
    public var smbGuestPasswordSet: Swift.Bool?
    /// A list of Active Directory users and groups that have special permissions for SMB file shares on the gateway.
    public var smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups?
    /// The type of security strategy that was specified for file gateway.
    ///
    /// * ClientSpecified: If you choose this option, requests are established based on what is negotiated by the client. This option is recommended when you want to maximize compatibility across different clients in your environment. Supported only for S3 File Gateway.
    ///
    /// * MandatorySigning: If you choose this option, File Gateway only allows connections from SMBv2 or SMBv3 clients that have signing turned on. This option works with SMB clients on Microsoft Windows Vista, Windows Server 2008, or later.
    ///
    /// * MandatoryEncryption: If you choose this option, File Gateway only allows connections from SMBv3 clients that have encryption turned on. Both 256-bit and 128-bit algorithms are allowed. This option is recommended for environments that handle sensitive data. It works with SMB clients on Microsoft Windows 8, Windows Server 2012, or later.
    ///
    /// * MandatoryEncryptionNoAes128: If you choose this option, File Gateway only allows connections from SMBv3 clients that use 256-bit AES encryption algorithms. 128-bit algorithms are not allowed. This option is recommended for environments that handle sensitive data. It works with SMB clients on Microsoft Windows 8, Windows Server 2012, or later.
    public var smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?

    public init(
        activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus? = nil,
        domainName: Swift.String? = nil,
        fileSharesVisible: Swift.Bool? = nil,
        gatewayARN: Swift.String? = nil,
        smbGuestPasswordSet: Swift.Bool? = nil,
        smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups? = nil,
        smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.domainName = domainName
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
        self.smbGuestPasswordSet = smbGuestPasswordSet
        self.smbLocalGroups = smbLocalGroups
        self.smbSecurityStrategy = smbSecurityStrategy
    }
}

/// A JSON object containing the [DescribeSnapshotScheduleInput$VolumeARN] of the volume.
public struct DescribeSnapshotScheduleInput {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

public struct DescribeSnapshotScheduleOutput {
    /// The snapshot description.
    public var description: Swift.String?
    /// The number of hours between snapshots.
    public var recurrenceInHours: Swift.Int?
    /// The hour of the day at which the snapshot schedule begins represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
    public var startAt: Swift.Int?
    /// A list of up to 50 tags assigned to the snapshot schedule, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A value that indicates the time zone of the gateway.
    public var timezone: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume that was specified in the request.
    public var volumeARN: Swift.String?

    public init(
        description: Swift.String? = nil,
        recurrenceInHours: Swift.Int? = nil,
        startAt: Swift.Int? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        timezone: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.timezone = timezone
        self.volumeARN = volumeARN
    }
}

/// A JSON object containing a list of [DescribeStorediSCSIVolumesInput$VolumeARNs].
public struct DescribeStorediSCSIVolumesInput {
    /// An array of strings where each string represents the Amazon Resource Name (ARN) of a stored volume. All of the specified stored volumes must be from the same gateway. Use [ListVolumes] to get volume ARNs for a gateway.
    /// This member is required.
    public var volumeARNs: [Swift.String]?

    public init(
        volumeARNs: [Swift.String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

extension StorageGatewayClientTypes {
    /// Describes an iSCSI stored volume.
    public struct StorediSCSIVolume {
        /// The date the volume was created. Volumes created prior to March 28, 2017 don’t have this timestamp.
        public var createdDate: Foundation.Date?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public var kmsKey: Swift.String?
        /// Indicates if when the stored volume was created, existing data on the underlying local disk was preserved. Valid Values: true | false
        public var preservedExistingData: Swift.Bool
        /// If the stored volume was created from a snapshot, this field contains the snapshot ID used, e.g. snap-78e22663. Otherwise, this field is not included.
        public var sourceSnapshotId: Swift.String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public var targetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public var volumeARN: Swift.String?
        /// A value that indicates whether a storage volume is attached to, detached from, or is in the process of detaching from a gateway. For more information, see [Moving your volumes to a different gateway](https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume).
        public var volumeAttachmentStatus: Swift.String?
        /// The ID of the local disk that was specified in the [CreateStorediSCSIVolume] operation.
        public var volumeDiskId: Swift.String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public var volumeId: Swift.String?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the stored volume is not restoring or bootstrapping.
        public var volumeProgress: Swift.Double?
        /// The size of the volume in bytes.
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeStatus: Swift.String?
        /// One of the VolumeType enumeration values describing the type of the volume.
        public var volumeType: Swift.String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on the number of blocks that are touched, instead of the actual amount of data written. This value can be useful for sequential write patterns but less accurate for random write patterns. VolumeUsedInBytes is different from the compressed size of the volume, which is the value that is used to calculate your bill. This value is not available for volumes created prior to May 13, 2015, until you store data on the volume.
        public var volumeUsedInBytes: Swift.Int?
        /// An [VolumeiSCSIAttributes] object that represents a collection of iSCSI attributes for one stored volume.
        public var volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes?

        public init(
            createdDate: Foundation.Date? = nil,
            kmsKey: Swift.String? = nil,
            preservedExistingData: Swift.Bool = false,
            sourceSnapshotId: Swift.String? = nil,
            targetName: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeDiskId: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeProgress: Swift.Double? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil,
            volumeUsedInBytes: Swift.Int? = nil,
            volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes? = nil
        )
        {
            self.createdDate = createdDate
            self.kmsKey = kmsKey
            self.preservedExistingData = preservedExistingData
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeDiskId = volumeDiskId
            self.volumeId = volumeId
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
        }
    }

}

public struct DescribeStorediSCSIVolumesOutput {
    /// Describes a single unit of output from [DescribeStorediSCSIVolumes]. The following fields are returned:
    ///
    /// * ChapEnabled: Indicates whether mutual CHAP is enabled for the iSCSI target.
    ///
    /// * LunNumber: The logical disk number.
    ///
    /// * NetworkInterfaceId: The network interface ID of the stored volume that initiator use to map the stored volume as an iSCSI target.
    ///
    /// * NetworkInterfacePort: The port used to communicate with iSCSI targets.
    ///
    /// * PreservedExistingData: Indicates when the stored volume was created, existing data on the underlying local disk was preserved.
    ///
    /// * SourceSnapshotId: If the stored volume was created from a snapshot, this field contains the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not included.
    ///
    /// * StorediSCSIVolumes: An array of StorediSCSIVolume objects where each object contains metadata about one stored volume.
    ///
    /// * TargetARN: The Amazon Resource Name (ARN) of the volume target.
    ///
    /// * VolumeARN: The Amazon Resource Name (ARN) of the stored volume.
    ///
    /// * VolumeDiskId: The disk ID of the local disk that was specified in the [CreateStorediSCSIVolume] operation.
    ///
    /// * VolumeId: The unique identifier of the storage volume, e.g. vol-1122AABB.
    ///
    /// * VolumeiSCSIAttributes: An [VolumeiSCSIAttributes] object that represents a collection of iSCSI attributes for one stored volume.
    ///
    /// * VolumeProgress: Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the stored volume is not restoring or bootstrapping.
    ///
    /// * VolumeSizeInBytes: The size of the volume in bytes.
    ///
    /// * VolumeStatus: One of the VolumeStatus values that indicates the state of the volume.
    ///
    /// * VolumeType: One of the enumeration values describing the type of the volume. Currently, only STORED volumes are supported.
    public var storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]?

    public init(
        storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]? = nil
    )
    {
        self.storediSCSIVolumes = storediSCSIVolumes
    }
}

/// DescribeTapeArchivesInput
public struct DescribeTapeArchivesInput {
    /// Specifies that the number of virtual tapes described be limited to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing virtual tapes.
    public var marker: Swift.String?
    /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual tapes you want to describe.
    public var tapeARNs: [Swift.String]?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

extension StorageGatewayClientTypes {
    /// Represents a virtual tape that is archived in the virtual tape shelf (VTS).
    public struct TapeArchive {
        /// The time that the archiving of the virtual tape was completed. The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var completionTime: Foundation.Date?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public var kmsKey: Swift.String?
        /// The time that the tape entered the custom tape pool. The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var poolEntryDate: Foundation.Date?
        /// The ID of the pool that was used to archive the tape. The tapes in this pool are archived in the S3 storage class that is associated with the pool.
        public var poolId: Swift.String?
        /// If the archived tape is subject to tape retention lock, the date that the archived tape started being retained.
        public var retentionStartDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the tape gateway that the virtual tape is being retrieved to. The virtual tape is retrieved from the virtual tape shelf (VTS).
        public var retrievedTo: Swift.String?
        /// The Amazon Resource Name (ARN) of an archived virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies the archived virtual tape.
        public var tapeBarcode: Swift.String?
        /// The date the virtual tape was created.
        public var tapeCreatedDate: Foundation.Date?
        /// The size, in bytes, of the archived virtual tape.
        public var tapeSizeInBytes: Swift.Int?
        /// The current state of the archived virtual tape.
        public var tapeStatus: Swift.String?
        /// The size, in bytes, of data stored on the virtual tape. This value is not available for tapes created prior to May 13, 2015.
        public var tapeUsedInBytes: Swift.Int?
        /// Set to true if the archived tape is stored as write-once-read-many (WORM).
        public var worm: Swift.Bool

        public init(
            completionTime: Foundation.Date? = nil,
            kmsKey: Swift.String? = nil,
            poolEntryDate: Foundation.Date? = nil,
            poolId: Swift.String? = nil,
            retentionStartDate: Foundation.Date? = nil,
            retrievedTo: Swift.String? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeCreatedDate: Foundation.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil,
            tapeUsedInBytes: Swift.Int? = nil,
            worm: Swift.Bool = false
        )
        {
            self.completionTime = completionTime
            self.kmsKey = kmsKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.retrievedTo = retrievedTo
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.worm = worm
        }
    }

}

/// DescribeTapeArchivesOutput
public struct DescribeTapeArchivesOutput {
    /// An opaque string that indicates the position at which the virtual tapes that were fetched for description ended. Use this marker in your next request to fetch the next set of virtual tapes in the virtual tape shelf (VTS). If there are no more virtual tapes to describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of virtual tape objects in the virtual tape shelf (VTS). The description includes of the Amazon Resource Name (ARN) of the virtual tapes. The information returned includes the Amazon Resource Names (ARNs) of the tapes, size of the tapes, status of the tapes, progress of the description, and tape barcode.
    public var tapeArchives: [StorageGatewayClientTypes.TapeArchive]?

    public init(
        marker: Swift.String? = nil,
        tapeArchives: [StorageGatewayClientTypes.TapeArchive]? = nil
    )
    {
        self.marker = marker
        self.tapeArchives = tapeArchives
    }
}

/// DescribeTapeRecoveryPointsInput
public struct DescribeTapeRecoveryPointsInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of virtual tape recovery points that are described be limited to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing the virtual tape recovery points.
    public var marker: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

extension StorageGatewayClientTypes {
    /// Describes a recovery point.
    public struct TapeRecoveryPointInfo {
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public var tapeARN: Swift.String?
        /// The time when the point-in-time view of the virtual tape was replicated for later recovery. The default timestamp format of the tape recovery point time is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var tapeRecoveryPointTime: Foundation.Date?
        /// The size, in bytes, of the virtual tapes to recover.
        public var tapeSizeInBytes: Swift.Int?
        /// The status of the virtual tapes.
        public var tapeStatus: Swift.String?

        public init(
            tapeARN: Swift.String? = nil,
            tapeRecoveryPointTime: Foundation.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil
        )
        {
            self.tapeARN = tapeARN
            self.tapeRecoveryPointTime = tapeRecoveryPointTime
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }
    }

}

/// DescribeTapeRecoveryPointsOutput
public struct DescribeTapeRecoveryPointsOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// An opaque string that indicates the position at which the virtual tape recovery points that were listed for description ended. Use this marker in your next request to list the next set of virtual tape recovery points in the list. If there are no more recovery points to describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of TapeRecoveryPointInfos that are available for the specified gateway.
    public var tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]?

    public init(
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.tapeRecoveryPointInfos = tapeRecoveryPointInfos
    }
}

/// DescribeTapesInput
public struct DescribeTapesInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of virtual tapes described be limited to the specified number. Amazon Web Services may impose its own limit, if this field is not set.
    public var limit: Swift.Int?
    /// A marker value, obtained in a previous call to DescribeTapes. This marker indicates which page of results to retrieve. If not specified, the first page of results is retrieved.
    public var marker: Swift.String?
    /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual tapes you want to describe. If this parameter is not specified, Tape gateway returns a description of all virtual tapes associated with the specified gateway.
    public var tapeARNs: [Swift.String]?

    public init(
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

extension StorageGatewayClientTypes {
    /// Describes a virtual tape object.
    public struct Tape {
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public var kmsKey: Swift.String?
        /// The date that the tape enters a custom tape pool.
        public var poolEntryDate: Foundation.Date?
        /// The ID of the pool that contains tapes that will be archived. The tapes in this pool are archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var poolId: Swift.String?
        /// For archiving virtual tapes, indicates how much data remains to be uploaded before archiving is complete. Range: 0 (not started) to 100 (complete).
        public var progress: Swift.Double?
        /// The date that the tape is first archived with tape retention lock enabled.
        public var retentionStartDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies a specific virtual tape.
        public var tapeBarcode: Swift.String?
        /// The date the virtual tape was created.
        public var tapeCreatedDate: Foundation.Date?
        /// The size, in bytes, of the virtual tape capacity.
        public var tapeSizeInBytes: Swift.Int?
        /// The current state of the virtual tape.
        public var tapeStatus: Swift.String?
        /// The size, in bytes, of data stored on the virtual tape. This value is not available for tapes created prior to May 13, 2015.
        public var tapeUsedInBytes: Swift.Int?
        /// The virtual tape library (VTL) device that the virtual tape is associated with.
        public var vtlDevice: Swift.String?
        /// If the tape is archived as write-once-read-many (WORM), this value is true.
        public var worm: Swift.Bool

        public init(
            kmsKey: Swift.String? = nil,
            poolEntryDate: Foundation.Date? = nil,
            poolId: Swift.String? = nil,
            progress: Swift.Double? = nil,
            retentionStartDate: Foundation.Date? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeCreatedDate: Foundation.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil,
            tapeUsedInBytes: Swift.Int? = nil,
            vtlDevice: Swift.String? = nil,
            worm: Swift.Bool = false
        )
        {
            self.kmsKey = kmsKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.progress = progress
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.vtlDevice = vtlDevice
            self.worm = worm
        }
    }

}

/// DescribeTapesOutput
public struct DescribeTapesOutput {
    /// An opaque string that can be used as part of a subsequent DescribeTapes call to retrieve the next page of results. If a response does not contain a marker, then there are no more results to be retrieved.
    public var marker: Swift.String?
    /// An array of virtual tape descriptions.
    public var tapes: [StorageGatewayClientTypes.Tape]?

    public init(
        marker: Swift.String? = nil,
        tapes: [StorageGatewayClientTypes.Tape]? = nil
    )
    {
        self.marker = marker
        self.tapes = tapes
    }
}

public struct DescribeUploadBufferInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DescribeUploadBufferOutput {
    /// An array of the gateway's local disk IDs that are configured as working storage. Each local disk ID is specified as a string (minimum length of 1 and maximum length of 300). If no local disks are configured as working storage, then the DiskIds array is empty.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The total number of bytes allocated in the gateway's as upload buffer.
    public var uploadBufferAllocatedInBytes: Swift.Int
    /// The total number of bytes being used in the gateway's upload buffer.
    public var uploadBufferUsedInBytes: Swift.Int

    public init(
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil,
        uploadBufferAllocatedInBytes: Swift.Int = 0,
        uploadBufferUsedInBytes: Swift.Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes
        self.uploadBufferUsedInBytes = uploadBufferUsedInBytes
    }
}

/// DescribeVTLDevicesInput
public struct DescribeVTLDevicesInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of VTL devices described be limited to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing the VTL devices.
    public var marker: Swift.String?
    /// An array of strings, where each string represents the Amazon Resource Name (ARN) of a VTL device. All of the specified VTL devices must be from the same gateway. If no VTL devices are specified, the result will contain all devices on the specified gateway.
    public var vtlDeviceARNs: [Swift.String]?

    public init(
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        vtlDeviceARNs: [Swift.String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.vtlDeviceARNs = vtlDeviceARNs
    }
}

extension StorageGatewayClientTypes {
    /// Lists iSCSI information about a VTL device.
    public struct DeviceiSCSIAttributes {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public var chapEnabled: Swift.Bool
        /// The network interface identifier of the VTL device.
        public var networkInterfaceId: Swift.String?
        /// The port used to communicate with iSCSI VTL device targets.
        public var networkInterfacePort: Swift.Int
        /// Specifies the unique Amazon Resource Name (ARN) that encodes the iSCSI qualified name(iqn) of a tape drive or media changer target.
        public var targetARN: Swift.String?

        public init(
            chapEnabled: Swift.Bool = false,
            networkInterfaceId: Swift.String? = nil,
            networkInterfacePort: Swift.Int = 0,
            targetARN: Swift.String? = nil
        )
        {
            self.chapEnabled = chapEnabled
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }
    }

}

extension StorageGatewayClientTypes {
    /// Represents a device object associated with a tape gateway.
    public struct VTLDevice {
        /// A list of iSCSI information about a VTL device.
        public var deviceiSCSIAttributes: StorageGatewayClientTypes.DeviceiSCSIAttributes?
        /// Specifies the unique Amazon Resource Name (ARN) of the device (tape drive or media changer).
        public var vtlDeviceARN: Swift.String?
        /// Specifies the model number of device that the VTL device emulates.
        public var vtlDeviceProductIdentifier: Swift.String?
        /// Specifies the type of device that the VTL device emulates.
        public var vtlDeviceType: Swift.String?
        /// Specifies the vendor of the device that the VTL device object emulates.
        public var vtlDeviceVendor: Swift.String?

        public init(
            deviceiSCSIAttributes: StorageGatewayClientTypes.DeviceiSCSIAttributes? = nil,
            vtlDeviceARN: Swift.String? = nil,
            vtlDeviceProductIdentifier: Swift.String? = nil,
            vtlDeviceType: Swift.String? = nil,
            vtlDeviceVendor: Swift.String? = nil
        )
        {
            self.deviceiSCSIAttributes = deviceiSCSIAttributes
            self.vtlDeviceARN = vtlDeviceARN
            self.vtlDeviceProductIdentifier = vtlDeviceProductIdentifier
            self.vtlDeviceType = vtlDeviceType
            self.vtlDeviceVendor = vtlDeviceVendor
        }
    }

}

/// DescribeVTLDevicesOutput
public struct DescribeVTLDevicesOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// An opaque string that indicates the position at which the VTL devices that were fetched for description ended. Use the marker in your next request to fetch the next set of VTL devices in the list. If there are no more VTL devices to describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of VTL device objects composed of the Amazon Resource Name (ARN) of the VTL devices.
    public var vtlDevices: [StorageGatewayClientTypes.VTLDevice]?

    public init(
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        vtlDevices: [StorageGatewayClientTypes.VTLDevice]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.vtlDevices = vtlDevices
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeWorkingStorageInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the following fields:
public struct DescribeWorkingStorageOutput {
    /// An array of the gateway's local disk IDs that are configured as working storage. Each local disk ID is specified as a string (minimum length of 1 and maximum length of 300). If no local disks are configured as working storage, then the DiskIds array is empty.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The total working storage in bytes allocated for the gateway. If no working storage is configured for the gateway, this field returns 0.
    public var workingStorageAllocatedInBytes: Swift.Int
    /// The total working storage in bytes in use by the gateway. If no working storage is configured for the gateway, this field returns 0.
    public var workingStorageUsedInBytes: Swift.Int

    public init(
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil,
        workingStorageAllocatedInBytes: Swift.Int = 0,
        workingStorageUsedInBytes: Swift.Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.workingStorageAllocatedInBytes = workingStorageAllocatedInBytes
        self.workingStorageUsedInBytes = workingStorageUsedInBytes
    }
}

/// AttachVolumeInput
public struct DetachVolumeInput {
    /// Set to true to forcibly remove the iSCSI connection of the target volume and detach the volume. The default is false. If this value is set to false, you must manually disconnect the iSCSI connection from the target volume. Valid Values: true | false
    public var forceDetach: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the volume to detach from the gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        forceDetach: Swift.Bool? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.forceDetach = forceDetach
        self.volumeARN = volumeARN
    }
}

/// AttachVolumeOutput
public struct DetachVolumeOutput {
    /// The Amazon Resource Name (ARN) of the volume that was detached.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

/// DisableGatewayInput
public struct DisableGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// DisableGatewayOutput
public struct DisableGatewayOutput {
    /// The unique Amazon Resource Name (ARN) of the disabled gateway.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct DisassociateFileSystemInput {
    /// The Amazon Resource Name (ARN) of the file system association to be deleted.
    /// This member is required.
    public var fileSystemAssociationARN: Swift.String?
    /// If this value is set to true, the operation disassociates an Amazon FSx file system immediately. It ends all data uploads to the file system, and the file system association enters the FORCE_DELETING status. If this value is set to false, the Amazon FSx file system does not disassociate until all data is uploaded.
    public var forceDelete: Swift.Bool?

    public init(
        fileSystemAssociationARN: Swift.String? = nil,
        forceDelete: Swift.Bool? = false
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.forceDelete = forceDelete
    }
}

public struct DisassociateFileSystemOutput {
    /// The Amazon Resource Name (ARN) of the deleted file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init(
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

extension StorageGatewayClientTypes {
    /// Represents a gateway's local disk.
    public struct Disk {
        /// The iSCSI qualified name (IQN) that is defined for a disk. This field is not included in the response if the local disk is not defined as an iSCSI target. The format of this field is targetIqn::LUNNumber::region-volumeId.
        public var diskAllocationResource: Swift.String?
        /// One of the DiskAllocationType enumeration values that identifies how a local disk is used. Valid Values: UPLOAD_BUFFER | CACHE_STORAGE
        public var diskAllocationType: Swift.String?
        /// A list of values that represents attributes of a local disk.
        public var diskAttributeList: [Swift.String]?
        /// The unique device ID or other distinguishing data that identifies a local disk.
        public var diskId: Swift.String?
        /// The device node of a local disk as assigned by the virtualization environment.
        public var diskNode: Swift.String?
        /// The path of a local disk in the gateway virtual machine (VM).
        public var diskPath: Swift.String?
        /// The local disk size in bytes.
        public var diskSizeInBytes: Swift.Int
        /// A value that represents the status of a local disk.
        public var diskStatus: Swift.String?

        public init(
            diskAllocationResource: Swift.String? = nil,
            diskAllocationType: Swift.String? = nil,
            diskAttributeList: [Swift.String]? = nil,
            diskId: Swift.String? = nil,
            diskNode: Swift.String? = nil,
            diskPath: Swift.String? = nil,
            diskSizeInBytes: Swift.Int = 0,
            diskStatus: Swift.String? = nil
        )
        {
            self.diskAllocationResource = diskAllocationResource
            self.diskAllocationType = diskAllocationType
            self.diskAttributeList = diskAttributeList
            self.diskId = diskId
            self.diskNode = diskNode
            self.diskPath = diskPath
            self.diskSizeInBytes = diskSizeInBytes
            self.diskStatus = diskStatus
        }
    }

}

extension StorageGatewayClientTypes {

    /// The type of the file share.
    public enum FileShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nfs
        case smb
        case sdkUnknown(Swift.String)

        public static var allCases: [FileShareType] {
            return [
                .nfs,
                .smb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nfs: return "NFS"
            case .smb: return "SMB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Describes a file share. Only supported S3 File Gateway.
    public struct FileShareInfo {
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The status of the file share. Valid Values: CREATING | UPDATING | AVAILABLE | DELETING
        public var fileShareStatus: Swift.String?
        /// The type of the file share.
        public var fileShareType: StorageGatewayClientTypes.FileShareType?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?

        public init(
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            fileShareType: StorageGatewayClientTypes.FileShareType? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareStatus = fileShareStatus
            self.fileShareType = fileShareType
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {
    /// Gets the summary returned by ListFileSystemAssociation, which is a summary of a created file system association.
    public struct FileSystemAssociationSummary {
        /// The Amazon Resource Name (ARN) of the file system association.
        public var fileSystemAssociationARN: Swift.String?
        /// The ID of the file system association.
        public var fileSystemAssociationId: Swift.String?
        /// The status of the file share. Valid Values: AVAILABLE | CREATING | DELETING | FORCE_DELETING | UPDATING | ERROR
        public var fileSystemAssociationStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?

        public init(
            fileSystemAssociationARN: Swift.String? = nil,
            fileSystemAssociationId: Swift.String? = nil,
            fileSystemAssociationStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationId = fileSystemAssociationId
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {
    /// Describes a gateway object.
    public struct GatewayInfo {
        /// Date after which this gateway will not receive software updates for new features and bug fixes.
        public var deprecationDate: Swift.String?
        /// The ID of the Amazon EC2 instance that was used to launch the gateway.
        public var ec2InstanceId: Swift.String?
        /// The Amazon Web Services Region where the Amazon EC2 instance is located.
        public var ec2InstanceRegion: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations.
        public var gatewayId: Swift.String?
        /// The name of the gateway.
        public var gatewayName: Swift.String?
        /// The state of the gateway. Valid Values: DISABLED | ACTIVE
        public var gatewayOperationalState: Swift.String?
        /// The type of the gateway.
        public var gatewayType: Swift.String?
        /// The type of hardware or software platform on which the gateway is running. Tape Gateway is no longer available on Snow Family devices.
        public var hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
        /// A unique identifier for the specific instance of the host platform running the gateway. This value is only available for certain host environments, and its format depends on the host environment type.
        public var hostEnvironmentId: Swift.String?
        /// The version number of the software running on the gateway appliance.
        public var softwareVersion: Swift.String?

        public init(
            deprecationDate: Swift.String? = nil,
            ec2InstanceId: Swift.String? = nil,
            ec2InstanceRegion: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayOperationalState: Swift.String? = nil,
            gatewayType: Swift.String? = nil,
            hostEnvironment: StorageGatewayClientTypes.HostEnvironment? = nil,
            hostEnvironmentId: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.deprecationDate = deprecationDate
            self.ec2InstanceId = ec2InstanceId
            self.ec2InstanceRegion = ec2InstanceRegion
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayOperationalState = gatewayOperationalState
            self.gatewayType = gatewayType
            self.hostEnvironment = hostEnvironment
            self.hostEnvironmentId = hostEnvironmentId
            self.softwareVersion = softwareVersion
        }
    }

}

/// JoinDomainInput
public struct JoinDomainInput {
    /// List of IPv4 addresses, NetBIOS names, or host names of your domain server. If you need to specify the port number include it after the colon (“:”). For example, mydc.mydomain.com:389.
    public var domainControllers: [Swift.String]?
    /// The name of the domain that you want the gateway to join.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The organizational unit (OU) is a container in an Active Directory that can hold users, groups, computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
    public var organizationalUnit: Swift.String?
    /// Sets the password of the user who has permission to add the gateway to the Active Directory domain.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies the time in seconds, in which the JoinDomain operation must complete. The default is 20 seconds.
    public var timeoutInSeconds: Swift.Int?
    /// Sets the user name of user who has permission to add the gateway to the Active Directory domain. The domain user account should be enabled to join computers to the domain. For example, you can use the domain administrator account or an account with delegated permissions to join computers to the domain.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        domainControllers: [Swift.String]? = nil,
        domainName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        organizationalUnit: Swift.String? = nil,
        password: Swift.String? = nil,
        timeoutInSeconds: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.domainControllers = domainControllers
        self.domainName = domainName
        self.gatewayARN = gatewayARN
        self.organizationalUnit = organizationalUnit
        self.password = password
        self.timeoutInSeconds = timeoutInSeconds
        self.userName = userName
    }
}

extension JoinDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JoinDomainInput(domainControllers: \(Swift.String(describing: domainControllers)), domainName: \(Swift.String(describing: domainName)), gatewayARN: \(Swift.String(describing: gatewayARN)), organizationalUnit: \(Swift.String(describing: organizationalUnit)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

/// JoinDomainOutput
public struct JoinDomainOutput {
    /// Indicates the status of the gateway as a member of the Active Directory domain.
    ///
    /// * ACCESS_DENIED: Indicates that the JoinDomain operation failed due to an authentication error.
    ///
    /// * DETACHED: Indicates that gateway is not joined to a domain.
    ///
    /// * JOINED: Indicates that the gateway has successfully joined a domain.
    ///
    /// * JOINING: Indicates that a JoinDomain operation is in progress.
    ///
    /// * NETWORK_ERROR: Indicates that JoinDomain operation failed due to a network or connectivity error.
    ///
    /// * TIMEOUT: Indicates that the JoinDomain operation failed because the operation didn't complete within the allotted time.
    ///
    /// * UNKNOWN_ERROR: Indicates that the JoinDomain operation failed due to another type of error.
    public var activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    /// The unique Amazon Resource Name (ARN) of the gateway that joined the domain.
    public var gatewayARN: Swift.String?

    public init(
        activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.gatewayARN = gatewayARN
    }
}

public struct ListAutomaticTapeCreationPoliciesInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct ListAutomaticTapeCreationPoliciesOutput {
    /// Gets a listing of information about the gateway's automatic tape creation policies, including the automatic tape creation rules and the gateway that is using the policies.
    public var automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]?

    public init(
        automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]? = nil
    )
    {
        self.automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfos
    }
}

/// ListFileShareInput
public struct ListFileSharesInput {
    /// The Amazon Resource Name (ARN) of the gateway whose file shares you want to list. If this field is not present, all file shares under your account are listed.
    public var gatewayARN: Swift.String?
    /// The maximum number of file shares to return in the response. The value must be an integer with a value greater than zero. Optional.
    public var limit: Swift.Int?
    /// Opaque pagination token returned from a previous ListFileShares operation. If present, Marker specifies where to continue the list from after a previous call to ListFileShares. Optional.
    public var marker: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

/// ListFileShareOutput
public struct ListFileSharesOutput {
    /// An array of information about the S3 File Gateway's file shares.
    public var fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]?
    /// If the request includes Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// If a value is present, there are more file shares to return. In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file shares.
    public var nextMarker: Swift.String?

    public init(
        fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileShareInfoList = fileShareInfoList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

public struct ListFileSystemAssociationsInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The maximum number of file system associations to return in the response. If present, Limit must be an integer with a value greater than zero. Optional.
    public var limit: Swift.Int?
    /// Opaque pagination token returned from a previous ListFileSystemAssociations operation. If present, Marker specifies where to continue the list from after a previous call to ListFileSystemAssociations. Optional.
    public var marker: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

public struct ListFileSystemAssociationsOutput {
    /// An array of information about the Amazon FSx gateway's file system associations.
    public var fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]?
    /// If the request includes Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// If a value is present, there are more file system associations to return. In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file system associations.
    public var nextMarker: Swift.String?

    public init(
        fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileSystemAssociationSummaryList = fileSystemAssociationSummaryList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

/// A JSON object containing zero or more of the following fields:
///
/// * [ListGatewaysInput$Limit]
///
/// * [ListGatewaysInput$Marker]
public struct ListGatewaysInput {
    /// Specifies that the list of gateways returned be limited to the specified number of items.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin the returned list of gateways.
    public var marker: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
    }
}

public struct ListGatewaysOutput {
    /// An array of [GatewayInfo] objects.
    public var gateways: [StorageGatewayClientTypes.GatewayInfo]?
    /// Use the marker in your next request to fetch the next set of gateways in the list. If there are no more gateways to list, this field does not appear in the response.
    public var marker: Swift.String?

    public init(
        gateways: [StorageGatewayClientTypes.GatewayInfo]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.marker = marker
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct ListLocalDisksInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct ListLocalDisksOutput {
    /// A JSON object containing the following fields:
    ///
    /// * [ListLocalDisksOutput$Disks]
    public var disks: [StorageGatewayClientTypes.Disk]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        disks: [StorageGatewayClientTypes.Disk]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.disks = disks
        self.gatewayARN = gatewayARN
    }
}

/// ListTagsForResourceInput
public struct ListTagsForResourceInput {
    /// Specifies that the list of tags returned be limited to the specified number of items.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin returning the list of tags.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.resourceARN = resourceARN
    }
}

/// ListTagsForResourceOutput
public struct ListTagsForResourceOutput {
    /// An opaque string that indicates the position at which to stop returning the list of tags.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    public var resourceARN: Swift.String?
    /// An array that contains the tags for the specified resource.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init(
        marker: Swift.String? = nil,
        resourceARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.marker = marker
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct ListTapePoolsInput {
    /// An optional number limit for the tape pools in the list returned by this call.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of tape pools.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of each of the custom tape pools you want to list. If you don't specify a custom tape pool ARN, the response lists all custom tape pools.
    public var poolARNs: [Swift.String]?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        poolARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.poolARNs = poolARNs
    }
}

extension StorageGatewayClientTypes {

    public enum PoolStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolStatus] {
            return [
                .active,
                .deleted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StorageGatewayClientTypes {
    /// Describes a custom tape pool.
    public struct PoolInfo {
        /// The Amazon Resource Name (ARN) of the custom tape pool. Use the [ListTapePools] operation to return a list of custom tape pools for your account and Amazon Web Services Region.
        public var poolARN: Swift.String?
        /// The name of the custom tape pool. PoolName can use all ASCII characters, except '/' and '\'.
        public var poolName: Swift.String?
        /// Status of the custom tape pool. Pool can be ACTIVE or DELETED.
        public var poolStatus: StorageGatewayClientTypes.PoolStatus?
        /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to 100 years (36,500 days).
        public var retentionLockTimeInDays: Swift.Int?
        /// Tape retention lock type, which can be configured in two modes. When configured in governance mode, Amazon Web Services accounts with specific IAM permissions are authorized to remove the tape retention lock from archived virtual tapes. When configured in compliance mode, the tape retention lock cannot be removed by any user, including the root Amazon Web Services account.
        public var retentionLockType: StorageGatewayClientTypes.RetentionLockType?
        /// The storage class that is associated with the custom pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var storageClass: StorageGatewayClientTypes.TapeStorageClass?

        public init(
            poolARN: Swift.String? = nil,
            poolName: Swift.String? = nil,
            poolStatus: StorageGatewayClientTypes.PoolStatus? = nil,
            retentionLockTimeInDays: Swift.Int? = nil,
            retentionLockType: StorageGatewayClientTypes.RetentionLockType? = nil,
            storageClass: StorageGatewayClientTypes.TapeStorageClass? = nil
        )
        {
            self.poolARN = poolARN
            self.poolName = poolName
            self.poolStatus = poolStatus
            self.retentionLockTimeInDays = retentionLockTimeInDays
            self.retentionLockType = retentionLockType
            self.storageClass = storageClass
        }
    }

}

public struct ListTapePoolsOutput {
    /// A string that indicates the position at which to begin the returned list of tape pools. Use the marker in your next request to continue pagination of tape pools. If there are no more tape pools to list, this element does not appear in the response body.
    public var marker: Swift.String?
    /// An array of PoolInfo objects, where each object describes a single custom tape pool. If there are no custom tape pools, the PoolInfos is an empty array.
    public var poolInfos: [StorageGatewayClientTypes.PoolInfo]?

    public init(
        marker: Swift.String? = nil,
        poolInfos: [StorageGatewayClientTypes.PoolInfo]? = nil
    )
    {
        self.marker = marker
        self.poolInfos = poolInfos
    }
}

/// A JSON object that contains one or more of the following fields:
///
/// * [ListTapesInput$Limit]
///
/// * [ListTapesInput$Marker]
///
/// * [ListTapesInput$TapeARNs]
public struct ListTapesInput {
    /// An optional number limit for the tapes in the list returned by this call.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of tapes.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of each of the tapes you want to list. If you don't specify a tape ARN, the response lists all tapes in both your VTL and VTS.
    public var tapeARNs: [Swift.String]?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

extension StorageGatewayClientTypes {
    /// Describes a virtual tape.
    public struct TapeInfo {
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The date that the tape entered the custom tape pool with tape retention lock enabled.
        public var poolEntryDate: Foundation.Date?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var poolId: Swift.String?
        /// The date that the tape became subject to tape retention lock.
        public var retentionStartDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of a virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies a specific virtual tape.
        public var tapeBarcode: Swift.String?
        /// The size, in bytes, of a virtual tape.
        public var tapeSizeInBytes: Swift.Int?
        /// The status of the tape.
        public var tapeStatus: Swift.String?

        public init(
            gatewayARN: Swift.String? = nil,
            poolEntryDate: Foundation.Date? = nil,
            poolId: Swift.String? = nil,
            retentionStartDate: Foundation.Date? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil
        )
        {
            self.gatewayARN = gatewayARN
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }
    }

}

/// A JSON object containing the following fields:
///
/// * [ListTapesOutput$Marker]
///
/// * [ListTapesOutput$VolumeInfos]
public struct ListTapesOutput {
    /// A string that indicates the position at which to begin returning the next list of tapes. Use the marker in your next request to continue pagination of tapes. If there are no more tapes to list, this element does not appear in the response body.
    public var marker: Swift.String?
    /// An array of [TapeInfo] objects, where each object describes a single tape. If there are no tapes in the tape library or VTS, then the TapeInfos is an empty array.
    public var tapeInfos: [StorageGatewayClientTypes.TapeInfo]?

    public init(
        marker: Swift.String? = nil,
        tapeInfos: [StorageGatewayClientTypes.TapeInfo]? = nil
    )
    {
        self.marker = marker
        self.tapeInfos = tapeInfos
    }
}

/// ListVolumeInitiatorsInput
public struct ListVolumeInitiatorsInput {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes for the gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

/// ListVolumeInitiatorsOutput
public struct ListVolumeInitiatorsOutput {
    /// The host names and port numbers of all iSCSI initiators that are connected to the gateway.
    public var initiators: [Swift.String]?

    public init(
        initiators: [Swift.String]? = nil
    )
    {
        self.initiators = initiators
    }
}

public struct ListVolumeRecoveryPointsInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

extension StorageGatewayClientTypes {
    /// Describes a storage volume recovery point object.
    public struct VolumeRecoveryPointInfo {
        /// The Amazon Resource Name (ARN) of the volume target.
        public var volumeARN: Swift.String?
        /// The time the recovery point was taken.
        public var volumeRecoveryPointTime: Swift.String?
        /// The size of the volume in bytes.
        public var volumeSizeInBytes: Swift.Int
        /// The size of the data stored on the volume in bytes. This value is not available for volumes created prior to May 13, 2015, until you store data on the volume.
        public var volumeUsageInBytes: Swift.Int

        public init(
            volumeARN: Swift.String? = nil,
            volumeRecoveryPointTime: Swift.String? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeUsageInBytes: Swift.Int = 0
        )
        {
            self.volumeARN = volumeARN
            self.volumeRecoveryPointTime = volumeRecoveryPointTime
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeUsageInBytes = volumeUsageInBytes
        }
    }

}

public struct ListVolumeRecoveryPointsOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// An array of [VolumeRecoveryPointInfo] objects.
    public var volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]?

    public init(
        gatewayARN: Swift.String? = nil,
        volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.volumeRecoveryPointInfos = volumeRecoveryPointInfos
    }
}

/// A JSON object that contains one or more of the following fields:
///
/// * [ListVolumesInput$Limit]
///
/// * [ListVolumesInput$Marker]
public struct ListVolumesInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// Specifies that the list of volumes returned be limited to the specified number of items.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of volumes. Obtain the marker from the response of a previous List iSCSI Volumes request.
    public var marker: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

extension StorageGatewayClientTypes {
    /// Describes a storage volume object.
    public struct VolumeInfo {
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var gatewayId: Swift.String?
        /// The Amazon Resource Name (ARN) for the storage volume. For example, the following is a valid ARN: arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/volume/vol-1122AABB Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeARN: Swift.String?
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeAttachmentStatus: Swift.String?
        /// The unique identifier assigned to the volume. This ID becomes part of the volume Amazon Resource Name (ARN), which you use as input for other operations. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeId: Swift.String?
        /// The size of the volume in bytes. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeType enumeration values describing the type of the volume.
        public var volumeType: Swift.String?

        public init(
            gatewayARN: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeType = volumeType
        }
    }

}

/// A JSON object containing the following fields:
///
/// * [ListVolumesOutput$Marker]
///
/// * [ListVolumesOutput$VolumeInfos]
public struct ListVolumesOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// Use the marker in your next request to continue pagination of iSCSI volumes. If there are no more volumes to list, this field does not appear in the response body.
    public var marker: Swift.String?
    /// An array of [VolumeInfo] objects, where each object describes an iSCSI volume. If no volumes are defined for the gateway, then VolumeInfos is an empty array "[]".
    public var volumeInfos: [StorageGatewayClientTypes.VolumeInfo]?

    public init(
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        volumeInfos: [StorageGatewayClientTypes.VolumeInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.volumeInfos = volumeInfos
    }
}

public struct NotifyWhenUploadedInput {
    /// The Amazon Resource Name (ARN) of the file share.
    /// This member is required.
    public var fileShareARN: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

public struct NotifyWhenUploadedOutput {
    /// The Amazon Resource Name (ARN) of the file share.
    public var fileShareARN: Swift.String?
    /// The randomly generated ID of the notification that was sent. This ID is in UUID format.
    public var notificationId: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil,
        notificationId: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

/// RefreshCacheInput
public struct RefreshCacheInput {
    /// The Amazon Resource Name (ARN) of the file share you want to refresh.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// A comma-separated list of the paths of folders to refresh in the cache. The default is ["/"]. The default refreshes objects and folders at the root of the Amazon S3 bucket. If Recursive is set to true, the entire S3 bucket that the file share has access to is refreshed. Do not include / when specifying folder names. For example, you would specify samplefolder rather than samplefolder/.
    public var folderList: [Swift.String]?
    /// A value that specifies whether to recursively refresh folders in the cache. The refresh includes folders that were in the cache the last time the gateway listed the folder's contents. If this value set to true, each folder that is listed in FolderList is recursively updated. Otherwise, subfolders listed in FolderList are not refreshed. Only objects that are in folders listed directly under FolderList are found and used for the update. The default is true. Valid Values: true | false
    public var recursive: Swift.Bool?

    public init(
        fileShareARN: Swift.String? = nil,
        folderList: [Swift.String]? = nil,
        recursive: Swift.Bool? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.folderList = folderList
        self.recursive = recursive
    }
}

/// RefreshCacheOutput
public struct RefreshCacheOutput {
    /// The Amazon Resource Name (ARN) of the file share.
    public var fileShareARN: Swift.String?
    /// The randomly generated ID of the notification that was sent. This ID is in UUID format.
    public var notificationId: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil,
        notificationId: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

/// RemoveTagsFromResourceInput
public struct RemoveTagsFromResourceInput {
    /// The Amazon Resource Name (ARN) of the resource you want to remove the tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags you want to remove from the specified resource. A tag is composed of a key-value pair.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

/// RemoveTagsFromResourceOutput
public struct RemoveTagsFromResourceOutput {
    /// The Amazon Resource Name (ARN) of the resource that the tags were removed from.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ResetCacheInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct ResetCacheOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// RetrieveTapeArchiveInput
public struct RetrieveTapeArchiveInput {
    /// The Amazon Resource Name (ARN) of the gateway you want to retrieve the virtual tape to. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region. You retrieve archived virtual tapes to only one gateway and the gateway must be a tape gateway.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to retrieve from the virtual tape shelf (VTS).
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

/// RetrieveTapeArchiveOutput
public struct RetrieveTapeArchiveOutput {
    /// The Amazon Resource Name (ARN) of the retrieved virtual tape.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

/// RetrieveTapeRecoveryPointInput
public struct RetrieveTapeRecoveryPointInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape for which you want to retrieve the recovery point.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

/// RetrieveTapeRecoveryPointOutput
public struct RetrieveTapeRecoveryPointOutput {
    /// The Amazon Resource Name (ARN) of the virtual tape for which the recovery point was retrieved.
    public var tapeARN: Swift.String?

    public init(
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

/// SetLocalConsolePasswordInput
public struct SetLocalConsolePasswordInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The password you want to set for your VM local console.
    /// This member is required.
    public var localConsolePassword: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        localConsolePassword: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.localConsolePassword = localConsolePassword
    }
}

extension SetLocalConsolePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetLocalConsolePasswordInput(gatewayARN: \(Swift.String(describing: gatewayARN)), localConsolePassword: \"CONTENT_REDACTED\")"}
}

public struct SetLocalConsolePasswordOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// SetSMBGuestPasswordInput
public struct SetSMBGuestPasswordInput {
    /// The Amazon Resource Name (ARN) of the S3 File Gateway the SMB file share is associated with.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The password that you want to set for your SMB server.
    /// This member is required.
    public var password: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.password = password
    }
}

extension SetSMBGuestPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSMBGuestPasswordInput(gatewayARN: \(Swift.String(describing: gatewayARN)), password: \"CONTENT_REDACTED\")"}
}

public struct SetSMBGuestPasswordOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to shut down.
public struct ShutdownGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was shut down.
public struct ShutdownGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct StartAvailabilityMonitorTestInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct StartAvailabilityMonitorTestOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to start.
public struct StartGatewayInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was restarted.
public struct StartGatewayOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateAutomaticTapeCreationPolicyInput {
    /// An automatic tape creation policy consists of a list of automatic tape creation rules. The rules determine when and how to automatically create new tapes.
    /// This member is required.
    public var automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.automaticTapeCreationRules = automaticTapeCreationRules
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateAutomaticTapeCreationPolicyOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [UpdateBandwidthRateLimitInput$AverageDownloadRateLimitInBitsPerSec]
///
/// * [UpdateBandwidthRateLimitInput$AverageUploadRateLimitInBitsPerSec]
public struct UpdateBandwidthRateLimitInput {
    /// The average download bandwidth rate limit in bits per second.
    public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
    /// The average upload bandwidth rate limit in bits per second.
    public var averageUploadRateLimitInBitsPerSec: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
        averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose throttle information was updated.
public struct UpdateBandwidthRateLimitOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateBandwidthRateLimitScheduleInput {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    /// This member is required.
    public var bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateBandwidthRateLimitScheduleOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [UpdateChapCredentialsInput$InitiatorName]
///
/// * [UpdateChapCredentialsInput$SecretToAuthenticateInitiator]
///
/// * [UpdateChapCredentialsInput$SecretToAuthenticateTarget]
///
/// * [UpdateChapCredentialsInput$TargetARN]
public struct UpdateChapCredentialsInput {
    /// The iSCSI initiator that connects to the target.
    /// This member is required.
    public var initiatorName: Swift.String?
    /// The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target. The secret key must be between 12 and 16 bytes when encoded in UTF-8.
    /// This member is required.
    public var secretToAuthenticateInitiator: Swift.String?
    /// The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g. Windows client). Byte constraints: Minimum bytes of 12. Maximum bytes of 16. The secret key must be between 12 and 16 bytes when encoded in UTF-8.
    public var secretToAuthenticateTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return the TargetARN for specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init(
        initiatorName: Swift.String? = nil,
        secretToAuthenticateInitiator: Swift.String? = nil,
        secretToAuthenticateTarget: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
        self.secretToAuthenticateTarget = secretToAuthenticateTarget
        self.targetARN = targetARN
    }
}

extension UpdateChapCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChapCredentialsInput(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)), secretToAuthenticateInitiator: \"CONTENT_REDACTED\", secretToAuthenticateTarget: \"CONTENT_REDACTED\")"}
}

/// A JSON object containing the following fields:
public struct UpdateChapCredentialsOutput {
    /// The iSCSI initiator that connects to the target. This is the same initiator name specified in the request.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the target. This is the same target specified in the request.
    public var targetARN: Swift.String?

    public init(
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

public struct UpdateFileSystemAssociationInput {
    /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
    public var auditDestinationARN: Swift.String?
    /// The refresh cache information for the file share or FSx file systems.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The Amazon Resource Name (ARN) of the file system association that you want to update.
    /// This member is required.
    public var fileSystemAssociationARN: Swift.String?
    /// The password of the user credential.
    public var password: Swift.String?
    /// The user name of the user credential that has permission to access the root share D$ of the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin user group.
    public var userName: Swift.String?

    public init(
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        fileSystemAssociationARN: Swift.String? = nil,
        password: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.password = password
        self.userName = userName
    }
}

extension UpdateFileSystemAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemAssociationInput(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

public struct UpdateFileSystemAssociationOutput {
    /// The ARN of the updated file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init(
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

public struct UpdateGatewayInformationInput {
    /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that you want to use to monitor and log events in the gateway. For more information, see [What is Amazon CloudWatch Logs?](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html)
    public var cloudWatchLogGroupARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies the size of the gateway's metadata cache. This setting impacts gateway performance and hardware recommendations. For more information, see [Performance guidance for gateways with multiple file shares](https://docs.aws.amazon.com/filegateway/latest/files3/performance-multiple-file-shares.html) in the Amazon S3 File Gateway User Guide.
    public var gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?
    /// A value that indicates the time zone of the gateway.
    public var gatewayTimezone: Swift.String?

    public init(
        cloudWatchLogGroupARN: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity? = nil,
        gatewayName: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.gatewayARN = gatewayARN
        self.gatewayCapacity = gatewayCapacity
        self.gatewayName = gatewayName
        self.gatewayTimezone = gatewayTimezone
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was updated.
public struct UpdateGatewayInformationOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.gatewayName = gatewayName
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to update.
public struct UpdateGatewaySoftwareNowInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was updated.
public struct UpdateGatewaySoftwareNowOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing the following fields:
///
/// * [UpdateMaintenanceStartTimeInput$SoftwareUpdatePreferences]
///
/// * [UpdateMaintenanceStartTimeInput$DayOfMonth]
///
/// * [UpdateMaintenanceStartTimeInput$DayOfWeek]
///
/// * [UpdateMaintenanceStartTimeInput$HourOfDay]
///
/// * [UpdateMaintenanceStartTimeInput$MinuteOfHour]
public struct UpdateMaintenanceStartTimeInput {
    /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month. It is not possible to set the maintenance schedule to start on days 29 through 31.
    public var dayOfMonth: Swift.Int?
    /// The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The hour component of the maintenance start time represented as hh, where hh is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
    public var hourOfDay: Swift.Int?
    /// The minute component of the maintenance start time represented as mm, where mm is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
    public var minuteOfHour: Swift.Int?
    /// A set of variables indicating the software update preferences for the gateway. Includes AutomaticUpdatePolicy field with the following inputs: ALL_VERSIONS - Enables regular gateway maintenance updates. EMERGENCY_VERSIONS_ONLY - Disables regular gateway maintenance updates. The gateway will still receive emergency version updates on rare occasions if necessary to remedy highly critical security or durability issues. You will be notified before an emergency version update is applied. These updates are applied during your gateway's scheduled maintenance window.
    public var softwareUpdatePreferences: StorageGatewayClientTypes.SoftwareUpdatePreferences?

    public init(
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil,
        softwareUpdatePreferences: StorageGatewayClientTypes.SoftwareUpdatePreferences? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
        self.softwareUpdatePreferences = softwareUpdatePreferences
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose maintenance start time is updated.
public struct UpdateMaintenanceStartTimeOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// UpdateNFSFileShareInput
public struct UpdateNFSFileShareInput {
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
    public var clientList: [Swift.String]?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
    public var encryptionType: StorageGatewayClientTypes.EncryptionType?
    /// The Amazon Resource Name (ARN) of the file share to be updated.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true. Valid Values: true | false
    @available(*, deprecated, message: "KMSEncrypted is deprecated, use EncryptionType instead.")
    public var kmsEncrypted: Swift.Bool?
    /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
    public var kmsKey: Swift.String?
    /// The default values for the file share. Optional.
    public var nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {\"Upload\": {\"SettlingTimeInSeconds\": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// The user mapped to anonymous user. Valid values are the following:
    ///
    /// * RootSquash: Only root is mapped to anonymous user.
    ///
    /// * NoSquash: No one is mapped to anonymous user.
    ///
    /// * AllSquash: Everyone is mapped to anonymous user.
    public var squash: Swift.String?

    public init(
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientList: [Swift.String]? = nil,
        defaultStorageClass: Swift.String? = nil,
        encryptionType: StorageGatewayClientTypes.EncryptionType? = nil,
        fileShareARN: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        squash: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.defaultStorageClass = defaultStorageClass
        self.encryptionType = encryptionType
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.nfsFileShareDefaults = nfsFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.squash = squash
    }
}

/// UpdateNFSFileShareOutput
public struct UpdateNFSFileShareOutput {
    /// The Amazon Resource Name (ARN) of the updated file share.
    public var fileShareARN: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

/// UpdateSMBFileShareInput
public struct UpdateSMBFileShareInput {
    /// The files and folders on this share will only be visible to users with read access.
    public var accessBasedEnumeration: Swift.Bool?
    /// A list of users or groups in the Active Directory that have administrator rights to the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var adminUserList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
    public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
    public var encryptionType: StorageGatewayClientTypes.EncryptionType?
    /// The Amazon Resource Name (ARN) of the SMB file share that you want to update.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var invalidUserList: [Swift.String]?
    /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead. We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true. Valid Values: true | false
    @available(*, deprecated, message: "KMSEncrypted is deprecated, use EncryptionType instead.")
    public var kmsEncrypted: Swift.Bool?
    /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
    public var kmsKey: Swift.String?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {\"Upload\": {\"SettlingTimeInSeconds\": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// Specifies whether opportunistic locking is enabled for the SMB file share. Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case. Valid Values: true | false
    public var oplocksEnabled: Swift.Bool?
    /// A value that sets the write status of a file share. Set this value to true to set write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// Set this value to true to enable access control list (ACL) on the SMB file share. Set it to false to map file and directory permissions to the POSIX permissions. For more information, see [Using Windows ACLs to limit SMB file share access](https://docs.aws.amazon.com/filegateway/latest/files3/smb-acl.html) in the Amazon S3 File Gateway User Guide. Valid Values: true | false
    public var smbaclEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var validUserList: [Swift.String]?

    public init(
        accessBasedEnumeration: Swift.Bool? = nil,
        adminUserList: [Swift.String]? = nil,
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
        defaultStorageClass: Swift.String? = nil,
        encryptionType: StorageGatewayClientTypes.EncryptionType? = nil,
        fileShareARN: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        invalidUserList: [Swift.String]? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        oplocksEnabled: Swift.Bool? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        smbaclEnabled: Swift.Bool? = nil,
        validUserList: [Swift.String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.defaultStorageClass = defaultStorageClass
        self.encryptionType = encryptionType
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.oplocksEnabled = oplocksEnabled
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.smbaclEnabled = smbaclEnabled
        self.validUserList = validUserList
    }
}

/// UpdateSMBFileShareOutput
public struct UpdateSMBFileShareOutput {
    /// The Amazon Resource Name (ARN) of the updated SMB file share.
    public var fileShareARN: Swift.String?

    public init(
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

public struct UpdateSMBFileShareVisibilityInput {
    /// The shares on this gateway appear when listing shares.
    /// This member is required.
    public var fileSharesVisible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init(
        fileSharesVisible: Swift.Bool? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateSMBFileShareVisibilityOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateSMBLocalGroupsInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A list of Active Directory users and groups that you want to grant special permissions for SMB file shares on the gateway.
    /// This member is required.
    public var smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups?

    public init(
        gatewayARN: Swift.String? = nil,
        smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.smbLocalGroups = smbLocalGroups
    }
}

public struct UpdateSMBLocalGroupsOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

public struct UpdateSMBSecurityStrategyInput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies the type of security strategy. ClientSpecified: If you choose this option, requests are established based on what is negotiated by the client. This option is recommended when you want to maximize compatibility across different clients in your environment. Supported only for S3 File Gateway. MandatorySigning: If you choose this option, File Gateway only allows connections from SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on Microsoft Windows Vista, Windows Server 2008 or newer. MandatoryEncryption: If you choose this option, File Gateway only allows connections from SMBv3 clients that have encryption enabled. This option is recommended for environments that handle sensitive data. This option works with SMB clients on Microsoft Windows 8, Windows Server 2012 or newer. MandatoryEncryptionNoAes128: If you choose this option, File Gateway only allows connections from SMBv3 clients that use 256-bit AES encryption algorithms. 128-bit algorithms are not allowed. This option is recommended for environments that handle sensitive data. It works with SMB clients on Microsoft Windows 8, Windows Server 2012, or later.
    /// This member is required.
    public var smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?

    public init(
        gatewayARN: Swift.String? = nil,
        smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.smbSecurityStrategy = smbSecurityStrategy
    }
}

public struct UpdateSMBSecurityStrategyOutput {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init(
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [UpdateSnapshotScheduleInput$Description]
///
/// * [UpdateSnapshotScheduleInput$RecurrenceInHours]
///
/// * [UpdateSnapshotScheduleInput$StartAt]
///
/// * [UpdateSnapshotScheduleInput$VolumeARN]
public struct UpdateSnapshotScheduleInput {
    /// Optional description of the snapshot that overwrites the existing description.
    public var description: Swift.String?
    /// Frequency of snapshots. Specify the number of hours between snapshots.
    /// This member is required.
    public var recurrenceInHours: Swift.Int?
    /// The hour of the day at which the snapshot schedule begins represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
    /// This member is required.
    public var startAt: Swift.Int?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init(
        description: Swift.String? = nil,
        recurrenceInHours: Swift.Int? = nil,
        startAt: Swift.Int? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the updated storage volume.
public struct UpdateSnapshotScheduleOutput {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    public var volumeARN: Swift.String?

    public init(
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

public struct UpdateVTLDeviceTypeInput {
    /// The type of medium changer you want to select. Valid Values: STK-L700 | AWS-Gateway-VTL | IBM-03584L32-0402
    /// This member is required.
    public var deviceType: Swift.String?
    /// The Amazon Resource Name (ARN) of the medium changer you want to select.
    /// This member is required.
    public var vtlDeviceARN: Swift.String?

    public init(
        deviceType: Swift.String? = nil,
        vtlDeviceARN: Swift.String? = nil
    )
    {
        self.deviceType = deviceType
        self.vtlDeviceARN = vtlDeviceARN
    }
}

/// UpdateVTLDeviceTypeOutput
public struct UpdateVTLDeviceTypeOutput {
    /// The Amazon Resource Name (ARN) of the medium changer you have selected.
    public var vtlDeviceARN: Swift.String?

    public init(
        vtlDeviceARN: Swift.String? = nil
    )
    {
        self.vtlDeviceARN = vtlDeviceARN
    }
}

extension ActivateGatewayInput {

    static func urlPathProvider(_ value: ActivateGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension AddCacheInput {

    static func urlPathProvider(_ value: AddCacheInput) -> Swift.String? {
        return "/"
    }
}

extension AddTagsToResourceInput {

    static func urlPathProvider(_ value: AddTagsToResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AddUploadBufferInput {

    static func urlPathProvider(_ value: AddUploadBufferInput) -> Swift.String? {
        return "/"
    }
}

extension AddWorkingStorageInput {

    static func urlPathProvider(_ value: AddWorkingStorageInput) -> Swift.String? {
        return "/"
    }
}

extension AssignTapePoolInput {

    static func urlPathProvider(_ value: AssignTapePoolInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateFileSystemInput {

    static func urlPathProvider(_ value: AssociateFileSystemInput) -> Swift.String? {
        return "/"
    }
}

extension AttachVolumeInput {

    static func urlPathProvider(_ value: AttachVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CancelArchivalInput {

    static func urlPathProvider(_ value: CancelArchivalInput) -> Swift.String? {
        return "/"
    }
}

extension CancelRetrievalInput {

    static func urlPathProvider(_ value: CancelRetrievalInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCachediSCSIVolumeInput {

    static func urlPathProvider(_ value: CreateCachediSCSIVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNFSFileShareInput {

    static func urlPathProvider(_ value: CreateNFSFileShareInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSMBFileShareInput {

    static func urlPathProvider(_ value: CreateSMBFileShareInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSnapshotInput {

    static func urlPathProvider(_ value: CreateSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSnapshotFromVolumeRecoveryPointInput {

    static func urlPathProvider(_ value: CreateSnapshotFromVolumeRecoveryPointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStorediSCSIVolumeInput {

    static func urlPathProvider(_ value: CreateStorediSCSIVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTapePoolInput {

    static func urlPathProvider(_ value: CreateTapePoolInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTapesInput {

    static func urlPathProvider(_ value: CreateTapesInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTapeWithBarcodeInput {

    static func urlPathProvider(_ value: CreateTapeWithBarcodeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAutomaticTapeCreationPolicyInput {

    static func urlPathProvider(_ value: DeleteAutomaticTapeCreationPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBandwidthRateLimitInput {

    static func urlPathProvider(_ value: DeleteBandwidthRateLimitInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteChapCredentialsInput {

    static func urlPathProvider(_ value: DeleteChapCredentialsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFileShareInput {

    static func urlPathProvider(_ value: DeleteFileShareInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSnapshotScheduleInput {

    static func urlPathProvider(_ value: DeleteSnapshotScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTapeInput {

    static func urlPathProvider(_ value: DeleteTapeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTapeArchiveInput {

    static func urlPathProvider(_ value: DeleteTapeArchiveInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTapePoolInput {

    static func urlPathProvider(_ value: DeleteTapePoolInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVolumeInput {

    static func urlPathProvider(_ value: DeleteVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAvailabilityMonitorTestInput {

    static func urlPathProvider(_ value: DescribeAvailabilityMonitorTestInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBandwidthRateLimitInput {

    static func urlPathProvider(_ value: DescribeBandwidthRateLimitInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBandwidthRateLimitScheduleInput {

    static func urlPathProvider(_ value: DescribeBandwidthRateLimitScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCacheInput {

    static func urlPathProvider(_ value: DescribeCacheInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCachediSCSIVolumesInput {

    static func urlPathProvider(_ value: DescribeCachediSCSIVolumesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeChapCredentialsInput {

    static func urlPathProvider(_ value: DescribeChapCredentialsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFileSystemAssociationsInput {

    static func urlPathProvider(_ value: DescribeFileSystemAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeGatewayInformationInput {

    static func urlPathProvider(_ value: DescribeGatewayInformationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceStartTimeInput {

    static func urlPathProvider(_ value: DescribeMaintenanceStartTimeInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeNFSFileSharesInput {

    static func urlPathProvider(_ value: DescribeNFSFileSharesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSMBFileSharesInput {

    static func urlPathProvider(_ value: DescribeSMBFileSharesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSMBSettingsInput {

    static func urlPathProvider(_ value: DescribeSMBSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSnapshotScheduleInput {

    static func urlPathProvider(_ value: DescribeSnapshotScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStorediSCSIVolumesInput {

    static func urlPathProvider(_ value: DescribeStorediSCSIVolumesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTapeArchivesInput {

    static func urlPathProvider(_ value: DescribeTapeArchivesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTapeRecoveryPointsInput {

    static func urlPathProvider(_ value: DescribeTapeRecoveryPointsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTapesInput {

    static func urlPathProvider(_ value: DescribeTapesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUploadBufferInput {

    static func urlPathProvider(_ value: DescribeUploadBufferInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVTLDevicesInput {

    static func urlPathProvider(_ value: DescribeVTLDevicesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkingStorageInput {

    static func urlPathProvider(_ value: DescribeWorkingStorageInput) -> Swift.String? {
        return "/"
    }
}

extension DetachVolumeInput {

    static func urlPathProvider(_ value: DetachVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension DisableGatewayInput {

    static func urlPathProvider(_ value: DisableGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateFileSystemInput {

    static func urlPathProvider(_ value: DisassociateFileSystemInput) -> Swift.String? {
        return "/"
    }
}

extension JoinDomainInput {

    static func urlPathProvider(_ value: JoinDomainInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomaticTapeCreationPoliciesInput {

    static func urlPathProvider(_ value: ListAutomaticTapeCreationPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListFileSharesInput {

    static func urlPathProvider(_ value: ListFileSharesInput) -> Swift.String? {
        return "/"
    }
}

extension ListFileSystemAssociationsInput {

    static func urlPathProvider(_ value: ListFileSystemAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/"
    }
}

extension ListLocalDisksInput {

    static func urlPathProvider(_ value: ListLocalDisksInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTapePoolsInput {

    static func urlPathProvider(_ value: ListTapePoolsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTapesInput {

    static func urlPathProvider(_ value: ListTapesInput) -> Swift.String? {
        return "/"
    }
}

extension ListVolumeInitiatorsInput {

    static func urlPathProvider(_ value: ListVolumeInitiatorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListVolumeRecoveryPointsInput {

    static func urlPathProvider(_ value: ListVolumeRecoveryPointsInput) -> Swift.String? {
        return "/"
    }
}

extension ListVolumesInput {

    static func urlPathProvider(_ value: ListVolumesInput) -> Swift.String? {
        return "/"
    }
}

extension NotifyWhenUploadedInput {

    static func urlPathProvider(_ value: NotifyWhenUploadedInput) -> Swift.String? {
        return "/"
    }
}

extension RefreshCacheInput {

    static func urlPathProvider(_ value: RefreshCacheInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveTagsFromResourceInput {

    static func urlPathProvider(_ value: RemoveTagsFromResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ResetCacheInput {

    static func urlPathProvider(_ value: ResetCacheInput) -> Swift.String? {
        return "/"
    }
}

extension RetrieveTapeArchiveInput {

    static func urlPathProvider(_ value: RetrieveTapeArchiveInput) -> Swift.String? {
        return "/"
    }
}

extension RetrieveTapeRecoveryPointInput {

    static func urlPathProvider(_ value: RetrieveTapeRecoveryPointInput) -> Swift.String? {
        return "/"
    }
}

extension SetLocalConsolePasswordInput {

    static func urlPathProvider(_ value: SetLocalConsolePasswordInput) -> Swift.String? {
        return "/"
    }
}

extension SetSMBGuestPasswordInput {

    static func urlPathProvider(_ value: SetSMBGuestPasswordInput) -> Swift.String? {
        return "/"
    }
}

extension ShutdownGatewayInput {

    static func urlPathProvider(_ value: ShutdownGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension StartAvailabilityMonitorTestInput {

    static func urlPathProvider(_ value: StartAvailabilityMonitorTestInput) -> Swift.String? {
        return "/"
    }
}

extension StartGatewayInput {

    static func urlPathProvider(_ value: StartGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAutomaticTapeCreationPolicyInput {

    static func urlPathProvider(_ value: UpdateAutomaticTapeCreationPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBandwidthRateLimitInput {

    static func urlPathProvider(_ value: UpdateBandwidthRateLimitInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBandwidthRateLimitScheduleInput {

    static func urlPathProvider(_ value: UpdateBandwidthRateLimitScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateChapCredentialsInput {

    static func urlPathProvider(_ value: UpdateChapCredentialsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFileSystemAssociationInput {

    static func urlPathProvider(_ value: UpdateFileSystemAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewayInformationInput {

    static func urlPathProvider(_ value: UpdateGatewayInformationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewaySoftwareNowInput {

    static func urlPathProvider(_ value: UpdateGatewaySoftwareNowInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMaintenanceStartTimeInput {

    static func urlPathProvider(_ value: UpdateMaintenanceStartTimeInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNFSFileShareInput {

    static func urlPathProvider(_ value: UpdateNFSFileShareInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSMBFileShareInput {

    static func urlPathProvider(_ value: UpdateSMBFileShareInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSMBFileShareVisibilityInput {

    static func urlPathProvider(_ value: UpdateSMBFileShareVisibilityInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSMBLocalGroupsInput {

    static func urlPathProvider(_ value: UpdateSMBLocalGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSMBSecurityStrategyInput {

    static func urlPathProvider(_ value: UpdateSMBSecurityStrategyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSnapshotScheduleInput {

    static func urlPathProvider(_ value: UpdateSnapshotScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVTLDeviceTypeInput {

    static func urlPathProvider(_ value: UpdateVTLDeviceTypeInput) -> Swift.String? {
        return "/"
    }
}

extension ActivateGatewayInput {

    static func write(value: ActivateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivationKey"].write(value.activationKey)
        try writer["GatewayName"].write(value.gatewayName)
        try writer["GatewayRegion"].write(value.gatewayRegion)
        try writer["GatewayTimezone"].write(value.gatewayTimezone)
        try writer["GatewayType"].write(value.gatewayType)
        try writer["MediumChangerType"].write(value.mediumChangerType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TapeDriveType"].write(value.tapeDriveType)
    }
}

extension AddCacheInput {

    static func write(value: AddCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DiskIds"].writeList(value.diskIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension AddTagsToResourceInput {

    static func write(value: AddTagsToResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddUploadBufferInput {

    static func write(value: AddUploadBufferInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DiskIds"].writeList(value.diskIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension AddWorkingStorageInput {

    static func write(value: AddWorkingStorageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DiskIds"].writeList(value.diskIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension AssignTapePoolInput {

    static func write(value: AssignTapePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BypassGovernanceRetention"].write(value.bypassGovernanceRetention)
        try writer["PoolId"].write(value.poolId)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension AssociateFileSystemInput {

    static func write(value: AssociateFileSystemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditDestinationARN"].write(value.auditDestinationARN)
        try writer["CacheAttributes"].write(value.cacheAttributes, with: StorageGatewayClientTypes.CacheAttributes.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["EndpointNetworkConfiguration"].write(value.endpointNetworkConfiguration, with: StorageGatewayClientTypes.EndpointNetworkConfiguration.write(value:to:))
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["LocationARN"].write(value.locationARN)
        try writer["Password"].write(value.password)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
    }
}

extension AttachVolumeInput {

    static func write(value: AttachVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DiskId"].write(value.diskId)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["TargetName"].write(value.targetName)
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension CancelArchivalInput {

    static func write(value: CancelArchivalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension CancelRetrievalInput {

    static func write(value: CancelRetrievalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension CreateCachediSCSIVolumeInput {

    static func write(value: CreateCachediSCSIVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["SourceVolumeARN"].write(value.sourceVolumeARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetName"].write(value.targetName)
        try writer["VolumeSizeInBytes"].write(value.volumeSizeInBytes)
    }
}

extension CreateNFSFileShareInput {

    static func write(value: CreateNFSFileShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditDestinationARN"].write(value.auditDestinationARN)
        try writer["BucketRegion"].write(value.bucketRegion)
        try writer["CacheAttributes"].write(value.cacheAttributes, with: StorageGatewayClientTypes.CacheAttributes.write(value:to:))
        try writer["ClientList"].writeList(value.clientList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["DefaultStorageClass"].write(value.defaultStorageClass)
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["FileShareName"].write(value.fileShareName)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["GuessMIMETypeEnabled"].write(value.guessMIMETypeEnabled)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["LocationARN"].write(value.locationARN)
        try writer["NFSFileShareDefaults"].write(value.nfsFileShareDefaults, with: StorageGatewayClientTypes.NFSFileShareDefaults.write(value:to:))
        try writer["NotificationPolicy"].write(value.notificationPolicy)
        try writer["ObjectACL"].write(value.objectACL)
        try writer["ReadOnly"].write(value.readOnly)
        try writer["RequesterPays"].write(value.requesterPays)
        try writer["Role"].write(value.role)
        try writer["Squash"].write(value.squash)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCEndpointDNSName"].write(value.vpcEndpointDNSName)
    }
}

extension CreateSMBFileShareInput {

    static func write(value: CreateSMBFileShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessBasedEnumeration"].write(value.accessBasedEnumeration)
        try writer["AdminUserList"].writeList(value.adminUserList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AuditDestinationARN"].write(value.auditDestinationARN)
        try writer["Authentication"].write(value.authentication)
        try writer["BucketRegion"].write(value.bucketRegion)
        try writer["CacheAttributes"].write(value.cacheAttributes, with: StorageGatewayClientTypes.CacheAttributes.write(value:to:))
        try writer["CaseSensitivity"].write(value.caseSensitivity)
        try writer["ClientToken"].write(value.clientToken)
        try writer["DefaultStorageClass"].write(value.defaultStorageClass)
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["FileShareName"].write(value.fileShareName)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["GuessMIMETypeEnabled"].write(value.guessMIMETypeEnabled)
        try writer["InvalidUserList"].writeList(value.invalidUserList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["LocationARN"].write(value.locationARN)
        try writer["NotificationPolicy"].write(value.notificationPolicy)
        try writer["ObjectACL"].write(value.objectACL)
        try writer["OplocksEnabled"].write(value.oplocksEnabled)
        try writer["ReadOnly"].write(value.readOnly)
        try writer["RequesterPays"].write(value.requesterPays)
        try writer["Role"].write(value.role)
        try writer["SMBACLEnabled"].write(value.smbaclEnabled)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCEndpointDNSName"].write(value.vpcEndpointDNSName)
        try writer["ValidUserList"].writeList(value.validUserList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSnapshotInput {

    static func write(value: CreateSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapshotDescription"].write(value.snapshotDescription)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension CreateSnapshotFromVolumeRecoveryPointInput {

    static func write(value: CreateSnapshotFromVolumeRecoveryPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapshotDescription"].write(value.snapshotDescription)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension CreateStorediSCSIVolumeInput {

    static func write(value: CreateStorediSCSIVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DiskId"].write(value.diskId)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["PreserveExistingData"].write(value.preserveExistingData)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetName"].write(value.targetName)
    }
}

extension CreateTapePoolInput {

    static func write(value: CreateTapePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PoolName"].write(value.poolName)
        try writer["RetentionLockTimeInDays"].write(value.retentionLockTimeInDays)
        try writer["RetentionLockType"].write(value.retentionLockType)
        try writer["StorageClass"].write(value.storageClass)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTapesInput {

    static func write(value: CreateTapesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["NumTapesToCreate"].write(value.numTapesToCreate)
        try writer["PoolId"].write(value.poolId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TapeBarcodePrefix"].write(value.tapeBarcodePrefix)
        try writer["TapeSizeInBytes"].write(value.tapeSizeInBytes)
        try writer["Worm"].write(value.worm)
    }
}

extension CreateTapeWithBarcodeInput {

    static func write(value: CreateTapeWithBarcodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["PoolId"].write(value.poolId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TapeBarcode"].write(value.tapeBarcode)
        try writer["TapeSizeInBytes"].write(value.tapeSizeInBytes)
        try writer["Worm"].write(value.worm)
    }
}

extension DeleteAutomaticTapeCreationPolicyInput {

    static func write(value: DeleteAutomaticTapeCreationPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DeleteBandwidthRateLimitInput {

    static func write(value: DeleteBandwidthRateLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BandwidthType"].write(value.bandwidthType)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DeleteChapCredentialsInput {

    static func write(value: DeleteChapCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitiatorName"].write(value.initiatorName)
        try writer["TargetARN"].write(value.targetARN)
    }
}

extension DeleteFileShareInput {

    static func write(value: DeleteFileShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileShareARN"].write(value.fileShareARN)
        try writer["ForceDelete"].write(value.forceDelete)
    }
}

extension DeleteGatewayInput {

    static func write(value: DeleteGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DeleteSnapshotScheduleInput {

    static func write(value: DeleteSnapshotScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension DeleteTapeInput {

    static func write(value: DeleteTapeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BypassGovernanceRetention"].write(value.bypassGovernanceRetention)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension DeleteTapeArchiveInput {

    static func write(value: DeleteTapeArchiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BypassGovernanceRetention"].write(value.bypassGovernanceRetention)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension DeleteTapePoolInput {

    static func write(value: DeleteTapePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PoolARN"].write(value.poolARN)
    }
}

extension DeleteVolumeInput {

    static func write(value: DeleteVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension DescribeAvailabilityMonitorTestInput {

    static func write(value: DescribeAvailabilityMonitorTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeBandwidthRateLimitInput {

    static func write(value: DescribeBandwidthRateLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeBandwidthRateLimitScheduleInput {

    static func write(value: DescribeBandwidthRateLimitScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeCacheInput {

    static func write(value: DescribeCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeCachediSCSIVolumesInput {

    static func write(value: DescribeCachediSCSIVolumesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeARNs"].writeList(value.volumeARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeChapCredentialsInput {

    static func write(value: DescribeChapCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetARN"].write(value.targetARN)
    }
}

extension DescribeFileSystemAssociationsInput {

    static func write(value: DescribeFileSystemAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileSystemAssociationARNList"].writeList(value.fileSystemAssociationARNList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeGatewayInformationInput {

    static func write(value: DescribeGatewayInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeMaintenanceStartTimeInput {

    static func write(value: DescribeMaintenanceStartTimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeNFSFileSharesInput {

    static func write(value: DescribeNFSFileSharesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileShareARNList"].writeList(value.fileShareARNList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSMBFileSharesInput {

    static func write(value: DescribeSMBFileSharesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileShareARNList"].writeList(value.fileShareARNList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSMBSettingsInput {

    static func write(value: DescribeSMBSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeSnapshotScheduleInput {

    static func write(value: DescribeSnapshotScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension DescribeStorediSCSIVolumesInput {

    static func write(value: DescribeStorediSCSIVolumesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeARNs"].writeList(value.volumeARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeTapeArchivesInput {

    static func write(value: DescribeTapeArchivesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["TapeARNs"].writeList(value.tapeARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeTapeRecoveryPointsInput {

    static func write(value: DescribeTapeRecoveryPointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
    }
}

extension DescribeTapesInput {

    static func write(value: DescribeTapesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["TapeARNs"].writeList(value.tapeARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeUploadBufferInput {

    static func write(value: DescribeUploadBufferInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DescribeVTLDevicesInput {

    static func write(value: DescribeVTLDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["VTLDeviceARNs"].writeList(value.vtlDeviceARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeWorkingStorageInput {

    static func write(value: DescribeWorkingStorageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DetachVolumeInput {

    static func write(value: DetachVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForceDetach"].write(value.forceDetach)
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension DisableGatewayInput {

    static func write(value: DisableGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension DisassociateFileSystemInput {

    static func write(value: DisassociateFileSystemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileSystemAssociationARN"].write(value.fileSystemAssociationARN)
        try writer["ForceDelete"].write(value.forceDelete)
    }
}

extension JoinDomainInput {

    static func write(value: JoinDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainControllers"].writeList(value.domainControllers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DomainName"].write(value.domainName)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["OrganizationalUnit"].write(value.organizationalUnit)
        try writer["Password"].write(value.password)
        try writer["TimeoutInSeconds"].write(value.timeoutInSeconds)
        try writer["UserName"].write(value.userName)
    }
}

extension ListAutomaticTapeCreationPoliciesInput {

    static func write(value: ListAutomaticTapeCreationPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension ListFileSharesInput {

    static func write(value: ListFileSharesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
    }
}

extension ListFileSystemAssociationsInput {

    static func write(value: ListFileSystemAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
    }
}

extension ListGatewaysInput {

    static func write(value: ListGatewaysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
    }
}

extension ListLocalDisksInput {

    static func write(value: ListLocalDisksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ListTapePoolsInput {

    static func write(value: ListTapePoolsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["PoolARNs"].writeList(value.poolARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTapesInput {

    static func write(value: ListTapesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["TapeARNs"].writeList(value.tapeARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListVolumeInitiatorsInput {

    static func write(value: ListVolumeInitiatorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension ListVolumeRecoveryPointsInput {

    static func write(value: ListVolumeRecoveryPointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension ListVolumesInput {

    static func write(value: ListVolumesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
    }
}

extension NotifyWhenUploadedInput {

    static func write(value: NotifyWhenUploadedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileShareARN"].write(value.fileShareARN)
    }
}

extension RefreshCacheInput {

    static func write(value: RefreshCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileShareARN"].write(value.fileShareARN)
        try writer["FolderList"].writeList(value.folderList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Recursive"].write(value.recursive)
    }
}

extension RemoveTagsFromResourceInput {

    static func write(value: RemoveTagsFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ResetCacheInput {

    static func write(value: ResetCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension RetrieveTapeArchiveInput {

    static func write(value: RetrieveTapeArchiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension RetrieveTapeRecoveryPointInput {

    static func write(value: RetrieveTapeRecoveryPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["TapeARN"].write(value.tapeARN)
    }
}

extension SetLocalConsolePasswordInput {

    static func write(value: SetLocalConsolePasswordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["LocalConsolePassword"].write(value.localConsolePassword)
    }
}

extension SetSMBGuestPasswordInput {

    static func write(value: SetSMBGuestPasswordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["Password"].write(value.password)
    }
}

extension ShutdownGatewayInput {

    static func write(value: ShutdownGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension StartAvailabilityMonitorTestInput {

    static func write(value: StartAvailabilityMonitorTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension StartGatewayInput {

    static func write(value: StartGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension UpdateAutomaticTapeCreationPolicyInput {

    static func write(value: UpdateAutomaticTapeCreationPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomaticTapeCreationRules"].writeList(value.automaticTapeCreationRules, memberWritingClosure: StorageGatewayClientTypes.AutomaticTapeCreationRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension UpdateBandwidthRateLimitInput {

    static func write(value: UpdateBandwidthRateLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AverageDownloadRateLimitInBitsPerSec"].write(value.averageDownloadRateLimitInBitsPerSec)
        try writer["AverageUploadRateLimitInBitsPerSec"].write(value.averageUploadRateLimitInBitsPerSec)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension UpdateBandwidthRateLimitScheduleInput {

    static func write(value: UpdateBandwidthRateLimitScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BandwidthRateLimitIntervals"].writeList(value.bandwidthRateLimitIntervals, memberWritingClosure: StorageGatewayClientTypes.BandwidthRateLimitInterval.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension UpdateChapCredentialsInput {

    static func write(value: UpdateChapCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitiatorName"].write(value.initiatorName)
        try writer["SecretToAuthenticateInitiator"].write(value.secretToAuthenticateInitiator)
        try writer["SecretToAuthenticateTarget"].write(value.secretToAuthenticateTarget)
        try writer["TargetARN"].write(value.targetARN)
    }
}

extension UpdateFileSystemAssociationInput {

    static func write(value: UpdateFileSystemAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditDestinationARN"].write(value.auditDestinationARN)
        try writer["CacheAttributes"].write(value.cacheAttributes, with: StorageGatewayClientTypes.CacheAttributes.write(value:to:))
        try writer["FileSystemAssociationARN"].write(value.fileSystemAssociationARN)
        try writer["Password"].write(value.password)
        try writer["UserName"].write(value.userName)
    }
}

extension UpdateGatewayInformationInput {

    static func write(value: UpdateGatewayInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogGroupARN"].write(value.cloudWatchLogGroupARN)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["GatewayCapacity"].write(value.gatewayCapacity)
        try writer["GatewayName"].write(value.gatewayName)
        try writer["GatewayTimezone"].write(value.gatewayTimezone)
    }
}

extension UpdateGatewaySoftwareNowInput {

    static func write(value: UpdateGatewaySoftwareNowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension UpdateMaintenanceStartTimeInput {

    static func write(value: UpdateMaintenanceStartTimeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfMonth"].write(value.dayOfMonth)
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["HourOfDay"].write(value.hourOfDay)
        try writer["MinuteOfHour"].write(value.minuteOfHour)
        try writer["SoftwareUpdatePreferences"].write(value.softwareUpdatePreferences, with: StorageGatewayClientTypes.SoftwareUpdatePreferences.write(value:to:))
    }
}

extension UpdateNFSFileShareInput {

    static func write(value: UpdateNFSFileShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditDestinationARN"].write(value.auditDestinationARN)
        try writer["CacheAttributes"].write(value.cacheAttributes, with: StorageGatewayClientTypes.CacheAttributes.write(value:to:))
        try writer["ClientList"].writeList(value.clientList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DefaultStorageClass"].write(value.defaultStorageClass)
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["FileShareARN"].write(value.fileShareARN)
        try writer["FileShareName"].write(value.fileShareName)
        try writer["GuessMIMETypeEnabled"].write(value.guessMIMETypeEnabled)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["NFSFileShareDefaults"].write(value.nfsFileShareDefaults, with: StorageGatewayClientTypes.NFSFileShareDefaults.write(value:to:))
        try writer["NotificationPolicy"].write(value.notificationPolicy)
        try writer["ObjectACL"].write(value.objectACL)
        try writer["ReadOnly"].write(value.readOnly)
        try writer["RequesterPays"].write(value.requesterPays)
        try writer["Squash"].write(value.squash)
    }
}

extension UpdateSMBFileShareInput {

    static func write(value: UpdateSMBFileShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessBasedEnumeration"].write(value.accessBasedEnumeration)
        try writer["AdminUserList"].writeList(value.adminUserList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AuditDestinationARN"].write(value.auditDestinationARN)
        try writer["CacheAttributes"].write(value.cacheAttributes, with: StorageGatewayClientTypes.CacheAttributes.write(value:to:))
        try writer["CaseSensitivity"].write(value.caseSensitivity)
        try writer["DefaultStorageClass"].write(value.defaultStorageClass)
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["FileShareARN"].write(value.fileShareARN)
        try writer["FileShareName"].write(value.fileShareName)
        try writer["GuessMIMETypeEnabled"].write(value.guessMIMETypeEnabled)
        try writer["InvalidUserList"].writeList(value.invalidUserList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KMSEncrypted"].write(value.kmsEncrypted)
        try writer["KMSKey"].write(value.kmsKey)
        try writer["NotificationPolicy"].write(value.notificationPolicy)
        try writer["ObjectACL"].write(value.objectACL)
        try writer["OplocksEnabled"].write(value.oplocksEnabled)
        try writer["ReadOnly"].write(value.readOnly)
        try writer["RequesterPays"].write(value.requesterPays)
        try writer["SMBACLEnabled"].write(value.smbaclEnabled)
        try writer["ValidUserList"].writeList(value.validUserList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateSMBFileShareVisibilityInput {

    static func write(value: UpdateSMBFileShareVisibilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileSharesVisible"].write(value.fileSharesVisible)
        try writer["GatewayARN"].write(value.gatewayARN)
    }
}

extension UpdateSMBLocalGroupsInput {

    static func write(value: UpdateSMBLocalGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["SMBLocalGroups"].write(value.smbLocalGroups, with: StorageGatewayClientTypes.SMBLocalGroups.write(value:to:))
    }
}

extension UpdateSMBSecurityStrategyInput {

    static func write(value: UpdateSMBSecurityStrategyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayARN"].write(value.gatewayARN)
        try writer["SMBSecurityStrategy"].write(value.smbSecurityStrategy)
    }
}

extension UpdateSnapshotScheduleInput {

    static func write(value: UpdateSnapshotScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["RecurrenceInHours"].write(value.recurrenceInHours)
        try writer["StartAt"].write(value.startAt)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: StorageGatewayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VolumeARN"].write(value.volumeARN)
    }
}

extension UpdateVTLDeviceTypeInput {

    static func write(value: UpdateVTLDeviceTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceType"].write(value.deviceType)
        try writer["VTLDeviceARN"].write(value.vtlDeviceARN)
    }
}

extension ActivateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ActivateGatewayOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension AddCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddCacheOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension AddTagsToResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddTagsToResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddTagsToResourceOutput()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        return value
    }
}

extension AddUploadBufferOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddUploadBufferOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddUploadBufferOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension AddWorkingStorageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddWorkingStorageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddWorkingStorageOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension AssignTapePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssignTapePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssignTapePoolOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension AssociateFileSystemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateFileSystemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateFileSystemOutput()
        value.fileSystemAssociationARN = try reader["FileSystemAssociationARN"].readIfPresent()
        return value
    }
}

extension AttachVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AttachVolumeOutput()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension CancelArchivalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelArchivalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelArchivalOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension CancelRetrievalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelRetrievalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelRetrievalOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension CreateCachediSCSIVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCachediSCSIVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCachediSCSIVolumeOutput()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension CreateNFSFileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNFSFileShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNFSFileShareOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        return value
    }
}

extension CreateSMBFileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSMBFileShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSMBFileShareOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        return value
    }
}

extension CreateSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSnapshotOutput()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSnapshotFromVolumeRecoveryPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSnapshotFromVolumeRecoveryPointOutput()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        value.volumeRecoveryPointTime = try reader["VolumeRecoveryPointTime"].readIfPresent()
        return value
    }
}

extension CreateStorediSCSIVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStorediSCSIVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStorediSCSIVolumeOutput()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        value.volumeSizeInBytes = try reader["VolumeSizeInBytes"].readIfPresent() ?? 0
        return value
    }
}

extension CreateTapePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTapePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTapePoolOutput()
        value.poolARN = try reader["PoolARN"].readIfPresent()
        return value
    }
}

extension CreateTapesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTapesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTapesOutput()
        value.tapeARNs = try reader["TapeARNs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateTapeWithBarcodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTapeWithBarcodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTapeWithBarcodeOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension DeleteAutomaticTapeCreationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAutomaticTapeCreationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAutomaticTapeCreationPolicyOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DeleteBandwidthRateLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBandwidthRateLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBandwidthRateLimitOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DeleteChapCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChapCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteChapCredentialsOutput()
        value.initiatorName = try reader["InitiatorName"].readIfPresent()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        return value
    }
}

extension DeleteFileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFileShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFileShareOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        return value
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DeleteSnapshotScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSnapshotScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSnapshotScheduleOutput()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension DeleteTapeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTapeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTapeOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension DeleteTapeArchiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTapeArchiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTapeArchiveOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension DeleteTapePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTapePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTapePoolOutput()
        value.poolARN = try reader["PoolARN"].readIfPresent()
        return value
    }
}

extension DeleteVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVolumeOutput()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension DescribeAvailabilityMonitorTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAvailabilityMonitorTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAvailabilityMonitorTestOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeBandwidthRateLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBandwidthRateLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBandwidthRateLimitOutput()
        value.averageDownloadRateLimitInBitsPerSec = try reader["AverageDownloadRateLimitInBitsPerSec"].readIfPresent()
        value.averageUploadRateLimitInBitsPerSec = try reader["AverageUploadRateLimitInBitsPerSec"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DescribeBandwidthRateLimitScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBandwidthRateLimitScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBandwidthRateLimitScheduleOutput()
        value.bandwidthRateLimitIntervals = try reader["BandwidthRateLimitIntervals"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.BandwidthRateLimitInterval.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DescribeCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCacheOutput()
        value.cacheAllocatedInBytes = try reader["CacheAllocatedInBytes"].readIfPresent() ?? 0
        value.cacheDirtyPercentage = try reader["CacheDirtyPercentage"].readIfPresent() ?? 0
        value.cacheHitPercentage = try reader["CacheHitPercentage"].readIfPresent() ?? 0
        value.cacheMissPercentage = try reader["CacheMissPercentage"].readIfPresent() ?? 0
        value.cacheUsedPercentage = try reader["CacheUsedPercentage"].readIfPresent() ?? 0
        value.diskIds = try reader["DiskIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DescribeCachediSCSIVolumesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCachediSCSIVolumesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCachediSCSIVolumesOutput()
        value.cachediSCSIVolumes = try reader["CachediSCSIVolumes"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.CachediSCSIVolume.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeChapCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChapCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChapCredentialsOutput()
        value.chapCredentials = try reader["ChapCredentials"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.ChapInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeFileSystemAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFileSystemAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFileSystemAssociationsOutput()
        value.fileSystemAssociationInfoList = try reader["FileSystemAssociationInfoList"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.FileSystemAssociationInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeGatewayInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayInformationOutput()
        value.cloudWatchLogGroupARN = try reader["CloudWatchLogGroupARN"].readIfPresent()
        value.deprecationDate = try reader["DeprecationDate"].readIfPresent()
        value.ec2InstanceId = try reader["Ec2InstanceId"].readIfPresent()
        value.ec2InstanceRegion = try reader["Ec2InstanceRegion"].readIfPresent()
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.gatewayCapacity = try reader["GatewayCapacity"].readIfPresent()
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        value.gatewayName = try reader["GatewayName"].readIfPresent()
        value.gatewayNetworkInterfaces = try reader["GatewayNetworkInterfaces"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayState = try reader["GatewayState"].readIfPresent()
        value.gatewayTimezone = try reader["GatewayTimezone"].readIfPresent()
        value.gatewayType = try reader["GatewayType"].readIfPresent()
        value.hostEnvironment = try reader["HostEnvironment"].readIfPresent()
        value.hostEnvironmentId = try reader["HostEnvironmentId"].readIfPresent()
        value.lastSoftwareUpdate = try reader["LastSoftwareUpdate"].readIfPresent()
        value.nextUpdateAvailabilityDate = try reader["NextUpdateAvailabilityDate"].readIfPresent()
        value.softwareUpdatesEndDate = try reader["SoftwareUpdatesEndDate"].readIfPresent()
        value.softwareVersion = try reader["SoftwareVersion"].readIfPresent()
        value.supportedGatewayCapacities = try reader["SupportedGatewayCapacities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<StorageGatewayClientTypes.GatewayCapacity>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcEndpoint = try reader["VPCEndpoint"].readIfPresent()
        return value
    }
}

extension DescribeMaintenanceStartTimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceStartTimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceStartTimeOutput()
        value.dayOfMonth = try reader["DayOfMonth"].readIfPresent()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.hourOfDay = try reader["HourOfDay"].readIfPresent()
        value.minuteOfHour = try reader["MinuteOfHour"].readIfPresent()
        value.softwareUpdatePreferences = try reader["SoftwareUpdatePreferences"].readIfPresent(with: StorageGatewayClientTypes.SoftwareUpdatePreferences.read(from:))
        value.timezone = try reader["Timezone"].readIfPresent()
        return value
    }
}

extension DescribeNFSFileSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNFSFileSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNFSFileSharesOutput()
        value.nfsFileShareInfoList = try reader["NFSFileShareInfoList"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.NFSFileShareInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSMBFileSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSMBFileSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSMBFileSharesOutput()
        value.smbFileShareInfoList = try reader["SMBFileShareInfoList"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.SMBFileShareInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSMBSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSMBSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSMBSettingsOutput()
        value.activeDirectoryStatus = try reader["ActiveDirectoryStatus"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.fileSharesVisible = try reader["FileSharesVisible"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.smbGuestPasswordSet = try reader["SMBGuestPasswordSet"].readIfPresent()
        value.smbLocalGroups = try reader["SMBLocalGroups"].readIfPresent(with: StorageGatewayClientTypes.SMBLocalGroups.read(from:))
        value.smbSecurityStrategy = try reader["SMBSecurityStrategy"].readIfPresent()
        return value
    }
}

extension DescribeSnapshotScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSnapshotScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSnapshotScheduleOutput()
        value.description = try reader["Description"].readIfPresent()
        value.recurrenceInHours = try reader["RecurrenceInHours"].readIfPresent()
        value.startAt = try reader["StartAt"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timezone = try reader["Timezone"].readIfPresent()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension DescribeStorediSCSIVolumesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStorediSCSIVolumesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStorediSCSIVolumesOutput()
        value.storediSCSIVolumes = try reader["StorediSCSIVolumes"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.StorediSCSIVolume.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTapeArchivesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTapeArchivesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTapeArchivesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.tapeArchives = try reader["TapeArchives"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.TapeArchive.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTapeRecoveryPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTapeRecoveryPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTapeRecoveryPointsOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.marker = try reader["Marker"].readIfPresent()
        value.tapeRecoveryPointInfos = try reader["TapeRecoveryPointInfos"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.TapeRecoveryPointInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTapesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTapesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTapesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.tapes = try reader["Tapes"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tape.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeUploadBufferOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUploadBufferOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUploadBufferOutput()
        value.diskIds = try reader["DiskIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.uploadBufferAllocatedInBytes = try reader["UploadBufferAllocatedInBytes"].readIfPresent() ?? 0
        value.uploadBufferUsedInBytes = try reader["UploadBufferUsedInBytes"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeVTLDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVTLDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVTLDevicesOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.marker = try reader["Marker"].readIfPresent()
        value.vtlDevices = try reader["VTLDevices"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.VTLDevice.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkingStorageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkingStorageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkingStorageOutput()
        value.diskIds = try reader["DiskIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.workingStorageAllocatedInBytes = try reader["WorkingStorageAllocatedInBytes"].readIfPresent() ?? 0
        value.workingStorageUsedInBytes = try reader["WorkingStorageUsedInBytes"].readIfPresent() ?? 0
        return value
    }
}

extension DetachVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetachVolumeOutput()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension DisableGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableGatewayOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension DisassociateFileSystemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFileSystemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateFileSystemOutput()
        value.fileSystemAssociationARN = try reader["FileSystemAssociationARN"].readIfPresent()
        return value
    }
}

extension JoinDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> JoinDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = JoinDomainOutput()
        value.activeDirectoryStatus = try reader["ActiveDirectoryStatus"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension ListAutomaticTapeCreationPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomaticTapeCreationPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomaticTapeCreationPoliciesOutput()
        value.automaticTapeCreationPolicyInfos = try reader["AutomaticTapeCreationPolicyInfos"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListFileSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFileSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFileSharesOutput()
        value.fileShareInfoList = try reader["FileShareInfoList"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.FileShareInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFileSystemAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFileSystemAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFileSystemAssociationsOutput()
        value.fileSystemAssociationSummaryList = try reader["FileSystemAssociationSummaryList"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.FileSystemAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gateways = try reader["Gateways"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.GatewayInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension ListLocalDisksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLocalDisksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLocalDisksOutput()
        value.disks = try reader["Disks"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Disk.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTapePoolsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTapePoolsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTapePoolsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.poolInfos = try reader["PoolInfos"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.PoolInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTapesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTapesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTapesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.tapeInfos = try reader["TapeInfos"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.TapeInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVolumeInitiatorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVolumeInitiatorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVolumeInitiatorsOutput()
        value.initiators = try reader["Initiators"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVolumeRecoveryPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVolumeRecoveryPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVolumeRecoveryPointsOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.volumeRecoveryPointInfos = try reader["VolumeRecoveryPointInfos"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.VolumeRecoveryPointInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVolumesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVolumesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVolumesOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.marker = try reader["Marker"].readIfPresent()
        value.volumeInfos = try reader["VolumeInfos"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.VolumeInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NotifyWhenUploadedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyWhenUploadedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = NotifyWhenUploadedOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        value.notificationId = try reader["NotificationId"].readIfPresent()
        return value
    }
}

extension RefreshCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RefreshCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RefreshCacheOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        value.notificationId = try reader["NotificationId"].readIfPresent()
        return value
    }
}

extension RemoveTagsFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTagsFromResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveTagsFromResourceOutput()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        return value
    }
}

extension ResetCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetCacheOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension RetrieveTapeArchiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveTapeArchiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveTapeArchiveOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension RetrieveTapeRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveTapeRecoveryPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveTapeRecoveryPointOutput()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        return value
    }
}

extension SetLocalConsolePasswordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetLocalConsolePasswordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetLocalConsolePasswordOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension SetSMBGuestPasswordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetSMBGuestPasswordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetSMBGuestPasswordOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension ShutdownGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ShutdownGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ShutdownGatewayOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension StartAvailabilityMonitorTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAvailabilityMonitorTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAvailabilityMonitorTestOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension StartGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartGatewayOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateAutomaticTapeCreationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutomaticTapeCreationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAutomaticTapeCreationPolicyOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateBandwidthRateLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBandwidthRateLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBandwidthRateLimitOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateBandwidthRateLimitScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBandwidthRateLimitScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBandwidthRateLimitScheduleOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateChapCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChapCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChapCredentialsOutput()
        value.initiatorName = try reader["InitiatorName"].readIfPresent()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        return value
    }
}

extension UpdateFileSystemAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFileSystemAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFileSystemAssociationOutput()
        value.fileSystemAssociationARN = try reader["FileSystemAssociationARN"].readIfPresent()
        return value
    }
}

extension UpdateGatewayInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayInformationOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.gatewayName = try reader["GatewayName"].readIfPresent()
        return value
    }
}

extension UpdateGatewaySoftwareNowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewaySoftwareNowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewaySoftwareNowOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateMaintenanceStartTimeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMaintenanceStartTimeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMaintenanceStartTimeOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateNFSFileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNFSFileShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNFSFileShareOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        return value
    }
}

extension UpdateSMBFileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSMBFileShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSMBFileShareOutput()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        return value
    }
}

extension UpdateSMBFileShareVisibilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSMBFileShareVisibilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSMBFileShareVisibilityOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateSMBLocalGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSMBLocalGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSMBLocalGroupsOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateSMBSecurityStrategyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSMBSecurityStrategyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSMBSecurityStrategyOutput()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension UpdateSnapshotScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSnapshotScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSnapshotScheduleOutput()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        return value
    }
}

extension UpdateVTLDeviceTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVTLDeviceTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVTLDeviceTypeOutput()
        value.vtlDeviceARN = try reader["VTLDeviceARN"].readIfPresent()
        return value
    }
}

enum ActivateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddTagsToResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddUploadBufferOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddWorkingStorageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssignTapePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateFileSystemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelArchivalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelRetrievalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCachediSCSIVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNFSFileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSMBFileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSnapshotFromVolumeRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStorediSCSIVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTapePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTapesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTapeWithBarcodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAutomaticTapeCreationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBandwidthRateLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChapCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSnapshotScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTapeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTapeArchiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTapePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAvailabilityMonitorTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBandwidthRateLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBandwidthRateLimitScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCachediSCSIVolumesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChapCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFileSystemAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceStartTimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNFSFileSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSMBFileSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSMBSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSnapshotScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStorediSCSIVolumesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTapeArchivesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTapeRecoveryPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTapesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUploadBufferOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVTLDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkingStorageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFileSystemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum JoinDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomaticTapeCreationPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFileSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFileSystemAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLocalDisksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTapePoolsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTapesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVolumeInitiatorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVolumeRecoveryPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVolumesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyWhenUploadedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RefreshCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTagsFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveTapeArchiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveTapeRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetLocalConsolePasswordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetSMBGuestPasswordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ShutdownGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAvailabilityMonitorTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutomaticTapeCreationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBandwidthRateLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBandwidthRateLimitScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChapCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFileSystemAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewaySoftwareNowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMaintenanceStartTimeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNFSFileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSMBFileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSMBFileShareVisibilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSMBLocalGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSMBSecurityStrategyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSnapshotScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVTLDeviceTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidGatewayRequestException": return try InvalidGatewayRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerError {
        let reader = baseError.errorBodyReader
        var value = InternalServerError()
        value.properties.error = try reader["error"].readIfPresent(with: StorageGatewayClientTypes.StorageGatewayError.read(from:))
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidGatewayRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidGatewayRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidGatewayRequestException()
        value.properties.error = try reader["error"].readIfPresent(with: StorageGatewayClientTypes.StorageGatewayError.read(from:))
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceUnavailableError {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableError()
        value.properties.error = try reader["error"].readIfPresent(with: StorageGatewayClientTypes.StorageGatewayError.read(from:))
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StorageGatewayClientTypes.BandwidthRateLimitInterval {

    static func write(value: StorageGatewayClientTypes.BandwidthRateLimitInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AverageDownloadRateLimitInBitsPerSec"].write(value.averageDownloadRateLimitInBitsPerSec)
        try writer["AverageUploadRateLimitInBitsPerSec"].write(value.averageUploadRateLimitInBitsPerSec)
        try writer["DaysOfWeek"].writeList(value.daysOfWeek, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndHourOfDay"].write(value.endHourOfDay)
        try writer["EndMinuteOfHour"].write(value.endMinuteOfHour)
        try writer["StartHourOfDay"].write(value.startHourOfDay)
        try writer["StartMinuteOfHour"].write(value.startMinuteOfHour)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.BandwidthRateLimitInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.BandwidthRateLimitInterval()
        value.startHourOfDay = try reader["StartHourOfDay"].readIfPresent() ?? 0
        value.startMinuteOfHour = try reader["StartMinuteOfHour"].readIfPresent() ?? 0
        value.endHourOfDay = try reader["EndHourOfDay"].readIfPresent() ?? 0
        value.endMinuteOfHour = try reader["EndMinuteOfHour"].readIfPresent() ?? 0
        value.daysOfWeek = try reader["DaysOfWeek"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.averageUploadRateLimitInBitsPerSec = try reader["AverageUploadRateLimitInBitsPerSec"].readIfPresent()
        value.averageDownloadRateLimitInBitsPerSec = try reader["AverageDownloadRateLimitInBitsPerSec"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.CachediSCSIVolume {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.CachediSCSIVolume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.CachediSCSIVolume()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.volumeStatus = try reader["VolumeStatus"].readIfPresent()
        value.volumeAttachmentStatus = try reader["VolumeAttachmentStatus"].readIfPresent()
        value.volumeSizeInBytes = try reader["VolumeSizeInBytes"].readIfPresent() ?? 0
        value.volumeProgress = try reader["VolumeProgress"].readIfPresent()
        value.sourceSnapshotId = try reader["SourceSnapshotId"].readIfPresent()
        value.volumeiSCSIAttributes = try reader["VolumeiSCSIAttributes"].readIfPresent(with: StorageGatewayClientTypes.VolumeiSCSIAttributes.read(from:))
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.volumeUsedInBytes = try reader["VolumeUsedInBytes"].readIfPresent()
        value.kmsKey = try reader["KMSKey"].readIfPresent()
        value.targetName = try reader["TargetName"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.VolumeiSCSIAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.VolumeiSCSIAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.VolumeiSCSIAttributes()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.networkInterfacePort = try reader["NetworkInterfacePort"].readIfPresent() ?? 0
        value.lunNumber = try reader["LunNumber"].readIfPresent()
        value.chapEnabled = try reader["ChapEnabled"].readIfPresent() ?? false
        return value
    }
}

extension StorageGatewayClientTypes.ChapInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.ChapInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.ChapInfo()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        value.secretToAuthenticateInitiator = try reader["SecretToAuthenticateInitiator"].readIfPresent()
        value.initiatorName = try reader["InitiatorName"].readIfPresent()
        value.secretToAuthenticateTarget = try reader["SecretToAuthenticateTarget"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.FileSystemAssociationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.FileSystemAssociationInfo()
        value.fileSystemAssociationARN = try reader["FileSystemAssociationARN"].readIfPresent()
        value.locationARN = try reader["LocationARN"].readIfPresent()
        value.fileSystemAssociationStatus = try reader["FileSystemAssociationStatus"].readIfPresent()
        value.auditDestinationARN = try reader["AuditDestinationARN"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cacheAttributes = try reader["CacheAttributes"].readIfPresent(with: StorageGatewayClientTypes.CacheAttributes.read(from:))
        value.endpointNetworkConfiguration = try reader["EndpointNetworkConfiguration"].readIfPresent(with: StorageGatewayClientTypes.EndpointNetworkConfiguration.read(from:))
        value.fileSystemAssociationStatusDetails = try reader["FileSystemAssociationStatusDetails"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.FileSystemAssociationStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.FileSystemAssociationStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.FileSystemAssociationStatusDetail()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.EndpointNetworkConfiguration {

    static func write(value: StorageGatewayClientTypes.EndpointNetworkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpAddresses"].writeList(value.ipAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.EndpointNetworkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.EndpointNetworkConfiguration()
        value.ipAddresses = try reader["IpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StorageGatewayClientTypes.CacheAttributes {

    static func write(value: StorageGatewayClientTypes.CacheAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CacheStaleTimeoutInSeconds"].write(value.cacheStaleTimeoutInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.CacheAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.CacheAttributes()
        value.cacheStaleTimeoutInSeconds = try reader["CacheStaleTimeoutInSeconds"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.Tag {

    static func write(value: StorageGatewayClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension StorageGatewayClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.NetworkInterface()
        value.ipv4Address = try reader["Ipv4Address"].readIfPresent()
        value.macAddress = try reader["MacAddress"].readIfPresent()
        value.ipv6Address = try reader["Ipv6Address"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.SoftwareUpdatePreferences {

    static func write(value: StorageGatewayClientTypes.SoftwareUpdatePreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomaticUpdatePolicy"].write(value.automaticUpdatePolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.SoftwareUpdatePreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.SoftwareUpdatePreferences()
        value.automaticUpdatePolicy = try reader["AutomaticUpdatePolicy"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.NFSFileShareInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.NFSFileShareInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.NFSFileShareInfo()
        value.nfsFileShareDefaults = try reader["NFSFileShareDefaults"].readIfPresent(with: StorageGatewayClientTypes.NFSFileShareDefaults.read(from:))
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        value.fileShareId = try reader["FileShareId"].readIfPresent()
        value.fileShareStatus = try reader["FileShareStatus"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.encryptionType = try reader["EncryptionType"].readIfPresent()
        value.kmsEncrypted = try reader["KMSEncrypted"].readIfPresent() ?? false
        value.kmsKey = try reader["KMSKey"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.locationARN = try reader["LocationARN"].readIfPresent()
        value.defaultStorageClass = try reader["DefaultStorageClass"].readIfPresent()
        value.objectACL = try reader["ObjectACL"].readIfPresent()
        value.clientList = try reader["ClientList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.squash = try reader["Squash"].readIfPresent()
        value.readOnly = try reader["ReadOnly"].readIfPresent()
        value.guessMIMETypeEnabled = try reader["GuessMIMETypeEnabled"].readIfPresent()
        value.requesterPays = try reader["RequesterPays"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fileShareName = try reader["FileShareName"].readIfPresent()
        value.cacheAttributes = try reader["CacheAttributes"].readIfPresent(with: StorageGatewayClientTypes.CacheAttributes.read(from:))
        value.notificationPolicy = try reader["NotificationPolicy"].readIfPresent()
        value.vpcEndpointDNSName = try reader["VPCEndpointDNSName"].readIfPresent()
        value.bucketRegion = try reader["BucketRegion"].readIfPresent()
        value.auditDestinationARN = try reader["AuditDestinationARN"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.NFSFileShareDefaults {

    static func write(value: StorageGatewayClientTypes.NFSFileShareDefaults?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryMode"].write(value.directoryMode)
        try writer["FileMode"].write(value.fileMode)
        try writer["GroupId"].write(value.groupId)
        try writer["OwnerId"].write(value.ownerId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.NFSFileShareDefaults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.NFSFileShareDefaults()
        value.fileMode = try reader["FileMode"].readIfPresent()
        value.directoryMode = try reader["DirectoryMode"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.SMBFileShareInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.SMBFileShareInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.SMBFileShareInfo()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        value.fileShareId = try reader["FileShareId"].readIfPresent()
        value.fileShareStatus = try reader["FileShareStatus"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.encryptionType = try reader["EncryptionType"].readIfPresent()
        value.kmsEncrypted = try reader["KMSEncrypted"].readIfPresent() ?? false
        value.kmsKey = try reader["KMSKey"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.locationARN = try reader["LocationARN"].readIfPresent()
        value.defaultStorageClass = try reader["DefaultStorageClass"].readIfPresent()
        value.objectACL = try reader["ObjectACL"].readIfPresent()
        value.readOnly = try reader["ReadOnly"].readIfPresent()
        value.guessMIMETypeEnabled = try reader["GuessMIMETypeEnabled"].readIfPresent()
        value.requesterPays = try reader["RequesterPays"].readIfPresent()
        value.smbaclEnabled = try reader["SMBACLEnabled"].readIfPresent()
        value.accessBasedEnumeration = try reader["AccessBasedEnumeration"].readIfPresent()
        value.adminUserList = try reader["AdminUserList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.validUserList = try reader["ValidUserList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.invalidUserList = try reader["InvalidUserList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.auditDestinationARN = try reader["AuditDestinationARN"].readIfPresent()
        value.authentication = try reader["Authentication"].readIfPresent()
        value.caseSensitivity = try reader["CaseSensitivity"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fileShareName = try reader["FileShareName"].readIfPresent()
        value.cacheAttributes = try reader["CacheAttributes"].readIfPresent(with: StorageGatewayClientTypes.CacheAttributes.read(from:))
        value.notificationPolicy = try reader["NotificationPolicy"].readIfPresent()
        value.vpcEndpointDNSName = try reader["VPCEndpointDNSName"].readIfPresent()
        value.bucketRegion = try reader["BucketRegion"].readIfPresent()
        value.oplocksEnabled = try reader["OplocksEnabled"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.SMBLocalGroups {

    static func write(value: StorageGatewayClientTypes.SMBLocalGroups?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayAdmins"].writeList(value.gatewayAdmins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.SMBLocalGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.SMBLocalGroups()
        value.gatewayAdmins = try reader["GatewayAdmins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StorageGatewayClientTypes.StorediSCSIVolume {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.StorediSCSIVolume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.StorediSCSIVolume()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.volumeStatus = try reader["VolumeStatus"].readIfPresent()
        value.volumeAttachmentStatus = try reader["VolumeAttachmentStatus"].readIfPresent()
        value.volumeSizeInBytes = try reader["VolumeSizeInBytes"].readIfPresent() ?? 0
        value.volumeProgress = try reader["VolumeProgress"].readIfPresent()
        value.volumeDiskId = try reader["VolumeDiskId"].readIfPresent()
        value.sourceSnapshotId = try reader["SourceSnapshotId"].readIfPresent()
        value.preservedExistingData = try reader["PreservedExistingData"].readIfPresent() ?? false
        value.volumeiSCSIAttributes = try reader["VolumeiSCSIAttributes"].readIfPresent(with: StorageGatewayClientTypes.VolumeiSCSIAttributes.read(from:))
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.volumeUsedInBytes = try reader["VolumeUsedInBytes"].readIfPresent()
        value.kmsKey = try reader["KMSKey"].readIfPresent()
        value.targetName = try reader["TargetName"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.TapeArchive {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.TapeArchive {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.TapeArchive()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        value.tapeBarcode = try reader["TapeBarcode"].readIfPresent()
        value.tapeCreatedDate = try reader["TapeCreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tapeSizeInBytes = try reader["TapeSizeInBytes"].readIfPresent()
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.retrievedTo = try reader["RetrievedTo"].readIfPresent()
        value.tapeStatus = try reader["TapeStatus"].readIfPresent()
        value.tapeUsedInBytes = try reader["TapeUsedInBytes"].readIfPresent()
        value.kmsKey = try reader["KMSKey"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.worm = try reader["Worm"].readIfPresent() ?? false
        value.retentionStartDate = try reader["RetentionStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.poolEntryDate = try reader["PoolEntryDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StorageGatewayClientTypes.TapeRecoveryPointInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.TapeRecoveryPointInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.TapeRecoveryPointInfo()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        value.tapeRecoveryPointTime = try reader["TapeRecoveryPointTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tapeSizeInBytes = try reader["TapeSizeInBytes"].readIfPresent()
        value.tapeStatus = try reader["TapeStatus"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.Tape {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.Tape {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.Tape()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        value.tapeBarcode = try reader["TapeBarcode"].readIfPresent()
        value.tapeCreatedDate = try reader["TapeCreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tapeSizeInBytes = try reader["TapeSizeInBytes"].readIfPresent()
        value.tapeStatus = try reader["TapeStatus"].readIfPresent()
        value.vtlDevice = try reader["VTLDevice"].readIfPresent()
        value.progress = try reader["Progress"].readIfPresent()
        value.tapeUsedInBytes = try reader["TapeUsedInBytes"].readIfPresent()
        value.kmsKey = try reader["KMSKey"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.worm = try reader["Worm"].readIfPresent() ?? false
        value.retentionStartDate = try reader["RetentionStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.poolEntryDate = try reader["PoolEntryDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StorageGatewayClientTypes.VTLDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.VTLDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.VTLDevice()
        value.vtlDeviceARN = try reader["VTLDeviceARN"].readIfPresent()
        value.vtlDeviceType = try reader["VTLDeviceType"].readIfPresent()
        value.vtlDeviceVendor = try reader["VTLDeviceVendor"].readIfPresent()
        value.vtlDeviceProductIdentifier = try reader["VTLDeviceProductIdentifier"].readIfPresent()
        value.deviceiSCSIAttributes = try reader["DeviceiSCSIAttributes"].readIfPresent(with: StorageGatewayClientTypes.DeviceiSCSIAttributes.read(from:))
        return value
    }
}

extension StorageGatewayClientTypes.DeviceiSCSIAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.DeviceiSCSIAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.DeviceiSCSIAttributes()
        value.targetARN = try reader["TargetARN"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.networkInterfacePort = try reader["NetworkInterfacePort"].readIfPresent() ?? 0
        value.chapEnabled = try reader["ChapEnabled"].readIfPresent() ?? false
        return value
    }
}

extension StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo()
        value.automaticTapeCreationRules = try reader["AutomaticTapeCreationRules"].readListIfPresent(memberReadingClosure: StorageGatewayClientTypes.AutomaticTapeCreationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.AutomaticTapeCreationRule {

    static func write(value: StorageGatewayClientTypes.AutomaticTapeCreationRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MinimumNumTapes"].write(value.minimumNumTapes)
        try writer["PoolId"].write(value.poolId)
        try writer["TapeBarcodePrefix"].write(value.tapeBarcodePrefix)
        try writer["TapeSizeInBytes"].write(value.tapeSizeInBytes)
        try writer["Worm"].write(value.worm)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.AutomaticTapeCreationRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.AutomaticTapeCreationRule()
        value.tapeBarcodePrefix = try reader["TapeBarcodePrefix"].readIfPresent() ?? ""
        value.poolId = try reader["PoolId"].readIfPresent() ?? ""
        value.tapeSizeInBytes = try reader["TapeSizeInBytes"].readIfPresent() ?? 0
        value.minimumNumTapes = try reader["MinimumNumTapes"].readIfPresent() ?? 0
        value.worm = try reader["Worm"].readIfPresent() ?? false
        return value
    }
}

extension StorageGatewayClientTypes.FileShareInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.FileShareInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.FileShareInfo()
        value.fileShareType = try reader["FileShareType"].readIfPresent()
        value.fileShareARN = try reader["FileShareARN"].readIfPresent()
        value.fileShareId = try reader["FileShareId"].readIfPresent()
        value.fileShareStatus = try reader["FileShareStatus"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.FileSystemAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.FileSystemAssociationSummary()
        value.fileSystemAssociationId = try reader["FileSystemAssociationId"].readIfPresent()
        value.fileSystemAssociationARN = try reader["FileSystemAssociationARN"].readIfPresent()
        value.fileSystemAssociationStatus = try reader["FileSystemAssociationStatus"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.GatewayInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.GatewayInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.GatewayInfo()
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.gatewayType = try reader["GatewayType"].readIfPresent()
        value.gatewayOperationalState = try reader["GatewayOperationalState"].readIfPresent()
        value.gatewayName = try reader["GatewayName"].readIfPresent()
        value.ec2InstanceId = try reader["Ec2InstanceId"].readIfPresent()
        value.ec2InstanceRegion = try reader["Ec2InstanceRegion"].readIfPresent()
        value.hostEnvironment = try reader["HostEnvironment"].readIfPresent()
        value.hostEnvironmentId = try reader["HostEnvironmentId"].readIfPresent()
        value.deprecationDate = try reader["DeprecationDate"].readIfPresent()
        value.softwareVersion = try reader["SoftwareVersion"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.Disk {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.Disk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.Disk()
        value.diskId = try reader["DiskId"].readIfPresent()
        value.diskPath = try reader["DiskPath"].readIfPresent()
        value.diskNode = try reader["DiskNode"].readIfPresent()
        value.diskStatus = try reader["DiskStatus"].readIfPresent()
        value.diskSizeInBytes = try reader["DiskSizeInBytes"].readIfPresent() ?? 0
        value.diskAllocationType = try reader["DiskAllocationType"].readIfPresent()
        value.diskAllocationResource = try reader["DiskAllocationResource"].readIfPresent()
        value.diskAttributeList = try reader["DiskAttributeList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StorageGatewayClientTypes.PoolInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.PoolInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.PoolInfo()
        value.poolARN = try reader["PoolARN"].readIfPresent()
        value.poolName = try reader["PoolName"].readIfPresent()
        value.storageClass = try reader["StorageClass"].readIfPresent()
        value.retentionLockType = try reader["RetentionLockType"].readIfPresent()
        value.retentionLockTimeInDays = try reader["RetentionLockTimeInDays"].readIfPresent()
        value.poolStatus = try reader["PoolStatus"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.TapeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.TapeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.TapeInfo()
        value.tapeARN = try reader["TapeARN"].readIfPresent()
        value.tapeBarcode = try reader["TapeBarcode"].readIfPresent()
        value.tapeSizeInBytes = try reader["TapeSizeInBytes"].readIfPresent()
        value.tapeStatus = try reader["TapeStatus"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.retentionStartDate = try reader["RetentionStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.poolEntryDate = try reader["PoolEntryDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StorageGatewayClientTypes.VolumeRecoveryPointInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.VolumeRecoveryPointInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.VolumeRecoveryPointInfo()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        value.volumeSizeInBytes = try reader["VolumeSizeInBytes"].readIfPresent() ?? 0
        value.volumeUsageInBytes = try reader["VolumeUsageInBytes"].readIfPresent() ?? 0
        value.volumeRecoveryPointTime = try reader["VolumeRecoveryPointTime"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.VolumeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.VolumeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.VolumeInfo()
        value.volumeARN = try reader["VolumeARN"].readIfPresent()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        value.gatewayARN = try reader["GatewayARN"].readIfPresent()
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.volumeSizeInBytes = try reader["VolumeSizeInBytes"].readIfPresent() ?? 0
        value.volumeAttachmentStatus = try reader["VolumeAttachmentStatus"].readIfPresent()
        return value
    }
}

extension StorageGatewayClientTypes.StorageGatewayError {

    static func read(from reader: SmithyJSON.Reader) throws -> StorageGatewayClientTypes.StorageGatewayError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = StorageGatewayClientTypes.StorageGatewayError()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorDetails = try reader["errorDetails"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public enum StorageGatewayClientTypes {}
