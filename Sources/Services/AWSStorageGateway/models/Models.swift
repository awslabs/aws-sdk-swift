// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActivateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayName = "GatewayName"
        case gatewayRegion = "GatewayRegion"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case mediumChangerType = "MediumChangerType"
        case tags = "Tags"
        case tapeDriveType = "TapeDriveType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationKey = self.activationKey {
            try encodeContainer.encode(activationKey, forKey: .activationKey)
        }
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayRegion = self.gatewayRegion {
            try encodeContainer.encode(gatewayRegion, forKey: .gatewayRegion)
        }
        if let gatewayTimezone = self.gatewayTimezone {
            try encodeContainer.encode(gatewayTimezone, forKey: .gatewayTimezone)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType, forKey: .gatewayType)
        }
        if let mediumChangerType = self.mediumChangerType {
            try encodeContainer.encode(mediumChangerType, forKey: .mediumChangerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tapeDriveType = self.tapeDriveType {
            try encodeContainer.encode(tapeDriveType, forKey: .tapeDriveType)
        }
    }
}

extension ActivateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [ActivateGatewayInput$ActivationKey]
///
/// * [ActivateGatewayInput$GatewayName]
///
/// * [ActivateGatewayInput$GatewayRegion]
///
/// * [ActivateGatewayInput$GatewayTimezone]
///
/// * [ActivateGatewayInput$GatewayType]
///
/// * [ActivateGatewayInput$MediumChangerType]
///
/// * [ActivateGatewayInput$TapeDriveType]
public struct ActivateGatewayInput: Swift.Equatable {
    /// Your gateway activation key. You can obtain the activation key by sending an HTTP GET request with redirects enabled to the gateway IP address (port 80). The redirect URL returned in the response provides you the activation key for your gateway in the query string parameter activationKey. It may also include other activation-related parameters, however, these are merely defaults -- the arguments you pass to the ActivateGateway API call determine the actual configuration of your gateway. For more information, see [Getting activation key](https://docs.aws.amazon.com/storagegateway/latest/userguide/get-activation-key.html) in the Storage Gateway User Guide.
    /// This member is required.
    public var activationKey: Swift.String?
    /// The name you configured for your gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// A value that indicates the Amazon Web Services Region where you want to store your data. The gateway Amazon Web Services Region specified must be the same Amazon Web Services Region as the Amazon Web Services Region in your Host header in the request. For more information about available Amazon Web Services Regions and endpoints for Storage Gateway, see [ Storage Gateway endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/sg.html) in the Amazon Web Services General Reference. Valid Values: See [ Storage Gateway endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/sg.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var gatewayRegion: Swift.String?
    /// A value that indicates the time zone you want to set for the gateway. The time zone is of the format "GMT-hr:mm" or "GMT+hr:mm". For example, GMT-4:00 indicates the time is 4 hours behind GMT. GMT+2:00 indicates the time is 2 hours ahead of GMT. The time zone is used, for example, for scheduling snapshots and your gateway's maintenance schedule.
    /// This member is required.
    public var gatewayTimezone: Swift.String?
    /// A value that defines the type of gateway to activate. The type specified is critical to all later functions of the gateway and cannot be changed after activation. The default value is CACHED. Valid Values: STORED | CACHED | VTL | VTL_SNOW | FILE_S3 | FILE_FSX_SMB
    public var gatewayType: Swift.String?
    /// The value that indicates the type of medium changer to use for tape gateway. This field is optional. Valid Values: STK-L700 | AWS-Gateway-VTL | IBM-03584L32-0402
    public var mediumChangerType: Swift.String?
    /// A list of up to 50 tags that you can assign to the gateway. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers that can be represented in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256 characters.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The value that indicates the type of tape drive to use for tape gateway. This field is optional. Valid Values: IBM-ULT3580-TD5
    public var tapeDriveType: Swift.String?

    public init (
        activationKey: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayRegion: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil,
        gatewayType: Swift.String? = nil,
        mediumChangerType: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeDriveType: Swift.String? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayName = gatewayName
        self.gatewayRegion = gatewayRegion
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.mediumChangerType = mediumChangerType
        self.tags = tags
        self.tapeDriveType = tapeDriveType
    }
}

struct ActivateGatewayInputBody: Swift.Equatable {
    let activationKey: Swift.String?
    let gatewayName: Swift.String?
    let gatewayTimezone: Swift.String?
    let gatewayRegion: Swift.String?
    let gatewayType: Swift.String?
    let tapeDriveType: Swift.String?
    let mediumChangerType: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension ActivateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationKey = "ActivationKey"
        case gatewayName = "GatewayName"
        case gatewayRegion = "GatewayRegion"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case mediumChangerType = "MediumChangerType"
        case tags = "Tags"
        case tapeDriveType = "TapeDriveType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationKey)
        activationKey = activationKeyDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let gatewayRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayRegion)
        gatewayRegion = gatewayRegionDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let tapeDriveTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeDriveType)
        tapeDriveType = tapeDriveTypeDecoded
        let mediumChangerTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediumChangerType)
        mediumChangerType = mediumChangerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ActivateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ActivateGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ActivateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// Storage Gateway returns the Amazon Resource Name (ARN) of the activated gateway. It is a string made of information such as your account, gateway name, and Amazon Web Services Region. This ARN is used to reference the gateway in other API operations as well as resource-based authorization. For gateways activated prior to September 02, 2015, the gateway ARN contains the gateway name rather than the gateway ID. Changing the name of the gateway has no effect on the gateway ARN.
public struct ActivateGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ActivateGatewayOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ActivateGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    public enum ActiveDirectoryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case detached
        case joined
        case joining
        case networkError
        case timeout
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveDirectoryStatus] {
            return [
                .accessDenied,
                .detached,
                .joined,
                .joining,
                .networkError,
                .timeout,
                .unknownError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .detached: return "DETACHED"
            case .joined: return "JOINED"
            case .joining: return "JOINING"
            case .networkError: return "NETWORK_ERROR"
            case .timeout: return "TIMEOUT"
            case .unknownError: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActiveDirectoryStatus(rawValue: rawValue) ?? ActiveDirectoryStatus.sdkUnknown(rawValue)
        }
    }
}

extension AddCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskid0 in diskIds {
                try diskIdsContainer.encode(diskid0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension AddCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddCacheInput: Swift.Equatable {
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddCacheInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskIds: [Swift.String]?
}

extension AddCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct AddCacheOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddCacheOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension AddCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// AddTagsToResourceInput
public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value pair that represents the tag you want to add to the resource. The value can be an empty string. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    /// This member is required.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

/// AddTagsToResourceOutput
public struct AddTagsToResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension AddUploadBufferInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskid0 in diskIds {
                try diskIdsContainer.encode(diskid0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension AddUploadBufferInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddUploadBufferInput: Swift.Equatable {
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddUploadBufferInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskIds: [Swift.String]?
}

extension AddUploadBufferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddUploadBufferOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddUploadBufferOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddUploadBufferOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddUploadBufferOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddUploadBufferOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct AddUploadBufferOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddUploadBufferOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension AddUploadBufferOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension AddWorkingStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskid0 in diskIds {
                try diskIdsContainer.encode(diskid0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension AddWorkingStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [AddWorkingStorageInput$DiskIds]
public struct AddWorkingStorageInput: Swift.Equatable {
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    /// This member is required.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddWorkingStorageInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskIds: [Swift.String]?
}

extension AddWorkingStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddWorkingStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddWorkingStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddWorkingStorageOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddWorkingStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddWorkingStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway for which working storage was configured.
public struct AddWorkingStorageOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddWorkingStorageOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension AddWorkingStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension AssignTapePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case poolId = "PoolId"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension AssignTapePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssignTapePoolInput: Swift.Equatable {
    /// Set permissions to bypass governance retention. If the lock type of the archived tape is Governance, the tape's archived age is not older than RetentionLockInDays, and the user does not already have BypassGovernanceRetention, setting this to TRUE enables the user to bypass the retention lock. This parameter is set to true by default for calls from the console. Valid values: TRUE | FALSE
    public var bypassGovernanceRetention: Swift.Bool
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    /// This member is required.
    public var poolId: Swift.String?
    /// The unique Amazon Resource Name (ARN) of the virtual tape that you want to add to the tape pool.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        bypassGovernanceRetention: Swift.Bool = false,
        poolId: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.poolId = poolId
        self.tapeARN = tapeARN
    }
}

struct AssignTapePoolInputBody: Swift.Equatable {
    let tapeARN: Swift.String?
    let poolId: Swift.String?
    let bypassGovernanceRetention: Swift.Bool
}

extension AssignTapePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case poolId = "PoolId"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassGovernanceRetention) ?? false
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension AssignTapePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignTapePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssignTapePoolOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignTapePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssignTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

public struct AssignTapePoolOutputResponse: Swift.Equatable {
    /// The unique Amazon Resource Names (ARN) of the virtual tape that was added to the tape pool.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct AssignTapePoolOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension AssignTapePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension AssociateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFileSystemInput(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), clientToken: \(Swift.String(describing: clientToken)), endpointNetworkConfiguration: \(Swift.String(describing: endpointNetworkConfiguration)), gatewayARN: \(Swift.String(describing: gatewayARN)), locationARN: \(Swift.String(describing: locationARN)), tags: \(Swift.String(describing: tags)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension AssociateFileSystemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientToken = "ClientToken"
        case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case password = "Password"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let endpointNetworkConfiguration = self.endpointNetworkConfiguration {
            try encodeContainer.encode(endpointNetworkConfiguration, forKey: .endpointNetworkConfiguration)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let locationARN = self.locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension AssociateFileSystemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateFileSystemInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
    public var auditDestinationARN: Swift.String?
    /// The refresh cache information for the file share or FSx file systems.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// A unique string value that you supply that is used by the FSx File Gateway to ensure idempotent file system association creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Specifies the network configuration information for the gateway associated with the Amazon FSx file system. If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
    public var endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon FSx file system to associate with the FSx File Gateway.
    /// This member is required.
    public var locationARN: Swift.String?
    /// The password of the user credential.
    /// This member is required.
    public var password: Swift.String?
    /// A list of up to 50 tags that can be assigned to the file system association. Each tag is a key-value pair.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The user name of the user credential that has permission to access the root share D$ of the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin user group.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientToken: Swift.String? = nil,
        endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration? = nil,
        gatewayARN: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        password: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.clientToken = clientToken
        self.endpointNetworkConfiguration = endpointNetworkConfiguration
        self.gatewayARN = gatewayARN
        self.locationARN = locationARN
        self.password = password
        self.tags = tags
        self.userName = userName
    }
}

struct AssociateFileSystemInputBody: Swift.Equatable {
    let userName: Swift.String?
    let password: Swift.String?
    let clientToken: Swift.String?
    let gatewayARN: Swift.String?
    let locationARN: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
    let auditDestinationARN: Swift.String?
    let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    let endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
}

extension AssociateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientToken = "ClientToken"
        case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case password = "Password"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let endpointNetworkConfigurationDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.EndpointNetworkConfiguration.self, forKey: .endpointNetworkConfiguration)
        endpointNetworkConfiguration = endpointNetworkConfigurationDecoded
    }
}

extension AssociateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct AssociateFileSystemOutputResponse: Swift.Equatable {
    /// The ARN of the newly created file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init (
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct AssociateFileSystemOutputResponseBody: Swift.Equatable {
    let fileSystemAssociationARN: Swift.String?
}

extension AssociateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

extension AttachVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case networkInterfaceId = "NetworkInterfaceId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskId = self.diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension AttachVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// AttachVolumeInput
public struct AttachVolumeInput: Swift.Equatable {
    /// The unique device ID or other distinguishing data that identifies the local disk used to create the volume. This value is only required when you are attaching a stored volume.
    public var diskId: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway that you want to attach the volume to.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use [DescribeGatewayInformation] to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
    public var targetName: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume to attach to the specified gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        diskId: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        targetName: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.networkInterfaceId = networkInterfaceId
        self.targetName = targetName
        self.volumeARN = volumeARN
    }
}

struct AttachVolumeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let targetName: Swift.String?
    let volumeARN: Swift.String?
    let networkInterfaceId: Swift.String?
    let diskId: Swift.String?
}

extension AttachVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case networkInterfaceId = "NetworkInterfaceId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let diskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskId)
        diskId = diskIdDecoded
    }
}

extension AttachVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AttachVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AttachVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
        } else {
            self.targetARN = nil
            self.volumeARN = nil
        }
    }
}

/// AttachVolumeOutput
public struct AttachVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name for the initiator that was used to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume that was attached to the gateway.
    public var volumeARN: Swift.String?

    public init (
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

struct AttachVolumeOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let targetARN: Swift.String?
}

extension AttachVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTapeCreationRules = automaticTapeCreationRules {
            var automaticTapeCreationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automaticTapeCreationRules)
            for automatictapecreationrule0 in automaticTapeCreationRules {
                try automaticTapeCreationRulesContainer.encode(automatictapecreationrule0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationRulesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.AutomaticTapeCreationRule?].self, forKey: .automaticTapeCreationRules)
        var automaticTapeCreationRulesDecoded0:[StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil
        if let automaticTapeCreationRulesContainer = automaticTapeCreationRulesContainer {
            automaticTapeCreationRulesDecoded0 = [StorageGatewayClientTypes.AutomaticTapeCreationRule]()
            for structure0 in automaticTapeCreationRulesContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationRulesDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationRules = automaticTapeCreationRulesDecoded0
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Information about the gateway's automatic tape creation policies, including the automatic tape creation rules and the gateway that is using the policies.
    public struct AutomaticTapeCreationPolicyInfo: Swift.Equatable {
        /// An automatic tape creation policy consists of a list of automatic tape creation rules. This returns the rules that determine when and how to automatically create new tapes.
        public var automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?

        public init (
            automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.automaticTapeCreationRules = automaticTapeCreationRules
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes.AutomaticTapeCreationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minimumNumTapes = "MinimumNumTapes"
        case poolId = "PoolId"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minimumNumTapes = self.minimumNumTapes {
            try encodeContainer.encode(minimumNumTapes, forKey: .minimumNumTapes)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tapeBarcodePrefix = self.tapeBarcodePrefix {
            try encodeContainer.encode(tapeBarcodePrefix, forKey: .tapeBarcodePrefix)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeBarcodePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcodePrefix)
        tapeBarcodePrefix = tapeBarcodePrefixDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let minimumNumTapesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumNumTapes)
        minimumNumTapes = minimumNumTapesDecoded
        let wormDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .worm) ?? false
        worm = wormDecoded
    }
}

extension StorageGatewayClientTypes {
    /// An automatic tape creation policy consists of automatic tape creation rules where each rule defines when and how to create new tapes. For more information about automatic tape creation, see [Creating Tapes Automatically](https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically).
    public struct AutomaticTapeCreationRule: Swift.Equatable {
        /// The minimum number of available virtual tapes that the gateway maintains at all times. If the number of tapes on the gateway goes below this value, the gateway creates as many new tapes as are needed to have MinimumNumTapes on the gateway. For more information about automatic tape creation, see [Creating Tapes Automatically](https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically).
        /// This member is required.
        public var minimumNumTapes: Swift.Int?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the Amazon S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// A prefix that you append to the barcode of the virtual tape that you are creating. This prefix makes the barcode unique. The prefix must be 1-4 characters in length and must be one of the uppercase letters from A to Z.
        /// This member is required.
        public var tapeBarcodePrefix: Swift.String?
        /// The size, in bytes, of the virtual tape capacity.
        /// This member is required.
        public var tapeSizeInBytes: Swift.Int?
        /// Set to true to indicate that tapes are to be archived as write-once-read-many (WORM). Set to false when WORM is not enabled for tapes.
        public var worm: Swift.Bool

        public init (
            minimumNumTapes: Swift.Int? = nil,
            poolId: Swift.String? = nil,
            tapeBarcodePrefix: Swift.String? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            worm: Swift.Bool = false
        )
        {
            self.minimumNumTapes = minimumNumTapes
            self.poolId = poolId
            self.tapeBarcodePrefix = tapeBarcodePrefix
            self.tapeSizeInBytes = tapeSizeInBytes
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes {
    public enum AvailabilityMonitorTestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityMonitorTestStatus] {
            return [
                .complete,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AvailabilityMonitorTestStatus(rawValue: rawValue) ?? AvailabilityMonitorTestStatus.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.BandwidthRateLimitInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case daysOfWeek = "DaysOfWeek"
        case endHourOfDay = "EndHourOfDay"
        case endMinuteOfHour = "EndMinuteOfHour"
        case startHourOfDay = "StartHourOfDay"
        case startMinuteOfHour = "StartMinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageDownloadRateLimitInBitsPerSec = self.averageDownloadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageDownloadRateLimitInBitsPerSec, forKey: .averageDownloadRateLimitInBitsPerSec)
        }
        if let averageUploadRateLimitInBitsPerSec = self.averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let daysOfWeek = daysOfWeek {
            var daysOfWeekContainer = encodeContainer.nestedUnkeyedContainer(forKey: .daysOfWeek)
            for dayofweek0 in daysOfWeek {
                try daysOfWeekContainer.encode(dayofweek0)
            }
        }
        if let endHourOfDay = self.endHourOfDay {
            try encodeContainer.encode(endHourOfDay, forKey: .endHourOfDay)
        }
        if let endMinuteOfHour = self.endMinuteOfHour {
            try encodeContainer.encode(endMinuteOfHour, forKey: .endMinuteOfHour)
        }
        if let startHourOfDay = self.startHourOfDay {
            try encodeContainer.encode(startHourOfDay, forKey: .startHourOfDay)
        }
        if let startMinuteOfHour = self.startMinuteOfHour {
            try encodeContainer.encode(startMinuteOfHour, forKey: .startMinuteOfHour)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startHourOfDay)
        startHourOfDay = startHourOfDayDecoded
        let startMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startMinuteOfHour)
        startMinuteOfHour = startMinuteOfHourDecoded
        let endHourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endHourOfDay)
        endHourOfDay = endHourOfDayDecoded
        let endMinuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endMinuteOfHour)
        endMinuteOfHour = endMinuteOfHourDecoded
        let daysOfWeekContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .daysOfWeek)
        var daysOfWeekDecoded0:[Swift.Int]? = nil
        if let daysOfWeekContainer = daysOfWeekContainer {
            daysOfWeekDecoded0 = [Swift.Int]()
            for integer0 in daysOfWeekContainer {
                if let integer0 = integer0 {
                    daysOfWeekDecoded0?.append(integer0)
                }
            }
        }
        daysOfWeek = daysOfWeekDecoded0
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a bandwidth rate limit interval for a gateway. A bandwidth rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit interval defines a period of time on one or more days of the week, during which bandwidth rate limits are specified for uploading, downloading, or both.
    public struct BandwidthRateLimitInterval: Swift.Equatable {
        /// The average download rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the download rate limit is not set.
        public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
        /// The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set.
        public var averageUploadRateLimitInBitsPerSec: Swift.Int?
        /// The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        /// This member is required.
        public var daysOfWeek: [Swift.Int]?
        /// The hour of the day to end the bandwidth rate limit interval.
        /// This member is required.
        public var endHourOfDay: Swift.Int?
        /// The minute of the hour to end the bandwidth rate limit interval. The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        /// This member is required.
        public var endMinuteOfHour: Swift.Int?
        /// The hour of the day to start the bandwidth rate limit interval.
        /// This member is required.
        public var startHourOfDay: Swift.Int?
        /// The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        /// This member is required.
        public var startMinuteOfHour: Swift.Int?

        public init (
            averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
            averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
            daysOfWeek: [Swift.Int]? = nil,
            endHourOfDay: Swift.Int? = nil,
            endMinuteOfHour: Swift.Int? = nil,
            startHourOfDay: Swift.Int? = nil,
            startMinuteOfHour: Swift.Int? = nil
        )
        {
            self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }
    }

}

extension StorageGatewayClientTypes.CacheAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheStaleTimeoutInSeconds = "CacheStaleTimeoutInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheStaleTimeoutInSeconds = self.cacheStaleTimeoutInSeconds {
            try encodeContainer.encode(cacheStaleTimeoutInSeconds, forKey: .cacheStaleTimeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheStaleTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cacheStaleTimeoutInSeconds)
        cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSecondsDecoded
    }
}

extension StorageGatewayClientTypes {
    /// The refresh cache information for the file share or FSx file systems.
    public struct CacheAttributes: Swift.Equatable {
        /// Refreshes a file share's cache by using Time To Live (TTL). TTL is the length of time since the last refresh after which access to the directory would cause the file gateway to first refresh that directory's contents from the Amazon S3 bucket or Amazon FSx file system. The TTL duration is in seconds. Valid Values:0, 300 to 2,592,000 seconds (5 minutes to 30 days)
        public var cacheStaleTimeoutInSeconds: Swift.Int?

        public init (
            cacheStaleTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds
        }
    }

}

extension StorageGatewayClientTypes.CachediSCSIVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case kmsKey = "KMSKey"
        case sourceSnapshotId = "SourceSnapshotId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeId = "VolumeId"
        case volumeProgress = "VolumeProgress"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeStatus = "VolumeStatus"
        case volumeType = "VolumeType"
        case volumeUsedInBytes = "VolumeUsedInBytes"
        case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let sourceSnapshotId = self.sourceSnapshotId {
            try encodeContainer.encode(sourceSnapshotId, forKey: .sourceSnapshotId)
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = self.volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeProgress = self.volumeProgress {
            try encodeContainer.encode(volumeProgress, forKey: .volumeProgress)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeStatus = self.volumeStatus {
            try encodeContainer.encode(volumeStatus, forKey: .volumeStatus)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
        if let volumeUsedInBytes = self.volumeUsedInBytes {
            try encodeContainer.encode(volumeUsedInBytes, forKey: .volumeUsedInBytes)
        }
        if let volumeiSCSIAttributes = self.volumeiSCSIAttributes {
            try encodeContainer.encode(volumeiSCSIAttributes, forKey: .volumeiSCSIAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeStatus)
        volumeStatus = volumeStatusDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
        let volumeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInBytes) ?? 0
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeProgressDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .volumeProgress)
        volumeProgress = volumeProgressDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let volumeiSCSIAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.VolumeiSCSIAttributes.self, forKey: .volumeiSCSIAttributes)
        volumeiSCSIAttributes = volumeiSCSIAttributesDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let volumeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsedInBytes)
        volumeUsedInBytes = volumeUsedInBytesDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes an iSCSI cached volume.
    public struct CachediSCSIVolume: Swift.Equatable {
        /// The date the volume was created. Volumes created prior to March 28, 2017 don’t have this timestamp.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public var kmsKey: Swift.String?
        /// If the cached volume was created from a snapshot, this field contains the snapshot ID used, e.g., snap-78e22663. Otherwise, this field is not included.
        public var sourceSnapshotId: Swift.String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public var targetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public var volumeARN: Swift.String?
        /// A value that indicates whether a storage volume is attached to or detached from a gateway. For more information, see [Moving your volumes to a different gateway](https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume).
        public var volumeAttachmentStatus: Swift.String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public var volumeId: Swift.String?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the cached volume is not restoring or bootstrapping.
        public var volumeProgress: Swift.Double?
        /// The size, in bytes, of the volume capacity.
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeStatus: Swift.String?
        /// One of the VolumeType enumeration values that describes the type of the volume.
        public var volumeType: Swift.String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on the number of blocks that are touched, instead of the actual amount of data written. This value can be useful for sequential write patterns but less accurate for random write patterns. VolumeUsedInBytes is different from the compressed size of the volume, which is the value that is used to calculate your bill. This value is not available for volumes created prior to May 13, 2015, until you store data on the volume. If you use a delete tool that overwrites the data on your volume with random data, your usage will not be reduced. This is because the random data is not compressible. If you want to reduce the amount of billed storage on your volume, we recommend overwriting your files with zeros to compress the data to a negligible amount of actual storage.
        public var volumeUsedInBytes: Swift.Int?
        /// An [VolumeiSCSIAttributes] object that represents a collection of iSCSI attributes for one stored volume.
        public var volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            kmsKey: Swift.String? = nil,
            sourceSnapshotId: Swift.String? = nil,
            targetName: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeProgress: Swift.Double? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil,
            volumeUsedInBytes: Swift.Int? = nil,
            volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes? = nil
        )
        {
            self.createdDate = createdDate
            self.kmsKey = kmsKey
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
        }
    }

}

extension CancelArchivalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension CancelArchivalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// CancelArchivalInput
public struct CancelArchivalInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel archiving for.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct CancelArchivalInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeARN: Swift.String?
}

extension CancelArchivalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelArchivalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelArchivalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelArchivalOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelArchivalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelArchivalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// CancelArchivalOutput
public struct CancelArchivalOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape for which archiving was canceled.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CancelArchivalOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension CancelArchivalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelRetrievalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension CancelRetrievalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// CancelRetrievalInput
public struct CancelRetrievalInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel retrieval for.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct CancelRetrievalInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeARN: Swift.String?
}

extension CancelRetrievalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelRetrievalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRetrievalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelRetrievalOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRetrievalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelRetrievalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// CancelRetrievalOutput
public struct CancelRetrievalOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape for which retrieval was canceled.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CancelRetrievalOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension CancelRetrievalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension StorageGatewayClientTypes {
    public enum CaseSensitivity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case casesensitive
        case clientspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [CaseSensitivity] {
            return [
                .casesensitive,
                .clientspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .casesensitive: return "CaseSensitive"
            case .clientspecified: return "ClientSpecified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CaseSensitivity(rawValue: rawValue) ?? CaseSensitivity.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.ChapInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = self.initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let secretToAuthenticateInitiator = self.secretToAuthenticateInitiator {
            try encodeContainer.encode(secretToAuthenticateInitiator, forKey: .secretToAuthenticateInitiator)
        }
        if let secretToAuthenticateTarget = self.secretToAuthenticateTarget {
            try encodeContainer.encode(secretToAuthenticateTarget, forKey: .secretToAuthenticateTarget)
        }
        if let targetARN = self.targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let secretToAuthenticateInitiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateInitiator)
        secretToAuthenticateInitiator = secretToAuthenticateInitiatorDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
        let secretToAuthenticateTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateTarget)
        secretToAuthenticateTarget = secretToAuthenticateTargetDecoded
    }
}

extension StorageGatewayClientTypes.ChapInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChapInfo(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)), secretToAuthenticateInitiator: \"CONTENT_REDACTED\", secretToAuthenticateTarget: \"CONTENT_REDACTED\")"}
}

extension StorageGatewayClientTypes {
    /// Describes Challenge-Handshake Authentication Protocol (CHAP) information that supports authentication between your gateway and iSCSI initiators.
    public struct ChapInfo: Swift.Equatable {
        /// The iSCSI initiator that connects to the target.
        public var initiatorName: Swift.String?
        /// The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.
        public var secretToAuthenticateInitiator: Swift.String?
        /// The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g., Windows client).
        public var secretToAuthenticateTarget: Swift.String?
        /// The Amazon Resource Name (ARN) of the volume. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var targetARN: Swift.String?

        public init (
            initiatorName: Swift.String? = nil,
            secretToAuthenticateInitiator: Swift.String? = nil,
            secretToAuthenticateTarget: Swift.String? = nil,
            targetARN: Swift.String? = nil
        )
        {
            self.initiatorName = initiatorName
            self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
            self.secretToAuthenticateTarget = secretToAuthenticateTarget
            self.targetARN = targetARN
        }
    }

}

extension CreateCachediSCSIVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case snapshotId = "SnapshotId"
        case sourceVolumeARN = "SourceVolumeARN"
        case tags = "Tags"
        case targetName = "TargetName"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let sourceVolumeARN = self.sourceVolumeARN {
            try encodeContainer.encode(sourceVolumeARN, forKey: .sourceVolumeARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
    }
}

extension CreateCachediSCSIVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCachediSCSIVolumeInput: Swift.Equatable {
    /// A unique identifier that you use to retry a request. If you retry a request, use the same ClientToken you specified in the initial request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use [DescribeGatewayInformation] to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// The snapshot ID (e.g. "snap-1122aabb") of the snapshot to restore as the new cached volume. Specify this field if you want to create the iSCSI storage volume from a snapshot; otherwise, do not include this field. To list snapshots for your account use [DescribeSnapshots](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html) in the Amazon Elastic Compute Cloud API Reference.
    public var snapshotId: Swift.String?
    /// The ARN for an existing volume. Specifying this ARN makes the new volume into an exact copy of the specified existing volume's latest recovery point. The VolumeSizeInBytes value for this new volume must be equal to or larger than the size of the existing volume, in bytes.
    public var sourceVolumeARN: Swift.String?
    /// A list of up to 50 tags that you can assign to a cached volume. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers that you can represent in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256 characters.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
    /// This member is required.
    public var targetName: Swift.String?
    /// The size of the volume in bytes.
    /// This member is required.
    public var volumeSizeInBytes: Swift.Int

    public init (
        clientToken: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        sourceVolumeARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        targetName: Swift.String? = nil,
        volumeSizeInBytes: Swift.Int = 0
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.networkInterfaceId = networkInterfaceId
        self.snapshotId = snapshotId
        self.sourceVolumeARN = sourceVolumeARN
        self.tags = tags
        self.targetName = targetName
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

struct CreateCachediSCSIVolumeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let volumeSizeInBytes: Swift.Int
    let snapshotId: Swift.String?
    let targetName: Swift.String?
    let sourceVolumeARN: Swift.String?
    let networkInterfaceId: Swift.String?
    let clientToken: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateCachediSCSIVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case snapshotId = "SnapshotId"
        case sourceVolumeARN = "SourceVolumeARN"
        case tags = "Tags"
        case targetName = "TargetName"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInBytes) ?? 0
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let sourceVolumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVolumeARN)
        sourceVolumeARN = sourceVolumeARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCachediSCSIVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCachediSCSIVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCachediSCSIVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachediSCSIVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCachediSCSIVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
        } else {
            self.targetARN = nil
            self.volumeARN = nil
        }
    }
}

public struct CreateCachediSCSIVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that initiators can use to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured volume.
    public var volumeARN: Swift.String?

    public init (
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

struct CreateCachediSCSIVolumeOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let targetARN: Swift.String?
}

extension CreateCachediSCSIVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension CreateNFSFileShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case locationARN = "LocationARN"
        case nfsFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
        case vpcEndpointDNSName = "VPCEndpointDNSName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let bucketRegion = self.bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for ipv4addresscidr0 in clientList {
                try clientListContainer.encode(ipv4addresscidr0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultStorageClass = self.defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareName = self.fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = self.guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let locationARN = self.locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let nfsFileShareDefaults = self.nfsFileShareDefaults {
            try encodeContainer.encode(nfsFileShareDefaults, forKey: .nfsFileShareDefaults)
        }
        if let notificationPolicy = self.notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = self.objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = self.requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let squash = self.squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcEndpointDNSName = self.vpcEndpointDNSName {
            try encodeContainer.encode(vpcEndpointDNSName, forKey: .vpcEndpointDNSName)
        }
    }
}

extension CreateNFSFileShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// CreateNFSFileShareInput
public struct CreateNFSFileShareInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies the Region of the S3 bucket where the NFS file share stores files. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var bucketRegion: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
    public var clientList: [Swift.String]?
    /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent file share creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 File Gateway on which you want to create a file share.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
    /// This member is required.
    public var locationARN: Swift.String?
    /// File share default values. Optional.
    public var nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {"Upload": {"SettlingTimeInSeconds": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes when it accesses the underlying storage.
    /// This member is required.
    public var role: Swift.String?
    /// A value that maps a user to anonymous user. Valid values are the following:
    ///
    /// * RootSquash: Only root is mapped to anonymous user.
    ///
    /// * NoSquash: No one is mapped to anonymous user.
    ///
    /// * AllSquash: Everyone is mapped to anonymous user.
    public var squash: Swift.String?
    /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var vpcEndpointDNSName: Swift.String?

    public init (
        auditDestinationARN: Swift.String? = nil,
        bucketRegion: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientList: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        role: Swift.String? = nil,
        squash: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vpcEndpointDNSName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.bucketRegion = bucketRegion
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.locationARN = locationARN
        self.nfsFileShareDefaults = nfsFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.squash = squash
        self.tags = tags
        self.vpcEndpointDNSName = vpcEndpointDNSName
    }
}

struct CreateNFSFileShareInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    let gatewayARN: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let role: Swift.String?
    let locationARN: Swift.String?
    let defaultStorageClass: Swift.String?
    let objectACL: StorageGatewayClientTypes.ObjectACL?
    let clientList: [Swift.String]?
    let squash: Swift.String?
    let readOnly: Swift.Bool?
    let guessMIMETypeEnabled: Swift.Bool?
    let requesterPays: Swift.Bool?
    let tags: [StorageGatewayClientTypes.Tag]?
    let fileShareName: Swift.String?
    let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    let notificationPolicy: Swift.String?
    let vpcEndpointDNSName: Swift.String?
    let bucketRegion: Swift.String?
    let auditDestinationARN: Swift.String?
}

extension CreateNFSFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case locationARN = "LocationARN"
        case nfsFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
        case vpcEndpointDNSName = "VPCEndpointDNSName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nfsFileShareDefaultsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.NFSFileShareDefaults.self, forKey: .nfsFileShareDefaults)
        nfsFileShareDefaults = nfsFileShareDefaultsDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vpcEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointDNSName)
        vpcEndpointDNSName = vpcEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
    }
}

extension CreateNFSFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNFSFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNFSFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNFSFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNFSFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// CreateNFSFileShareOutput
public struct CreateNFSFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct CreateNFSFileShareOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
}

extension CreateNFSFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension CreateSMBFileShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case smbaclEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case vpcEndpointDNSName = "VPCEndpointDNSName"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = self.accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlistuser0 in adminUserList {
                try adminUserListContainer.encode(userlistuser0)
            }
        }
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let bucketRegion = self.bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = self.caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultStorageClass = self.defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareName = self.fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = self.guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlistuser0 in invalidUserList {
                try invalidUserListContainer.encode(userlistuser0)
            }
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let locationARN = self.locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let notificationPolicy = self.notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = self.objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let oplocksEnabled = self.oplocksEnabled {
            try encodeContainer.encode(oplocksEnabled, forKey: .oplocksEnabled)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = self.requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let smbaclEnabled = self.smbaclEnabled {
            try encodeContainer.encode(smbaclEnabled, forKey: .smbaclEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcEndpointDNSName = self.vpcEndpointDNSName {
            try encodeContainer.encode(vpcEndpointDNSName, forKey: .vpcEndpointDNSName)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlistuser0 in validUserList {
                try validUserListContainer.encode(userlistuser0)
            }
        }
    }
}

extension CreateSMBFileShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// CreateSMBFileShareInput
public struct CreateSMBFileShareInput: Swift.Equatable {
    /// The files and folders on this share will only be visible to users with read access.
    public var accessBasedEnumeration: Swift.Bool?
    /// A list of users or groups in the Active Directory that will be granted administrator privileges on the file share. These users can do all file operations as the super-user. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Use this option very carefully, because any user in this list can do anything they like on the file share, regardless of file permissions.
    public var adminUserList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// The authentication method that users use to access the file share. The default is ActiveDirectory. Valid Values: ActiveDirectory | GuestAccess
    public var authentication: Swift.String?
    /// Specifies the Region of the S3 bucket where the SMB file share stores files. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var bucketRegion: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
    public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent file share creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// The ARN of the S3 File Gateway on which you want to create a file share.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var invalidUserList: [Swift.String]?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
    /// This member is required.
    public var locationARN: Swift.String?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {"Upload": {"SettlingTimeInSeconds": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// Specifies whether opportunistic locking is enabled for the SMB file share. Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case. Valid Values: true | false
    public var oplocksEnabled: Swift.Bool?
    /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes when it accesses the underlying storage.
    /// This member is required.
    public var role: Swift.String?
    /// Set this value to true to enable access control list (ACL) on the SMB file share. Set it to false to map file and directory permissions to the POSIX permissions. For more information, see [Using Microsoft Windows ACLs to control access to an SMB file share](https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html) in the Storage Gateway User Guide. Valid Values: true | false
    public var smbaclEnabled: Swift.Bool?
    /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A list of users or groups in the Active Directory that are allowed to access the file [ share. A group must be prefixed with the @ character. Acceptable formats include: ]DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var validUserList: [Swift.String]?
    /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
    public var vpcEndpointDNSName: Swift.String?

    public init (
        accessBasedEnumeration: Swift.Bool? = nil,
        adminUserList: [Swift.String]? = nil,
        auditDestinationARN: Swift.String? = nil,
        authentication: Swift.String? = nil,
        bucketRegion: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
        clientToken: Swift.String? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        invalidUserList: [Swift.String]? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        locationARN: Swift.String? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        oplocksEnabled: Swift.Bool? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        role: Swift.String? = nil,
        smbaclEnabled: Swift.Bool? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        validUserList: [Swift.String]? = nil,
        vpcEndpointDNSName: Swift.String? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.authentication = authentication
        self.bucketRegion = bucketRegion
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.locationARN = locationARN
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.oplocksEnabled = oplocksEnabled
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.smbaclEnabled = smbaclEnabled
        self.tags = tags
        self.validUserList = validUserList
        self.vpcEndpointDNSName = vpcEndpointDNSName
    }
}

struct CreateSMBFileShareInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let gatewayARN: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let role: Swift.String?
    let locationARN: Swift.String?
    let defaultStorageClass: Swift.String?
    let objectACL: StorageGatewayClientTypes.ObjectACL?
    let readOnly: Swift.Bool?
    let guessMIMETypeEnabled: Swift.Bool?
    let requesterPays: Swift.Bool?
    let smbaclEnabled: Swift.Bool?
    let accessBasedEnumeration: Swift.Bool?
    let adminUserList: [Swift.String]?
    let validUserList: [Swift.String]?
    let invalidUserList: [Swift.String]?
    let auditDestinationARN: Swift.String?
    let authentication: Swift.String?
    let caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    let tags: [StorageGatewayClientTypes.Tag]?
    let fileShareName: Swift.String?
    let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    let notificationPolicy: Swift.String?
    let vpcEndpointDNSName: Swift.String?
    let bucketRegion: Swift.String?
    let oplocksEnabled: Swift.Bool?
}

extension CreateSMBFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case smbaclEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case vpcEndpointDNSName = "VPCEndpointDNSName"
        case validUserList = "ValidUserList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let smbaclEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smbaclEnabled)
        smbaclEnabled = smbaclEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[Swift.String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [Swift.String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validUserList)
        var validUserListDecoded0:[Swift.String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [Swift.String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[Swift.String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [Swift.String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vpcEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointDNSName)
        vpcEndpointDNSName = vpcEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
        let oplocksEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .oplocksEnabled)
        oplocksEnabled = oplocksEnabledDecoded
    }
}

extension CreateSMBFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSMBFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSMBFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSMBFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSMBFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// CreateSMBFileShareOutput
public struct CreateSMBFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct CreateSMBFileShareOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
}

extension CreateSMBFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension CreateSnapshotFromVolumeRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotDescription = self.snapshotDescription {
            try encodeContainer.encode(snapshotDescription, forKey: .snapshotDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension CreateSnapshotFromVolumeRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointInput: Swift.Equatable {
    /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic Block Store snapshots panel in the Description field, and in the Storage Gateway snapshot Details pane, Description field.
    /// This member is required.
    public var snapshotDescription: Swift.String?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        snapshotDescription: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotFromVolumeRecoveryPointInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let snapshotDescription: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateSnapshotFromVolumeRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotDescription)
        snapshotDescription = snapshotDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSnapshotFromVolumeRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSnapshotFromVolumeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshotId = output.snapshotId
            self.volumeARN = output.volumeARN
            self.volumeRecoveryPointTime = output.volumeRecoveryPointTime
        } else {
            self.snapshotId = nil
            self.volumeARN = nil
            self.volumeRecoveryPointTime = nil
        }
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointOutputResponse: Swift.Equatable {
    /// The ID of the snapshot.
    public var snapshotId: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    public var volumeARN: Swift.String?
    /// The time the volume was created from the recovery point.
    public var volumeRecoveryPointTime: Swift.String?

    public init (
        snapshotId: Swift.String? = nil,
        volumeARN: Swift.String? = nil,
        volumeRecoveryPointTime: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
        self.volumeRecoveryPointTime = volumeRecoveryPointTime
    }
}

struct CreateSnapshotFromVolumeRecoveryPointOutputResponseBody: Swift.Equatable {
    let snapshotId: Swift.String?
    let volumeARN: Swift.String?
    let volumeRecoveryPointTime: Swift.String?
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
        case volumeARN = "VolumeARN"
        case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeRecoveryPointTime)
        volumeRecoveryPointTime = volumeRecoveryPointTimeDecoded
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotDescription = self.snapshotDescription {
            try encodeContainer.encode(snapshotDescription, forKey: .snapshotDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [CreateSnapshotInput$SnapshotDescription]
///
/// * [CreateSnapshotInput$VolumeARN]
public struct CreateSnapshotInput: Swift.Equatable {
    /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic Block Store snapshots panel in the Description field, and in the Storage Gateway snapshot Details pane, Description field.
    /// This member is required.
    public var snapshotDescription: Swift.String?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        snapshotDescription: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let snapshotDescription: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotDescription)
        snapshotDescription = snapshotDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSnapshotOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshotId = output.snapshotId
            self.volumeARN = output.volumeARN
        } else {
            self.snapshotId = nil
            self.volumeARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct CreateSnapshotOutputResponse: Swift.Equatable {
    /// The snapshot ID that is used to refer to the snapshot in future operations such as describing snapshots (Amazon Elastic Compute Cloud API DescribeSnapshots) or creating a volume from a snapshot ([CreateStorediSCSIVolume]).
    public var snapshotId: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume of which the snapshot was taken.
    public var volumeARN: Swift.String?

    public init (
        snapshotId: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let snapshotId: Swift.String?
}

extension CreateSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension CreateStorediSCSIVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case preserveExistingData = "PreserveExistingData"
        case snapshotId = "SnapshotId"
        case tags = "Tags"
        case targetName = "TargetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskId = self.diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if preserveExistingData != false {
            try encodeContainer.encode(preserveExistingData, forKey: .preserveExistingData)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
    }
}

extension CreateStorediSCSIVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [CreateStorediSCSIVolumeInput$DiskId]
///
/// * [CreateStorediSCSIVolumeInput$NetworkInterfaceId]
///
/// * [CreateStorediSCSIVolumeInput$PreserveExistingData]
///
/// * [CreateStorediSCSIVolumeInput$SnapshotId]
///
/// * [CreateStorediSCSIVolumeInput$TargetName]
public struct CreateStorediSCSIVolumeInput: Swift.Equatable {
    /// The unique identifier for the gateway local disk that is configured as a stored volume. Use [ListLocalDisks](https://docs.aws.amazon.com/storagegateway/latest/userguide/API_ListLocalDisks.html) to list disk IDs for a gateway.
    /// This member is required.
    public var diskId: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use [DescribeGatewayInformation] to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
    /// This member is required.
    public var networkInterfaceId: Swift.String?
    /// Set to true if you want to preserve the data on the local disk. Otherwise, set to false to create an empty volume. Valid Values: true | false
    /// This member is required.
    public var preserveExistingData: Swift.Bool
    /// The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as the new stored volume. Specify this field if you want to create the iSCSI storage volume from a snapshot; otherwise, do not include this field. To list snapshots for your account use [DescribeSnapshots](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html) in the Amazon Elastic Compute Cloud API Reference.
    public var snapshotId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a stored volume. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
    /// This member is required.
    public var targetName: Swift.String?

    public init (
        diskId: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        preserveExistingData: Swift.Bool = false,
        snapshotId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.networkInterfaceId = networkInterfaceId
        self.preserveExistingData = preserveExistingData
        self.snapshotId = snapshotId
        self.tags = tags
        self.targetName = targetName
    }
}

struct CreateStorediSCSIVolumeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskId: Swift.String?
    let snapshotId: Swift.String?
    let preserveExistingData: Swift.Bool
    let targetName: Swift.String?
    let networkInterfaceId: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateStorediSCSIVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case preserveExistingData = "PreserveExistingData"
        case snapshotId = "SnapshotId"
        case tags = "Tags"
        case targetName = "TargetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskId)
        diskId = diskIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let preserveExistingDataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveExistingData) ?? false
        preserveExistingData = preserveExistingDataDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStorediSCSIVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStorediSCSIVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateStorediSCSIVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStorediSCSIVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateStorediSCSIVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
            self.volumeSizeInBytes = output.volumeSizeInBytes
        } else {
            self.targetARN = nil
            self.volumeARN = nil
            self.volumeSizeInBytes = 0
        }
    }
}

/// A JSON object containing the following fields:
public struct CreateStorediSCSIVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that initiators can use to connect to the target.
    public var targetARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the configured volume.
    public var volumeARN: Swift.String?
    /// The size of the volume in bytes.
    public var volumeSizeInBytes: Swift.Int

    public init (
        targetARN: Swift.String? = nil,
        volumeARN: Swift.String? = nil,
        volumeSizeInBytes: Swift.Int = 0
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

struct CreateStorediSCSIVolumeOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let volumeSizeInBytes: Swift.Int
    let targetARN: Swift.String?
}

extension CreateStorediSCSIVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInBytes) ?? 0
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension CreateTapePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolName = "PoolName"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolName = self.poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let retentionLockTimeInDays = self.retentionLockTimeInDays {
            try encodeContainer.encode(retentionLockTimeInDays, forKey: .retentionLockTimeInDays)
        }
        if let retentionLockType = self.retentionLockType {
            try encodeContainer.encode(retentionLockType.rawValue, forKey: .retentionLockType)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTapePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTapePoolInput: Swift.Equatable {
    /// The name of the new custom tape pool.
    /// This member is required.
    public var poolName: Swift.String?
    /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to 100 years (36,500 days).
    public var retentionLockTimeInDays: Swift.Int?
    /// Tape retention lock can be configured in two modes. When configured in governance mode, Amazon Web Services accounts with specific IAM permissions are authorized to remove the tape retention lock from archived virtual tapes. When configured in compliance mode, the tape retention lock cannot be removed by any user, including the root Amazon Web Services account.
    public var retentionLockType: StorageGatewayClientTypes.RetentionLockType?
    /// The storage class that is associated with the new custom pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    /// This member is required.
    public var storageClass: StorageGatewayClientTypes.TapeStorageClass?
    /// A list of up to 50 tags that can be assigned to tape pool. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init (
        poolName: Swift.String? = nil,
        retentionLockTimeInDays: Swift.Int? = nil,
        retentionLockType: StorageGatewayClientTypes.RetentionLockType? = nil,
        storageClass: StorageGatewayClientTypes.TapeStorageClass? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.poolName = poolName
        self.retentionLockTimeInDays = retentionLockTimeInDays
        self.retentionLockType = retentionLockType
        self.storageClass = storageClass
        self.tags = tags
    }
}

struct CreateTapePoolInputBody: Swift.Equatable {
    let poolName: Swift.String?
    let storageClass: StorageGatewayClientTypes.TapeStorageClass?
    let retentionLockType: StorageGatewayClientTypes.RetentionLockType?
    let retentionLockTimeInDays: Swift.Int?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateTapePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolName = "PoolName"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.TapeStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionLockTypeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.RetentionLockType.self, forKey: .retentionLockType)
        retentionLockType = retentionLockTypeDecoded
        let retentionLockTimeInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionLockTimeInDays)
        retentionLockTimeInDays = retentionLockTimeInDaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTapePoolOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.poolARN = output.poolARN
        } else {
            self.poolARN = nil
        }
    }
}

public struct CreateTapePoolOutputResponse: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) that represents the custom tape pool. Use the [ListTapePools] operation to return a list of tape pools for your account and Amazon Web Services Region.
    public var poolARN: Swift.String?

    public init (
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct CreateTapePoolOutputResponseBody: Swift.Equatable {
    let poolARN: Swift.String?
}

extension CreateTapePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

extension CreateTapeWithBarcodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tapeBarcode = self.tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }
}

extension CreateTapeWithBarcodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// CreateTapeWithBarcodeInput
public struct CreateTapeWithBarcodeInput: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tape with. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Deep Archive) that corresponds to the pool.
    public var poolId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a virtual tape that has a barcode. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The barcode that you want to assign to the tape. Barcodes cannot be reused. This includes barcodes used for tapes that have been deleted.
    /// This member is required.
    public var tapeBarcode: Swift.String?
    /// The size, in bytes, of the virtual tape that you want to create. The size must be aligned by gigabyte (102410241024 bytes).
    /// This member is required.
    public var tapeSizeInBytes: Swift.Int?
    /// Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM) tape.
    public var worm: Swift.Bool

    public init (
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        poolId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeBarcode: Swift.String? = nil,
        tapeSizeInBytes: Swift.Int? = nil,
        worm: Swift.Bool = false
    )
    {
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcode = tapeBarcode
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

struct CreateTapeWithBarcodeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeSizeInBytes: Swift.Int?
    let tapeBarcode: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let poolId: Swift.String?
    let worm: Swift.Bool
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateTapeWithBarcodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .worm) ?? false
        worm = wormDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapeWithBarcodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapeWithBarcodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTapeWithBarcodeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapeWithBarcodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTapeWithBarcodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// CreateTapeOutput
public struct CreateTapeWithBarcodeOutputResponse: Swift.Equatable {
    /// A unique Amazon Resource Name (ARN) that represents the virtual tape that was created.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CreateTapeWithBarcodeOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension CreateTapeWithBarcodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CreateTapesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case numTapesToCreate = "NumTapesToCreate"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let numTapesToCreate = self.numTapesToCreate {
            try encodeContainer.encode(numTapesToCreate, forKey: .numTapesToCreate)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tapeBarcodePrefix = self.tapeBarcodePrefix {
            try encodeContainer.encode(tapeBarcodePrefix, forKey: .tapeBarcodePrefix)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }
}

extension CreateTapesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// CreateTapesInput
public struct CreateTapesInput: Swift.Equatable {
    /// A unique identifier that you use to retry a request. If you retry a request, use the same ClientToken you specified in the initial request. Using the same ClientToken prevents creating the tape multiple times.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tapes with. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The number of virtual tapes that you want to create.
    /// This member is required.
    public var numTapesToCreate: Swift.Int?
    /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
    public var poolId: Swift.String?
    /// A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A prefix that you append to the barcode of the virtual tape you are creating. This prefix makes the barcode unique. The prefix must be 1-4 characters in length and must be one of the uppercase letters from A to Z.
    /// This member is required.
    public var tapeBarcodePrefix: Swift.String?
    /// The size, in bytes, of the virtual tapes that you want to create. The size must be aligned by gigabyte (102410241024 bytes).
    /// This member is required.
    public var tapeSizeInBytes: Swift.Int?
    /// Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM) tape.
    public var worm: Swift.Bool

    public init (
        clientToken: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        numTapesToCreate: Swift.Int? = nil,
        poolId: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        tapeBarcodePrefix: Swift.String? = nil,
        tapeSizeInBytes: Swift.Int? = nil,
        worm: Swift.Bool = false
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.numTapesToCreate = numTapesToCreate
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcodePrefix = tapeBarcodePrefix
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

struct CreateTapesInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeSizeInBytes: Swift.Int?
    let clientToken: Swift.String?
    let numTapesToCreate: Swift.Int?
    let tapeBarcodePrefix: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let poolId: Swift.String?
    let worm: Swift.Bool
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension CreateTapesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case numTapesToCreate = "NumTapesToCreate"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let numTapesToCreateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numTapesToCreate)
        numTapesToCreate = numTapesToCreateDecoded
        let tapeBarcodePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcodePrefix)
        tapeBarcodePrefix = tapeBarcodePrefixDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .worm) ?? false
        worm = wormDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTapesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTapesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARNs = output.tapeARNs
        } else {
            self.tapeARNs = nil
        }
    }
}

/// CreateTapeOutput
public struct CreateTapesOutputResponse: Swift.Equatable {
    /// A list of unique Amazon Resource Names (ARNs) that represents the virtual tapes that were created.
    public var tapeARNs: [Swift.String]?

    public init (
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.tapeARNs = tapeARNs
    }
}

struct CreateTapesOutputResponseBody: Swift.Equatable {
    let tapeARNs: [Swift.String]?
}

extension CreateTapesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
    }
}

extension DeleteAutomaticTapeCreationPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DeleteAutomaticTapeCreationPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAutomaticTapeCreationPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteAutomaticTapeCreationPolicyInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DeleteAutomaticTapeCreationPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteAutomaticTapeCreationPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutomaticTapeCreationPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAutomaticTapeCreationPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutomaticTapeCreationPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAutomaticTapeCreationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct DeleteAutomaticTapeCreationPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteAutomaticTapeCreationPolicyOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DeleteAutomaticTapeCreationPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteBandwidthRateLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthType = "BandwidthType"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthType = self.bandwidthType {
            try encodeContainer.encode(bandwidthType, forKey: .bandwidthType)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DeleteBandwidthRateLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the following fields:
///
/// * [DeleteBandwidthRateLimitInput$BandwidthType]
public struct DeleteBandwidthRateLimitInput: Swift.Equatable {
    /// One of the BandwidthType values that indicates the gateway bandwidth rate limit to delete. Valid Values: UPLOAD | DOWNLOAD | ALL
    /// This member is required.
    public var bandwidthType: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        bandwidthType: Swift.String? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthType = bandwidthType
        self.gatewayARN = gatewayARN
    }
}

struct DeleteBandwidthRateLimitInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let bandwidthType: Swift.String?
}

extension DeleteBandwidthRateLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthType = "BandwidthType"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandwidthType)
        bandwidthType = bandwidthTypeDecoded
    }
}

extension DeleteBandwidthRateLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBandwidthRateLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBandwidthRateLimitOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBandwidthRateLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose bandwidth rate information was deleted.
public struct DeleteBandwidthRateLimitOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteBandwidthRateLimitOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DeleteBandwidthRateLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteChapCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = self.initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let targetARN = self.targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

extension DeleteChapCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [DeleteChapCredentialsInput$InitiatorName]
///
/// * [DeleteChapCredentialsInput$TargetARN]
public struct DeleteChapCredentialsInput: Swift.Equatable {
    /// The iSCSI initiator that connects to the target.
    /// This member is required.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct DeleteChapCredentialsInputBody: Swift.Equatable {
    let targetARN: Swift.String?
    let initiatorName: Swift.String?
}

extension DeleteChapCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

extension DeleteChapCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChapCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChapCredentialsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChapCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiatorName = output.initiatorName
            self.targetARN = output.targetARN
        } else {
            self.initiatorName = nil
            self.targetARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DeleteChapCredentialsOutputResponse: Swift.Equatable {
    /// The iSCSI initiator that connects to the target.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the target.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct DeleteChapCredentialsOutputResponseBody: Swift.Equatable {
    let targetARN: Swift.String?
    let initiatorName: Swift.String?
}

extension DeleteChapCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

extension DeleteFileShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case forceDelete = "ForceDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteFileShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DeleteFileShareInput
public struct DeleteFileShareInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share to be deleted.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// If this value is set to true, the operation deletes a file share immediately and aborts all data uploads to Amazon Web Services. Otherwise, the file share is not deleted until all data is uploaded to Amazon Web Services. This process aborts the data upload process, and the file share enters the FORCE_DELETING status. Valid Values: true | false
    public var forceDelete: Swift.Bool

    public init (
        fileShareARN: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.fileShareARN = fileShareARN
        self.forceDelete = forceDelete
    }
}

struct DeleteFileShareInputBody: Swift.Equatable {
    let fileShareARN: Swift.String?
    let forceDelete: Swift.Bool
}

extension DeleteFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case forceDelete = "ForceDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete) ?? false
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// DeleteFileShareOutput
public struct DeleteFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct DeleteFileShareOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
}

extension DeleteFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension DeleteGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DeleteGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the ID of the gateway to delete.
public struct DeleteGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DeleteGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the ID of the deleted gateway.
public struct DeleteGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteGatewayOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DeleteGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteSnapshotScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension DeleteSnapshotScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSnapshotScheduleInput: Swift.Equatable {
    /// The volume which snapshot schedule to delete.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteSnapshotScheduleInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension DeleteSnapshotScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

public struct DeleteSnapshotScheduleOutputResponse: Swift.Equatable {
    /// The volume which snapshot schedule was deleted.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteSnapshotScheduleOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension DeleteSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteTapeArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension DeleteTapeArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DeleteTapeArchiveInput
public struct DeleteTapeArchiveInput: Swift.Equatable {
    /// Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock. Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes with tape retention lock set to compliance can't be deleted.
    public var bypassGovernanceRetention: Swift.Bool
    /// The Amazon Resource Name (ARN) of the virtual tape to delete from the virtual tape shelf (VTS).
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        bypassGovernanceRetention: Swift.Bool = false,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeArchiveInputBody: Swift.Equatable {
    let tapeARN: Swift.String?
    let bypassGovernanceRetention: Swift.Bool
}

extension DeleteTapeArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassGovernanceRetention) ?? false
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension DeleteTapeArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapeArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTapeArchiveOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapeArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTapeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// DeleteTapeArchiveOutput
public struct DeleteTapeArchiveOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape that was deleted from the virtual tape shelf (VTS).
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeArchiveOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension DeleteTapeArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension DeleteTapeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension DeleteTapeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DeleteTapeInput
public struct DeleteTapeInput: Swift.Equatable {
    /// Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock. Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes with tape retention lock set to compliance can't be deleted.
    public var bypassGovernanceRetention: Swift.Bool
    /// The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is associated with. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape to delete.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        bypassGovernanceRetention: Swift.Bool = false,
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeARN: Swift.String?
    let bypassGovernanceRetention: Swift.Bool
}

extension DeleteTapeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassGovernanceRetention) ?? false
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension DeleteTapeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTapeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTapeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// DeleteTapeOutput
public struct DeleteTapeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted virtual tape.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension DeleteTapeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension DeleteTapePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolARN = self.poolARN {
            try encodeContainer.encode(poolARN, forKey: .poolARN)
        }
    }
}

extension DeleteTapePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTapePoolInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom tape pool to delete.
    /// This member is required.
    public var poolARN: Swift.String?

    public init (
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct DeleteTapePoolInputBody: Swift.Equatable {
    let poolARN: Swift.String?
}

extension DeleteTapePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

extension DeleteTapePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTapePoolOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.poolARN = output.poolARN
        } else {
            self.poolARN = nil
        }
    }
}

public struct DeleteTapePoolOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom tape pool being deleted.
    public var poolARN: Swift.String?

    public init (
        poolARN: Swift.String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct DeleteTapePoolOutputResponseBody: Swift.Equatable {
    let poolARN: Swift.String?
}

extension DeleteTapePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

extension DeleteVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension DeleteVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the [DeleteVolumeInput$VolumeARN] to delete.
public struct DeleteVolumeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteVolumeInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension DeleteVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the storage volume that was deleted.
public struct DeleteVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage volume that was deleted. It is the same ARN you provided in the request.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteVolumeOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension DeleteVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DescribeAvailabilityMonitorTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeAvailabilityMonitorTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAvailabilityMonitorTestInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeAvailabilityMonitorTestInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeAvailabilityMonitorTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeAvailabilityMonitorTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAvailabilityMonitorTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAvailabilityMonitorTestOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailabilityMonitorTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAvailabilityMonitorTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.gatewayARN = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAvailabilityMonitorTestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The time the high availability monitoring test was started. If a test hasn't been performed, the value of this field is null.
    public var startTime: ClientRuntime.Date?
    /// The status of the high availability monitoring test. If a test hasn't been performed, the value of this field is null.
    public var status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus?

    public init (
        gatewayARN: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeAvailabilityMonitorTestOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let status: StorageGatewayClientTypes.AvailabilityMonitorTestStatus?
    let startTime: ClientRuntime.Date?
}

extension DescribeAvailabilityMonitorTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case startTime = "StartTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.AvailabilityMonitorTestStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension DescribeBandwidthRateLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeBandwidthRateLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeBandwidthRateLimitInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeBandwidthRateLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeBandwidthRateLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBandwidthRateLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBandwidthRateLimitOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBandwidthRateLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.averageDownloadRateLimitInBitsPerSec = output.averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = output.averageUploadRateLimitInBitsPerSec
            self.gatewayARN = output.gatewayARN
        } else {
            self.averageDownloadRateLimitInBitsPerSec = nil
            self.averageUploadRateLimitInBitsPerSec = nil
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeBandwidthRateLimitOutputResponse: Swift.Equatable {
    /// The average download bandwidth rate limit in bits per second. This field does not appear in the response if the download rate limit is not set.
    public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
    /// The average upload bandwidth rate limit in bits per second. This field does not appear in the response if the upload rate limit is not set.
    public var averageUploadRateLimitInBitsPerSec: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
        averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let averageUploadRateLimitInBitsPerSec: Swift.Int?
    let averageDownloadRateLimitInBitsPerSec: Swift.Int?
}

extension DescribeBandwidthRateLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension DescribeBandwidthRateLimitScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeBandwidthRateLimitScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBandwidthRateLimitScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBandwidthRateLimitScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBandwidthRateLimitScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bandwidthRateLimitIntervals = output.bandwidthRateLimitIntervals
            self.gatewayARN = output.gatewayARN
        } else {
            self.bandwidthRateLimitIntervals = nil
            self.gatewayARN = nil
        }
    }
}

public struct DescribeBandwidthRateLimitScheduleOutputResponse: Swift.Equatable {
    /// An array that contains the bandwidth rate limit intervals for a tape or volume gateway.
    public var bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitScheduleOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension DescribeBandwidthRateLimitScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [StorageGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension DescribeCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCacheInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeCacheInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cacheAllocatedInBytes = output.cacheAllocatedInBytes
            self.cacheDirtyPercentage = output.cacheDirtyPercentage
            self.cacheHitPercentage = output.cacheHitPercentage
            self.cacheMissPercentage = output.cacheMissPercentage
            self.cacheUsedPercentage = output.cacheUsedPercentage
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
        } else {
            self.cacheAllocatedInBytes = 0
            self.cacheDirtyPercentage = 0.0
            self.cacheHitPercentage = 0.0
            self.cacheMissPercentage = 0.0
            self.cacheUsedPercentage = 0.0
            self.diskIds = nil
            self.gatewayARN = nil
        }
    }
}

public struct DescribeCacheOutputResponse: Swift.Equatable {
    /// The amount of cache in bytes allocated to a gateway.
    public var cacheAllocatedInBytes: Swift.Int
    /// The file share's contribution to the overall percentage of the gateway's cache that has not been persisted to Amazon Web Services. The sample is taken at the end of the reporting period.
    public var cacheDirtyPercentage: Swift.Double
    /// Percent of application read operations from the file shares that are served from cache. The sample is taken at the end of the reporting period.
    public var cacheHitPercentage: Swift.Double
    /// Percent of application read operations from the file shares that are not served from cache. The sample is taken at the end of the reporting period.
    public var cacheMissPercentage: Swift.Double
    /// Percent use of the gateway's cache storage. This metric applies only to the gateway-cached volume setup. The sample is taken at the end of the reporting period.
    public var cacheUsedPercentage: Swift.Double
    /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the [ListLocalDisks] API.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        cacheAllocatedInBytes: Swift.Int = 0,
        cacheDirtyPercentage: Swift.Double = 0.0,
        cacheHitPercentage: Swift.Double = 0.0,
        cacheMissPercentage: Swift.Double = 0.0,
        cacheUsedPercentage: Swift.Double = 0.0,
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.cacheAllocatedInBytes = cacheAllocatedInBytes
        self.cacheDirtyPercentage = cacheDirtyPercentage
        self.cacheHitPercentage = cacheHitPercentage
        self.cacheMissPercentage = cacheMissPercentage
        self.cacheUsedPercentage = cacheUsedPercentage
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct DescribeCacheOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskIds: [Swift.String]?
    let cacheAllocatedInBytes: Swift.Int
    let cacheUsedPercentage: Swift.Double
    let cacheDirtyPercentage: Swift.Double
    let cacheHitPercentage: Swift.Double
    let cacheMissPercentage: Swift.Double
}

extension DescribeCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheAllocatedInBytes = "CacheAllocatedInBytes"
        case cacheDirtyPercentage = "CacheDirtyPercentage"
        case cacheHitPercentage = "CacheHitPercentage"
        case cacheMissPercentage = "CacheMissPercentage"
        case cacheUsedPercentage = "CacheUsedPercentage"
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let cacheAllocatedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cacheAllocatedInBytes) ?? 0
        cacheAllocatedInBytes = cacheAllocatedInBytesDecoded
        let cacheUsedPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cacheUsedPercentage) ?? 0.0
        cacheUsedPercentage = cacheUsedPercentageDecoded
        let cacheDirtyPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cacheDirtyPercentage) ?? 0.0
        cacheDirtyPercentage = cacheDirtyPercentageDecoded
        let cacheHitPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cacheHitPercentage) ?? 0.0
        cacheHitPercentage = cacheHitPercentageDecoded
        let cacheMissPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cacheMissPercentage) ?? 0.0
        cacheMissPercentage = cacheMissPercentageDecoded
    }
}

extension DescribeCachediSCSIVolumesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARNs = volumeARNs {
            var volumeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeARNs)
            for volumearn0 in volumeARNs {
                try volumeARNsContainer.encode(volumearn0)
            }
        }
    }
}

extension DescribeCachediSCSIVolumesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCachediSCSIVolumesInput: Swift.Equatable {
    /// An array of strings where each string represents the Amazon Resource Name (ARN) of a cached volume. All of the specified cached volumes must be from the same gateway. Use [ListVolumes] to get volume ARNs for a gateway.
    /// This member is required.
    public var volumeARNs: [Swift.String]?

    public init (
        volumeARNs: [Swift.String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

struct DescribeCachediSCSIVolumesInputBody: Swift.Equatable {
    let volumeARNs: [Swift.String]?
}

extension DescribeCachediSCSIVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .volumeARNs)
        var volumeARNsDecoded0:[Swift.String]? = nil
        if let volumeARNsContainer = volumeARNsContainer {
            volumeARNsDecoded0 = [Swift.String]()
            for string0 in volumeARNsContainer {
                if let string0 = string0 {
                    volumeARNsDecoded0?.append(string0)
                }
            }
        }
        volumeARNs = volumeARNsDecoded0
    }
}

extension DescribeCachediSCSIVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCachediSCSIVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCachediSCSIVolumesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCachediSCSIVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCachediSCSIVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cachediSCSIVolumes = output.cachediSCSIVolumes
        } else {
            self.cachediSCSIVolumes = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeCachediSCSIVolumesOutputResponse: Swift.Equatable {
    /// An array of objects where each object contains metadata about one cached volume.
    public var cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]?

    public init (
        cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]? = nil
    )
    {
        self.cachediSCSIVolumes = cachediSCSIVolumes
    }
}

struct DescribeCachediSCSIVolumesOutputResponseBody: Swift.Equatable {
    let cachediSCSIVolumes: [StorageGatewayClientTypes.CachediSCSIVolume]?
}

extension DescribeCachediSCSIVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachediSCSIVolumes = "CachediSCSIVolumes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachediSCSIVolumesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.CachediSCSIVolume?].self, forKey: .cachediSCSIVolumes)
        var cachediSCSIVolumesDecoded0:[StorageGatewayClientTypes.CachediSCSIVolume]? = nil
        if let cachediSCSIVolumesContainer = cachediSCSIVolumesContainer {
            cachediSCSIVolumesDecoded0 = [StorageGatewayClientTypes.CachediSCSIVolume]()
            for structure0 in cachediSCSIVolumesContainer {
                if let structure0 = structure0 {
                    cachediSCSIVolumesDecoded0?.append(structure0)
                }
            }
        }
        cachediSCSIVolumes = cachediSCSIVolumesDecoded0
    }
}

extension DescribeChapCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetARN = self.targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

extension DescribeChapCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the iSCSI volume target.
public struct DescribeChapCredentialsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return to retrieve the TargetARN for specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init (
        targetARN: Swift.String? = nil
    )
    {
        self.targetARN = targetARN
    }
}

struct DescribeChapCredentialsInputBody: Swift.Equatable {
    let targetARN: Swift.String?
}

extension DescribeChapCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension DescribeChapCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChapCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChapCredentialsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChapCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.chapCredentials = output.chapCredentials
        } else {
            self.chapCredentials = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeChapCredentialsOutputResponse: Swift.Equatable {
    /// An array of [ChapInfo] objects that represent CHAP credentials. Each object in the array contains CHAP credential information for one target-initiator pair. If no CHAP credentials are set, an empty array is returned. CHAP credential information is provided in a JSON object with the following fields:
    ///
    /// * InitiatorName: The iSCSI initiator that connects to the target.
    ///
    /// * SecretToAuthenticateInitiator: The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.
    ///
    /// * SecretToAuthenticateTarget: The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g. Windows client).
    ///
    /// * TargetARN: The Amazon Resource Name (ARN) of the storage volume.
    public var chapCredentials: [StorageGatewayClientTypes.ChapInfo]?

    public init (
        chapCredentials: [StorageGatewayClientTypes.ChapInfo]? = nil
    )
    {
        self.chapCredentials = chapCredentials
    }
}

struct DescribeChapCredentialsOutputResponseBody: Swift.Equatable {
    let chapCredentials: [StorageGatewayClientTypes.ChapInfo]?
}

extension DescribeChapCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chapCredentials = "ChapCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chapCredentialsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.ChapInfo?].self, forKey: .chapCredentials)
        var chapCredentialsDecoded0:[StorageGatewayClientTypes.ChapInfo]? = nil
        if let chapCredentialsContainer = chapCredentialsContainer {
            chapCredentialsDecoded0 = [StorageGatewayClientTypes.ChapInfo]()
            for structure0 in chapCredentialsContainer {
                if let structure0 = structure0 {
                    chapCredentialsDecoded0?.append(structure0)
                }
            }
        }
        chapCredentials = chapCredentialsDecoded0
    }
}

extension DescribeFileSystemAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARNList = "FileSystemAssociationARNList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARNList = fileSystemAssociationARNList {
            var fileSystemAssociationARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemAssociationARNList)
            for filesystemassociationarn0 in fileSystemAssociationARNList {
                try fileSystemAssociationARNListContainer.encode(filesystemassociationarn0)
            }
        }
    }
}

extension DescribeFileSystemAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFileSystemAssociationsInput: Swift.Equatable {
    /// An array containing the Amazon Resource Name (ARN) of each file system association to be described.
    /// This member is required.
    public var fileSystemAssociationARNList: [Swift.String]?

    public init (
        fileSystemAssociationARNList: [Swift.String]? = nil
    )
    {
        self.fileSystemAssociationARNList = fileSystemAssociationARNList
    }
}

struct DescribeFileSystemAssociationsInputBody: Swift.Equatable {
    let fileSystemAssociationARNList: [Swift.String]?
}

extension DescribeFileSystemAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARNList = "FileSystemAssociationARNList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileSystemAssociationARNList)
        var fileSystemAssociationARNListDecoded0:[Swift.String]? = nil
        if let fileSystemAssociationARNListContainer = fileSystemAssociationARNListContainer {
            fileSystemAssociationARNListDecoded0 = [Swift.String]()
            for string0 in fileSystemAssociationARNListContainer {
                if let string0 = string0 {
                    fileSystemAssociationARNListDecoded0?.append(string0)
                }
            }
        }
        fileSystemAssociationARNList = fileSystemAssociationARNListDecoded0
    }
}

extension DescribeFileSystemAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFileSystemAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFileSystemAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationInfoList = output.fileSystemAssociationInfoList
        } else {
            self.fileSystemAssociationInfoList = nil
        }
    }
}

public struct DescribeFileSystemAssociationsOutputResponse: Swift.Equatable {
    /// An array containing the FileSystemAssociationInfo data type of each file system association to be described.
    public var fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]?

    public init (
        fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]? = nil
    )
    {
        self.fileSystemAssociationInfoList = fileSystemAssociationInfoList
    }
}

struct DescribeFileSystemAssociationsOutputResponseBody: Swift.Equatable {
    let fileSystemAssociationInfoList: [StorageGatewayClientTypes.FileSystemAssociationInfo]?
}

extension DescribeFileSystemAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationInfoList = "FileSystemAssociationInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileSystemAssociationInfo?].self, forKey: .fileSystemAssociationInfoList)
        var fileSystemAssociationInfoListDecoded0:[StorageGatewayClientTypes.FileSystemAssociationInfo]? = nil
        if let fileSystemAssociationInfoListContainer = fileSystemAssociationInfoListContainer {
            fileSystemAssociationInfoListDecoded0 = [StorageGatewayClientTypes.FileSystemAssociationInfo]()
            for structure0 in fileSystemAssociationInfoListContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationInfoListDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationInfoList = fileSystemAssociationInfoListDecoded0
    }
}

extension DescribeGatewayInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeGatewayInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the ID of the gateway.
public struct DescribeGatewayInformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeGatewayInformationInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeGatewayInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeGatewayInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGatewayInformationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogGroupARN = output.cloudWatchLogGroupARN
            self.deprecationDate = output.deprecationDate
            self.ec2InstanceId = output.ec2InstanceId
            self.ec2InstanceRegion = output.ec2InstanceRegion
            self.endpointType = output.endpointType
            self.gatewayARN = output.gatewayARN
            self.gatewayCapacity = output.gatewayCapacity
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayNetworkInterfaces = output.gatewayNetworkInterfaces
            self.gatewayState = output.gatewayState
            self.gatewayTimezone = output.gatewayTimezone
            self.gatewayType = output.gatewayType
            self.hostEnvironment = output.hostEnvironment
            self.hostEnvironmentId = output.hostEnvironmentId
            self.lastSoftwareUpdate = output.lastSoftwareUpdate
            self.nextUpdateAvailabilityDate = output.nextUpdateAvailabilityDate
            self.softwareUpdatesEndDate = output.softwareUpdatesEndDate
            self.supportedGatewayCapacities = output.supportedGatewayCapacities
            self.tags = output.tags
            self.vpcEndpoint = output.vpcEndpoint
        } else {
            self.cloudWatchLogGroupARN = nil
            self.deprecationDate = nil
            self.ec2InstanceId = nil
            self.ec2InstanceRegion = nil
            self.endpointType = nil
            self.gatewayARN = nil
            self.gatewayCapacity = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayNetworkInterfaces = nil
            self.gatewayState = nil
            self.gatewayTimezone = nil
            self.gatewayType = nil
            self.hostEnvironment = nil
            self.hostEnvironmentId = nil
            self.lastSoftwareUpdate = nil
            self.nextUpdateAvailabilityDate = nil
            self.softwareUpdatesEndDate = nil
            self.supportedGatewayCapacities = nil
            self.tags = nil
            self.vpcEndpoint = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeGatewayInformationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to monitor events in the gateway. This field only only exist and returns once it have been chosen and set by the SGW service, based on the OS version of the gateway VM
    public var cloudWatchLogGroupARN: Swift.String?
    /// Date after which this gateway will not receive software updates for new features and bug fixes.
    public var deprecationDate: Swift.String?
    /// The ID of the Amazon EC2 instance that was used to launch the gateway.
    public var ec2InstanceId: Swift.String?
    /// The Amazon Web Services Region where the Amazon EC2 instance is located.
    public var ec2InstanceRegion: Swift.String?
    /// The type of endpoint for your gateway. Valid Values: STANDARD | FIPS
    public var endpointType: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// Specifies the size of the gateway's metadata cache.
    public var gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations.
    public var gatewayId: Swift.String?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?
    /// A [NetworkInterface] array that contains descriptions of the gateway network interfaces.
    public var gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]?
    /// A value that indicates the operating state of the gateway.
    public var gatewayState: Swift.String?
    /// A value that indicates the time zone configured for the gateway.
    public var gatewayTimezone: Swift.String?
    /// The type of the gateway.
    public var gatewayType: Swift.String?
    /// The type of hardware or software platform on which the gateway is running.
    public var hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
    /// A unique identifier for the specific instance of the host platform running the gateway. This value is only available for certain host environments, and its format depends on the host environment type.
    public var hostEnvironmentId: Swift.String?
    /// The date on which the last software update was applied to the gateway. If the gateway has never been updated, this field does not return a value in the response. This only only exist and returns once it have been chosen and set by the SGW service, based on the OS version of the gateway VM
    public var lastSoftwareUpdate: Swift.String?
    /// The date on which an update to the gateway is available. This date is in the time zone of the gateway. If the gateway is not available for an update this field is not returned in the response.
    public var nextUpdateAvailabilityDate: Swift.String?
    /// Date after which this gateway will not receive software updates for new features.
    public var softwareUpdatesEndDate: Swift.String?
    /// A list of the metadata cache sizes that the gateway can support based on its current hardware specifications.
    public var supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]?
    /// A list of up to 50 tags assigned to the gateway, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The configuration settings for the virtual private cloud (VPC) endpoint for your gateway.
    public var vpcEndpoint: Swift.String?

    public init (
        cloudWatchLogGroupARN: Swift.String? = nil,
        deprecationDate: Swift.String? = nil,
        ec2InstanceId: Swift.String? = nil,
        ec2InstanceRegion: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]? = nil,
        gatewayState: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil,
        gatewayType: Swift.String? = nil,
        hostEnvironment: StorageGatewayClientTypes.HostEnvironment? = nil,
        hostEnvironmentId: Swift.String? = nil,
        lastSoftwareUpdate: Swift.String? = nil,
        nextUpdateAvailabilityDate: Swift.String? = nil,
        softwareUpdatesEndDate: Swift.String? = nil,
        supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        vpcEndpoint: Swift.String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.deprecationDate = deprecationDate
        self.ec2InstanceId = ec2InstanceId
        self.ec2InstanceRegion = ec2InstanceRegion
        self.endpointType = endpointType
        self.gatewayARN = gatewayARN
        self.gatewayCapacity = gatewayCapacity
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayNetworkInterfaces = gatewayNetworkInterfaces
        self.gatewayState = gatewayState
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.hostEnvironment = hostEnvironment
        self.hostEnvironmentId = hostEnvironmentId
        self.lastSoftwareUpdate = lastSoftwareUpdate
        self.nextUpdateAvailabilityDate = nextUpdateAvailabilityDate
        self.softwareUpdatesEndDate = softwareUpdatesEndDate
        self.supportedGatewayCapacities = supportedGatewayCapacities
        self.tags = tags
        self.vpcEndpoint = vpcEndpoint
    }
}

struct DescribeGatewayInformationOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let gatewayId: Swift.String?
    let gatewayName: Swift.String?
    let gatewayTimezone: Swift.String?
    let gatewayState: Swift.String?
    let gatewayNetworkInterfaces: [StorageGatewayClientTypes.NetworkInterface]?
    let gatewayType: Swift.String?
    let nextUpdateAvailabilityDate: Swift.String?
    let lastSoftwareUpdate: Swift.String?
    let ec2InstanceId: Swift.String?
    let ec2InstanceRegion: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
    let vpcEndpoint: Swift.String?
    let cloudWatchLogGroupARN: Swift.String?
    let hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
    let endpointType: Swift.String?
    let softwareUpdatesEndDate: Swift.String?
    let deprecationDate: Swift.String?
    let gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    let supportedGatewayCapacities: [StorageGatewayClientTypes.GatewayCapacity]?
    let hostEnvironmentId: Swift.String?
}

extension DescribeGatewayInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case deprecationDate = "DeprecationDate"
        case ec2InstanceId = "Ec2InstanceId"
        case ec2InstanceRegion = "Ec2InstanceRegion"
        case endpointType = "EndpointType"
        case gatewayARN = "GatewayARN"
        case gatewayCapacity = "GatewayCapacity"
        case gatewayId = "GatewayId"
        case gatewayName = "GatewayName"
        case gatewayNetworkInterfaces = "GatewayNetworkInterfaces"
        case gatewayState = "GatewayState"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case hostEnvironment = "HostEnvironment"
        case hostEnvironmentId = "HostEnvironmentId"
        case lastSoftwareUpdate = "LastSoftwareUpdate"
        case nextUpdateAvailabilityDate = "NextUpdateAvailabilityDate"
        case softwareUpdatesEndDate = "SoftwareUpdatesEndDate"
        case supportedGatewayCapacities = "SupportedGatewayCapacities"
        case tags = "Tags"
        case vpcEndpoint = "VPCEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let gatewayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayState)
        gatewayState = gatewayStateDecoded
        let gatewayNetworkInterfacesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.NetworkInterface?].self, forKey: .gatewayNetworkInterfaces)
        var gatewayNetworkInterfacesDecoded0:[StorageGatewayClientTypes.NetworkInterface]? = nil
        if let gatewayNetworkInterfacesContainer = gatewayNetworkInterfacesContainer {
            gatewayNetworkInterfacesDecoded0 = [StorageGatewayClientTypes.NetworkInterface]()
            for structure0 in gatewayNetworkInterfacesContainer {
                if let structure0 = structure0 {
                    gatewayNetworkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        gatewayNetworkInterfaces = gatewayNetworkInterfacesDecoded0
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let nextUpdateAvailabilityDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextUpdateAvailabilityDate)
        nextUpdateAvailabilityDate = nextUpdateAvailabilityDateDecoded
        let lastSoftwareUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSoftwareUpdate)
        lastSoftwareUpdate = lastSoftwareUpdateDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ec2InstanceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceRegion)
        ec2InstanceRegion = ec2InstanceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vpcEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpoint)
        vpcEndpoint = vpcEndpointDecoded
        let cloudWatchLogGroupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupARN)
        cloudWatchLogGroupARN = cloudWatchLogGroupARNDecoded
        let hostEnvironmentDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.HostEnvironment.self, forKey: .hostEnvironment)
        hostEnvironment = hostEnvironmentDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let softwareUpdatesEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareUpdatesEndDate)
        softwareUpdatesEndDate = softwareUpdatesEndDateDecoded
        let deprecationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
        let gatewayCapacityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.GatewayCapacity.self, forKey: .gatewayCapacity)
        gatewayCapacity = gatewayCapacityDecoded
        let supportedGatewayCapacitiesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.GatewayCapacity?].self, forKey: .supportedGatewayCapacities)
        var supportedGatewayCapacitiesDecoded0:[StorageGatewayClientTypes.GatewayCapacity]? = nil
        if let supportedGatewayCapacitiesContainer = supportedGatewayCapacitiesContainer {
            supportedGatewayCapacitiesDecoded0 = [StorageGatewayClientTypes.GatewayCapacity]()
            for string0 in supportedGatewayCapacitiesContainer {
                if let string0 = string0 {
                    supportedGatewayCapacitiesDecoded0?.append(string0)
                }
            }
        }
        supportedGatewayCapacities = supportedGatewayCapacitiesDecoded0
        let hostEnvironmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostEnvironmentId)
        hostEnvironmentId = hostEnvironmentIdDecoded
    }
}

extension DescribeMaintenanceStartTimeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeMaintenanceStartTimeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeMaintenanceStartTimeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeMaintenanceStartTimeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeMaintenanceStartTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeMaintenanceStartTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceStartTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMaintenanceStartTimeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceStartTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dayOfMonth = output.dayOfMonth
            self.dayOfWeek = output.dayOfWeek
            self.gatewayARN = output.gatewayARN
            self.hourOfDay = output.hourOfDay
            self.minuteOfHour = output.minuteOfHour
            self.timezone = output.timezone
        } else {
            self.dayOfMonth = nil
            self.dayOfWeek = nil
            self.gatewayARN = nil
            self.hourOfDay = nil
            self.minuteOfHour = nil
            self.timezone = nil
        }
    }
}

/// A JSON object containing the following fields:
///
/// * [DescribeMaintenanceStartTimeOutput$DayOfMonth]
///
/// * [DescribeMaintenanceStartTimeOutput$DayOfWeek]
///
/// * [DescribeMaintenanceStartTimeOutput$HourOfDay]
///
/// * [DescribeMaintenanceStartTimeOutput$MinuteOfHour]
///
/// * [DescribeMaintenanceStartTimeOutput$Timezone]
public struct DescribeMaintenanceStartTimeOutputResponse: Swift.Equatable {
    /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
    public var dayOfMonth: Swift.Int?
    /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
    public var hourOfDay: Swift.Int?
    /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
    public var minuteOfHour: Swift.Int?
    /// A value that indicates the time zone that is set for the gateway. The start time and day of week specified should be in the time zone of the gateway.
    public var timezone: Swift.String?

    public init (
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
        self.timezone = timezone
    }
}

struct DescribeMaintenanceStartTimeOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let hourOfDay: Swift.Int?
    let minuteOfHour: Swift.Int?
    let dayOfWeek: Swift.Int?
    let dayOfMonth: Swift.Int?
    let timezone: Swift.String?
}

extension DescribeMaintenanceStartTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
        case timezone = "Timezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

extension DescribeNFSFileSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARNList = fileShareARNList {
            var fileShareARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileShareARNList)
            for filesharearn0 in fileShareARNList {
                try fileShareARNListContainer.encode(filesharearn0)
            }
        }
    }
}

extension DescribeNFSFileSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeNFSFileSharesInput
public struct DescribeNFSFileSharesInput: Swift.Equatable {
    /// An array containing the Amazon Resource Name (ARN) of each file share to be described.
    /// This member is required.
    public var fileShareARNList: [Swift.String]?

    public init (
        fileShareARNList: [Swift.String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

struct DescribeNFSFileSharesInputBody: Swift.Equatable {
    let fileShareARNList: [Swift.String]?
}

extension DescribeNFSFileSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileShareARNList)
        var fileShareARNListDecoded0:[Swift.String]? = nil
        if let fileShareARNListContainer = fileShareARNListContainer {
            fileShareARNListDecoded0 = [Swift.String]()
            for string0 in fileShareARNListContainer {
                if let string0 = string0 {
                    fileShareARNListDecoded0?.append(string0)
                }
            }
        }
        fileShareARNList = fileShareARNListDecoded0
    }
}

extension DescribeNFSFileSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNFSFileSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNFSFileSharesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNFSFileSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNFSFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nfsFileShareInfoList = output.nfsFileShareInfoList
        } else {
            self.nfsFileShareInfoList = nil
        }
    }
}

/// DescribeNFSFileSharesOutput
public struct DescribeNFSFileSharesOutputResponse: Swift.Equatable {
    /// An array containing a description for each requested file share.
    public var nfsFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]?

    public init (
        nfsFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]? = nil
    )
    {
        self.nfsFileShareInfoList = nfsFileShareInfoList
    }
}

struct DescribeNFSFileSharesOutputResponseBody: Swift.Equatable {
    let nfsFileShareInfoList: [StorageGatewayClientTypes.NFSFileShareInfo]?
}

extension DescribeNFSFileSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nfsFileShareInfoList = "NFSFileShareInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nfsFileShareInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.NFSFileShareInfo?].self, forKey: .nfsFileShareInfoList)
        var nfsFileShareInfoListDecoded0:[StorageGatewayClientTypes.NFSFileShareInfo]? = nil
        if let nfsFileShareInfoListContainer = nfsFileShareInfoListContainer {
            nfsFileShareInfoListDecoded0 = [StorageGatewayClientTypes.NFSFileShareInfo]()
            for structure0 in nfsFileShareInfoListContainer {
                if let structure0 = structure0 {
                    nfsFileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        nfsFileShareInfoList = nfsFileShareInfoListDecoded0
    }
}

extension DescribeSMBFileSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARNList = fileShareARNList {
            var fileShareARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileShareARNList)
            for filesharearn0 in fileShareARNList {
                try fileShareARNListContainer.encode(filesharearn0)
            }
        }
    }
}

extension DescribeSMBFileSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeSMBFileSharesInput
public struct DescribeSMBFileSharesInput: Swift.Equatable {
    /// An array containing the Amazon Resource Name (ARN) of each file share to be described.
    /// This member is required.
    public var fileShareARNList: [Swift.String]?

    public init (
        fileShareARNList: [Swift.String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

struct DescribeSMBFileSharesInputBody: Swift.Equatable {
    let fileShareARNList: [Swift.String]?
}

extension DescribeSMBFileSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileShareARNList)
        var fileShareARNListDecoded0:[Swift.String]? = nil
        if let fileShareARNListContainer = fileShareARNListContainer {
            fileShareARNListDecoded0 = [Swift.String]()
            for string0 in fileShareARNListContainer {
                if let string0 = string0 {
                    fileShareARNListDecoded0?.append(string0)
                }
            }
        }
        fileShareARNList = fileShareARNListDecoded0
    }
}

extension DescribeSMBFileSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSMBFileSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSMBFileSharesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSMBFileSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSMBFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.smbFileShareInfoList = output.smbFileShareInfoList
        } else {
            self.smbFileShareInfoList = nil
        }
    }
}

/// DescribeSMBFileSharesOutput
public struct DescribeSMBFileSharesOutputResponse: Swift.Equatable {
    /// An array containing a description for each requested file share.
    public var smbFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]?

    public init (
        smbFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]? = nil
    )
    {
        self.smbFileShareInfoList = smbFileShareInfoList
    }
}

struct DescribeSMBFileSharesOutputResponseBody: Swift.Equatable {
    let smbFileShareInfoList: [StorageGatewayClientTypes.SMBFileShareInfo]?
}

extension DescribeSMBFileSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case smbFileShareInfoList = "SMBFileShareInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smbFileShareInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.SMBFileShareInfo?].self, forKey: .smbFileShareInfoList)
        var smbFileShareInfoListDecoded0:[StorageGatewayClientTypes.SMBFileShareInfo]? = nil
        if let smbFileShareInfoListContainer = smbFileShareInfoListContainer {
            smbFileShareInfoListDecoded0 = [StorageGatewayClientTypes.SMBFileShareInfo]()
            for structure0 in smbFileShareInfoListContainer {
                if let structure0 = structure0 {
                    smbFileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        smbFileShareInfoList = smbFileShareInfoListDecoded0
    }
}

extension DescribeSMBSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeSMBSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSMBSettingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeSMBSettingsInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeSMBSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeSMBSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSMBSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSMBSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSMBSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSMBSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeDirectoryStatus = output.activeDirectoryStatus
            self.domainName = output.domainName
            self.fileSharesVisible = output.fileSharesVisible
            self.gatewayARN = output.gatewayARN
            self.smbGuestPasswordSet = output.smbGuestPasswordSet
            self.smbLocalGroups = output.smbLocalGroups
            self.smbSecurityStrategy = output.smbSecurityStrategy
        } else {
            self.activeDirectoryStatus = nil
            self.domainName = nil
            self.fileSharesVisible = nil
            self.gatewayARN = nil
            self.smbGuestPasswordSet = nil
            self.smbLocalGroups = nil
            self.smbSecurityStrategy = nil
        }
    }
}

public struct DescribeSMBSettingsOutputResponse: Swift.Equatable {
    /// Indicates the status of a gateway that is a member of the Active Directory domain.
    ///
    /// * ACCESS_DENIED: Indicates that the JoinDomain operation failed due to an authentication error.
    ///
    /// * DETACHED: Indicates that gateway is not joined to a domain.
    ///
    /// * JOINED: Indicates that the gateway has successfully joined a domain.
    ///
    /// * JOINING: Indicates that a JoinDomain operation is in progress.
    ///
    /// * NETWORK_ERROR: Indicates that JoinDomain operation failed due to a network or connectivity error.
    ///
    /// * TIMEOUT: Indicates that the JoinDomain operation failed because the operation didn't complete within the allotted time.
    ///
    /// * UNKNOWN_ERROR: Indicates that the JoinDomain operation failed due to another type of error.
    public var activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    /// The name of the domain that the gateway is joined to.
    public var domainName: Swift.String?
    /// The shares on this gateway appear when listing shares. Only supported for S3 File Gateways.
    public var fileSharesVisible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// This value is true if a password for the guest user smbguest is set, otherwise false. Only supported for S3 File Gateways. Valid Values: true | false
    public var smbGuestPasswordSet: Swift.Bool?
    /// A list of Active Directory users and groups that have special permissions for SMB file shares on the gateway.
    public var smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups?
    /// The type of security strategy that was specified for file gateway.
    ///
    /// * ClientSpecified: If you use this option, requests are established based on what is negotiated by the client. This option is recommended when you want to maximize compatibility across different clients in your environment. Only supported for S3 File Gateways.
    ///
    /// * MandatorySigning: If you use this option, file gateway only allows connections from SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on Microsoft Windows Vista, Windows Server 2008 or newer.
    ///
    /// * MandatoryEncryption: If you use this option, file gateway only allows connections from SMBv3 clients that have encryption enabled. This option is highly recommended for environments that handle sensitive data. This option works with SMB clients on Microsoft Windows 8, Windows Server 2012 or newer.
    public var smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?

    public init (
        activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus? = nil,
        domainName: Swift.String? = nil,
        fileSharesVisible: Swift.Bool? = nil,
        gatewayARN: Swift.String? = nil,
        smbGuestPasswordSet: Swift.Bool? = nil,
        smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups? = nil,
        smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.domainName = domainName
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
        self.smbGuestPasswordSet = smbGuestPasswordSet
        self.smbLocalGroups = smbLocalGroups
        self.smbSecurityStrategy = smbSecurityStrategy
    }
}

struct DescribeSMBSettingsOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let domainName: Swift.String?
    let activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    let smbGuestPasswordSet: Swift.Bool?
    let smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?
    let fileSharesVisible: Swift.Bool?
    let smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups?
}

extension DescribeSMBSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryStatus = "ActiveDirectoryStatus"
        case domainName = "DomainName"
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
        case smbGuestPasswordSet = "SMBGuestPasswordSet"
        case smbLocalGroups = "SMBLocalGroups"
        case smbSecurityStrategy = "SMBSecurityStrategy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeDirectoryStatusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ActiveDirectoryStatus.self, forKey: .activeDirectoryStatus)
        activeDirectoryStatus = activeDirectoryStatusDecoded
        let smbGuestPasswordSetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smbGuestPasswordSet)
        smbGuestPasswordSet = smbGuestPasswordSetDecoded
        let smbSecurityStrategyDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.SMBSecurityStrategy.self, forKey: .smbSecurityStrategy)
        smbSecurityStrategy = smbSecurityStrategyDecoded
        let fileSharesVisibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fileSharesVisible)
        fileSharesVisible = fileSharesVisibleDecoded
        let smbLocalGroupsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.SMBLocalGroups.self, forKey: .smbLocalGroups)
        smbLocalGroups = smbLocalGroupsDecoded
    }
}

extension DescribeSnapshotScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension DescribeSnapshotScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the [DescribeSnapshotScheduleInput$VolumeARN] of the volume.
public struct DescribeSnapshotScheduleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DescribeSnapshotScheduleInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension DescribeSnapshotScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DescribeSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.recurrenceInHours = output.recurrenceInHours
            self.startAt = output.startAt
            self.tags = output.tags
            self.timezone = output.timezone
            self.volumeARN = output.volumeARN
        } else {
            self.description = nil
            self.recurrenceInHours = nil
            self.startAt = nil
            self.tags = nil
            self.timezone = nil
            self.volumeARN = nil
        }
    }
}

public struct DescribeSnapshotScheduleOutputResponse: Swift.Equatable {
    /// The snapshot description.
    public var description: Swift.String?
    /// The number of hours between snapshots.
    public var recurrenceInHours: Swift.Int?
    /// The hour of the day at which the snapshot schedule begins represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
    public var startAt: Swift.Int?
    /// A list of up to 50 tags assigned to the snapshot schedule, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// A value that indicates the time zone of the gateway.
    public var timezone: Swift.String?
    /// The Amazon Resource Name (ARN) of the volume that was specified in the request.
    public var volumeARN: Swift.String?

    public init (
        description: Swift.String? = nil,
        recurrenceInHours: Swift.Int? = nil,
        startAt: Swift.Int? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        timezone: Swift.String? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.timezone = timezone
        self.volumeARN = volumeARN
    }
}

struct DescribeSnapshotScheduleOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let startAt: Swift.Int?
    let recurrenceInHours: Swift.Int?
    let description: Swift.String?
    let timezone: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension DescribeSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case timezone = "Timezone"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let startAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startAt)
        startAt = startAtDecoded
        let recurrenceInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurrenceInHours)
        recurrenceInHours = recurrenceInHoursDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeStorediSCSIVolumesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARNs = volumeARNs {
            var volumeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeARNs)
            for volumearn0 in volumeARNs {
                try volumeARNsContainer.encode(volumearn0)
            }
        }
    }
}

extension DescribeStorediSCSIVolumesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing a list of [DescribeStorediSCSIVolumesInput$VolumeARNs].
public struct DescribeStorediSCSIVolumesInput: Swift.Equatable {
    /// An array of strings where each string represents the Amazon Resource Name (ARN) of a stored volume. All of the specified stored volumes must be from the same gateway. Use [ListVolumes] to get volume ARNs for a gateway.
    /// This member is required.
    public var volumeARNs: [Swift.String]?

    public init (
        volumeARNs: [Swift.String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

struct DescribeStorediSCSIVolumesInputBody: Swift.Equatable {
    let volumeARNs: [Swift.String]?
}

extension DescribeStorediSCSIVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .volumeARNs)
        var volumeARNsDecoded0:[Swift.String]? = nil
        if let volumeARNsContainer = volumeARNsContainer {
            volumeARNsDecoded0 = [Swift.String]()
            for string0 in volumeARNsContainer {
                if let string0 = string0 {
                    volumeARNsDecoded0?.append(string0)
                }
            }
        }
        volumeARNs = volumeARNsDecoded0
    }
}

extension DescribeStorediSCSIVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStorediSCSIVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeStorediSCSIVolumesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorediSCSIVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeStorediSCSIVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.storediSCSIVolumes = output.storediSCSIVolumes
        } else {
            self.storediSCSIVolumes = nil
        }
    }
}

public struct DescribeStorediSCSIVolumesOutputResponse: Swift.Equatable {
    /// Describes a single unit of output from [DescribeStorediSCSIVolumes]. The following fields are returned:
    ///
    /// * ChapEnabled: Indicates whether mutual CHAP is enabled for the iSCSI target.
    ///
    /// * LunNumber: The logical disk number.
    ///
    /// * NetworkInterfaceId: The network interface ID of the stored volume that initiator use to map the stored volume as an iSCSI target.
    ///
    /// * NetworkInterfacePort: The port used to communicate with iSCSI targets.
    ///
    /// * PreservedExistingData: Indicates when the stored volume was created, existing data on the underlying local disk was preserved.
    ///
    /// * SourceSnapshotId: If the stored volume was created from a snapshot, this field contains the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not included.
    ///
    /// * StorediSCSIVolumes: An array of StorediSCSIVolume objects where each object contains metadata about one stored volume.
    ///
    /// * TargetARN: The Amazon Resource Name (ARN) of the volume target.
    ///
    /// * VolumeARN: The Amazon Resource Name (ARN) of the stored volume.
    ///
    /// * VolumeDiskId: The disk ID of the local disk that was specified in the [CreateStorediSCSIVolume] operation.
    ///
    /// * VolumeId: The unique identifier of the storage volume, e.g. vol-1122AABB.
    ///
    /// * VolumeiSCSIAttributes: An [VolumeiSCSIAttributes] object that represents a collection of iSCSI attributes for one stored volume.
    ///
    /// * VolumeProgress: Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the stored volume is not restoring or bootstrapping.
    ///
    /// * VolumeSizeInBytes: The size of the volume in bytes.
    ///
    /// * VolumeStatus: One of the VolumeStatus values that indicates the state of the volume.
    ///
    /// * VolumeType: One of the enumeration values describing the type of the volume. Currently, only STORED volumes are supported.
    public var storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]?

    public init (
        storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]? = nil
    )
    {
        self.storediSCSIVolumes = storediSCSIVolumes
    }
}

struct DescribeStorediSCSIVolumesOutputResponseBody: Swift.Equatable {
    let storediSCSIVolumes: [StorageGatewayClientTypes.StorediSCSIVolume]?
}

extension DescribeStorediSCSIVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storediSCSIVolumes = "StorediSCSIVolumes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storediSCSIVolumesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.StorediSCSIVolume?].self, forKey: .storediSCSIVolumes)
        var storediSCSIVolumesDecoded0:[StorageGatewayClientTypes.StorediSCSIVolume]? = nil
        if let storediSCSIVolumesContainer = storediSCSIVolumesContainer {
            storediSCSIVolumesDecoded0 = [StorageGatewayClientTypes.StorediSCSIVolume]()
            for structure0 in storediSCSIVolumesContainer {
                if let structure0 = structure0 {
                    storediSCSIVolumesDecoded0?.append(structure0)
                }
            }
        }
        storediSCSIVolumes = storediSCSIVolumesDecoded0
    }
}

extension DescribeTapeArchivesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearn0 in tapeARNs {
                try tapeARNsContainer.encode(tapearn0)
            }
        }
    }
}

extension DescribeTapeArchivesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeTapeArchivesInput
public struct DescribeTapeArchivesInput: Swift.Equatable {
    /// Specifies that the number of virtual tapes described be limited to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing virtual tapes.
    public var marker: Swift.String?
    /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual tapes you want to describe.
    public var tapeARNs: [Swift.String]?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct DescribeTapeArchivesInputBody: Swift.Equatable {
    let tapeARNs: [Swift.String]?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension DescribeTapeArchivesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapeArchivesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapeArchivesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTapeArchivesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapeArchivesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTapeArchivesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tapeArchives = output.tapeArchives
        } else {
            self.marker = nil
            self.tapeArchives = nil
        }
    }
}

/// DescribeTapeArchivesOutput
public struct DescribeTapeArchivesOutputResponse: Swift.Equatable {
    /// An opaque string that indicates the position at which the virtual tapes that were fetched for description ended. Use this marker in your next request to fetch the next set of virtual tapes in the virtual tape shelf (VTS). If there are no more virtual tapes to describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of virtual tape objects in the virtual tape shelf (VTS). The description includes of the Amazon Resource Name (ARN) of the virtual tapes. The information returned includes the Amazon Resource Names (ARNs) of the tapes, size of the tapes, status of the tapes, progress of the description, and tape barcode.
    public var tapeArchives: [StorageGatewayClientTypes.TapeArchive]?

    public init (
        marker: Swift.String? = nil,
        tapeArchives: [StorageGatewayClientTypes.TapeArchive]? = nil
    )
    {
        self.marker = marker
        self.tapeArchives = tapeArchives
    }
}

struct DescribeTapeArchivesOutputResponseBody: Swift.Equatable {
    let tapeArchives: [StorageGatewayClientTypes.TapeArchive]?
    let marker: Swift.String?
}

extension DescribeTapeArchivesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tapeArchives = "TapeArchives"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeArchivesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.TapeArchive?].self, forKey: .tapeArchives)
        var tapeArchivesDecoded0:[StorageGatewayClientTypes.TapeArchive]? = nil
        if let tapeArchivesContainer = tapeArchivesContainer {
            tapeArchivesDecoded0 = [StorageGatewayClientTypes.TapeArchive]()
            for structure0 in tapeArchivesContainer {
                if let structure0 = structure0 {
                    tapeArchivesDecoded0?.append(structure0)
                }
            }
        }
        tapeArchives = tapeArchivesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeTapeRecoveryPointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

extension DescribeTapeRecoveryPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeTapeRecoveryPointsInput
public struct DescribeTapeRecoveryPointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of virtual tape recovery points that are described be limited to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing the virtual tape recovery points.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeTapeRecoveryPointsInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension DescribeTapeRecoveryPointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapeRecoveryPointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapeRecoveryPointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTapeRecoveryPointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapeRecoveryPointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTapeRecoveryPointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.tapeRecoveryPointInfos = output.tapeRecoveryPointInfos
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.tapeRecoveryPointInfos = nil
        }
    }
}

/// DescribeTapeRecoveryPointsOutput
public struct DescribeTapeRecoveryPointsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// An opaque string that indicates the position at which the virtual tape recovery points that were listed for description ended. Use this marker in your next request to list the next set of virtual tape recovery points in the list. If there are no more recovery points to describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of TapeRecoveryPointInfos that are available for the specified gateway.
    public var tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]?

    public init (
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.tapeRecoveryPointInfos = tapeRecoveryPointInfos
    }
}

struct DescribeTapeRecoveryPointsOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeRecoveryPointInfos: [StorageGatewayClientTypes.TapeRecoveryPointInfo]?
    let marker: Swift.String?
}

extension DescribeTapeRecoveryPointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case tapeRecoveryPointInfos = "TapeRecoveryPointInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeRecoveryPointInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.TapeRecoveryPointInfo?].self, forKey: .tapeRecoveryPointInfos)
        var tapeRecoveryPointInfosDecoded0:[StorageGatewayClientTypes.TapeRecoveryPointInfo]? = nil
        if let tapeRecoveryPointInfosContainer = tapeRecoveryPointInfosContainer {
            tapeRecoveryPointInfosDecoded0 = [StorageGatewayClientTypes.TapeRecoveryPointInfo]()
            for structure0 in tapeRecoveryPointInfosContainer {
                if let structure0 = structure0 {
                    tapeRecoveryPointInfosDecoded0?.append(structure0)
                }
            }
        }
        tapeRecoveryPointInfos = tapeRecoveryPointInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeTapesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearn0 in tapeARNs {
                try tapeARNsContainer.encode(tapearn0)
            }
        }
    }
}

extension DescribeTapesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeTapesInput
public struct DescribeTapesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of virtual tapes described be limited to the specified number. Amazon Web Services may impose its own limit, if this field is not set.
    public var limit: Swift.Int?
    /// A marker value, obtained in a previous call to DescribeTapes. This marker indicates which page of results to retrieve. If not specified, the first page of results is retrieved.
    public var marker: Swift.String?
    /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual tapes you want to describe. If this parameter is not specified, Tape gateway returns a description of all virtual tapes associated with the specified gateway.
    public var tapeARNs: [Swift.String]?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct DescribeTapesInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let tapeARNs: [Swift.String]?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension DescribeTapesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTapesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTapesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tapes = output.tapes
        } else {
            self.marker = nil
            self.tapes = nil
        }
    }
}

/// DescribeTapesOutput
public struct DescribeTapesOutputResponse: Swift.Equatable {
    /// An opaque string that can be used as part of a subsequent DescribeTapes call to retrieve the next page of results. If a response does not contain a marker, then there are no more results to be retrieved.
    public var marker: Swift.String?
    /// An array of virtual tape descriptions.
    public var tapes: [StorageGatewayClientTypes.Tape]?

    public init (
        marker: Swift.String? = nil,
        tapes: [StorageGatewayClientTypes.Tape]? = nil
    )
    {
        self.marker = marker
        self.tapes = tapes
    }
}

struct DescribeTapesOutputResponseBody: Swift.Equatable {
    let tapes: [StorageGatewayClientTypes.Tape]?
    let marker: Swift.String?
}

extension DescribeTapesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tapes = "Tapes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tape?].self, forKey: .tapes)
        var tapesDecoded0:[StorageGatewayClientTypes.Tape]? = nil
        if let tapesContainer = tapesContainer {
            tapesDecoded0 = [StorageGatewayClientTypes.Tape]()
            for structure0 in tapesContainer {
                if let structure0 = structure0 {
                    tapesDecoded0?.append(structure0)
                }
            }
        }
        tapes = tapesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeUploadBufferInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeUploadBufferInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUploadBufferInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeUploadBufferInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeUploadBufferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeUploadBufferOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUploadBufferOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeUploadBufferOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUploadBufferOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeUploadBufferOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
            self.uploadBufferAllocatedInBytes = output.uploadBufferAllocatedInBytes
            self.uploadBufferUsedInBytes = output.uploadBufferUsedInBytes
        } else {
            self.diskIds = nil
            self.gatewayARN = nil
            self.uploadBufferAllocatedInBytes = 0
            self.uploadBufferUsedInBytes = 0
        }
    }
}

public struct DescribeUploadBufferOutputResponse: Swift.Equatable {
    /// An array of the gateway's local disk IDs that are configured as working storage. Each local disk ID is specified as a string (minimum length of 1 and maximum length of 300). If no local disks are configured as working storage, then the DiskIds array is empty.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The total number of bytes allocated in the gateway's as upload buffer.
    public var uploadBufferAllocatedInBytes: Swift.Int
    /// The total number of bytes being used in the gateway's upload buffer.
    public var uploadBufferUsedInBytes: Swift.Int

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil,
        uploadBufferAllocatedInBytes: Swift.Int = 0,
        uploadBufferUsedInBytes: Swift.Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes
        self.uploadBufferUsedInBytes = uploadBufferUsedInBytes
    }
}

struct DescribeUploadBufferOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskIds: [Swift.String]?
    let uploadBufferUsedInBytes: Swift.Int
    let uploadBufferAllocatedInBytes: Swift.Int
}

extension DescribeUploadBufferOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
        case uploadBufferAllocatedInBytes = "UploadBufferAllocatedInBytes"
        case uploadBufferUsedInBytes = "UploadBufferUsedInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let uploadBufferUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uploadBufferUsedInBytes) ?? 0
        uploadBufferUsedInBytes = uploadBufferUsedInBytesDecoded
        let uploadBufferAllocatedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uploadBufferAllocatedInBytes) ?? 0
        uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytesDecoded
    }
}

extension DescribeVTLDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case vtlDeviceARNs = "VTLDeviceARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let vtlDeviceARNs = vtlDeviceARNs {
            var vtlDeviceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vtlDeviceARNs)
            for vtldevicearn0 in vtlDeviceARNs {
                try vtlDeviceARNsContainer.encode(vtldevicearn0)
            }
        }
    }
}

extension DescribeVTLDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeVTLDevicesInput
public struct DescribeVTLDevicesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies that the number of VTL devices described be limited to the specified number.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin describing the VTL devices.
    public var marker: Swift.String?
    /// An array of strings, where each string represents the Amazon Resource Name (ARN) of a VTL device. All of the specified VTL devices must be from the same gateway. If no VTL devices are specified, the result will contain all devices on the specified gateway.
    public var vtlDeviceARNs: [Swift.String]?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        vtlDeviceARNs: [Swift.String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.vtlDeviceARNs = vtlDeviceARNs
    }
}

struct DescribeVTLDevicesInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let vtlDeviceARNs: [Swift.String]?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension DescribeVTLDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case vtlDeviceARNs = "VTLDeviceARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let vtlDeviceARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vtlDeviceARNs)
        var vtlDeviceARNsDecoded0:[Swift.String]? = nil
        if let vtlDeviceARNsContainer = vtlDeviceARNsContainer {
            vtlDeviceARNsDecoded0 = [Swift.String]()
            for string0 in vtlDeviceARNsContainer {
                if let string0 = string0 {
                    vtlDeviceARNsDecoded0?.append(string0)
                }
            }
        }
        vtlDeviceARNs = vtlDeviceARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeVTLDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVTLDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVTLDevicesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVTLDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVTLDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.vtlDevices = output.vtlDevices
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.vtlDevices = nil
        }
    }
}

/// DescribeVTLDevicesOutput
public struct DescribeVTLDevicesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// An opaque string that indicates the position at which the VTL devices that were fetched for description ended. Use the marker in your next request to fetch the next set of VTL devices in the list. If there are no more VTL devices to describe, this field does not appear in the response.
    public var marker: Swift.String?
    /// An array of VTL device objects composed of the Amazon Resource Name (ARN) of the VTL devices.
    public var vtlDevices: [StorageGatewayClientTypes.VTLDevice]?

    public init (
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        vtlDevices: [StorageGatewayClientTypes.VTLDevice]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.vtlDevices = vtlDevices
    }
}

struct DescribeVTLDevicesOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let vtlDevices: [StorageGatewayClientTypes.VTLDevice]?
    let marker: Swift.String?
}

extension DescribeVTLDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case vtlDevices = "VTLDevices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let vtlDevicesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.VTLDevice?].self, forKey: .vtlDevices)
        var vtlDevicesDecoded0:[StorageGatewayClientTypes.VTLDevice]? = nil
        if let vtlDevicesContainer = vtlDevicesContainer {
            vtlDevicesDecoded0 = [StorageGatewayClientTypes.VTLDevice]()
            for structure0 in vtlDevicesContainer {
                if let structure0 = structure0 {
                    vtlDevicesDecoded0?.append(structure0)
                }
            }
        }
        vtlDevices = vtlDevicesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeWorkingStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DescribeWorkingStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct DescribeWorkingStorageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeWorkingStorageInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DescribeWorkingStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeWorkingStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkingStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkingStorageOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkingStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkingStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
            self.workingStorageAllocatedInBytes = output.workingStorageAllocatedInBytes
            self.workingStorageUsedInBytes = output.workingStorageUsedInBytes
        } else {
            self.diskIds = nil
            self.gatewayARN = nil
            self.workingStorageAllocatedInBytes = 0
            self.workingStorageUsedInBytes = 0
        }
    }
}

/// A JSON object containing the following fields:
public struct DescribeWorkingStorageOutputResponse: Swift.Equatable {
    /// An array of the gateway's local disk IDs that are configured as working storage. Each local disk ID is specified as a string (minimum length of 1 and maximum length of 300). If no local disks are configured as working storage, then the DiskIds array is empty.
    public var diskIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The total working storage in bytes allocated for the gateway. If no working storage is configured for the gateway, this field returns 0.
    public var workingStorageAllocatedInBytes: Swift.Int
    /// The total working storage in bytes in use by the gateway. If no working storage is configured for the gateway, this field returns 0.
    public var workingStorageUsedInBytes: Swift.Int

    public init (
        diskIds: [Swift.String]? = nil,
        gatewayARN: Swift.String? = nil,
        workingStorageAllocatedInBytes: Swift.Int = 0,
        workingStorageUsedInBytes: Swift.Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.workingStorageAllocatedInBytes = workingStorageAllocatedInBytes
        self.workingStorageUsedInBytes = workingStorageUsedInBytes
    }
}

struct DescribeWorkingStorageOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let diskIds: [Swift.String]?
    let workingStorageUsedInBytes: Swift.Int
    let workingStorageAllocatedInBytes: Swift.Int
}

extension DescribeWorkingStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
        case workingStorageAllocatedInBytes = "WorkingStorageAllocatedInBytes"
        case workingStorageUsedInBytes = "WorkingStorageUsedInBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[Swift.String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [Swift.String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let workingStorageUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workingStorageUsedInBytes) ?? 0
        workingStorageUsedInBytes = workingStorageUsedInBytesDecoded
        let workingStorageAllocatedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workingStorageAllocatedInBytes) ?? 0
        workingStorageAllocatedInBytes = workingStorageAllocatedInBytesDecoded
    }
}

extension DetachVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDetach = "ForceDetach"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceDetach = self.forceDetach {
            try encodeContainer.encode(forceDetach, forKey: .forceDetach)
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension DetachVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// AttachVolumeInput
public struct DetachVolumeInput: Swift.Equatable {
    /// Set to true to forcibly remove the iSCSI connection of the target volume and detach the volume. The default is false. If this value is set to false, you must manually disconnect the iSCSI connection from the target volume. Valid Values: true | false
    public var forceDetach: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the volume to detach from the gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        forceDetach: Swift.Bool? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.forceDetach = forceDetach
        self.volumeARN = volumeARN
    }
}

struct DetachVolumeInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let forceDetach: Swift.Bool?
}

extension DetachVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceDetach = "ForceDetach"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let forceDetachDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDetach)
        forceDetach = forceDetachDecoded
    }
}

extension DetachVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetachVolumeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DetachVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// AttachVolumeOutput
public struct DetachVolumeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume that was detached.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DetachVolumeOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension DetachVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension StorageGatewayClientTypes.DeviceiSCSIAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chapEnabled = "ChapEnabled"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfacePort = "NetworkInterfacePort"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if chapEnabled != false {
            try encodeContainer.encode(chapEnabled, forKey: .chapEnabled)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if networkInterfacePort != 0 {
            try encodeContainer.encode(networkInterfacePort, forKey: .networkInterfacePort)
        }
        if let targetARN = self.targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfacePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkInterfacePort) ?? 0
        networkInterfacePort = networkInterfacePortDecoded
        let chapEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .chapEnabled) ?? false
        chapEnabled = chapEnabledDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Lists iSCSI information about a VTL device.
    public struct DeviceiSCSIAttributes: Swift.Equatable {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public var chapEnabled: Swift.Bool
        /// The network interface identifier of the VTL device.
        public var networkInterfaceId: Swift.String?
        /// The port used to communicate with iSCSI VTL device targets.
        public var networkInterfacePort: Swift.Int
        /// Specifies the unique Amazon Resource Name (ARN) that encodes the iSCSI qualified name(iqn) of a tape drive or media changer target.
        public var targetARN: Swift.String?

        public init (
            chapEnabled: Swift.Bool = false,
            networkInterfaceId: Swift.String? = nil,
            networkInterfacePort: Swift.Int = 0,
            targetARN: Swift.String? = nil
        )
        {
            self.chapEnabled = chapEnabled
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }
    }

}

extension DisableGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension DisableGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DisableGatewayInput
public struct DisableGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DisableGatewayInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DisableGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DisableGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// DisableGatewayOutput
public struct DisableGatewayOutputResponse: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) of the disabled gateway.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DisableGatewayOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension DisableGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DisassociateFileSystemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case forceDelete = "ForceDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARN = self.fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DisassociateFileSystemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateFileSystemInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file system association to be deleted.
    /// This member is required.
    public var fileSystemAssociationARN: Swift.String?
    /// If this value is set to true, the operation disassociates an Amazon FSx file system immediately. It ends all data uploads to the file system, and the file system association enters the FORCE_DELETING status. If this value is set to false, the Amazon FSx file system does not disassociate until all data is uploaded.
    public var forceDelete: Swift.Bool

    public init (
        fileSystemAssociationARN: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.forceDelete = forceDelete
    }
}

struct DisassociateFileSystemInputBody: Swift.Equatable {
    let fileSystemAssociationARN: Swift.String?
    let forceDelete: Swift.Bool
}

extension DisassociateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case forceDelete = "ForceDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete) ?? false
        forceDelete = forceDeleteDecoded
    }
}

extension DisassociateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct DisassociateFileSystemOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init (
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct DisassociateFileSystemOutputResponseBody: Swift.Equatable {
    let fileSystemAssociationARN: Swift.String?
}

extension DisassociateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

extension StorageGatewayClientTypes.Disk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskAllocationResource = "DiskAllocationResource"
        case diskAllocationType = "DiskAllocationType"
        case diskAttributeList = "DiskAttributeList"
        case diskId = "DiskId"
        case diskNode = "DiskNode"
        case diskPath = "DiskPath"
        case diskSizeInBytes = "DiskSizeInBytes"
        case diskStatus = "DiskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskAllocationResource = self.diskAllocationResource {
            try encodeContainer.encode(diskAllocationResource, forKey: .diskAllocationResource)
        }
        if let diskAllocationType = self.diskAllocationType {
            try encodeContainer.encode(diskAllocationType, forKey: .diskAllocationType)
        }
        if let diskAttributeList = diskAttributeList {
            var diskAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskAttributeList)
            for diskattribute0 in diskAttributeList {
                try diskAttributeListContainer.encode(diskattribute0)
            }
        }
        if let diskId = self.diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let diskNode = self.diskNode {
            try encodeContainer.encode(diskNode, forKey: .diskNode)
        }
        if let diskPath = self.diskPath {
            try encodeContainer.encode(diskPath, forKey: .diskPath)
        }
        if diskSizeInBytes != 0 {
            try encodeContainer.encode(diskSizeInBytes, forKey: .diskSizeInBytes)
        }
        if let diskStatus = self.diskStatus {
            try encodeContainer.encode(diskStatus, forKey: .diskStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskId)
        diskId = diskIdDecoded
        let diskPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskPath)
        diskPath = diskPathDecoded
        let diskNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskNode)
        diskNode = diskNodeDecoded
        let diskStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskStatus)
        diskStatus = diskStatusDecoded
        let diskSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .diskSizeInBytes) ?? 0
        diskSizeInBytes = diskSizeInBytesDecoded
        let diskAllocationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskAllocationType)
        diskAllocationType = diskAllocationTypeDecoded
        let diskAllocationResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskAllocationResource)
        diskAllocationResource = diskAllocationResourceDecoded
        let diskAttributeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .diskAttributeList)
        var diskAttributeListDecoded0:[Swift.String]? = nil
        if let diskAttributeListContainer = diskAttributeListContainer {
            diskAttributeListDecoded0 = [Swift.String]()
            for string0 in diskAttributeListContainer {
                if let string0 = string0 {
                    diskAttributeListDecoded0?.append(string0)
                }
            }
        }
        diskAttributeList = diskAttributeListDecoded0
    }
}

extension StorageGatewayClientTypes {
    /// Represents a gateway's local disk.
    public struct Disk: Swift.Equatable {
        /// The iSCSI qualified name (IQN) that is defined for a disk. This field is not included in the response if the local disk is not defined as an iSCSI target. The format of this field is targetIqn::LUNNumber::region-volumeId.
        public var diskAllocationResource: Swift.String?
        /// One of the DiskAllocationType enumeration values that identifies how a local disk is used. Valid Values: UPLOAD_BUFFER | CACHE_STORAGE
        public var diskAllocationType: Swift.String?
        /// A list of values that represents attributes of a local disk.
        public var diskAttributeList: [Swift.String]?
        /// The unique device ID or other distinguishing data that identifies a local disk.
        public var diskId: Swift.String?
        /// The device node of a local disk as assigned by the virtualization environment.
        public var diskNode: Swift.String?
        /// The path of a local disk in the gateway virtual machine (VM).
        public var diskPath: Swift.String?
        /// The local disk size in bytes.
        public var diskSizeInBytes: Swift.Int
        /// A value that represents the status of a local disk.
        public var diskStatus: Swift.String?

        public init (
            diskAllocationResource: Swift.String? = nil,
            diskAllocationType: Swift.String? = nil,
            diskAttributeList: [Swift.String]? = nil,
            diskId: Swift.String? = nil,
            diskNode: Swift.String? = nil,
            diskPath: Swift.String? = nil,
            diskSizeInBytes: Swift.Int = 0,
            diskStatus: Swift.String? = nil
        )
        {
            self.diskAllocationResource = diskAllocationResource
            self.diskAllocationType = diskAllocationType
            self.diskAttributeList = diskAttributeList
            self.diskId = diskId
            self.diskNode = diskNode
            self.diskPath = diskPath
            self.diskSizeInBytes = diskSizeInBytes
            self.diskStatus = diskStatus
        }
    }

}

extension StorageGatewayClientTypes.EndpointNetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddresses = "IpAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipv4address0 in ipAddresses {
                try ipAddressesContainer.encode(ipv4address0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

extension StorageGatewayClientTypes {
    /// Specifies network configuration information for the gateway associated with the Amazon FSx file system.
    public struct EndpointNetworkConfiguration: Swift.Equatable {
        /// A list of gateway IP addresses on which the associated Amazon FSx file system is available. If multiple file systems are associated with this gateway, this field is required.
        public var ipAddresses: [Swift.String]?

        public init (
            ipAddresses: [Swift.String]? = nil
        )
        {
            self.ipAddresses = ipAddresses
        }
    }

}

extension StorageGatewayClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationkeyexpired
        case activationkeyinvalid
        case activationkeynotfound
        case authenticationfailure
        case bandwidththrottleschedulenotfound
        case blocked
        case cannotexportsnapshot
        case chapcredentialnotfound
        case diskalreadyallocated
        case diskdoesnotexist
        case disksizegreaterthanvolumemaxsize
        case disksizelessthanvolumesize
        case disksizenotgigaligned
        case duplicatecertificateinfo
        case duplicateschedule
        case endpointnotfound
        case gatewayinternalerror
        case gatewaynotconnected
        case gatewaynotfound
        case gatewayproxynetworkconnectionbusy
        case iamnotsupported
        case initiatorinvalid
        case initiatornotfound
        case internalerror
        case invalidendpoint
        case invalidgateway
        case invalidparameters
        case invalidschedule
        case joindomaininprogress
        case localstoragelimitexceeded
        case lunalreadyallocated
        case luninvalid
        case maximumcontentlengthexceeded
        case maximumtapecartridgecountexceeded
        case maximumvolumecountexceeded
        case networkconfigurationchanged
        case nodisksavailable
        case notimplemented
        case notsupported
        case operationaborted
        case outdatedgateway
        case parametersnotimplemented
        case regioninvalid
        case requesttimeout
        case serviceunavailable
        case snapshotdeleted
        case snapshotidinvalid
        case snapshotinprogress
        case snapshotnotfound
        case snapshotschedulenotfound
        case stagingareafull
        case storagefailure
        case tapecartridgenotfound
        case targetalreadyexists
        case targetinvalid
        case targetnotfound
        case unauthorizedoperation
        case volumealreadyexists
        case volumeidinvalid
        case volumeinuse
        case volumenotfound
        case volumenotready
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .activationkeyexpired,
                .activationkeyinvalid,
                .activationkeynotfound,
                .authenticationfailure,
                .bandwidththrottleschedulenotfound,
                .blocked,
                .cannotexportsnapshot,
                .chapcredentialnotfound,
                .diskalreadyallocated,
                .diskdoesnotexist,
                .disksizegreaterthanvolumemaxsize,
                .disksizelessthanvolumesize,
                .disksizenotgigaligned,
                .duplicatecertificateinfo,
                .duplicateschedule,
                .endpointnotfound,
                .gatewayinternalerror,
                .gatewaynotconnected,
                .gatewaynotfound,
                .gatewayproxynetworkconnectionbusy,
                .iamnotsupported,
                .initiatorinvalid,
                .initiatornotfound,
                .internalerror,
                .invalidendpoint,
                .invalidgateway,
                .invalidparameters,
                .invalidschedule,
                .joindomaininprogress,
                .localstoragelimitexceeded,
                .lunalreadyallocated,
                .luninvalid,
                .maximumcontentlengthexceeded,
                .maximumtapecartridgecountexceeded,
                .maximumvolumecountexceeded,
                .networkconfigurationchanged,
                .nodisksavailable,
                .notimplemented,
                .notsupported,
                .operationaborted,
                .outdatedgateway,
                .parametersnotimplemented,
                .regioninvalid,
                .requesttimeout,
                .serviceunavailable,
                .snapshotdeleted,
                .snapshotidinvalid,
                .snapshotinprogress,
                .snapshotnotfound,
                .snapshotschedulenotfound,
                .stagingareafull,
                .storagefailure,
                .tapecartridgenotfound,
                .targetalreadyexists,
                .targetinvalid,
                .targetnotfound,
                .unauthorizedoperation,
                .volumealreadyexists,
                .volumeidinvalid,
                .volumeinuse,
                .volumenotfound,
                .volumenotready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationkeyexpired: return "ActivationKeyExpired"
            case .activationkeyinvalid: return "ActivationKeyInvalid"
            case .activationkeynotfound: return "ActivationKeyNotFound"
            case .authenticationfailure: return "AuthenticationFailure"
            case .bandwidththrottleschedulenotfound: return "BandwidthThrottleScheduleNotFound"
            case .blocked: return "Blocked"
            case .cannotexportsnapshot: return "CannotExportSnapshot"
            case .chapcredentialnotfound: return "ChapCredentialNotFound"
            case .diskalreadyallocated: return "DiskAlreadyAllocated"
            case .diskdoesnotexist: return "DiskDoesNotExist"
            case .disksizegreaterthanvolumemaxsize: return "DiskSizeGreaterThanVolumeMaxSize"
            case .disksizelessthanvolumesize: return "DiskSizeLessThanVolumeSize"
            case .disksizenotgigaligned: return "DiskSizeNotGigAligned"
            case .duplicatecertificateinfo: return "DuplicateCertificateInfo"
            case .duplicateschedule: return "DuplicateSchedule"
            case .endpointnotfound: return "EndpointNotFound"
            case .gatewayinternalerror: return "GatewayInternalError"
            case .gatewaynotconnected: return "GatewayNotConnected"
            case .gatewaynotfound: return "GatewayNotFound"
            case .gatewayproxynetworkconnectionbusy: return "GatewayProxyNetworkConnectionBusy"
            case .iamnotsupported: return "IAMNotSupported"
            case .initiatorinvalid: return "InitiatorInvalid"
            case .initiatornotfound: return "InitiatorNotFound"
            case .internalerror: return "InternalError"
            case .invalidendpoint: return "InvalidEndpoint"
            case .invalidgateway: return "InvalidGateway"
            case .invalidparameters: return "InvalidParameters"
            case .invalidschedule: return "InvalidSchedule"
            case .joindomaininprogress: return "JoinDomainInProgress"
            case .localstoragelimitexceeded: return "LocalStorageLimitExceeded"
            case .lunalreadyallocated: return "LunAlreadyAllocated "
            case .luninvalid: return "LunInvalid"
            case .maximumcontentlengthexceeded: return "MaximumContentLengthExceeded"
            case .maximumtapecartridgecountexceeded: return "MaximumTapeCartridgeCountExceeded"
            case .maximumvolumecountexceeded: return "MaximumVolumeCountExceeded"
            case .networkconfigurationchanged: return "NetworkConfigurationChanged"
            case .nodisksavailable: return "NoDisksAvailable"
            case .notimplemented: return "NotImplemented"
            case .notsupported: return "NotSupported"
            case .operationaborted: return "OperationAborted"
            case .outdatedgateway: return "OutdatedGateway"
            case .parametersnotimplemented: return "ParametersNotImplemented"
            case .regioninvalid: return "RegionInvalid"
            case .requesttimeout: return "RequestTimeout"
            case .serviceunavailable: return "ServiceUnavailable"
            case .snapshotdeleted: return "SnapshotDeleted"
            case .snapshotidinvalid: return "SnapshotIdInvalid"
            case .snapshotinprogress: return "SnapshotInProgress"
            case .snapshotnotfound: return "SnapshotNotFound"
            case .snapshotschedulenotfound: return "SnapshotScheduleNotFound"
            case .stagingareafull: return "StagingAreaFull"
            case .storagefailure: return "StorageFailure"
            case .tapecartridgenotfound: return "TapeCartridgeNotFound"
            case .targetalreadyexists: return "TargetAlreadyExists"
            case .targetinvalid: return "TargetInvalid"
            case .targetnotfound: return "TargetNotFound"
            case .unauthorizedoperation: return "UnauthorizedOperation"
            case .volumealreadyexists: return "VolumeAlreadyExists"
            case .volumeidinvalid: return "VolumeIdInvalid"
            case .volumeinuse: return "VolumeInUse"
            case .volumenotfound: return "VolumeNotFound"
            case .volumenotready: return "VolumeNotReady"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.FileShareInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareStatus = "FileShareStatus"
        case fileShareType = "FileShareType"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = self.fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareStatus = self.fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let fileShareType = self.fileShareType {
            try encodeContainer.encode(fileShareType.rawValue, forKey: .fileShareType)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareTypeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.FileShareType.self, forKey: .fileShareType)
        fileShareType = fileShareTypeDecoded
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a file share. Only supported S3 File Gateway.
    public struct FileShareInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The status of the file share. Valid Values: CREATING | UPDATING | AVAILABLE | DELETING
        public var fileShareStatus: Swift.String?
        /// The type of the file share.
        public var fileShareType: StorageGatewayClientTypes.FileShareType?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?

        public init (
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            fileShareType: StorageGatewayClientTypes.FileShareType? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareStatus = fileShareStatus
            self.fileShareType = fileShareType
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {
    /// The type of the file share.
    public enum FileShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nfs
        case smb
        case sdkUnknown(Swift.String)

        public static var allCases: [FileShareType] {
            return [
                .nfs,
                .smb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nfs: return "NFS"
            case .smb: return "SMB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileShareType(rawValue: rawValue) ?? FileShareType.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.FileSystemAssociationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case fileSystemAssociationStatus = "FileSystemAssociationStatus"
        case fileSystemAssociationStatusDetails = "FileSystemAssociationStatusDetails"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let endpointNetworkConfiguration = self.endpointNetworkConfiguration {
            try encodeContainer.encode(endpointNetworkConfiguration, forKey: .endpointNetworkConfiguration)
        }
        if let fileSystemAssociationARN = self.fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let fileSystemAssociationStatus = self.fileSystemAssociationStatus {
            try encodeContainer.encode(fileSystemAssociationStatus, forKey: .fileSystemAssociationStatus)
        }
        if let fileSystemAssociationStatusDetails = fileSystemAssociationStatusDetails {
            var fileSystemAssociationStatusDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemAssociationStatusDetails)
            for filesystemassociationstatusdetail0 in fileSystemAssociationStatusDetails {
                try fileSystemAssociationStatusDetailsContainer.encode(filesystemassociationstatusdetail0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let locationARN = self.locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let fileSystemAssociationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationStatus)
        fileSystemAssociationStatus = fileSystemAssociationStatusDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let endpointNetworkConfigurationDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.EndpointNetworkConfiguration.self, forKey: .endpointNetworkConfiguration)
        endpointNetworkConfiguration = endpointNetworkConfigurationDecoded
        let fileSystemAssociationStatusDetailsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileSystemAssociationStatusDetail?].self, forKey: .fileSystemAssociationStatusDetails)
        var fileSystemAssociationStatusDetailsDecoded0:[StorageGatewayClientTypes.FileSystemAssociationStatusDetail]? = nil
        if let fileSystemAssociationStatusDetailsContainer = fileSystemAssociationStatusDetailsContainer {
            fileSystemAssociationStatusDetailsDecoded0 = [StorageGatewayClientTypes.FileSystemAssociationStatusDetail]()
            for structure0 in fileSystemAssociationStatusDetailsContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationStatusDetailsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationStatusDetails = fileSystemAssociationStatusDetailsDecoded0
    }
}

extension StorageGatewayClientTypes {
    /// Describes the object returned by DescribeFileSystemAssociations that describes a created file system association.
    public struct FileSystemAssociationInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
        public var auditDestinationARN: Swift.String?
        /// The refresh cache information for the file share or FSx file systems.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// Specifies network configuration information for the gateway associated with the Amazon FSx file system. If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
        public var endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the file system association.
        public var fileSystemAssociationARN: Swift.String?
        /// The status of the file system association. Valid Values: AVAILABLE | CREATING | DELETING | FORCE_DELETING | UPDATING | ERROR
        public var fileSystemAssociationStatus: Swift.String?
        /// An array containing the FileSystemAssociationStatusDetail data type, which provides detailed information on file system association status.
        public var fileSystemAssociationStatusDetails: [StorageGatewayClientTypes.FileSystemAssociationStatusDetail]?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The ARN of the backend Amazon FSx file system used for storing file data. For information, see [FileSystem](https://docs.aws.amazon.com/fsx/latest/APIReference/API_FileSystem.html) in the Amazon FSx API Reference.
        public var locationARN: Swift.String?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair.
        public var tags: [StorageGatewayClientTypes.Tag]?

        public init (
            auditDestinationARN: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            endpointNetworkConfiguration: StorageGatewayClientTypes.EndpointNetworkConfiguration? = nil,
            fileSystemAssociationARN: Swift.String? = nil,
            fileSystemAssociationStatus: Swift.String? = nil,
            fileSystemAssociationStatusDetails: [StorageGatewayClientTypes.FileSystemAssociationStatusDetail]? = nil,
            gatewayARN: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil
        )
        {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.endpointNetworkConfiguration = endpointNetworkConfiguration
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.fileSystemAssociationStatusDetails = fileSystemAssociationStatusDetails
            self.gatewayARN = gatewayARN
            self.locationARN = locationARN
            self.tags = tags
        }
    }

}

extension StorageGatewayClientTypes.FileSystemAssociationStatusDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Detailed information on file system association status.
    public struct FileSystemAssociationStatusDetail: Swift.Equatable {
        /// The error code for a given file system association status.
        public var errorCode: Swift.String?

        public init (
            errorCode: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
        }
    }

}

extension StorageGatewayClientTypes.FileSystemAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case fileSystemAssociationId = "FileSystemAssociationId"
        case fileSystemAssociationStatus = "FileSystemAssociationStatus"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARN = self.fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let fileSystemAssociationId = self.fileSystemAssociationId {
            try encodeContainer.encode(fileSystemAssociationId, forKey: .fileSystemAssociationId)
        }
        if let fileSystemAssociationStatus = self.fileSystemAssociationStatus {
            try encodeContainer.encode(fileSystemAssociationStatus, forKey: .fileSystemAssociationStatus)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationId)
        fileSystemAssociationId = fileSystemAssociationIdDecoded
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let fileSystemAssociationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationStatus)
        fileSystemAssociationStatus = fileSystemAssociationStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Gets the summary returned by ListFileSystemAssociation, which is a summary of a created file system association.
    public struct FileSystemAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the file system association.
        public var fileSystemAssociationARN: Swift.String?
        /// The ID of the file system association.
        public var fileSystemAssociationId: Swift.String?
        /// The status of the file share. Valid Values: AVAILABLE | CREATING | DELETING | FORCE_DELETING | UPDATING | ERROR
        public var fileSystemAssociationStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?

        public init (
            fileSystemAssociationARN: Swift.String? = nil,
            fileSystemAssociationId: Swift.String? = nil,
            fileSystemAssociationStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil
        )
        {
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationId = fileSystemAssociationId
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.gatewayARN = gatewayARN
        }
    }

}

extension StorageGatewayClientTypes {
    public enum GatewayCapacity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayCapacity] {
            return [
                .large,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "Large"
            case .medium: return "Medium"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayCapacity(rawValue: rawValue) ?? GatewayCapacity.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.GatewayInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceId = "Ec2InstanceId"
        case ec2InstanceRegion = "Ec2InstanceRegion"
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case gatewayName = "GatewayName"
        case gatewayOperationalState = "GatewayOperationalState"
        case gatewayType = "GatewayType"
        case hostEnvironment = "HostEnvironment"
        case hostEnvironmentId = "HostEnvironmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceId = self.ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let ec2InstanceRegion = self.ec2InstanceRegion {
            try encodeContainer.encode(ec2InstanceRegion, forKey: .ec2InstanceRegion)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayOperationalState = self.gatewayOperationalState {
            try encodeContainer.encode(gatewayOperationalState, forKey: .gatewayOperationalState)
        }
        if let gatewayType = self.gatewayType {
            try encodeContainer.encode(gatewayType, forKey: .gatewayType)
        }
        if let hostEnvironment = self.hostEnvironment {
            try encodeContainer.encode(hostEnvironment.rawValue, forKey: .hostEnvironment)
        }
        if let hostEnvironmentId = self.hostEnvironmentId {
            try encodeContainer.encode(hostEnvironmentId, forKey: .hostEnvironmentId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let gatewayOperationalStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayOperationalState)
        gatewayOperationalState = gatewayOperationalStateDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ec2InstanceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceRegion)
        ec2InstanceRegion = ec2InstanceRegionDecoded
        let hostEnvironmentDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.HostEnvironment.self, forKey: .hostEnvironment)
        hostEnvironment = hostEnvironmentDecoded
        let hostEnvironmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostEnvironmentId)
        hostEnvironmentId = hostEnvironmentIdDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a gateway object.
    public struct GatewayInfo: Swift.Equatable {
        /// The ID of the Amazon EC2 instance that was used to launch the gateway.
        public var ec2InstanceId: Swift.String?
        /// The Amazon Web Services Region where the Amazon EC2 instance is located.
        public var ec2InstanceRegion: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations.
        public var gatewayId: Swift.String?
        /// The name of the gateway.
        public var gatewayName: Swift.String?
        /// The state of the gateway. Valid Values: DISABLED | ACTIVE
        public var gatewayOperationalState: Swift.String?
        /// The type of the gateway.
        public var gatewayType: Swift.String?
        /// The type of hardware or software platform on which the gateway is running.
        public var hostEnvironment: StorageGatewayClientTypes.HostEnvironment?
        /// A unique identifier for the specific instance of the host platform running the gateway. This value is only available for certain host environments, and its format depends on the host environment type.
        public var hostEnvironmentId: Swift.String?

        public init (
            ec2InstanceId: Swift.String? = nil,
            ec2InstanceRegion: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayOperationalState: Swift.String? = nil,
            gatewayType: Swift.String? = nil,
            hostEnvironment: StorageGatewayClientTypes.HostEnvironment? = nil,
            hostEnvironmentId: Swift.String? = nil
        )
        {
            self.ec2InstanceId = ec2InstanceId
            self.ec2InstanceRegion = ec2InstanceRegion
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayOperationalState = gatewayOperationalState
            self.gatewayType = gatewayType
            self.hostEnvironment = hostEnvironment
            self.hostEnvironmentId = hostEnvironmentId
        }
    }

}

extension StorageGatewayClientTypes {
    public enum HostEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case hyperV
        case kvm
        case other
        case snowball
        case vmware
        case sdkUnknown(Swift.String)

        public static var allCases: [HostEnvironment] {
            return [
                .ec2,
                .hyperV,
                .kvm,
                .other,
                .snowball,
                .vmware,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .hyperV: return "HYPER-V"
            case .kvm: return "KVM"
            case .other: return "OTHER"
            case .snowball: return "SNOWBALL"
            case .vmware: return "VMWARE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HostEnvironment(rawValue: rawValue) ?? HostEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error has occurred during the request. For more information, see the error and message fields.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A [StorageGatewayError] that provides more information about the cause of the error.
    public var error: StorageGatewayClientTypes.StorageGatewayError?
    /// A human-readable message describing the error that occurred.
    public var message: Swift.String?

    public init (
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
    let error: StorageGatewayClientTypes.StorageGatewayError?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

extension InvalidGatewayRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidGatewayRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception occurred because an invalid gateway request was issued to the service. For more information, see the error and message fields.
public struct InvalidGatewayRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A [StorageGatewayError] that provides more detail about the cause of the error.
    public var error: StorageGatewayClientTypes.StorageGatewayError?
    /// A human-readable message describing the error that occurred.
    public var message: Swift.String?

    public init (
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct InvalidGatewayRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let error: StorageGatewayClientTypes.StorageGatewayError?
}

extension InvalidGatewayRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

extension JoinDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JoinDomainInput(domainControllers: \(Swift.String(describing: domainControllers)), domainName: \(Swift.String(describing: domainName)), gatewayARN: \(Swift.String(describing: gatewayARN)), organizationalUnit: \(Swift.String(describing: organizationalUnit)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension JoinDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainControllers = "DomainControllers"
        case domainName = "DomainName"
        case gatewayARN = "GatewayARN"
        case organizationalUnit = "OrganizationalUnit"
        case password = "Password"
        case timeoutInSeconds = "TimeoutInSeconds"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainControllers = domainControllers {
            var domainControllersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainControllers)
            for host0 in domainControllers {
                try domainControllersContainer.encode(host0)
            }
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let organizationalUnit = self.organizationalUnit {
            try encodeContainer.encode(organizationalUnit, forKey: .organizationalUnit)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension JoinDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// JoinDomainInput
public struct JoinDomainInput: Swift.Equatable {
    /// List of IPv4 addresses, NetBIOS names, or host names of your domain server. If you need to specify the port number include it after the colon (“:”). For example, mydc.mydomain.com:389.
    public var domainControllers: [Swift.String]?
    /// The name of the domain that you want the gateway to join.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The organizational unit (OU) is a container in an Active Directory that can hold users, groups, computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
    public var organizationalUnit: Swift.String?
    /// Sets the password of the user who has permission to add the gateway to the Active Directory domain.
    /// This member is required.
    public var password: Swift.String?
    /// Specifies the time in seconds, in which the JoinDomain operation must complete. The default is 20 seconds.
    public var timeoutInSeconds: Swift.Int?
    /// Sets the user name of user who has permission to add the gateway to the Active Directory domain. The domain user account should be enabled to join computers to the domain. For example, you can use the domain administrator account or an account with delegated permissions to join computers to the domain.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        domainControllers: [Swift.String]? = nil,
        domainName: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        organizationalUnit: Swift.String? = nil,
        password: Swift.String? = nil,
        timeoutInSeconds: Swift.Int? = nil,
        userName: Swift.String? = nil
    )
    {
        self.domainControllers = domainControllers
        self.domainName = domainName
        self.gatewayARN = gatewayARN
        self.organizationalUnit = organizationalUnit
        self.password = password
        self.timeoutInSeconds = timeoutInSeconds
        self.userName = userName
    }
}

struct JoinDomainInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let domainName: Swift.String?
    let organizationalUnit: Swift.String?
    let domainControllers: [Swift.String]?
    let timeoutInSeconds: Swift.Int?
    let userName: Swift.String?
    let password: Swift.String?
}

extension JoinDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainControllers = "DomainControllers"
        case domainName = "DomainName"
        case gatewayARN = "GatewayARN"
        case organizationalUnit = "OrganizationalUnit"
        case password = "Password"
        case timeoutInSeconds = "TimeoutInSeconds"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnit)
        organizationalUnit = organizationalUnitDecoded
        let domainControllersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domainControllers)
        var domainControllersDecoded0:[Swift.String]? = nil
        if let domainControllersContainer = domainControllersContainer {
            domainControllersDecoded0 = [Swift.String]()
            for string0 in domainControllersContainer {
                if let string0 = string0 {
                    domainControllersDecoded0?.append(string0)
                }
            }
        }
        domainControllers = domainControllersDecoded0
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension JoinDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension JoinDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum JoinDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension JoinDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: JoinDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeDirectoryStatus = output.activeDirectoryStatus
            self.gatewayARN = output.gatewayARN
        } else {
            self.activeDirectoryStatus = nil
            self.gatewayARN = nil
        }
    }
}

/// JoinDomainOutput
public struct JoinDomainOutputResponse: Swift.Equatable {
    /// Indicates the status of the gateway as a member of the Active Directory domain.
    ///
    /// * ACCESS_DENIED: Indicates that the JoinDomain operation failed due to an authentication error.
    ///
    /// * DETACHED: Indicates that gateway is not joined to a domain.
    ///
    /// * JOINED: Indicates that the gateway has successfully joined a domain.
    ///
    /// * JOINING: Indicates that a JoinDomain operation is in progress.
    ///
    /// * NETWORK_ERROR: Indicates that JoinDomain operation failed due to a network or connectivity error.
    ///
    /// * TIMEOUT: Indicates that the JoinDomain operation failed because the operation didn't complete within the allotted time.
    ///
    /// * UNKNOWN_ERROR: Indicates that the JoinDomain operation failed due to another type of error.
    public var activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
    /// The unique Amazon Resource Name (ARN) of the gateway that joined the domain.
    public var gatewayARN: Swift.String?

    public init (
        activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.gatewayARN = gatewayARN
    }
}

struct JoinDomainOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let activeDirectoryStatus: StorageGatewayClientTypes.ActiveDirectoryStatus?
}

extension JoinDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryStatus = "ActiveDirectoryStatus"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let activeDirectoryStatusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ActiveDirectoryStatus.self, forKey: .activeDirectoryStatus)
        activeDirectoryStatus = activeDirectoryStatusDecoded
    }
}

extension ListAutomaticTapeCreationPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension ListAutomaticTapeCreationPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAutomaticTapeCreationPoliciesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListAutomaticTapeCreationPoliciesInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ListAutomaticTapeCreationPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListAutomaticTapeCreationPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutomaticTapeCreationPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAutomaticTapeCreationPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutomaticTapeCreationPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAutomaticTapeCreationPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automaticTapeCreationPolicyInfos = output.automaticTapeCreationPolicyInfos
        } else {
            self.automaticTapeCreationPolicyInfos = nil
        }
    }
}

public struct ListAutomaticTapeCreationPoliciesOutputResponse: Swift.Equatable {
    /// Gets a listing of information about the gateway's automatic tape creation policies, including the automatic tape creation rules and the gateway that is using the policies.
    public var automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]?

    public init (
        automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]? = nil
    )
    {
        self.automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfos
    }
}

struct ListAutomaticTapeCreationPoliciesOutputResponseBody: Swift.Equatable {
    let automaticTapeCreationPolicyInfos: [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]?
}

extension ListAutomaticTapeCreationPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationPolicyInfos = "AutomaticTapeCreationPolicyInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationPolicyInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo?].self, forKey: .automaticTapeCreationPolicyInfos)
        var automaticTapeCreationPolicyInfosDecoded0:[StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]? = nil
        if let automaticTapeCreationPolicyInfosContainer = automaticTapeCreationPolicyInfosContainer {
            automaticTapeCreationPolicyInfosDecoded0 = [StorageGatewayClientTypes.AutomaticTapeCreationPolicyInfo]()
            for structure0 in automaticTapeCreationPolicyInfosContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationPolicyInfosDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfosDecoded0
    }
}

extension ListFileSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

extension ListFileSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// ListFileShareInput
public struct ListFileSharesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway whose file shares you want to list. If this field is not present, all file shares under your account are listed.
    public var gatewayARN: Swift.String?
    /// The maximum number of file shares to return in the response. The value must be an integer with a value greater than zero. Optional.
    public var limit: Swift.Int?
    /// Opaque pagination token returned from a previous ListFileShares operation. If present, Marker specifies where to continue the list from after a previous call to ListFileShares. Optional.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListFileSharesInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let limit: Swift.Int?
    let marker: Swift.String?
}

extension ListFileSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListFileSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFileSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFileSharesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFileSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareInfoList = output.fileShareInfoList
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileShareInfoList = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

/// ListFileShareOutput
public struct ListFileSharesOutputResponse: Swift.Equatable {
    /// An array of information about the S3 File Gateway's file shares.
    public var fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]?
    /// If the request includes Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// If a value is present, there are more file shares to return. In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file shares.
    public var nextMarker: Swift.String?

    public init (
        fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileShareInfoList = fileShareInfoList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct ListFileSharesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let nextMarker: Swift.String?
    let fileShareInfoList: [StorageGatewayClientTypes.FileShareInfo]?
}

extension ListFileSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareInfoList = "FileShareInfoList"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let fileShareInfoListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileShareInfo?].self, forKey: .fileShareInfoList)
        var fileShareInfoListDecoded0:[StorageGatewayClientTypes.FileShareInfo]? = nil
        if let fileShareInfoListContainer = fileShareInfoListContainer {
            fileShareInfoListDecoded0 = [StorageGatewayClientTypes.FileShareInfo]()
            for structure0 in fileShareInfoListContainer {
                if let structure0 = structure0 {
                    fileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        fileShareInfoList = fileShareInfoListDecoded0
    }
}

extension ListFileSystemAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

extension ListFileSystemAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFileSystemAssociationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The maximum number of file system associations to return in the response. If present, Limit must be an integer with a value greater than zero. Optional.
    public var limit: Swift.Int?
    /// Opaque pagination token returned from a previous ListFileSystemAssociations operation. If present, Marker specifies where to continue the list from after a previous call to ListFileSystemAssociations. Optional.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListFileSystemAssociationsInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let limit: Swift.Int?
    let marker: Swift.String?
}

extension ListFileSystemAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListFileSystemAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFileSystemAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFileSystemAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFileSystemAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFileSystemAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationSummaryList = output.fileSystemAssociationSummaryList
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileSystemAssociationSummaryList = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFileSystemAssociationsOutputResponse: Swift.Equatable {
    /// An array of information about the Amazon FSx gateway's file system associations.
    public var fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]?
    /// If the request includes Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// If a value is present, there are more file system associations to return. In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file system associations.
    public var nextMarker: Swift.String?

    public init (
        fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileSystemAssociationSummaryList = fileSystemAssociationSummaryList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct ListFileSystemAssociationsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let nextMarker: Swift.String?
    let fileSystemAssociationSummaryList: [StorageGatewayClientTypes.FileSystemAssociationSummary]?
}

extension ListFileSystemAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationSummaryList = "FileSystemAssociationSummaryList"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let fileSystemAssociationSummaryListContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.FileSystemAssociationSummary?].self, forKey: .fileSystemAssociationSummaryList)
        var fileSystemAssociationSummaryListDecoded0:[StorageGatewayClientTypes.FileSystemAssociationSummary]? = nil
        if let fileSystemAssociationSummaryListContainer = fileSystemAssociationSummaryListContainer {
            fileSystemAssociationSummaryListDecoded0 = [StorageGatewayClientTypes.FileSystemAssociationSummary]()
            for structure0 in fileSystemAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationSummaryList = fileSystemAssociationSummaryListDecoded0
    }
}

extension ListGatewaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing zero or more of the following fields:
///
/// * [ListGatewaysInput$Limit]
///
/// * [ListGatewaysInput$Marker]
public struct ListGatewaysInput: Swift.Equatable {
    /// Specifies that the list of gateways returned be limited to the specified number of items.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin the returned list of gateways.
    public var marker: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension ListGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGatewaysOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.marker = output.marker
        } else {
            self.gateways = nil
            self.marker = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Swift.Equatable {
    /// An array of [GatewayInfo] objects.
    public var gateways: [StorageGatewayClientTypes.GatewayInfo]?
    /// Use the marker in your next request to fetch the next set of gateways in the list. If there are no more gateways to list, this field does not appear in the response.
    public var marker: Swift.String?

    public init (
        gateways: [StorageGatewayClientTypes.GatewayInfo]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.marker = marker
    }
}

struct ListGatewaysOutputResponseBody: Swift.Equatable {
    let gateways: [StorageGatewayClientTypes.GatewayInfo]?
    let marker: Swift.String?
}

extension ListGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "Gateways"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.GatewayInfo?].self, forKey: .gateways)
        var gatewaysDecoded0:[StorageGatewayClientTypes.GatewayInfo]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [StorageGatewayClientTypes.GatewayInfo]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListLocalDisksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension ListLocalDisksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway.
public struct ListLocalDisksInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListLocalDisksInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ListLocalDisksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListLocalDisksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLocalDisksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLocalDisksOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLocalDisksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLocalDisksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disks = output.disks
            self.gatewayARN = output.gatewayARN
        } else {
            self.disks = nil
            self.gatewayARN = nil
        }
    }
}

public struct ListLocalDisksOutputResponse: Swift.Equatable {
    /// A JSON object containing the following fields:
    ///
    /// * [ListLocalDisksOutput$Disks]
    public var disks: [StorageGatewayClientTypes.Disk]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        disks: [StorageGatewayClientTypes.Disk]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.disks = disks
        self.gatewayARN = gatewayARN
    }
}

struct ListLocalDisksOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let disks: [StorageGatewayClientTypes.Disk]?
}

extension ListLocalDisksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disks = "Disks"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let disksContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[StorageGatewayClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [StorageGatewayClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// ListTagsForResourceInput
public struct ListTagsForResourceInput: Swift.Equatable {
    /// Specifies that the list of tags returned be limited to the specified number of items.
    public var limit: Swift.Int?
    /// An opaque string that indicates the position at which to begin returning the list of tags.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.resourceARN = output.resourceARN
            self.tags = output.tags
        } else {
            self.marker = nil
            self.resourceARN = nil
            self.tags = nil
        }
    }
}

/// ListTagsForResourceOutput
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An opaque string that indicates the position at which to stop returning the list of tags.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    public var resourceARN: Swift.String?
    /// An array that contains the tags for the specified resource.
    public var tags: [StorageGatewayClientTypes.Tag]?

    public init (
        marker: Swift.String? = nil,
        resourceARN: Swift.String? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil
    )
    {
        self.marker = marker
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let marker: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTapePoolsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case poolARNs = "PoolARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let poolARNs = poolARNs {
            var poolARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .poolARNs)
            for poolarn0 in poolARNs {
                try poolARNsContainer.encode(poolarn0)
            }
        }
    }
}

extension ListTapePoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTapePoolsInput: Swift.Equatable {
    /// An optional number limit for the tape pools in the list returned by this call.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of tape pools.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of each of the custom tape pools you want to list. If you don't specify a custom tape pool ARN, the response lists all custom tape pools.
    public var poolARNs: [Swift.String]?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        poolARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.poolARNs = poolARNs
    }
}

struct ListTapePoolsInputBody: Swift.Equatable {
    let poolARNs: [Swift.String]?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension ListTapePoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case poolARNs = "PoolARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .poolARNs)
        var poolARNsDecoded0:[Swift.String]? = nil
        if let poolARNsContainer = poolARNsContainer {
            poolARNsDecoded0 = [Swift.String]()
            for string0 in poolARNsContainer {
                if let string0 = string0 {
                    poolARNsDecoded0?.append(string0)
                }
            }
        }
        poolARNs = poolARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTapePoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTapePoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTapePoolsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTapePoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTapePoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.poolInfos = output.poolInfos
        } else {
            self.marker = nil
            self.poolInfos = nil
        }
    }
}

public struct ListTapePoolsOutputResponse: Swift.Equatable {
    /// A string that indicates the position at which to begin the returned list of tape pools. Use the marker in your next request to continue pagination of tape pools. If there are no more tape pools to list, this element does not appear in the response body.
    public var marker: Swift.String?
    /// An array of PoolInfo objects, where each object describes a single custom tape pool. If there are no custom tape pools, the PoolInfos is an empty array.
    public var poolInfos: [StorageGatewayClientTypes.PoolInfo]?

    public init (
        marker: Swift.String? = nil,
        poolInfos: [StorageGatewayClientTypes.PoolInfo]? = nil
    )
    {
        self.marker = marker
        self.poolInfos = poolInfos
    }
}

struct ListTapePoolsOutputResponseBody: Swift.Equatable {
    let poolInfos: [StorageGatewayClientTypes.PoolInfo]?
    let marker: Swift.String?
}

extension ListTapePoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case poolInfos = "PoolInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.PoolInfo?].self, forKey: .poolInfos)
        var poolInfosDecoded0:[StorageGatewayClientTypes.PoolInfo]? = nil
        if let poolInfosContainer = poolInfosContainer {
            poolInfosDecoded0 = [StorageGatewayClientTypes.PoolInfo]()
            for structure0 in poolInfosContainer {
                if let structure0 = structure0 {
                    poolInfosDecoded0?.append(structure0)
                }
            }
        }
        poolInfos = poolInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListTapesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearn0 in tapeARNs {
                try tapeARNsContainer.encode(tapearn0)
            }
        }
    }
}

extension ListTapesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object that contains one or more of the following fields:
///
/// * [ListTapesInput$Limit]
///
/// * [ListTapesInput$Marker]
///
/// * [ListTapesInput$TapeARNs]
public struct ListTapesInput: Swift.Equatable {
    /// An optional number limit for the tapes in the list returned by this call.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of tapes.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of each of the tapes you want to list. If you don't specify a tape ARN, the response lists all tapes in both your VTL and VTS.
    public var tapeARNs: [Swift.String]?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        tapeARNs: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct ListTapesInputBody: Swift.Equatable {
    let tapeARNs: [Swift.String]?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension ListTapesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[Swift.String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [Swift.String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTapesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTapesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTapesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTapesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTapesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.tapeInfos = output.tapeInfos
        } else {
            self.marker = nil
            self.tapeInfos = nil
        }
    }
}

/// A JSON object containing the following fields:
///
/// * [ListTapesOutput$Marker]
///
/// * [ListTapesOutput$VolumeInfos]
public struct ListTapesOutputResponse: Swift.Equatable {
    /// A string that indicates the position at which to begin returning the next list of tapes. Use the marker in your next request to continue pagination of tapes. If there are no more tapes to list, this element does not appear in the response body.
    public var marker: Swift.String?
    /// An array of [TapeInfo] objects, where each object describes a single tape. If there are no tapes in the tape library or VTS, then the TapeInfos is an empty array.
    public var tapeInfos: [StorageGatewayClientTypes.TapeInfo]?

    public init (
        marker: Swift.String? = nil,
        tapeInfos: [StorageGatewayClientTypes.TapeInfo]? = nil
    )
    {
        self.marker = marker
        self.tapeInfos = tapeInfos
    }
}

struct ListTapesOutputResponseBody: Swift.Equatable {
    let tapeInfos: [StorageGatewayClientTypes.TapeInfo]?
    let marker: Swift.String?
}

extension ListTapesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case tapeInfos = "TapeInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.TapeInfo?].self, forKey: .tapeInfos)
        var tapeInfosDecoded0:[StorageGatewayClientTypes.TapeInfo]? = nil
        if let tapeInfosContainer = tapeInfosContainer {
            tapeInfosDecoded0 = [StorageGatewayClientTypes.TapeInfo]()
            for structure0 in tapeInfosContainer {
                if let structure0 = structure0 {
                    tapeInfosDecoded0?.append(structure0)
                }
            }
        }
        tapeInfos = tapeInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListVolumeInitiatorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension ListVolumeInitiatorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// ListVolumeInitiatorsInput
public struct ListVolumeInitiatorsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes for the gateway.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct ListVolumeInitiatorsInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension ListVolumeInitiatorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension ListVolumeInitiatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumeInitiatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVolumeInitiatorsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumeInitiatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVolumeInitiatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiators = output.initiators
        } else {
            self.initiators = nil
        }
    }
}

/// ListVolumeInitiatorsOutput
public struct ListVolumeInitiatorsOutputResponse: Swift.Equatable {
    /// The host names and port numbers of all iSCSI initiators that are connected to the gateway.
    public var initiators: [Swift.String]?

    public init (
        initiators: [Swift.String]? = nil
    )
    {
        self.initiators = initiators
    }
}

struct ListVolumeInitiatorsOutputResponseBody: Swift.Equatable {
    let initiators: [Swift.String]?
}

extension ListVolumeInitiatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiators = "Initiators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .initiators)
        var initiatorsDecoded0:[Swift.String]? = nil
        if let initiatorsContainer = initiatorsContainer {
            initiatorsDecoded0 = [Swift.String]()
            for string0 in initiatorsContainer {
                if let string0 = string0 {
                    initiatorsDecoded0?.append(string0)
                }
            }
        }
        initiators = initiatorsDecoded0
    }
}

extension ListVolumeRecoveryPointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension ListVolumeRecoveryPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVolumeRecoveryPointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListVolumeRecoveryPointsInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ListVolumeRecoveryPointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListVolumeRecoveryPointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumeRecoveryPointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVolumeRecoveryPointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumeRecoveryPointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVolumeRecoveryPointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.volumeRecoveryPointInfos = output.volumeRecoveryPointInfos
        } else {
            self.gatewayARN = nil
            self.volumeRecoveryPointInfos = nil
        }
    }
}

public struct ListVolumeRecoveryPointsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// An array of [VolumeRecoveryPointInfo] objects.
    public var volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]?

    public init (
        gatewayARN: Swift.String? = nil,
        volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.volumeRecoveryPointInfos = volumeRecoveryPointInfos
    }
}

struct ListVolumeRecoveryPointsOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let volumeRecoveryPointInfos: [StorageGatewayClientTypes.VolumeRecoveryPointInfo]?
}

extension ListVolumeRecoveryPointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case volumeRecoveryPointInfos = "VolumeRecoveryPointInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let volumeRecoveryPointInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.VolumeRecoveryPointInfo?].self, forKey: .volumeRecoveryPointInfos)
        var volumeRecoveryPointInfosDecoded0:[StorageGatewayClientTypes.VolumeRecoveryPointInfo]? = nil
        if let volumeRecoveryPointInfosContainer = volumeRecoveryPointInfosContainer {
            volumeRecoveryPointInfosDecoded0 = [StorageGatewayClientTypes.VolumeRecoveryPointInfo]()
            for structure0 in volumeRecoveryPointInfosContainer {
                if let structure0 = structure0 {
                    volumeRecoveryPointInfosDecoded0?.append(structure0)
                }
            }
        }
        volumeRecoveryPointInfos = volumeRecoveryPointInfosDecoded0
    }
}

extension ListVolumesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

extension ListVolumesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object that contains one or more of the following fields:
///
/// * [ListVolumesInput$Limit]
///
/// * [ListVolumesInput$Marker]
public struct ListVolumesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// Specifies that the list of volumes returned be limited to the specified number of items.
    public var limit: Swift.Int?
    /// A string that indicates the position at which to begin the returned list of volumes. Obtain the marker from the response of a previous List iSCSI Volumes request.
    public var marker: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListVolumesInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension ListVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVolumesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.volumeInfos = output.volumeInfos
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.volumeInfos = nil
        }
    }
}

/// A JSON object containing the following fields:
///
/// * [ListVolumesOutput$Marker]
///
/// * [ListVolumesOutput$VolumeInfos]
public struct ListVolumesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// Use the marker in your next request to continue pagination of iSCSI volumes. If there are no more volumes to list, this field does not appear in the response body.
    public var marker: Swift.String?
    /// An array of [VolumeInfo] objects, where each object describes an iSCSI volume. If no volumes are defined for the gateway, then VolumeInfos is an empty array "[]".
    public var volumeInfos: [StorageGatewayClientTypes.VolumeInfo]?

    public init (
        gatewayARN: Swift.String? = nil,
        marker: Swift.String? = nil,
        volumeInfos: [StorageGatewayClientTypes.VolumeInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.volumeInfos = volumeInfos
    }
}

struct ListVolumesOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let marker: Swift.String?
    let volumeInfos: [StorageGatewayClientTypes.VolumeInfo]?
}

extension ListVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case volumeInfos = "VolumeInfos"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let volumeInfosContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.VolumeInfo?].self, forKey: .volumeInfos)
        var volumeInfosDecoded0:[StorageGatewayClientTypes.VolumeInfo]? = nil
        if let volumeInfosContainer = volumeInfosContainer {
            volumeInfosDecoded0 = [StorageGatewayClientTypes.VolumeInfo]()
            for structure0 in volumeInfosContainer {
                if let structure0 = structure0 {
                    volumeInfosDecoded0?.append(structure0)
                }
            }
        }
        volumeInfos = volumeInfosDecoded0
    }
}

extension StorageGatewayClientTypes.NFSFileShareDefaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryMode = "DirectoryMode"
        case fileMode = "FileMode"
        case groupId = "GroupId"
        case ownerId = "OwnerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryMode = self.directoryMode {
            try encodeContainer.encode(directoryMode, forKey: .directoryMode)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode, forKey: .fileMode)
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let directoryModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryMode)
        directoryMode = directoryModeDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .groupId)
        groupId = groupIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes Network File System (NFS) file share default values. Files and folders stored as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that represent files and folders are assigned these default Unix permissions. This operation is only supported for S3 File Gateways.
    public struct NFSFileShareDefaults: Swift.Equatable {
        /// The Unix directory mode in the form "nnnn". For example, 0666 represents the default access mode for all directories inside the file share. The default value is 0777.
        public var directoryMode: Swift.String?
        /// The Unix file mode in the form "nnnn". For example, 0666 represents the default file mode inside the file share. The default value is 0666.
        public var fileMode: Swift.String?
        /// The default group ID for the file share (unless the files have another group ID specified). The default value is nfsnobody.
        public var groupId: Swift.Int?
        /// The default owner ID for files in the file share (unless the files have another owner ID specified). The default value is nfsnobody.
        public var ownerId: Swift.Int?

        public init (
            directoryMode: Swift.String? = nil,
            fileMode: Swift.String? = nil,
            groupId: Swift.Int? = nil,
            ownerId: Swift.Int? = nil
        )
        {
            self.directoryMode = directoryMode
            self.fileMode = fileMode
            self.groupId = groupId
            self.ownerId = ownerId
        }
    }

}

extension StorageGatewayClientTypes.NFSFileShareInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareName = "FileShareName"
        case fileShareStatus = "FileShareStatus"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case locationARN = "LocationARN"
        case nfsFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case path = "Path"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
        case vpcEndpointDNSName = "VPCEndpointDNSName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let bucketRegion = self.bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for ipv4addresscidr0 in clientList {
                try clientListContainer.encode(ipv4addresscidr0)
            }
        }
        if let defaultStorageClass = self.defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = self.fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareName = self.fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let fileShareStatus = self.fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = self.guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if kmsEncrypted != false {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let locationARN = self.locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let nfsFileShareDefaults = self.nfsFileShareDefaults {
            try encodeContainer.encode(nfsFileShareDefaults, forKey: .nfsFileShareDefaults)
        }
        if let notificationPolicy = self.notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = self.objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = self.requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let squash = self.squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcEndpointDNSName = self.vpcEndpointDNSName {
            try encodeContainer.encode(vpcEndpointDNSName, forKey: .vpcEndpointDNSName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nfsFileShareDefaultsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.NFSFileShareDefaults.self, forKey: .nfsFileShareDefaults)
        nfsFileShareDefaults = nfsFileShareDefaultsDecoded
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted) ?? false
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vpcEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointDNSName)
        vpcEndpointDNSName = vpcEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
    }
}

extension StorageGatewayClientTypes {
    /// The Unix file permissions and ownership information assigned, by default, to native S3 objects when an S3 File Gateway discovers them in S3 buckets. This operation is only supported in S3 File Gateways.
    public struct NFSFileShareInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public var auditDestinationARN: Swift.String?
        /// Specifies the Region of the S3 bucket where the NFS file share stores files. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var bucketRegion: Swift.String?
        /// Refresh cache information for the file share.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
        public var clientList: [Swift.String]?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public var defaultStorageClass: Swift.String?
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
        public var fileShareName: Swift.String?
        /// The status of the file share. Valid Values: CREATING | UPDATING | AVAILABLE | DELETING
        public var fileShareStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public var guessMIMETypeEnabled: Swift.Bool?
        /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
        public var kmsEncrypted: Swift.Bool
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public var kmsKey: Swift.String?
        /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
        public var locationARN: Swift.String?
        /// Describes Network File System (NFS) file share default values. Files and folders stored as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that represent files and folders are assigned these default Unix permissions. This operation is only supported for S3 File Gateways.
        public var nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {"Upload": {"SettlingTimeInSeconds": 60}} The following example sets NotificationPolicy off. {}
        public var notificationPolicy: Swift.String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that an S3 File Gateway puts objects into. The default value is private.
        public var objectACL: StorageGatewayClientTypes.ObjectACL?
        /// The file share path used by the NFS client to identify the mount point.
        public var path: Swift.String?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public var readOnly: Swift.Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
        public var requesterPays: Swift.Bool?
        /// The ARN of the IAM role that an S3 File Gateway assumes when it accesses the underlying storage.
        public var role: Swift.String?
        /// The user mapped to anonymous user. Valid options are the following:
        ///
        /// * RootSquash: Only root is mapped to anonymous user.
        ///
        /// * NoSquash: No one is mapped to anonymous user.
        ///
        /// * AllSquash: Everyone is mapped to anonymous user.
        public var squash: Swift.String?
        /// A list of up to 50 tags assigned to the NFS file share, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public var tags: [StorageGatewayClientTypes.Tag]?
        /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3. This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var vpcEndpointDNSName: Swift.String?

        public init (
            auditDestinationARN: Swift.String? = nil,
            bucketRegion: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            clientList: [Swift.String]? = nil,
            defaultStorageClass: Swift.String? = nil,
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareName: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            guessMIMETypeEnabled: Swift.Bool? = nil,
            kmsEncrypted: Swift.Bool = false,
            kmsKey: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
            notificationPolicy: Swift.String? = nil,
            objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
            path: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            requesterPays: Swift.Bool? = nil,
            role: Swift.String? = nil,
            squash: Swift.String? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil,
            vpcEndpointDNSName: Swift.String? = nil
        )
        {
            self.auditDestinationARN = auditDestinationARN
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }
    }

}

extension StorageGatewayClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv4Address = "Ipv4Address"
        case ipv6Address = "Ipv6Address"
        case macAddress = "MacAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv4Address = self.ipv4Address {
            try encodeContainer.encode(ipv4Address, forKey: .ipv4Address)
        }
        if let ipv6Address = self.ipv6Address {
            try encodeContainer.encode(ipv6Address, forKey: .ipv6Address)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv4AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv4Address)
        ipv4Address = ipv4AddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipv6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6Address)
        ipv6Address = ipv6AddressDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a gateway's network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The Internet Protocol version 4 (IPv4) address of the interface.
        public var ipv4Address: Swift.String?
        /// The Internet Protocol version 6 (IPv6) address of the interface. Currently not supported.
        public var ipv6Address: Swift.String?
        /// The Media Access Control (MAC) address of the interface. This is currently unsupported and will not be returned in output.
        public var macAddress: Swift.String?

        public init (
            ipv4Address: Swift.String? = nil,
            ipv6Address: Swift.String? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ipv4Address = ipv4Address
            self.ipv6Address = ipv6Address
            self.macAddress = macAddress
        }
    }

}

extension NotifyWhenUploadedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
    }
}

extension NotifyWhenUploadedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyWhenUploadedInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share.
    /// This member is required.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct NotifyWhenUploadedInputBody: Swift.Equatable {
    let fileShareARN: Swift.String?
}

extension NotifyWhenUploadedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension NotifyWhenUploadedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyWhenUploadedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum NotifyWhenUploadedOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyWhenUploadedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotifyWhenUploadedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
            self.notificationId = output.notificationId
        } else {
            self.fileShareARN = nil
            self.notificationId = nil
        }
    }
}

public struct NotifyWhenUploadedOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share.
    public var fileShareARN: Swift.String?
    /// The randomly generated ID of the notification that was sent. This ID is in UUID format.
    public var notificationId: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil,
        notificationId: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

struct NotifyWhenUploadedOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
    let notificationId: Swift.String?
}

extension NotifyWhenUploadedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case notificationId = "NotificationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let notificationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationId)
        notificationId = notificationIdDecoded
    }
}

extension StorageGatewayClientTypes {
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that an S3 File Gateway puts objects into. The default value is private.
    public enum ObjectACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectACL] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectACL(rawValue: rawValue) ?? ObjectACL.sdkUnknown(rawValue)
        }
    }
}

extension StorageGatewayClientTypes.PoolInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolARN = "PoolARN"
        case poolName = "PoolName"
        case poolStatus = "PoolStatus"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolARN = self.poolARN {
            try encodeContainer.encode(poolARN, forKey: .poolARN)
        }
        if let poolName = self.poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let poolStatus = self.poolStatus {
            try encodeContainer.encode(poolStatus.rawValue, forKey: .poolStatus)
        }
        if let retentionLockTimeInDays = self.retentionLockTimeInDays {
            try encodeContainer.encode(retentionLockTimeInDays, forKey: .retentionLockTimeInDays)
        }
        if let retentionLockType = self.retentionLockType {
            try encodeContainer.encode(retentionLockType.rawValue, forKey: .retentionLockType)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.TapeStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionLockTypeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.RetentionLockType.self, forKey: .retentionLockType)
        retentionLockType = retentionLockTypeDecoded
        let retentionLockTimeInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionLockTimeInDays)
        retentionLockTimeInDays = retentionLockTimeInDaysDecoded
        let poolStatusDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.PoolStatus.self, forKey: .poolStatus)
        poolStatus = poolStatusDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a custom tape pool.
    public struct PoolInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom tape pool. Use the [ListTapePools] operation to return a list of custom tape pools for your account and Amazon Web Services Region.
        public var poolARN: Swift.String?
        /// The name of the custom tape pool. PoolName can use all ASCII characters, except '/' and '\'.
        public var poolName: Swift.String?
        /// Status of the custom tape pool. Pool can be ACTIVE or DELETED.
        public var poolStatus: StorageGatewayClientTypes.PoolStatus?
        /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to 100 years (36,500 days).
        public var retentionLockTimeInDays: Swift.Int?
        /// Tape retention lock type, which can be configured in two modes. When configured in governance mode, Amazon Web Services accounts with specific IAM permissions are authorized to remove the tape retention lock from archived virtual tapes. When configured in compliance mode, the tape retention lock cannot be removed by any user, including the root Amazon Web Services account.
        public var retentionLockType: StorageGatewayClientTypes.RetentionLockType?
        /// The storage class that is associated with the custom pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var storageClass: StorageGatewayClientTypes.TapeStorageClass?

        public init (
            poolARN: Swift.String? = nil,
            poolName: Swift.String? = nil,
            poolStatus: StorageGatewayClientTypes.PoolStatus? = nil,
            retentionLockTimeInDays: Swift.Int? = nil,
            retentionLockType: StorageGatewayClientTypes.RetentionLockType? = nil,
            storageClass: StorageGatewayClientTypes.TapeStorageClass? = nil
        )
        {
            self.poolARN = poolARN
            self.poolName = poolName
            self.poolStatus = poolStatus
            self.retentionLockTimeInDays = retentionLockTimeInDays
            self.retentionLockType = retentionLockType
            self.storageClass = storageClass
        }
    }

}

extension StorageGatewayClientTypes {
    public enum PoolStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolStatus] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolStatus(rawValue: rawValue) ?? PoolStatus.sdkUnknown(rawValue)
        }
    }
}

extension RefreshCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case folderList = "FolderList"
        case recursive = "Recursive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let folderList = folderList {
            var folderListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderList)
            for folder0 in folderList {
                try folderListContainer.encode(folder0)
            }
        }
        if let recursive = self.recursive {
            try encodeContainer.encode(recursive, forKey: .recursive)
        }
    }
}

extension RefreshCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// RefreshCacheInput
public struct RefreshCacheInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share you want to refresh.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// A comma-separated list of the paths of folders to refresh in the cache. The default is ["/"]. The default refreshes objects and folders at the root of the Amazon S3 bucket. If Recursive is set to true, the entire S3 bucket that the file share has access to is refreshed.
    public var folderList: [Swift.String]?
    /// A value that specifies whether to recursively refresh folders in the cache. The refresh includes folders that were in the cache the last time the gateway listed the folder's contents. If this value set to true, each folder that is listed in FolderList is recursively updated. Otherwise, subfolders listed in FolderList are not refreshed. Only objects that are in folders listed directly under FolderList are found and used for the update. The default is true. Valid Values: true | false
    public var recursive: Swift.Bool?

    public init (
        fileShareARN: Swift.String? = nil,
        folderList: [Swift.String]? = nil,
        recursive: Swift.Bool? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.folderList = folderList
        self.recursive = recursive
    }
}

struct RefreshCacheInputBody: Swift.Equatable {
    let fileShareARN: Swift.String?
    let folderList: [Swift.String]?
    let recursive: Swift.Bool?
}

extension RefreshCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case folderList = "FolderList"
        case recursive = "Recursive"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let folderListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .folderList)
        var folderListDecoded0:[Swift.String]? = nil
        if let folderListContainer = folderListContainer {
            folderListDecoded0 = [Swift.String]()
            for string0 in folderListContainer {
                if let string0 = string0 {
                    folderListDecoded0?.append(string0)
                }
            }
        }
        folderList = folderListDecoded0
        let recursiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recursive)
        recursive = recursiveDecoded
    }
}

extension RefreshCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RefreshCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RefreshCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
            self.notificationId = output.notificationId
        } else {
            self.fileShareARN = nil
            self.notificationId = nil
        }
    }
}

/// RefreshCacheOutput
public struct RefreshCacheOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the file share.
    public var fileShareARN: Swift.String?
    /// The randomly generated ID of the notification that was sent. This ID is in UUID format.
    public var notificationId: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil,
        notificationId: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

struct RefreshCacheOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
    let notificationId: Swift.String?
}

extension RefreshCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
        case notificationId = "NotificationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let notificationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationId)
        notificationId = notificationIdDecoded
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// RemoveTagsFromResourceInput
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to remove the tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags you want to remove from the specified resource. A tag is composed of a key-value pair.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RemoveTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

/// RemoveTagsFromResourceOutput
public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that the tags were removed from.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ResetCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension ResetCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetCacheInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ResetCacheInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ResetCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ResetCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetCacheOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResetCacheOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct ResetCacheOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ResetCacheOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ResetCacheOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes {
    public enum RetentionLockType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionLockType] {
            return [
                .compliance,
                .governance,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionLockType(rawValue: rawValue) ?? RetentionLockType.sdkUnknown(rawValue)
        }
    }
}

extension RetrieveTapeArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension RetrieveTapeArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// RetrieveTapeArchiveInput
public struct RetrieveTapeArchiveInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway you want to retrieve the virtual tape to. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region. You retrieve archived virtual tapes to only one gateway and the gateway must be a tape gateway.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape you want to retrieve from the virtual tape shelf (VTS).
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeArchiveInputBody: Swift.Equatable {
    let tapeARN: Swift.String?
    let gatewayARN: Swift.String?
}

extension RetrieveTapeArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension RetrieveTapeArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveTapeArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetrieveTapeArchiveOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveTapeArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetrieveTapeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// RetrieveTapeArchiveOutput
public struct RetrieveTapeArchiveOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retrieved virtual tape.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeArchiveOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension RetrieveTapeArchiveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension RetrieveTapeRecoveryPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

extension RetrieveTapeRecoveryPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// RetrieveTapeRecoveryPointInput
public struct RetrieveTapeRecoveryPointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the virtual tape for which you want to retrieve the recovery point.
    /// This member is required.
    public var tapeARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        tapeARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeRecoveryPointInputBody: Swift.Equatable {
    let tapeARN: Swift.String?
    let gatewayARN: Swift.String?
}

extension RetrieveTapeRecoveryPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension RetrieveTapeRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveTapeRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetrieveTapeRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveTapeRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetrieveTapeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// RetrieveTapeRecoveryPointOutput
public struct RetrieveTapeRecoveryPointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the virtual tape for which the recovery point was retrieved.
    public var tapeARN: Swift.String?

    public init (
        tapeARN: Swift.String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeRecoveryPointOutputResponseBody: Swift.Equatable {
    let tapeARN: Swift.String?
}

extension RetrieveTapeRecoveryPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension StorageGatewayClientTypes.SMBFileShareInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case bucketRegion = "BucketRegion"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareName = "FileShareName"
        case fileShareStatus = "FileShareStatus"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case path = "Path"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case smbaclEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case vpcEndpointDNSName = "VPCEndpointDNSName"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = self.accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlistuser0 in adminUserList {
                try adminUserListContainer.encode(userlistuser0)
            }
        }
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let bucketRegion = self.bucketRegion {
            try encodeContainer.encode(bucketRegion, forKey: .bucketRegion)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = self.caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let defaultStorageClass = self.defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = self.fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareName = self.fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let fileShareStatus = self.fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = self.guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlistuser0 in invalidUserList {
                try invalidUserListContainer.encode(userlistuser0)
            }
        }
        if kmsEncrypted != false {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let locationARN = self.locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let notificationPolicy = self.notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = self.objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let oplocksEnabled = self.oplocksEnabled {
            try encodeContainer.encode(oplocksEnabled, forKey: .oplocksEnabled)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = self.requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let smbaclEnabled = self.smbaclEnabled {
            try encodeContainer.encode(smbaclEnabled, forKey: .smbaclEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcEndpointDNSName = self.vpcEndpointDNSName {
            try encodeContainer.encode(vpcEndpointDNSName, forKey: .vpcEndpointDNSName)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlistuser0 in validUserList {
                try validUserListContainer.encode(userlistuser0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted) ?? false
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let smbaclEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smbaclEnabled)
        smbaclEnabled = smbaclEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[Swift.String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [Swift.String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validUserList)
        var validUserListDecoded0:[Swift.String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [Swift.String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[Swift.String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [Swift.String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let vpcEndpointDNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointDNSName)
        vpcEndpointDNSName = vpcEndpointDNSNameDecoded
        let bucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketRegion)
        bucketRegion = bucketRegionDecoded
        let oplocksEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .oplocksEnabled)
        oplocksEnabled = oplocksEnabledDecoded
    }
}

extension StorageGatewayClientTypes {
    /// The Windows file permissions and ownership information assigned, by default, to native S3 objects when S3 File Gateway discovers them in S3 buckets. This operation is only supported for S3 File Gateways.
    public struct SMBFileShareInfo: Swift.Equatable {
        /// Indicates whether AccessBasedEnumeration is enabled.
        public var accessBasedEnumeration: Swift.Bool?
        /// A list of users or groups in the Active Directory that have administrator rights to the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public var adminUserList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public var auditDestinationARN: Swift.String?
        /// The authentication method of the file share. The default is ActiveDirectory. Valid Values: ActiveDirectory | GuestAccess
        public var authentication: Swift.String?
        /// Specifies the Region of the S3 bucket where the SMB file share stores files. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var bucketRegion: Swift.String?
        /// Refresh cache information for the file share.
        public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
        /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
        public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public var defaultStorageClass: Swift.String?
        /// The Amazon Resource Name (ARN) of the file share.
        public var fileShareARN: Swift.String?
        /// The ID of the file share.
        public var fileShareId: Swift.String?
        /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
        public var fileShareName: Swift.String?
        /// The status of the file share. Valid Values: CREATING | UPDATING | AVAILABLE | DELETING
        public var fileShareStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public var guessMIMETypeEnabled: Swift.Bool?
        /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public var invalidUserList: [Swift.String]?
        /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
        public var kmsEncrypted: Swift.Bool
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public var kmsKey: Swift.String?
        /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/). You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN: arn:aws:s3:::my-bucket/prefix/ Access point ARN: arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/ If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see [Delegating access control to access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points-policies.html#access-points-delegating-control) in the Amazon S3 User Guide. Access point alias: test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
        public var locationARN: Swift.String?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {"Upload": {"SettlingTimeInSeconds": 60}} The following example sets NotificationPolicy off. {}
        public var notificationPolicy: Swift.String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that an S3 File Gateway puts objects into. The default value is private.
        public var objectACL: StorageGatewayClientTypes.ObjectACL?
        /// Specifies whether opportunistic locking is enabled for the SMB file share. Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case. Valid Values: true | false
        public var oplocksEnabled: Swift.Bool?
        /// The file share path used by the SMB client to identify the mount point.
        public var path: Swift.String?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public var readOnly: Swift.Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
        public var requesterPays: Swift.Bool?
        /// The ARN of the IAM role that an S3 File Gateway assumes when it accesses the underlying storage.
        public var role: Swift.String?
        /// If this value is set to true, it indicates that access control list (ACL) is enabled on the SMB file share. If it is set to false, it indicates that file and directory permissions are mapped to the POSIX permission. For more information, see [Using Microsoft Windows ACLs to control access to an SMB file share](https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html) in the Storage Gateway User Guide.
        public var smbaclEnabled: Swift.Bool?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public var tags: [StorageGatewayClientTypes.Tag]?
        /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public var validUserList: [Swift.String]?
        /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3. This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public var vpcEndpointDNSName: Swift.String?

        public init (
            accessBasedEnumeration: Swift.Bool? = nil,
            adminUserList: [Swift.String]? = nil,
            auditDestinationARN: Swift.String? = nil,
            authentication: Swift.String? = nil,
            bucketRegion: Swift.String? = nil,
            cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
            caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
            defaultStorageClass: Swift.String? = nil,
            fileShareARN: Swift.String? = nil,
            fileShareId: Swift.String? = nil,
            fileShareName: Swift.String? = nil,
            fileShareStatus: Swift.String? = nil,
            gatewayARN: Swift.String? = nil,
            guessMIMETypeEnabled: Swift.Bool? = nil,
            invalidUserList: [Swift.String]? = nil,
            kmsEncrypted: Swift.Bool = false,
            kmsKey: Swift.String? = nil,
            locationARN: Swift.String? = nil,
            notificationPolicy: Swift.String? = nil,
            objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
            oplocksEnabled: Swift.Bool? = nil,
            path: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            requesterPays: Swift.Bool? = nil,
            role: Swift.String? = nil,
            smbaclEnabled: Swift.Bool? = nil,
            tags: [StorageGatewayClientTypes.Tag]? = nil,
            validUserList: [Swift.String]? = nil,
            vpcEndpointDNSName: Swift.String? = nil
        )
        {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.smbaclEnabled = smbaclEnabled
            self.tags = tags
            self.validUserList = validUserList
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }
    }

}

extension StorageGatewayClientTypes.SMBLocalGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayAdmins = "GatewayAdmins"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayAdmins = gatewayAdmins {
            var gatewayAdminsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayAdmins)
            for userlistuser0 in gatewayAdmins {
                try gatewayAdminsContainer.encode(userlistuser0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayAdminsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .gatewayAdmins)
        var gatewayAdminsDecoded0:[Swift.String]? = nil
        if let gatewayAdminsContainer = gatewayAdminsContainer {
            gatewayAdminsDecoded0 = [Swift.String]()
            for string0 in gatewayAdminsContainer {
                if let string0 = string0 {
                    gatewayAdminsDecoded0?.append(string0)
                }
            }
        }
        gatewayAdmins = gatewayAdminsDecoded0
    }
}

extension StorageGatewayClientTypes {
    /// A list of Active Directory users and groups that have special permissions for SMB file shares on the gateway.
    public struct SMBLocalGroups: Swift.Equatable {
        /// A list of Active Directory users and groups that have local Gateway Admin permissions. Acceptable formats include: DOMAIN\User1, user1, DOMAIN\group1, and group1. Gateway Admins can use the Shared Folders Microsoft Management Console snap-in to force-close files that are open and locked.
        public var gatewayAdmins: [Swift.String]?

        public init (
            gatewayAdmins: [Swift.String]? = nil
        )
        {
            self.gatewayAdmins = gatewayAdmins
        }
    }

}

extension StorageGatewayClientTypes {
    public enum SMBSecurityStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clientspecified
        case mandatoryencryption
        case mandatorysigning
        case sdkUnknown(Swift.String)

        public static var allCases: [SMBSecurityStrategy] {
            return [
                .clientspecified,
                .mandatoryencryption,
                .mandatorysigning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientspecified: return "ClientSpecified"
            case .mandatoryencryption: return "MandatoryEncryption"
            case .mandatorysigning: return "MandatorySigning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SMBSecurityStrategy(rawValue: rawValue) ?? SMBSecurityStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableErrorBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error has occurred because the service is unavailable. For more information, see the error and message fields.
public struct ServiceUnavailableError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A [StorageGatewayError] that provides more information about the cause of the error.
    public var error: StorageGatewayClientTypes.StorageGatewayError?
    /// A human-readable message describing the error that occurred.
    public var message: Swift.String?

    public init (
        error: StorageGatewayClientTypes.StorageGatewayError? = nil,
        message: Swift.String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct ServiceUnavailableErrorBody: Swift.Equatable {
    let message: Swift.String?
    let error: StorageGatewayClientTypes.StorageGatewayError?
}

extension ServiceUnavailableErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

extension SetLocalConsolePasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetLocalConsolePasswordInput(gatewayARN: \(Swift.String(describing: gatewayARN)), localConsolePassword: \"CONTENT_REDACTED\")"}
}

extension SetLocalConsolePasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case localConsolePassword = "LocalConsolePassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let localConsolePassword = self.localConsolePassword {
            try encodeContainer.encode(localConsolePassword, forKey: .localConsolePassword)
        }
    }
}

extension SetLocalConsolePasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// SetLocalConsolePasswordInput
public struct SetLocalConsolePasswordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The password you want to set for your VM local console.
    /// This member is required.
    public var localConsolePassword: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        localConsolePassword: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.localConsolePassword = localConsolePassword
    }
}

struct SetLocalConsolePasswordInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let localConsolePassword: Swift.String?
}

extension SetLocalConsolePasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case localConsolePassword = "LocalConsolePassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let localConsolePasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localConsolePassword)
        localConsolePassword = localConsolePasswordDecoded
    }
}

extension SetLocalConsolePasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetLocalConsolePasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetLocalConsolePasswordOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLocalConsolePasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SetLocalConsolePasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct SetLocalConsolePasswordOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct SetLocalConsolePasswordOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension SetLocalConsolePasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension SetSMBGuestPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSMBGuestPasswordInput(gatewayARN: \(Swift.String(describing: gatewayARN)), password: \"CONTENT_REDACTED\")"}
}

extension SetSMBGuestPasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case password = "Password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

extension SetSMBGuestPasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// SetSMBGuestPasswordInput
public struct SetSMBGuestPasswordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 File Gateway the SMB file share is associated with.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The password that you want to set for your SMB server.
    /// This member is required.
    public var password: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.password = password
    }
}

struct SetSMBGuestPasswordInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let password: Swift.String?
}

extension SetSMBGuestPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case password = "Password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension SetSMBGuestPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetSMBGuestPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetSMBGuestPasswordOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSMBGuestPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SetSMBGuestPasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct SetSMBGuestPasswordOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct SetSMBGuestPasswordOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension SetSMBGuestPasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ShutdownGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension ShutdownGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to shut down.
public struct ShutdownGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ShutdownGatewayInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ShutdownGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ShutdownGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ShutdownGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ShutdownGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ShutdownGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ShutdownGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was shut down.
public struct ShutdownGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ShutdownGatewayOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension ShutdownGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartAvailabilityMonitorTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension StartAvailabilityMonitorTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAvailabilityMonitorTestInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartAvailabilityMonitorTestInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension StartAvailabilityMonitorTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartAvailabilityMonitorTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAvailabilityMonitorTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartAvailabilityMonitorTestOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAvailabilityMonitorTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartAvailabilityMonitorTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct StartAvailabilityMonitorTestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartAvailabilityMonitorTestOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension StartAvailabilityMonitorTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension StartGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to start.
public struct StartGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartGatewayInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension StartGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was restarted.
public struct StartGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartGatewayOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension StartGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayClientTypes.StorageGatewayError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .errorDetails)
            for (dictKey0, errorDetails0) in errorDetails {
                try errorDetailsContainer.encode(errorDetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .errorDetails)
        var errorDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in errorDetailsContainer {
                if let string0 = string0 {
                    errorDetailsDecoded0?[key0] = string0
                }
            }
        }
        errorDetails = errorDetailsDecoded0
    }
}

extension StorageGatewayClientTypes {
    /// Provides additional information about an error that was returned by the service. See the errorCode and errorDetails members for more information about the error.
    public struct StorageGatewayError: Swift.Equatable {
        /// Additional information about the error.
        public var errorCode: StorageGatewayClientTypes.ErrorCode?
        /// Human-readable text that provides detail about the error that occurred.
        public var errorDetails: [Swift.String:Swift.String]?

        public init (
            errorCode: StorageGatewayClientTypes.ErrorCode? = nil,
            errorDetails: [Swift.String:Swift.String]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
        }
    }

}

extension StorageGatewayClientTypes.StorediSCSIVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case kmsKey = "KMSKey"
        case preservedExistingData = "PreservedExistingData"
        case sourceSnapshotId = "SourceSnapshotId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeDiskId = "VolumeDiskId"
        case volumeId = "VolumeId"
        case volumeProgress = "VolumeProgress"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeStatus = "VolumeStatus"
        case volumeType = "VolumeType"
        case volumeUsedInBytes = "VolumeUsedInBytes"
        case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if preservedExistingData != false {
            try encodeContainer.encode(preservedExistingData, forKey: .preservedExistingData)
        }
        if let sourceSnapshotId = self.sourceSnapshotId {
            try encodeContainer.encode(sourceSnapshotId, forKey: .sourceSnapshotId)
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = self.volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeDiskId = self.volumeDiskId {
            try encodeContainer.encode(volumeDiskId, forKey: .volumeDiskId)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeProgress = self.volumeProgress {
            try encodeContainer.encode(volumeProgress, forKey: .volumeProgress)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeStatus = self.volumeStatus {
            try encodeContainer.encode(volumeStatus, forKey: .volumeStatus)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
        if let volumeUsedInBytes = self.volumeUsedInBytes {
            try encodeContainer.encode(volumeUsedInBytes, forKey: .volumeUsedInBytes)
        }
        if let volumeiSCSIAttributes = self.volumeiSCSIAttributes {
            try encodeContainer.encode(volumeiSCSIAttributes, forKey: .volumeiSCSIAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeStatus)
        volumeStatus = volumeStatusDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
        let volumeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInBytes) ?? 0
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeProgressDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .volumeProgress)
        volumeProgress = volumeProgressDecoded
        let volumeDiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeDiskId)
        volumeDiskId = volumeDiskIdDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let preservedExistingDataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preservedExistingData) ?? false
        preservedExistingData = preservedExistingDataDecoded
        let volumeiSCSIAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.VolumeiSCSIAttributes.self, forKey: .volumeiSCSIAttributes)
        volumeiSCSIAttributes = volumeiSCSIAttributesDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let volumeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsedInBytes)
        volumeUsedInBytes = volumeUsedInBytesDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes an iSCSI stored volume.
    public struct StorediSCSIVolume: Swift.Equatable {
        /// The date the volume was created. Volumes created prior to March 28, 2017 don’t have this timestamp.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public var kmsKey: Swift.String?
        /// Indicates if when the stored volume was created, existing data on the underlying local disk was preserved. Valid Values: true | false
        public var preservedExistingData: Swift.Bool
        /// If the stored volume was created from a snapshot, this field contains the snapshot ID used, e.g. snap-78e22663. Otherwise, this field is not included.
        public var sourceSnapshotId: Swift.String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public var targetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public var volumeARN: Swift.String?
        /// A value that indicates whether a storage volume is attached to, detached from, or is in the process of detaching from a gateway. For more information, see [Moving your volumes to a different gateway](https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume).
        public var volumeAttachmentStatus: Swift.String?
        /// The ID of the local disk that was specified in the [CreateStorediSCSIVolume] operation.
        public var volumeDiskId: Swift.String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public var volumeId: Swift.String?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the stored volume is not restoring or bootstrapping.
        public var volumeProgress: Swift.Double?
        /// The size of the volume in bytes.
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeStatus: Swift.String?
        /// One of the VolumeType enumeration values describing the type of the volume.
        public var volumeType: Swift.String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on the number of blocks that are touched, instead of the actual amount of data written. This value can be useful for sequential write patterns but less accurate for random write patterns. VolumeUsedInBytes is different from the compressed size of the volume, which is the value that is used to calculate your bill. This value is not available for volumes created prior to May 13, 2015, until you store data on the volume.
        public var volumeUsedInBytes: Swift.Int?
        /// An [VolumeiSCSIAttributes] object that represents a collection of iSCSI attributes for one stored volume.
        public var volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            kmsKey: Swift.String? = nil,
            preservedExistingData: Swift.Bool = false,
            sourceSnapshotId: Swift.String? = nil,
            targetName: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeDiskId: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeProgress: Swift.Double? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil,
            volumeUsedInBytes: Swift.Int? = nil,
            volumeiSCSIAttributes: StorageGatewayClientTypes.VolumeiSCSIAttributes? = nil
        )
        {
            self.createdDate = createdDate
            self.kmsKey = kmsKey
            self.preservedExistingData = preservedExistingData
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeDiskId = volumeDiskId
            self.volumeId = volumeId
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
        }
    }

}

extension StorageGatewayClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension StorageGatewayClientTypes {
    /// A key-value pair that helps you manage, filter, and search for your resource. Allowed characters: letters, white space, and numbers, representable in UTF-8, and the following characters: + - = . _ : /.
    public struct Tag: Swift.Equatable {
        /// Tag key. The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension StorageGatewayClientTypes.Tape: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey = "KMSKey"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case progress = "Progress"
        case retentionStartDate = "RetentionStartDate"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeCreatedDate = "TapeCreatedDate"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
        case tapeUsedInBytes = "TapeUsedInBytes"
        case vtlDevice = "VTLDevice"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let poolEntryDate = self.poolEntryDate {
            try encodeContainer.encodeTimestamp(poolEntryDate, format: .epochSeconds, forKey: .poolEntryDate)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let progress = self.progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
        if let retentionStartDate = self.retentionStartDate {
            try encodeContainer.encodeTimestamp(retentionStartDate, format: .epochSeconds, forKey: .retentionStartDate)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = self.tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeCreatedDate = self.tapeCreatedDate {
            try encodeContainer.encodeTimestamp(tapeCreatedDate, format: .epochSeconds, forKey: .tapeCreatedDate)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = self.tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
        if let tapeUsedInBytes = self.tapeUsedInBytes {
            try encodeContainer.encode(tapeUsedInBytes, forKey: .tapeUsedInBytes)
        }
        if let vtlDevice = self.vtlDevice {
            try encodeContainer.encode(vtlDevice, forKey: .vtlDevice)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .tapeCreatedDate)
        tapeCreatedDate = tapeCreatedDateDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let vtlDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDevice)
        vtlDevice = vtlDeviceDecoded
        let progressDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .progress)
        progress = progressDecoded
        let tapeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeUsedInBytes)
        tapeUsedInBytes = tapeUsedInBytesDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .worm) ?? false
        worm = wormDecoded
        let retentionStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a virtual tape object.
    public struct Tape: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public var kmsKey: Swift.String?
        /// The date that the tape enters a custom tape pool.
        public var poolEntryDate: ClientRuntime.Date?
        /// The ID of the pool that contains tapes that will be archived. The tapes in this pool are archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var poolId: Swift.String?
        /// For archiving virtual tapes, indicates how much data remains to be uploaded before archiving is complete. Range: 0 (not started) to 100 (complete).
        public var progress: Swift.Double?
        /// The date that the tape is first archived with tape retention lock enabled.
        public var retentionStartDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies a specific virtual tape.
        public var tapeBarcode: Swift.String?
        /// The date the virtual tape was created.
        public var tapeCreatedDate: ClientRuntime.Date?
        /// The size, in bytes, of the virtual tape capacity.
        public var tapeSizeInBytes: Swift.Int?
        /// The current state of the virtual tape.
        public var tapeStatus: Swift.String?
        /// The size, in bytes, of data stored on the virtual tape. This value is not available for tapes created prior to May 13, 2015.
        public var tapeUsedInBytes: Swift.Int?
        /// The virtual tape library (VTL) device that the virtual tape is associated with.
        public var vtlDevice: Swift.String?
        /// If the tape is archived as write-once-read-many (WORM), this value is true.
        public var worm: Swift.Bool

        public init (
            kmsKey: Swift.String? = nil,
            poolEntryDate: ClientRuntime.Date? = nil,
            poolId: Swift.String? = nil,
            progress: Swift.Double? = nil,
            retentionStartDate: ClientRuntime.Date? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeCreatedDate: ClientRuntime.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil,
            tapeUsedInBytes: Swift.Int? = nil,
            vtlDevice: Swift.String? = nil,
            worm: Swift.Bool = false
        )
        {
            self.kmsKey = kmsKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.progress = progress
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.vtlDevice = vtlDevice
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes.TapeArchive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case kmsKey = "KMSKey"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case retentionStartDate = "RetentionStartDate"
        case retrievedTo = "RetrievedTo"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeCreatedDate = "TapeCreatedDate"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
        case tapeUsedInBytes = "TapeUsedInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let poolEntryDate = self.poolEntryDate {
            try encodeContainer.encodeTimestamp(poolEntryDate, format: .epochSeconds, forKey: .poolEntryDate)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let retentionStartDate = self.retentionStartDate {
            try encodeContainer.encodeTimestamp(retentionStartDate, format: .epochSeconds, forKey: .retentionStartDate)
        }
        if let retrievedTo = self.retrievedTo {
            try encodeContainer.encode(retrievedTo, forKey: .retrievedTo)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = self.tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeCreatedDate = self.tapeCreatedDate {
            try encodeContainer.encodeTimestamp(tapeCreatedDate, format: .epochSeconds, forKey: .tapeCreatedDate)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = self.tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
        if let tapeUsedInBytes = self.tapeUsedInBytes {
            try encodeContainer.encode(tapeUsedInBytes, forKey: .tapeUsedInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeCreatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .tapeCreatedDate)
        tapeCreatedDate = tapeCreatedDateDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let retrievedToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievedTo)
        retrievedTo = retrievedToDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let tapeUsedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeUsedInBytes)
        tapeUsedInBytes = tapeUsedInBytesDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .worm) ?? false
        worm = wormDecoded
        let retentionStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Represents a virtual tape that is archived in the virtual tape shelf (VTS).
    public struct TapeArchive: Swift.Equatable {
        /// The time that the archiving of the virtual tape was completed. The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var completionTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public var kmsKey: Swift.String?
        /// The time that the tape entered the custom tape pool. The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var poolEntryDate: ClientRuntime.Date?
        /// The ID of the pool that was used to archive the tape. The tapes in this pool are archived in the S3 storage class that is associated with the pool.
        public var poolId: Swift.String?
        /// If the archived tape is subject to tape retention lock, the date that the archived tape started being retained.
        public var retentionStartDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the tape gateway that the virtual tape is being retrieved to. The virtual tape is retrieved from the virtual tape shelf (VTS).
        public var retrievedTo: Swift.String?
        /// The Amazon Resource Name (ARN) of an archived virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies the archived virtual tape.
        public var tapeBarcode: Swift.String?
        /// The date the virtual tape was created.
        public var tapeCreatedDate: ClientRuntime.Date?
        /// The size, in bytes, of the archived virtual tape.
        public var tapeSizeInBytes: Swift.Int?
        /// The current state of the archived virtual tape.
        public var tapeStatus: Swift.String?
        /// The size, in bytes, of data stored on the virtual tape. This value is not available for tapes created prior to May 13, 2015.
        public var tapeUsedInBytes: Swift.Int?
        /// Set to true if the archived tape is stored as write-once-read-many (WORM).
        public var worm: Swift.Bool

        public init (
            completionTime: ClientRuntime.Date? = nil,
            kmsKey: Swift.String? = nil,
            poolEntryDate: ClientRuntime.Date? = nil,
            poolId: Swift.String? = nil,
            retentionStartDate: ClientRuntime.Date? = nil,
            retrievedTo: Swift.String? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeCreatedDate: ClientRuntime.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil,
            tapeUsedInBytes: Swift.Int? = nil,
            worm: Swift.Bool = false
        )
        {
            self.completionTime = completionTime
            self.kmsKey = kmsKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.retrievedTo = retrievedTo
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.worm = worm
        }
    }

}

extension StorageGatewayClientTypes.TapeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case retentionStartDate = "RetentionStartDate"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let poolEntryDate = self.poolEntryDate {
            try encodeContainer.encodeTimestamp(poolEntryDate, format: .epochSeconds, forKey: .poolEntryDate)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let retentionStartDate = self.retentionStartDate {
            try encodeContainer.encodeTimestamp(retentionStartDate, format: .epochSeconds, forKey: .retentionStartDate)
        }
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = self.tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = self.tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let retentionStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a virtual tape.
    public struct TapeInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The date that the tape entered the custom tape pool with tape retention lock enabled.
        public var poolEntryDate: ClientRuntime.Date?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public var poolId: Swift.String?
        /// The date that the tape became subject to tape retention lock.
        public var retentionStartDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of a virtual tape.
        public var tapeARN: Swift.String?
        /// The barcode that identifies a specific virtual tape.
        public var tapeBarcode: Swift.String?
        /// The size, in bytes, of a virtual tape.
        public var tapeSizeInBytes: Swift.Int?
        /// The status of the tape.
        public var tapeStatus: Swift.String?

        public init (
            gatewayARN: Swift.String? = nil,
            poolEntryDate: ClientRuntime.Date? = nil,
            poolId: Swift.String? = nil,
            retentionStartDate: ClientRuntime.Date? = nil,
            tapeARN: Swift.String? = nil,
            tapeBarcode: Swift.String? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil
        )
        {
            self.gatewayARN = gatewayARN
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }
    }

}

extension StorageGatewayClientTypes.TapeRecoveryPointInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tapeARN = "TapeARN"
        case tapeRecoveryPointTime = "TapeRecoveryPointTime"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tapeARN = self.tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeRecoveryPointTime = self.tapeRecoveryPointTime {
            try encodeContainer.encodeTimestamp(tapeRecoveryPointTime, format: .epochSeconds, forKey: .tapeRecoveryPointTime)
        }
        if let tapeSizeInBytes = self.tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = self.tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeRecoveryPointTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .tapeRecoveryPointTime)
        tapeRecoveryPointTime = tapeRecoveryPointTimeDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a recovery point.
    public struct TapeRecoveryPointInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public var tapeARN: Swift.String?
        /// The time when the point-in-time view of the virtual tape was replicated for later recovery. The default timestamp format of the tape recovery point time is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public var tapeRecoveryPointTime: ClientRuntime.Date?
        /// The size, in bytes, of the virtual tapes to recover.
        public var tapeSizeInBytes: Swift.Int?
        /// The status of the virtual tapes.
        public var tapeStatus: Swift.String?

        public init (
            tapeARN: Swift.String? = nil,
            tapeRecoveryPointTime: ClientRuntime.Date? = nil,
            tapeSizeInBytes: Swift.Int? = nil,
            tapeStatus: Swift.String? = nil
        )
        {
            self.tapeARN = tapeARN
            self.tapeRecoveryPointTime = tapeRecoveryPointTime
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }
    }

}

extension StorageGatewayClientTypes {
    public enum TapeStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case sdkUnknown(Swift.String)

        public static var allCases: [TapeStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TapeStorageClass(rawValue: rawValue) ?? TapeStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension UpdateAutomaticTapeCreationPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTapeCreationRules = automaticTapeCreationRules {
            var automaticTapeCreationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automaticTapeCreationRules)
            for automatictapecreationrule0 in automaticTapeCreationRules {
                try automaticTapeCreationRulesContainer.encode(automatictapecreationrule0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension UpdateAutomaticTapeCreationPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAutomaticTapeCreationPolicyInput: Swift.Equatable {
    /// An automatic tape creation policy consists of a list of automatic tape creation rules. The rules determine when and how to automatically create new tapes.
    /// This member is required.
    public var automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.automaticTapeCreationRules = automaticTapeCreationRules
        self.gatewayARN = gatewayARN
    }
}

struct UpdateAutomaticTapeCreationPolicyInputBody: Swift.Equatable {
    let automaticTapeCreationRules: [StorageGatewayClientTypes.AutomaticTapeCreationRule]?
    let gatewayARN: Swift.String?
}

extension UpdateAutomaticTapeCreationPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationRulesContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.AutomaticTapeCreationRule?].self, forKey: .automaticTapeCreationRules)
        var automaticTapeCreationRulesDecoded0:[StorageGatewayClientTypes.AutomaticTapeCreationRule]? = nil
        if let automaticTapeCreationRulesContainer = automaticTapeCreationRulesContainer {
            automaticTapeCreationRulesDecoded0 = [StorageGatewayClientTypes.AutomaticTapeCreationRule]()
            for structure0 in automaticTapeCreationRulesContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationRulesDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationRules = automaticTapeCreationRulesDecoded0
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateAutomaticTapeCreationPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAutomaticTapeCreationPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAutomaticTapeCreationPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAutomaticTapeCreationPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAutomaticTapeCreationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateAutomaticTapeCreationPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateAutomaticTapeCreationPolicyOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateAutomaticTapeCreationPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateBandwidthRateLimitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageDownloadRateLimitInBitsPerSec = self.averageDownloadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageDownloadRateLimitInBitsPerSec, forKey: .averageDownloadRateLimitInBitsPerSec)
        }
        if let averageUploadRateLimitInBitsPerSec = self.averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension UpdateBandwidthRateLimitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [UpdateBandwidthRateLimitInput$AverageDownloadRateLimitInBitsPerSec]
///
/// * [UpdateBandwidthRateLimitInput$AverageUploadRateLimitInBitsPerSec]
public struct UpdateBandwidthRateLimitInput: Swift.Equatable {
    /// The average download bandwidth rate limit in bits per second.
    public var averageDownloadRateLimitInBitsPerSec: Swift.Int?
    /// The average upload bandwidth rate limit in bits per second.
    public var averageUploadRateLimitInBitsPerSec: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        averageDownloadRateLimitInBitsPerSec: Swift.Int? = nil,
        averageUploadRateLimitInBitsPerSec: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let averageUploadRateLimitInBitsPerSec: Swift.Int?
    let averageDownloadRateLimitInBitsPerSec: Swift.Int?
}

extension UpdateBandwidthRateLimitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension UpdateBandwidthRateLimitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBandwidthRateLimitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBandwidthRateLimitOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBandwidthRateLimitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose throttle information was updated.
public struct UpdateBandwidthRateLimitOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateBandwidthRateLimitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateBandwidthRateLimitScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthRateLimitIntervals = bandwidthRateLimitIntervals {
            var bandwidthRateLimitIntervalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandwidthRateLimitIntervals)
            for bandwidthratelimitinterval0 in bandwidthRateLimitIntervals {
                try bandwidthRateLimitIntervalsContainer.encode(bandwidthratelimitinterval0)
            }
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension UpdateBandwidthRateLimitScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateBandwidthRateLimitScheduleInput: Swift.Equatable {
    /// An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
    /// This member is required.
    public var bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitScheduleInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let bandwidthRateLimitIntervals: [StorageGatewayClientTypes.BandwidthRateLimitInterval]?
}

extension UpdateBandwidthRateLimitScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[StorageGatewayClientTypes.BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [StorageGatewayClientTypes.BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension UpdateBandwidthRateLimitScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBandwidthRateLimitScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBandwidthRateLimitScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBandwidthRateLimitScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateBandwidthRateLimitScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitScheduleOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateBandwidthRateLimitScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateChapCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChapCredentialsInput(initiatorName: \(Swift.String(describing: initiatorName)), targetARN: \(Swift.String(describing: targetARN)), secretToAuthenticateInitiator: \"CONTENT_REDACTED\", secretToAuthenticateTarget: \"CONTENT_REDACTED\")"}
}

extension UpdateChapCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = self.initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let secretToAuthenticateInitiator = self.secretToAuthenticateInitiator {
            try encodeContainer.encode(secretToAuthenticateInitiator, forKey: .secretToAuthenticateInitiator)
        }
        if let secretToAuthenticateTarget = self.secretToAuthenticateTarget {
            try encodeContainer.encode(secretToAuthenticateTarget, forKey: .secretToAuthenticateTarget)
        }
        if let targetARN = self.targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

extension UpdateChapCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [UpdateChapCredentialsInput$InitiatorName]
///
/// * [UpdateChapCredentialsInput$SecretToAuthenticateInitiator]
///
/// * [UpdateChapCredentialsInput$SecretToAuthenticateTarget]
///
/// * [UpdateChapCredentialsInput$TargetARN]
public struct UpdateChapCredentialsInput: Swift.Equatable {
    /// The iSCSI initiator that connects to the target.
    /// This member is required.
    public var initiatorName: Swift.String?
    /// The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target. The secret key must be between 12 and 16 bytes when encoded in UTF-8.
    /// This member is required.
    public var secretToAuthenticateInitiator: Swift.String?
    /// The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g. Windows client). Byte constraints: Minimum bytes of 12. Maximum bytes of 16. The secret key must be between 12 and 16 bytes when encoded in UTF-8.
    public var secretToAuthenticateTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the [DescribeStorediSCSIVolumes] operation to return the TargetARN for specified VolumeARN.
    /// This member is required.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        secretToAuthenticateInitiator: Swift.String? = nil,
        secretToAuthenticateTarget: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
        self.secretToAuthenticateTarget = secretToAuthenticateTarget
        self.targetARN = targetARN
    }
}

struct UpdateChapCredentialsInputBody: Swift.Equatable {
    let targetARN: Swift.String?
    let secretToAuthenticateInitiator: Swift.String?
    let initiatorName: Swift.String?
    let secretToAuthenticateTarget: Swift.String?
}

extension UpdateChapCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let secretToAuthenticateInitiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateInitiator)
        secretToAuthenticateInitiator = secretToAuthenticateInitiatorDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
        let secretToAuthenticateTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToAuthenticateTarget)
        secretToAuthenticateTarget = secretToAuthenticateTargetDecoded
    }
}

extension UpdateChapCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChapCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChapCredentialsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChapCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiatorName = output.initiatorName
            self.targetARN = output.targetARN
        } else {
            self.initiatorName = nil
            self.targetARN = nil
        }
    }
}

/// A JSON object containing the following fields:
public struct UpdateChapCredentialsOutputResponse: Swift.Equatable {
    /// The iSCSI initiator that connects to the target. This is the same initiator name specified in the request.
    public var initiatorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the target. This is the same target specified in the request.
    public var targetARN: Swift.String?

    public init (
        initiatorName: Swift.String? = nil,
        targetARN: Swift.String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct UpdateChapCredentialsOutputResponseBody: Swift.Equatable {
    let targetARN: Swift.String?
    let initiatorName: Swift.String?
}

extension UpdateChapCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

extension UpdateFileSystemAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemAssociationInput(auditDestinationARN: \(Swift.String(describing: auditDestinationARN)), cacheAttributes: \(Swift.String(describing: cacheAttributes)), fileSystemAssociationARN: \(Swift.String(describing: fileSystemAssociationARN)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension UpdateFileSystemAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let fileSystemAssociationARN = self.fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension UpdateFileSystemAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFileSystemAssociationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
    public var auditDestinationARN: Swift.String?
    /// The refresh cache information for the file share or FSx file systems.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The Amazon Resource Name (ARN) of the file system association that you want to update.
    /// This member is required.
    public var fileSystemAssociationARN: Swift.String?
    /// The password of the user credential.
    public var password: Swift.String?
    /// The user name of the user credential that has permission to access the root share D$ of the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin user group.
    public var userName: Swift.String?

    public init (
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        fileSystemAssociationARN: Swift.String? = nil,
        password: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.password = password
        self.userName = userName
    }
}

struct UpdateFileSystemAssociationInputBody: Swift.Equatable {
    let fileSystemAssociationARN: Swift.String?
    let userName: Swift.String?
    let password: Swift.String?
    let auditDestinationARN: Swift.String?
    let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
}

extension UpdateFileSystemAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case password = "Password"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
    }
}

extension UpdateFileSystemAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFileSystemAssociationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFileSystemAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct UpdateFileSystemAssociationOutputResponse: Swift.Equatable {
    /// The ARN of the updated file system association.
    public var fileSystemAssociationARN: Swift.String?

    public init (
        fileSystemAssociationARN: Swift.String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct UpdateFileSystemAssociationOutputResponseBody: Swift.Equatable {
    let fileSystemAssociationARN: Swift.String?
}

extension UpdateFileSystemAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

extension UpdateGatewayInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case gatewayARN = "GatewayARN"
        case gatewayCapacity = "GatewayCapacity"
        case gatewayName = "GatewayName"
        case gatewayTimezone = "GatewayTimezone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupARN = self.cloudWatchLogGroupARN {
            try encodeContainer.encode(cloudWatchLogGroupARN, forKey: .cloudWatchLogGroupARN)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayCapacity = self.gatewayCapacity {
            try encodeContainer.encode(gatewayCapacity.rawValue, forKey: .gatewayCapacity)
        }
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayTimezone = self.gatewayTimezone {
            try encodeContainer.encode(gatewayTimezone, forKey: .gatewayTimezone)
        }
    }
}

extension UpdateGatewayInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayInformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that you want to use to monitor and log events in the gateway. For more information, see [What is Amazon CloudWatch Logs?](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html)
    public var cloudWatchLogGroupARN: Swift.String?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies the size of the gateway's metadata cache.
    public var gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?
    /// A value that indicates the time zone of the gateway.
    public var gatewayTimezone: Swift.String?

    public init (
        cloudWatchLogGroupARN: Swift.String? = nil,
        gatewayARN: Swift.String? = nil,
        gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity? = nil,
        gatewayName: Swift.String? = nil,
        gatewayTimezone: Swift.String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.gatewayARN = gatewayARN
        self.gatewayCapacity = gatewayCapacity
        self.gatewayName = gatewayName
        self.gatewayTimezone = gatewayTimezone
    }
}

struct UpdateGatewayInformationInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let gatewayName: Swift.String?
    let gatewayTimezone: Swift.String?
    let cloudWatchLogGroupARN: Swift.String?
    let gatewayCapacity: StorageGatewayClientTypes.GatewayCapacity?
}

extension UpdateGatewayInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case gatewayARN = "GatewayARN"
        case gatewayCapacity = "GatewayCapacity"
        case gatewayName = "GatewayName"
        case gatewayTimezone = "GatewayTimezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let cloudWatchLogGroupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupARN)
        cloudWatchLogGroupARN = cloudWatchLogGroupARNDecoded
        let gatewayCapacityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.GatewayCapacity.self, forKey: .gatewayCapacity)
        gatewayCapacity = gatewayCapacityDecoded
    }
}

extension UpdateGatewayInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewayInformationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
            self.gatewayName = output.gatewayName
        } else {
            self.gatewayARN = nil
            self.gatewayName = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was updated.
public struct UpdateGatewayInformationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?
    /// The name you configured for your gateway.
    public var gatewayName: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInformationOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let gatewayName: Swift.String?
}

extension UpdateGatewayInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case gatewayName = "GatewayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

extension UpdateGatewaySoftwareNowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension UpdateGatewaySoftwareNowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway to update.
public struct UpdateGatewaySoftwareNowInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateGatewaySoftwareNowInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateGatewaySoftwareNowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateGatewaySoftwareNowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewaySoftwareNowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewaySoftwareNowOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewaySoftwareNowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGatewaySoftwareNowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway that was updated.
public struct UpdateGatewaySoftwareNowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateGatewaySoftwareNowOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateGatewaySoftwareNowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateMaintenanceStartTimeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let hourOfDay = self.hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = self.minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }
}

extension UpdateMaintenanceStartTimeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing the following fields:
///
/// * [UpdateMaintenanceStartTimeInput$DayOfMonth]
///
/// * [UpdateMaintenanceStartTimeInput$DayOfWeek]
///
/// * [UpdateMaintenanceStartTimeInput$HourOfDay]
///
/// * [UpdateMaintenanceStartTimeInput$MinuteOfHour]
public struct UpdateMaintenanceStartTimeInput: Swift.Equatable {
    /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
    public var dayOfMonth: Swift.Int?
    /// The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.
    public var dayOfWeek: Swift.Int?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// The hour component of the maintenance start time represented as hh, where hh is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
    /// This member is required.
    public var hourOfDay: Swift.Int?
    /// The minute component of the maintenance start time represented as mm, where mm is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
    /// This member is required.
    public var minuteOfHour: Swift.Int?

    public init (
        dayOfMonth: Swift.Int? = nil,
        dayOfWeek: Swift.Int? = nil,
        gatewayARN: Swift.String? = nil,
        hourOfDay: Swift.Int? = nil,
        minuteOfHour: Swift.Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

struct UpdateMaintenanceStartTimeInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let hourOfDay: Swift.Int?
    let minuteOfHour: Swift.Int?
    let dayOfWeek: Swift.Int?
    let dayOfMonth: Swift.Int?
}

extension UpdateMaintenanceStartTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension UpdateMaintenanceStartTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceStartTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMaintenanceStartTimeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceStartTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the gateway whose maintenance start time is updated.
public struct UpdateMaintenanceStartTimeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateMaintenanceStartTimeOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateMaintenanceStartTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateNFSFileShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case nfsFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case squash = "Squash"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for ipv4addresscidr0 in clientList {
                try clientListContainer.encode(ipv4addresscidr0)
            }
        }
        if let defaultStorageClass = self.defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareName = self.fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let guessMIMETypeEnabled = self.guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let nfsFileShareDefaults = self.nfsFileShareDefaults {
            try encodeContainer.encode(nfsFileShareDefaults, forKey: .nfsFileShareDefaults)
        }
        if let notificationPolicy = self.notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = self.objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = self.requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let squash = self.squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
    }
}

extension UpdateNFSFileShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// UpdateNFSFileShareInput
public struct UpdateNFSFileShareInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
    public var clientList: [Swift.String]?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// The Amazon Resource Name (ARN) of the file share to be updated.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The default values for the file share. Optional.
    public var nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {"Upload": {"SettlingTimeInSeconds": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// The user mapped to anonymous user. Valid values are the following:
    ///
    /// * RootSquash: Only root is mapped to anonymous user.
    ///
    /// * NoSquash: No one is mapped to anonymous user.
    ///
    /// * AllSquash: Everyone is mapped to anonymous user.
    public var squash: Swift.String?

    public init (
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        clientList: [Swift.String]? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareARN: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        squash: Swift.String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.nfsFileShareDefaults = nfsFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.squash = squash
    }
}

struct UpdateNFSFileShareInputBody: Swift.Equatable {
    let fileShareARN: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let nfsFileShareDefaults: StorageGatewayClientTypes.NFSFileShareDefaults?
    let defaultStorageClass: Swift.String?
    let objectACL: StorageGatewayClientTypes.ObjectACL?
    let clientList: [Swift.String]?
    let squash: Swift.String?
    let readOnly: Swift.Bool?
    let guessMIMETypeEnabled: Swift.Bool?
    let requesterPays: Swift.Bool?
    let fileShareName: Swift.String?
    let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    let notificationPolicy: Swift.String?
    let auditDestinationARN: Swift.String?
}

extension UpdateNFSFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case nfsFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case squash = "Squash"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let nfsFileShareDefaultsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.NFSFileShareDefaults.self, forKey: .nfsFileShareDefaults)
        nfsFileShareDefaults = nfsFileShareDefaultsDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
    }
}

extension UpdateNFSFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNFSFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNFSFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNFSFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateNFSFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// UpdateNFSFileShareOutput
public struct UpdateNFSFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct UpdateNFSFileShareOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
}

extension UpdateNFSFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension UpdateSMBFileShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case smbaclEnabled = "SMBACLEnabled"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = self.accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlistuser0 in adminUserList {
                try adminUserListContainer.encode(userlistuser0)
            }
        }
        if let auditDestinationARN = self.auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = self.cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = self.caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let defaultStorageClass = self.defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = self.fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareName = self.fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let guessMIMETypeEnabled = self.guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlistuser0 in invalidUserList {
                try invalidUserListContainer.encode(userlistuser0)
            }
        }
        if let kmsEncrypted = self.kmsEncrypted {
            try encodeContainer.encode(kmsEncrypted, forKey: .kmsEncrypted)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let notificationPolicy = self.notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = self.objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let oplocksEnabled = self.oplocksEnabled {
            try encodeContainer.encode(oplocksEnabled, forKey: .oplocksEnabled)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = self.requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let smbaclEnabled = self.smbaclEnabled {
            try encodeContainer.encode(smbaclEnabled, forKey: .smbaclEnabled)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlistuser0 in validUserList {
                try validUserListContainer.encode(userlistuser0)
            }
        }
    }
}

extension UpdateSMBFileShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// UpdateSMBFileShareInput
public struct UpdateSMBFileShareInput: Swift.Equatable {
    /// The files and folders on this share will only be visible to users with read access.
    public var accessBasedEnumeration: Swift.Bool?
    /// A list of users or groups in the Active Directory that have administrator rights to the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var adminUserList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the storage used for audit logs.
    public var auditDestinationARN: Swift.String?
    /// Specifies refresh cache information for the file share.
    public var cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
    public var caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
    public var defaultStorageClass: Swift.String?
    /// The Amazon Resource Name (ARN) of the SMB file share that you want to update.
    /// This member is required.
    public var fileShareARN: Swift.String?
    /// The name of the file share. Optional. FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
    public var fileShareName: Swift.String?
    /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
    public var guessMIMETypeEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var invalidUserList: [Swift.String]?
    /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
    public var kmsEncrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
    public var kmsKey: Swift.String?
    /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period. SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60. {"Upload": {"SettlingTimeInSeconds": 60}} The following example sets NotificationPolicy off. {}
    public var notificationPolicy: Swift.String?
    /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
    public var objectACL: StorageGatewayClientTypes.ObjectACL?
    /// Specifies whether opportunistic locking is enabled for the SMB file share. Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case. Valid Values: true | false
    public var oplocksEnabled: Swift.Bool?
    /// A value that sets the write status of a file share. Set this value to true to set write status to read-only, otherwise set to false. Valid Values: true | false
    public var readOnly: Swift.Bool?
    /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data. RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration. Valid Values: true | false
    public var requesterPays: Swift.Bool?
    /// Set this value to true to enable access control list (ACL) on the SMB file share. Set it to false to map file and directory permissions to the POSIX permissions. For more information, see [Using Microsoft Windows ACLs to control access to an SMB file share](https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html) in the Storage Gateway User Guide. Valid Values: true | false
    public var smbaclEnabled: Swift.Bool?
    /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
    public var validUserList: [Swift.String]?

    public init (
        accessBasedEnumeration: Swift.Bool? = nil,
        adminUserList: [Swift.String]? = nil,
        auditDestinationARN: Swift.String? = nil,
        cacheAttributes: StorageGatewayClientTypes.CacheAttributes? = nil,
        caseSensitivity: StorageGatewayClientTypes.CaseSensitivity? = nil,
        defaultStorageClass: Swift.String? = nil,
        fileShareARN: Swift.String? = nil,
        fileShareName: Swift.String? = nil,
        guessMIMETypeEnabled: Swift.Bool? = nil,
        invalidUserList: [Swift.String]? = nil,
        kmsEncrypted: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        notificationPolicy: Swift.String? = nil,
        objectACL: StorageGatewayClientTypes.ObjectACL? = nil,
        oplocksEnabled: Swift.Bool? = nil,
        readOnly: Swift.Bool? = nil,
        requesterPays: Swift.Bool? = nil,
        smbaclEnabled: Swift.Bool? = nil,
        validUserList: [Swift.String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kmsEncrypted = kmsEncrypted
        self.kmsKey = kmsKey
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.oplocksEnabled = oplocksEnabled
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.smbaclEnabled = smbaclEnabled
        self.validUserList = validUserList
    }
}

struct UpdateSMBFileShareInputBody: Swift.Equatable {
    let fileShareARN: Swift.String?
    let kmsEncrypted: Swift.Bool?
    let kmsKey: Swift.String?
    let defaultStorageClass: Swift.String?
    let objectACL: StorageGatewayClientTypes.ObjectACL?
    let readOnly: Swift.Bool?
    let guessMIMETypeEnabled: Swift.Bool?
    let requesterPays: Swift.Bool?
    let smbaclEnabled: Swift.Bool?
    let accessBasedEnumeration: Swift.Bool?
    let adminUserList: [Swift.String]?
    let validUserList: [Swift.String]?
    let invalidUserList: [Swift.String]?
    let auditDestinationARN: Swift.String?
    let caseSensitivity: StorageGatewayClientTypes.CaseSensitivity?
    let fileShareName: Swift.String?
    let cacheAttributes: StorageGatewayClientTypes.CacheAttributes?
    let notificationPolicy: Swift.String?
    let oplocksEnabled: Swift.Bool?
}

extension UpdateSMBFileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kmsEncrypted = "KMSEncrypted"
        case kmsKey = "KMSKey"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case oplocksEnabled = "OplocksEnabled"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case smbaclEnabled = "SMBACLEnabled"
        case validUserList = "ValidUserList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let kmsEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .kmsEncrypted)
        kmsEncrypted = kmsEncryptedDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let smbaclEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smbaclEnabled)
        smbaclEnabled = smbaclEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[Swift.String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [Swift.String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validUserList)
        var validUserListDecoded0:[Swift.String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [Swift.String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[Swift.String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [Swift.String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let fileShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
        let oplocksEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .oplocksEnabled)
        oplocksEnabled = oplocksEnabledDecoded
    }
}

extension UpdateSMBFileShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBFileShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSMBFileShareOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBFileShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSMBFileShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// UpdateSMBFileShareOutput
public struct UpdateSMBFileShareOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated SMB file share.
    public var fileShareARN: Swift.String?

    public init (
        fileShareARN: Swift.String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct UpdateSMBFileShareOutputResponseBody: Swift.Equatable {
    let fileShareARN: Swift.String?
}

extension UpdateSMBFileShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension UpdateSMBFileShareVisibilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSharesVisible = self.fileSharesVisible {
            try encodeContainer.encode(fileSharesVisible, forKey: .fileSharesVisible)
        }
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

extension UpdateSMBFileShareVisibilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSMBFileShareVisibilityInput: Swift.Equatable {
    /// The shares on this gateway appear when listing shares.
    /// This member is required.
    public var fileSharesVisible: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?

    public init (
        fileSharesVisible: Swift.Bool? = nil,
        gatewayARN: Swift.String? = nil
    )
    {
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBFileShareVisibilityInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let fileSharesVisible: Swift.Bool?
}

extension UpdateSMBFileShareVisibilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let fileSharesVisibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fileSharesVisible)
        fileSharesVisible = fileSharesVisibleDecoded
    }
}

extension UpdateSMBFileShareVisibilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBFileShareVisibilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSMBFileShareVisibilityOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBFileShareVisibilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSMBFileShareVisibilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBFileShareVisibilityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBFileShareVisibilityOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateSMBFileShareVisibilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateSMBLocalGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case smbLocalGroups = "SMBLocalGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let smbLocalGroups = self.smbLocalGroups {
            try encodeContainer.encode(smbLocalGroups, forKey: .smbLocalGroups)
        }
    }
}

extension UpdateSMBLocalGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSMBLocalGroupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// A list of Active Directory users and groups that you want to grant special permissions for SMB file shares on the gateway.
    /// This member is required.
    public var smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups?

    public init (
        gatewayARN: Swift.String? = nil,
        smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.smbLocalGroups = smbLocalGroups
    }
}

struct UpdateSMBLocalGroupsInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let smbLocalGroups: StorageGatewayClientTypes.SMBLocalGroups?
}

extension UpdateSMBLocalGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case smbLocalGroups = "SMBLocalGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let smbLocalGroupsDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.SMBLocalGroups.self, forKey: .smbLocalGroups)
        smbLocalGroups = smbLocalGroupsDecoded
    }
}

extension UpdateSMBLocalGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBLocalGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSMBLocalGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBLocalGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSMBLocalGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBLocalGroupsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBLocalGroupsOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateSMBLocalGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateSMBSecurityStrategyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case smbSecurityStrategy = "SMBSecurityStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let smbSecurityStrategy = self.smbSecurityStrategy {
            try encodeContainer.encode(smbSecurityStrategy.rawValue, forKey: .smbSecurityStrategy)
        }
    }
}

extension UpdateSMBSecurityStrategyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSMBSecurityStrategyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    /// This member is required.
    public var gatewayARN: Swift.String?
    /// Specifies the type of security strategy. ClientSpecified: if you use this option, requests are established based on what is negotiated by the client. This option is recommended when you want to maximize compatibility across different clients in your environment. Supported only in S3 File Gateway. MandatorySigning: if you use this option, file gateway only allows connections from SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on Microsoft Windows Vista, Windows Server 2008 or newer. MandatoryEncryption: if you use this option, file gateway only allows connections from SMBv3 clients that have encryption enabled. This option is highly recommended for environments that handle sensitive data. This option works with SMB clients on Microsoft Windows 8, Windows Server 2012 or newer.
    /// This member is required.
    public var smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?

    public init (
        gatewayARN: Swift.String? = nil,
        smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.smbSecurityStrategy = smbSecurityStrategy
    }
}

struct UpdateSMBSecurityStrategyInputBody: Swift.Equatable {
    let gatewayARN: Swift.String?
    let smbSecurityStrategy: StorageGatewayClientTypes.SMBSecurityStrategy?
}

extension UpdateSMBSecurityStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case smbSecurityStrategy = "SMBSecurityStrategy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let smbSecurityStrategyDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.SMBSecurityStrategy.self, forKey: .smbSecurityStrategy)
        smbSecurityStrategy = smbSecurityStrategyDecoded
    }
}

extension UpdateSMBSecurityStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBSecurityStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSMBSecurityStrategyOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBSecurityStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSMBSecurityStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBSecurityStrategyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
    public var gatewayARN: Swift.String?

    public init (
        gatewayARN: Swift.String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBSecurityStrategyOutputResponseBody: Swift.Equatable {
    let gatewayARN: Swift.String?
}

extension UpdateSMBSecurityStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateSnapshotScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recurrenceInHours = self.recurrenceInHours {
            try encodeContainer.encode(recurrenceInHours, forKey: .recurrenceInHours)
        }
        if let startAt = self.startAt {
            try encodeContainer.encode(startAt, forKey: .startAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

extension UpdateSnapshotScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A JSON object containing one or more of the following fields:
///
/// * [UpdateSnapshotScheduleInput$Description]
///
/// * [UpdateSnapshotScheduleInput$RecurrenceInHours]
///
/// * [UpdateSnapshotScheduleInput$StartAt]
///
/// * [UpdateSnapshotScheduleInput$VolumeARN]
public struct UpdateSnapshotScheduleInput: Swift.Equatable {
    /// Optional description of the snapshot that overwrites the existing description.
    public var description: Swift.String?
    /// Frequency of snapshots. Specify the number of hours between snapshots.
    /// This member is required.
    public var recurrenceInHours: Swift.Int?
    /// The hour of the day at which the snapshot schedule begins represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
    /// This member is required.
    public var startAt: Swift.Int?
    /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair. Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
    public var tags: [StorageGatewayClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    /// This member is required.
    public var volumeARN: Swift.String?

    public init (
        description: Swift.String? = nil,
        recurrenceInHours: Swift.Int? = nil,
        startAt: Swift.Int? = nil,
        tags: [StorageGatewayClientTypes.Tag]? = nil,
        volumeARN: Swift.String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct UpdateSnapshotScheduleInputBody: Swift.Equatable {
    let volumeARN: Swift.String?
    let startAt: Swift.Int?
    let recurrenceInHours: Swift.Int?
    let description: Swift.String?
    let tags: [StorageGatewayClientTypes.Tag]?
}

extension UpdateSnapshotScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let startAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startAt)
        startAt = startAtDecoded
        let recurrenceInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurrenceInHours)
        recurrenceInHours = recurrenceInHoursDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([StorageGatewayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[StorageGatewayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [StorageGatewayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSnapshotScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSnapshotScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSnapshotScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSnapshotScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// A JSON object containing the Amazon Resource Name (ARN) of the updated storage volume.
public struct UpdateSnapshotScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the volume. Use the [ListVolumes] operation to return a list of gateway volumes.
    public var volumeARN: Swift.String?

    public init (
        volumeARN: Swift.String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct UpdateSnapshotScheduleOutputResponseBody: Swift.Equatable {
    let volumeARN: Swift.String?
}

extension UpdateSnapshotScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension UpdateVTLDeviceTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceType = "DeviceType"
        case vtlDeviceARN = "VTLDeviceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let vtlDeviceARN = self.vtlDeviceARN {
            try encodeContainer.encode(vtlDeviceARN, forKey: .vtlDeviceARN)
        }
    }
}

extension UpdateVTLDeviceTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVTLDeviceTypeInput: Swift.Equatable {
    /// The type of medium changer you want to select. Valid Values: STK-L700 | AWS-Gateway-VTL | IBM-03584L32-0402
    /// This member is required.
    public var deviceType: Swift.String?
    /// The Amazon Resource Name (ARN) of the medium changer you want to select.
    /// This member is required.
    public var vtlDeviceARN: Swift.String?

    public init (
        deviceType: Swift.String? = nil,
        vtlDeviceARN: Swift.String? = nil
    )
    {
        self.deviceType = deviceType
        self.vtlDeviceARN = vtlDeviceARN
    }
}

struct UpdateVTLDeviceTypeInputBody: Swift.Equatable {
    let vtlDeviceARN: Swift.String?
    let deviceType: Swift.String?
}

extension UpdateVTLDeviceTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceType = "DeviceType"
        case vtlDeviceARN = "VTLDeviceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vtlDeviceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDeviceARN)
        vtlDeviceARN = vtlDeviceARNDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
    }
}

extension UpdateVTLDeviceTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVTLDeviceTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVTLDeviceTypeOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVTLDeviceTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVTLDeviceTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vtlDeviceARN = output.vtlDeviceARN
        } else {
            self.vtlDeviceARN = nil
        }
    }
}

/// UpdateVTLDeviceTypeOutput
public struct UpdateVTLDeviceTypeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the medium changer you have selected.
    public var vtlDeviceARN: Swift.String?

    public init (
        vtlDeviceARN: Swift.String? = nil
    )
    {
        self.vtlDeviceARN = vtlDeviceARN
    }
}

struct UpdateVTLDeviceTypeOutputResponseBody: Swift.Equatable {
    let vtlDeviceARN: Swift.String?
}

extension UpdateVTLDeviceTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vtlDeviceARN = "VTLDeviceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vtlDeviceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDeviceARN)
        vtlDeviceARN = vtlDeviceARNDecoded
    }
}

extension StorageGatewayClientTypes.VTLDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceiSCSIAttributes = "DeviceiSCSIAttributes"
        case vtlDeviceARN = "VTLDeviceARN"
        case vtlDeviceProductIdentifier = "VTLDeviceProductIdentifier"
        case vtlDeviceType = "VTLDeviceType"
        case vtlDeviceVendor = "VTLDeviceVendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceiSCSIAttributes = self.deviceiSCSIAttributes {
            try encodeContainer.encode(deviceiSCSIAttributes, forKey: .deviceiSCSIAttributes)
        }
        if let vtlDeviceARN = self.vtlDeviceARN {
            try encodeContainer.encode(vtlDeviceARN, forKey: .vtlDeviceARN)
        }
        if let vtlDeviceProductIdentifier = self.vtlDeviceProductIdentifier {
            try encodeContainer.encode(vtlDeviceProductIdentifier, forKey: .vtlDeviceProductIdentifier)
        }
        if let vtlDeviceType = self.vtlDeviceType {
            try encodeContainer.encode(vtlDeviceType, forKey: .vtlDeviceType)
        }
        if let vtlDeviceVendor = self.vtlDeviceVendor {
            try encodeContainer.encode(vtlDeviceVendor, forKey: .vtlDeviceVendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vtlDeviceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDeviceARN)
        vtlDeviceARN = vtlDeviceARNDecoded
        let vtlDeviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDeviceType)
        vtlDeviceType = vtlDeviceTypeDecoded
        let vtlDeviceVendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDeviceVendor)
        vtlDeviceVendor = vtlDeviceVendorDecoded
        let vtlDeviceProductIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vtlDeviceProductIdentifier)
        vtlDeviceProductIdentifier = vtlDeviceProductIdentifierDecoded
        let deviceiSCSIAttributesDecoded = try containerValues.decodeIfPresent(StorageGatewayClientTypes.DeviceiSCSIAttributes.self, forKey: .deviceiSCSIAttributes)
        deviceiSCSIAttributes = deviceiSCSIAttributesDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Represents a device object associated with a tape gateway.
    public struct VTLDevice: Swift.Equatable {
        /// A list of iSCSI information about a VTL device.
        public var deviceiSCSIAttributes: StorageGatewayClientTypes.DeviceiSCSIAttributes?
        /// Specifies the unique Amazon Resource Name (ARN) of the device (tape drive or media changer).
        public var vtlDeviceARN: Swift.String?
        /// Specifies the model number of device that the VTL device emulates.
        public var vtlDeviceProductIdentifier: Swift.String?
        /// Specifies the type of device that the VTL device emulates.
        public var vtlDeviceType: Swift.String?
        /// Specifies the vendor of the device that the VTL device object emulates.
        public var vtlDeviceVendor: Swift.String?

        public init (
            deviceiSCSIAttributes: StorageGatewayClientTypes.DeviceiSCSIAttributes? = nil,
            vtlDeviceARN: Swift.String? = nil,
            vtlDeviceProductIdentifier: Swift.String? = nil,
            vtlDeviceType: Swift.String? = nil,
            vtlDeviceVendor: Swift.String? = nil
        )
        {
            self.deviceiSCSIAttributes = deviceiSCSIAttributes
            self.vtlDeviceARN = vtlDeviceARN
            self.vtlDeviceProductIdentifier = vtlDeviceProductIdentifier
            self.vtlDeviceType = vtlDeviceType
            self.vtlDeviceVendor = vtlDeviceVendor
        }
    }

}

extension StorageGatewayClientTypes.VolumeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeId = "VolumeId"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = self.gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = self.volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInBytes) ?? 0
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a storage volume object.
    public struct VolumeInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway. Use the [ListGateways] operation to return a list of gateways for your account and Amazon Web Services Region.
        public var gatewayARN: Swift.String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var gatewayId: Swift.String?
        /// The Amazon Resource Name (ARN) for the storage volume. For example, the following is a valid ARN: arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/volume/vol-1122AABB Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeARN: Swift.String?
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public var volumeAttachmentStatus: Swift.String?
        /// The unique identifier assigned to the volume. This ID becomes part of the volume Amazon Resource Name (ARN), which you use as input for other operations. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeId: Swift.String?
        /// The size of the volume in bytes. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public var volumeSizeInBytes: Swift.Int
        /// One of the VolumeType enumeration values describing the type of the volume.
        public var volumeType: Swift.String?

        public init (
            gatewayARN: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            volumeARN: Swift.String? = nil,
            volumeAttachmentStatus: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeType = volumeType
        }
    }

}

extension StorageGatewayClientTypes.VolumeRecoveryPointInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeARN = "VolumeARN"
        case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeUsageInBytes = "VolumeUsageInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = self.volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeRecoveryPointTime = self.volumeRecoveryPointTime {
            try encodeContainer.encode(volumeRecoveryPointTime, forKey: .volumeRecoveryPointTime)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if volumeUsageInBytes != 0 {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInBytes) ?? 0
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeUsageInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsageInBytes) ?? 0
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeRecoveryPointTime)
        volumeRecoveryPointTime = volumeRecoveryPointTimeDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Describes a storage volume recovery point object.
    public struct VolumeRecoveryPointInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the volume target.
        public var volumeARN: Swift.String?
        /// The time the recovery point was taken.
        public var volumeRecoveryPointTime: Swift.String?
        /// The size of the volume in bytes.
        public var volumeSizeInBytes: Swift.Int
        /// The size of the data stored on the volume in bytes. This value is not available for volumes created prior to May 13, 2015, until you store data on the volume.
        public var volumeUsageInBytes: Swift.Int

        public init (
            volumeARN: Swift.String? = nil,
            volumeRecoveryPointTime: Swift.String? = nil,
            volumeSizeInBytes: Swift.Int = 0,
            volumeUsageInBytes: Swift.Int = 0
        )
        {
            self.volumeARN = volumeARN
            self.volumeRecoveryPointTime = volumeRecoveryPointTime
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeUsageInBytes = volumeUsageInBytes
        }
    }

}

extension StorageGatewayClientTypes.VolumeiSCSIAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chapEnabled = "ChapEnabled"
        case lunNumber = "LunNumber"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfacePort = "NetworkInterfacePort"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if chapEnabled != false {
            try encodeContainer.encode(chapEnabled, forKey: .chapEnabled)
        }
        if let lunNumber = self.lunNumber {
            try encodeContainer.encode(lunNumber, forKey: .lunNumber)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if networkInterfacePort != 0 {
            try encodeContainer.encode(networkInterfacePort, forKey: .networkInterfacePort)
        }
        if let targetARN = self.targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfacePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkInterfacePort) ?? 0
        networkInterfacePort = networkInterfacePortDecoded
        let lunNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lunNumber)
        lunNumber = lunNumberDecoded
        let chapEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .chapEnabled) ?? false
        chapEnabled = chapEnabledDecoded
    }
}

extension StorageGatewayClientTypes {
    /// Lists iSCSI information about a volume.
    public struct VolumeiSCSIAttributes: Swift.Equatable {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public var chapEnabled: Swift.Bool
        /// The logical disk number.
        public var lunNumber: Swift.Int?
        /// The network interface identifier.
        public var networkInterfaceId: Swift.String?
        /// The port used to communicate with iSCSI targets.
        public var networkInterfacePort: Swift.Int
        /// The Amazon Resource Name (ARN) of the volume target.
        public var targetARN: Swift.String?

        public init (
            chapEnabled: Swift.Bool = false,
            lunNumber: Swift.Int? = nil,
            networkInterfaceId: Swift.String? = nil,
            networkInterfacePort: Swift.Int = 0,
            targetARN: Swift.String? = nil
        )
        {
            self.chapEnabled = chapEnabled
            self.lunNumber = lunNumber
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }
    }

}
