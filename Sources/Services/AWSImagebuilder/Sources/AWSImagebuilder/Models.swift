//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension ImagebuilderClientTypes {

    /// Includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified filter.
    public struct SeverityCounts: Swift.Sendable {
        /// The total number of findings across all severity levels for the specified filter.
        public var all: Swift.Int?
        /// The number of critical severity findings for the specified filter.
        public var critical: Swift.Int?
        /// The number of high severity findings for the specified filter.
        public var high: Swift.Int?
        /// The number of medium severity findings for the specified filter.
        public var medium: Swift.Int?

        public init(
            all: Swift.Int? = nil,
            critical: Swift.Int? = nil,
            high: Swift.Int? = nil,
            medium: Swift.Int? = nil
        )
        {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains counts of vulnerability findings from image scans that run when you create new Image Builder images, or build new versions of existing images. The vulnerability counts are grouped by severity level. The counts are aggregated across resources to create the final tally for the account that owns them.
    public struct AccountAggregation: Swift.Sendable {
        /// Identifies the account that owns the aggregated resource findings.
        public var accountId: Swift.String?
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains settings for the Systems Manager agent on your build instance.
    public struct SystemsManagerAgent: Swift.Sendable {
        /// Controls whether the Systems Manager agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
        public var uninstallAfterBuild: Swift.Bool?

        public init(
            uninstallAfterBuild: Swift.Bool? = nil
        )
        {
            self.uninstallAfterBuild = uninstallAfterBuild
        }
    }
}

extension ImagebuilderClientTypes {

    /// In addition to your infrastructure configuration, these settings provide an extra layer of control over your build instances. You can also specify commands to run on launch for all of your build instances. Image Builder does not automatically install the Systems Manager agent on Windows instances. If your base image includes the Systems Manager agent, then the AMI that you create will also include the agent. For Linux instances, if the base image does not already include the Systems Manager agent, Image Builder installs it. For Linux instances where Image Builder installs the Systems Manager agent, you can choose whether to keep it for the AMI that you create.
    public struct AdditionalInstanceConfiguration: Swift.Sendable {
        /// Contains settings for the Systems Manager agent on your build instance.
        public var systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch your build instance. The userDataOverride property replaces any commands that Image Builder might have added to ensure that Systems Manager is installed on your Linux build instance. If you override the user data, make sure that you add commands to install Systems Manager, if it is not pre-installed on your base image. The user data is always base 64 encoded. For example, the following commands are encoded as IyEvYmluL2Jhc2gKbWtkaXIgLXAgL3Zhci9iYi8KdG91Y2ggL3Zhci$: #!/bin/bash mkdir -p /var/bb/ touch /var
        public var userDataOverride: Swift.String?

        public init(
            systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent? = nil,
            userDataOverride: Swift.String? = nil
        )
        {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ImageStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case building
        case cancelled
        case creating
        case deleted
        case deprecated
        case disabled
        case distributing
        case failed
        case integrating
        case pending
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStatus] {
            return [
                .available,
                .building,
                .cancelled,
                .creating,
                .deleted,
                .deprecated,
                .disabled,
                .distributing,
                .failed,
                .integrating,
                .pending,
                .testing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .disabled: return "DISABLED"
            case .distributing: return "DISTRIBUTING"
            case .failed: return "FAILED"
            case .integrating: return "INTEGRATING"
            case .pending: return "PENDING"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Image status and the reason for that status.
    public struct ImageState: Swift.Sendable {
        /// The reason for the status of the image.
        public var reason: Swift.String?
        /// The status of the image.
        public var status: ImagebuilderClientTypes.ImageStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ImageStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension ImagebuilderClientTypes {

    /// Details of an Amazon EC2 AMI.
    public struct Ami: Swift.Sendable {
        /// The account ID of the owner of the AMI.
        public var accountId: Swift.String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The AMI ID of the Amazon EC2 AMI.
        public var image: Swift.String?
        /// The name of the Amazon EC2 AMI.
        public var name: Swift.String?
        /// The Amazon Web Services Region of the Amazon EC2 AMI.
        public var region: Swift.String?
        /// Image status and the reason for that status.
        public var state: ImagebuilderClientTypes.ImageState?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            image: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }
    }
}

extension ImagebuilderClientTypes {

    /// Describes the configuration for a launch permission. The launch permission modification request is sent to the [Amazon EC2 ModifyImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html) API on behalf of the user for each Region they have selected to distribute the AMI. To make an AMI public, set the launch permission authorized accounts to all. See the examples for making an AMI public at [Amazon EC2 ModifyImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html).
    public struct LaunchPermissionConfiguration: Swift.Sendable {
        /// The ARN for an Amazon Web Services Organization that you want to share your AMI with. For more information, see [What is Organizations?](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html).
        public var organizationArns: [Swift.String]?
        /// The ARN for an Organizations organizational unit (OU) that you want to share your AMI with. For more information about key concepts for Organizations, see [Organizations terminology and concepts](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html).
        public var organizationalUnitArns: [Swift.String]?
        /// The name of the group.
        public var userGroups: [Swift.String]?
        /// The Amazon Web Services account ID.
        public var userIds: [Swift.String]?

        public init(
            organizationArns: [Swift.String]? = nil,
            organizationalUnitArns: [Swift.String]? = nil,
            userGroups: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.organizationArns = organizationArns
            self.organizationalUnitArns = organizationalUnitArns
            self.userGroups = userGroups
            self.userIds = userIds
        }
    }
}

extension ImagebuilderClientTypes {

    /// Define and configure the output AMIs of the pipeline.
    public struct AmiDistributionConfiguration: Swift.Sendable {
        /// The tags to apply to AMIs distributed to this Region.
        public var amiTags: [Swift.String: Swift.String]?
        /// The description of the AMI distribution configuration. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The KMS key identifier used to encrypt the distributed image.
        public var kmsKeyId: Swift.String?
        /// Launch permissions can be used to configure which Amazon Web Services accounts can use the AMI to launch instances.
        public var launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration?
        /// The name of the output AMI.
        public var name: Swift.String?
        /// The ID of an account to which you want to distribute an image.
        public var targetAccountIds: [Swift.String]?

        public init(
            amiTags: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration? = nil,
            name: Swift.String? = nil,
            targetAccountIds: [Swift.String]? = nil
        )
        {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }
    }
}

extension ImagebuilderClientTypes {

    public enum BuildType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `import`
        case scheduled
        case userInitiated
        case sdkUnknown(Swift.String)

        public static var allCases: [BuildType] {
            return [
                .import,
                .scheduled,
                .userInitiated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .import: return "IMPORT"
            case .scheduled: return "SCHEDULED"
            case .userInitiated: return "USER_INITIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You have exceeded the permitted request rate for the specific operation.
public struct CallRateLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CallRateLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// These errors are usually caused by a client action, such as using an action or resource on behalf of a user that doesn't have permissions to use the action or resource, or specifying an invalid resource identifier.
public struct ClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You are not authorized to perform the requested operation.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have specified a client token for an operation using parameter values that differ from a previous request that used the same client token.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have requested an action that that the service doesn't support.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource that you are trying to operate on is currently in use. Review the message details and retry later.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the service encounters an unrecoverable exception.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is unable to process your request at this time.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelImageCreationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that you want to cancel creation for.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

public struct CancelImageCreationOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The ARN of the image whose creation this request canceled.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

public struct CancelLifecycleExecutionInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Identifies the specific runtime instance of the image lifecycle to cancel.
    /// This member is required.
    public var lifecycleExecutionId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        lifecycleExecutionId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.lifecycleExecutionId = lifecycleExecutionId
    }
}

public struct CancelLifecycleExecutionOutput: Swift.Sendable {
    /// The unique identifier for the image lifecycle runtime instance that was canceled.
    public var lifecycleExecutionId: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
    }
}

extension ImagebuilderClientTypes {

    /// Defines a parameter that is used to provide configuration details for the component.
    public struct ComponentParameterDetail: Swift.Sendable {
        /// The default value of this parameter if no input is provided.
        public var defaultValue: [Swift.String]?
        /// Describes this parameter.
        public var description: Swift.String?
        /// The name of this input parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of input this parameter provides. The currently supported value is "string".
        /// This member is required.
        public var type: Swift.String?

        public init(
            defaultValue: [Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

extension ImagebuilderClientTypes {

    public enum Platform: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .linux,
                .macos,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .macos: return "macOS"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ComponentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .deprecated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// A group of fields that describe the current status of components.
    public struct ComponentState: Swift.Sendable {
        /// Describes how or why the component changed state.
        public var reason: Swift.String?
        /// The current state of the component.
        public var status: ImagebuilderClientTypes.ComponentStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ComponentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ComponentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case build
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .build,
                .test
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// A detailed view of a component.
    public struct Component: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// Describes what change has been made in this version of the component, or what makes this version different from other versions of the component.
        public var changeDescription: Swift.String?
        /// Component data contains the YAML document content for the component.
        public var data: Swift.String?
        /// The date that Image Builder created the component.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The encryption status of the component.
        public var encrypted: Swift.Bool?
        /// The KMS key identifier used to encrypt the component.
        public var kmsKeyId: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// Indicates whether component source is hidden from view in the console, and from component detail results for API, CLI, or SDK operations.
        public var obfuscate: Swift.Bool
        /// The owner of the component.
        public var owner: Swift.String?
        /// Contains parameter details for each of the parameters that the component document defined for the component.
        public var parameters: [ImagebuilderClientTypes.ComponentParameterDetail]?
        /// The operating system platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Contains the name of the publisher if this is a third-party component. Otherwise, this property is empty.
        public var publisher: Swift.String?
        /// Describes the current status of the component. This is used for components that are no longer active.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is available, Image Builder performs a prefix match against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags that apply to the component.
        public var tags: [Swift.String: Swift.String]?
        /// The component type specifies whether Image Builder uses the component to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            data: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            obfuscate: Swift.Bool = false,
            owner: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameterDetail]? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            publisher: Swift.String? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.obfuscate = obfuscate
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.publisher = publisher
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains a key/value pair that sets the named component parameter.
    public struct ComponentParameter: Swift.Sendable {
        /// The name of the component parameter to set.
        /// This member is required.
        public var name: Swift.String?
        /// Sets the value for the named component parameter.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension ImagebuilderClientTypes {

    /// Configuration details of the component.
    public struct ComponentConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the component.
        /// This member is required.
        public var componentArn: Swift.String?
        /// A group of parameter settings that Image Builder uses to configure the component for a specific recipe.
        public var parameters: [ImagebuilderClientTypes.ComponentParameter]?

        public init(
            componentArn: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameter]? = nil
        )
        {
            self.componentArn = componentArn
            self.parameters = parameters
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ComponentFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case shell
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentFormat] {
            return [
                .shell
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .shell: return "SHELL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// A high-level summary of a component.
    public struct ComponentSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description for the current version of the component.
        public var changeDescription: Swift.String?
        /// The original creation date of the component.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// Indicates whether component source is hidden from view in the console, and from component detail results for API, CLI, or SDK operations.
        public var obfuscate: Swift.Bool
        /// The owner of the component.
        public var owner: Swift.String?
        /// The operating system platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Contains the name of the publisher if this is a third-party component. Otherwise, this property is empty.
        public var publisher: Swift.String?
        /// Describes the current status of the component.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version that the component supports. If the OS information is available, Image Builder performs a prefix match against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags that apply to the component.
        public var tags: [Swift.String: Swift.String]?
        /// The component type specifies whether Image Builder uses the component to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            obfuscate: Swift.Bool = false,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            publisher: Swift.String? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.obfuscate = obfuscate
            self.owner = owner
            self.platform = platform
            self.publisher = publisher
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }
}

extension ImagebuilderClientTypes {

    /// The defining characteristics of a specific version of an Amazon Web Services TOE component.
    public struct ComponentVersion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the component. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// he operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The semantic version of the component. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }
    }
}

extension ImagebuilderClientTypes {

    /// A container encapsulates the runtime environment for an application.
    public struct Container: Swift.Sendable {
        /// A list of URIs for containers created in the context Region.
        public var imageUris: [Swift.String]?
        /// Containers and container images are Region-specific. This is the Region context for the container.
        public var region: Swift.String?

        public init(
            imageUris: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.imageUris = imageUris
            self.region = region
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ContainerRepositoryService: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerRepositoryService] {
            return [
                .ecr
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// The container repository where the output container image is stored.
    public struct TargetContainerRepository: Swift.Sendable {
        /// The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// Specifies the service in which this image was registered.
        /// This member is required.
        public var service: ImagebuilderClientTypes.ContainerRepositoryService?

        public init(
            repositoryName: Swift.String? = nil,
            service: ImagebuilderClientTypes.ContainerRepositoryService? = nil
        )
        {
            self.repositoryName = repositoryName
            self.service = service
        }
    }
}

extension ImagebuilderClientTypes {

    /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
    public struct ContainerDistributionConfiguration: Swift.Sendable {
        /// Tags that are attached to the container distribution configuration.
        public var containerTags: [Swift.String]?
        /// The description of the container distribution configuration.
        public var description: Swift.String?
        /// The destination repository for the container distribution configuration.
        /// This member is required.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?

        public init(
            containerTags: [Swift.String]? = nil,
            description: Swift.String? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil
        )
        {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ContainerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerType] {
            return [
                .docker
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    public enum EbsVolumeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [EbsVolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Amazon EBS-specific block device mapping specifications.
    public struct EbsInstanceBlockDeviceSpecification: Swift.Sendable {
        /// Use to configure delete on termination of the associated device.
        public var deleteOnTermination: Swift.Bool?
        /// Use to configure device encryption.
        public var encrypted: Swift.Bool?
        /// Use to configure device IOPS.
        public var iops: Swift.Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public var kmsKeyId: Swift.String?
        /// The snapshot that defines the device contents.
        public var snapshotId: Swift.String?
        /// For GP3 volumes only – The throughput in MiB/s that the volume supports.
        public var throughput: Swift.Int?
        /// Use to override the device's volume size.
        public var volumeSize: Swift.Int?
        /// Use to override the device's volume type.
        public var volumeType: ImagebuilderClientTypes.EbsVolumeType?

        public init(
            deleteOnTermination: Swift.Bool? = nil,
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: ImagebuilderClientTypes.EbsVolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines block device mappings for the instance used to configure your image.
    public struct InstanceBlockDeviceMapping: Swift.Sendable {
        /// The device to which these mappings apply.
        public var deviceName: Swift.String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public var ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the base image.
        public var noDevice: Swift.String?
        /// Use to manage instance ephemeral devices.
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines a custom base AMI and block device mapping configurations of an instance used for building and testing container images.
    public struct InstanceConfiguration: Swift.Sendable {
        /// Defines the block devices to attach for building an instance from this Image Builder AMI.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public var image: Swift.String?

        public init(
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            image: Swift.String? = nil
        )
        {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }
    }
}

extension ImagebuilderClientTypes {

    /// A container recipe.
    public struct ContainerRecipe: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the container recipe. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the container recipe.
        public var description: Swift.String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
        public var dockerfileTemplateData: Swift.String?
        /// A flag that indicates if the target container is encrypted.
        public var encrypted: Swift.Bool?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to the target Region.
        public var kmsKeyId: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String: Swift.String]?
        /// The destination repository for the container image.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
        /// The semantic version of the container recipe. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?
        /// The working directory for use during build and test workflows.
        public var workingDirectory: Swift.String?

        public init(
            arn: Swift.String? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            dockerfileTemplateData: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }
}

extension ImagebuilderClientTypes {

    /// A summary of a container recipe
    public struct ContainerRecipeSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public var arn: Swift.String?
        /// Specifies the type of container, such as "Docker".
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }
}

/// You have specified two or more mutually exclusive parameters. Review the error message for details.
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombinationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your version number is out of bounds or does not follow the required syntax.
public struct InvalidVersionNumberException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidVersionNumberException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded the number of permitted resources or operations for this service. For service quotas, see [EC2 Image Builder endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/imagebuilder.html#limits_imagebuilder).
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateComponentInput: Swift.Sendable {
    /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of the component.
    public var changeDescription: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Component data contains inline YAML document content for the component. Alternatively, you can specify the uri of a YAML document file stored in Amazon S3. However, you cannot specify both properties.
    public var data: Swift.String?
    /// Describes the contents of the component.
    public var description: Swift.String?
    /// The ID of the KMS key that is used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The operating system platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
    public var supportedOsVersions: [Swift.String]?
    /// The tags that apply to the component.
    public var tags: [Swift.String: Swift.String]?
    /// The uri of a YAML component document file. This must be an S3 URL (s3://bucket/key), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component data property. You cannot specify both properties.
    public var uri: Swift.String?

    public init(
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        supportedOsVersions: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.uri = uri
    }
}

public struct CreateComponentOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the component that the request created.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

/// The resource that you are trying to create already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateContainerRecipeInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Components for build and test that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The type of container to create.
    /// This member is required.
    public var containerType: ImagebuilderClientTypes.ContainerType?
    /// The description of the container recipe.
    public var description: Swift.String?
    /// The Dockerfile template used to build your image as an inline data blob.
    public var dockerfileTemplateData: Swift.String?
    /// The Amazon S3 URI for the Dockerfile that will be used to build your container image.
    public var dockerfileTemplateUri: Swift.String?
    /// Specifies the operating system version for the base image.
    public var imageOsVersionOverride: Swift.String?
    /// A group of options that can be used to configure an instance for building and testing container images.
    public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    /// Identifies which KMS key is used to encrypt the Dockerfile template.
    public var kmsKeyId: Swift.String?
    /// The name of the container recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image for the container recipe.
    /// This member is required.
    public var parentImage: Swift.String?
    /// Specifies the operating system platform when you use a custom base image.
    public var platformOverride: ImagebuilderClientTypes.Platform?
    /// The semantic version of the container recipe. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the container recipe.
    public var tags: [Swift.String: Swift.String]?
    /// The destination repository for the container image.
    /// This member is required.
    public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    /// The working directory for use during build and test workflows.
    public var workingDirectory: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        containerType: ImagebuilderClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        dockerfileTemplateData: Swift.String? = nil,
        dockerfileTemplateUri: Swift.String? = nil,
        imageOsVersionOverride: Swift.String? = nil,
        instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        platformOverride: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.containerType = containerType
        self.description = description
        self.dockerfileTemplateData = dockerfileTemplateData
        self.dockerfileTemplateUri = dockerfileTemplateUri
        self.imageOsVersionOverride = imageOsVersionOverride
        self.instanceConfiguration = instanceConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.parentImage = parentImage
        self.platformOverride = platformOverride
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.targetRepository = targetRepository
        self.workingDirectory = workingDirectory
    }
}

public struct CreateContainerRecipeOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// Returns the Amazon Resource Name (ARN) of the container recipe that the request created.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    /// Identifies the launch template that the associated Windows AMI uses for launching an instance when faster launching is enabled. You can specify either the launchTemplateName or the launchTemplateId, but not both.
    public struct FastLaunchLaunchTemplateSpecification: Swift.Sendable {
        /// The ID of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateName: Swift.String?
        /// The version of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateVersion: Swift.String?

        public init(
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            launchTemplateVersion: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.launchTemplateVersion = launchTemplateVersion
        }
    }
}

extension ImagebuilderClientTypes {

    /// Configuration settings for creating and managing pre-provisioned snapshots for a fast-launch enabled Windows AMI.
    public struct FastLaunchSnapshotConfiguration: Swift.Sendable {
        /// The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
        public var targetResourceCount: Swift.Int?

        public init(
            targetResourceCount: Swift.Int? = nil
        )
        {
            self.targetResourceCount = targetResourceCount
        }
    }
}

extension ImagebuilderClientTypes {

    /// Define and configure faster launching for output Windows AMIs.
    public struct FastLaunchConfiguration: Swift.Sendable {
        /// The owner account ID for the fast-launch enabled Windows AMI.
        public var accountId: Swift.String?
        /// A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        public var launchTemplate: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification?
        /// The maximum number of parallel instances that are launched for creating resources.
        public var maxParallelLaunches: Swift.Int?
        /// Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        public var snapshotConfiguration: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration?

        public init(
            accountId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            launchTemplate: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification? = nil,
            maxParallelLaunches: Swift.Int? = nil,
            snapshotConfiguration: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration? = nil
        )
        {
            self.accountId = accountId
            self.enabled = enabled
            self.launchTemplate = launchTemplate
            self.maxParallelLaunches = maxParallelLaunches
            self.snapshotConfiguration = snapshotConfiguration
        }
    }
}

extension ImagebuilderClientTypes {

    /// Identifies an Amazon EC2 launch template to use for a specific account.
    public struct LaunchTemplateConfiguration: Swift.Sendable {
        /// The account ID that this configuration applies to.
        public var accountId: Swift.String?
        /// Identifies the Amazon EC2 launch template to use.
        /// This member is required.
        public var launchTemplateId: Swift.String?
        /// Set the specified Amazon EC2 launch template as the default launch template for the specified account.
        public var setDefaultVersion: Swift.Bool

        public init(
            accountId: Swift.String? = nil,
            launchTemplateId: Swift.String? = nil,
            setDefaultVersion: Swift.Bool = false
        )
        {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }
    }
}

extension ImagebuilderClientTypes {

    public enum DiskImageFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case raw
        case vhd
        case vmdk
        case sdkUnknown(Swift.String)

        public static var allCases: [DiskImageFormat] {
            return [
                .raw,
                .vhd,
                .vmdk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .raw: return "RAW"
            case .vhd: return "VHD"
            case .vmdk: return "VMDK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Properties that configure export from your build instance to a compatible file format for your VM.
    public struct S3ExportConfiguration: Swift.Sendable {
        /// Export the updated image to one of the following supported disk image formats:
        ///
        /// * Virtual Hard Disk (VHD) – Compatible with Citrix Xen and Microsoft Hyper-V virtualization products.
        ///
        /// * Stream-optimized ESX Virtual Machine Disk (VMDK) – Compatible with VMware ESX and VMware vSphere versions 4, 5, and 6.
        ///
        /// * Raw – Raw format.
        /// This member is required.
        public var diskImageFormat: ImagebuilderClientTypes.DiskImageFormat?
        /// The name of the role that grants VM Import/Export permission to export images to your S3 bucket.
        /// This member is required.
        public var roleName: Swift.String?
        /// The S3 bucket in which to store the output disk images for your VM.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 path for the bucket where the output disk images for your VM are stored.
        public var s3Prefix: Swift.String?

        public init(
            diskImageFormat: ImagebuilderClientTypes.DiskImageFormat? = nil,
            roleName: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.diskImageFormat = diskImageFormat
            self.roleName = roleName
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines the settings for a specific Region.
    public struct Distribution: Swift.Sendable {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public var amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
        public var containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration?
        /// The Windows faster-launching configurations to use for AMI distribution.
        public var fastLaunchConfigurations: [ImagebuilderClientTypes.FastLaunchConfiguration]?
        /// A group of launchTemplateConfiguration settings that apply to image distribution for specified accounts.
        public var launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified Region.
        public var licenseConfigurationArns: [Swift.String]?
        /// The target Region.
        /// This member is required.
        public var region: Swift.String?
        /// Configure export settings to deliver disk images created from your image build, using a file format that is compatible with your VMs in that Region.
        public var s3ExportConfiguration: ImagebuilderClientTypes.S3ExportConfiguration?

        public init(
            amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration? = nil,
            containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration? = nil,
            fastLaunchConfigurations: [ImagebuilderClientTypes.FastLaunchConfiguration]? = nil,
            launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil,
            licenseConfigurationArns: [Swift.String]? = nil,
            region: Swift.String? = nil,
            s3ExportConfiguration: ImagebuilderClientTypes.S3ExportConfiguration? = nil
        )
        {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.fastLaunchConfigurations = fastLaunchConfigurations
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
            self.s3ExportConfiguration = s3ExportConfiguration
        }
    }
}

public struct CreateDistributionConfigurationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?
    /// The name of the distribution configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags of the distribution configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributions = distributions
        self.name = name
        self.tags = tags
    }
}

public struct CreateDistributionConfigurationOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was created by this request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    /// Settings that Image Builder uses to configure the ECR repository and the output container images that Amazon Inspector scans.
    public struct EcrConfiguration: Swift.Sendable {
        /// Tags for Image Builder to apply to the output container image that Amazon Inspector scans. Tags can help you identify and manage your scanned images.
        public var containerTags: [Swift.String]?
        /// The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you don’t provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository for vulnerability scans of your output container images.
        public var repositoryName: Swift.String?

        public init(
            containerTags: [Swift.String]? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.containerTags = containerTags
            self.repositoryName = repositoryName
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains settings for Image Builder image resource and container image scans.
    public struct ImageScanningConfiguration: Swift.Sendable {
        /// Contains Amazon ECR settings for vulnerability scans.
        public var ecrConfiguration: ImagebuilderClientTypes.EcrConfiguration?
        /// A setting that indicates whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        public var imageScanningEnabled: Swift.Bool?

        public init(
            ecrConfiguration: ImagebuilderClientTypes.EcrConfiguration? = nil,
            imageScanningEnabled: Swift.Bool? = nil
        )
        {
            self.ecrConfiguration = ecrConfiguration
            self.imageScanningEnabled = imageScanningEnabled
        }
    }
}

extension ImagebuilderClientTypes {

    /// Configure image tests for your pipeline build. Tests run after building the image, to verify that the AMI or container image is valid before distributing it.
    public struct ImageTestsConfiguration: Swift.Sendable {
        /// Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.
        public var imageTestsEnabled: Swift.Bool?
        /// The maximum time in minutes that tests are permitted to run. The timeoutMinutes attribute is not currently active. This value is ignored.
        public var timeoutMinutes: Swift.Int?

        public init(
            imageTestsEnabled: Swift.Bool? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }
    }
}

extension ImagebuilderClientTypes {

    public enum OnWorkflowFailure: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abort
        case `continue`
        case sdkUnknown(Swift.String)

        public static var allCases: [OnWorkflowFailure] {
            return [
                .abort,
                .continue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abort: return "ABORT"
            case .continue: return "CONTINUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains a key/value pair that sets the named workflow parameter.
    public struct WorkflowParameter: Swift.Sendable {
        /// The name of the workflow parameter to set.
        /// This member is required.
        public var name: Swift.String?
        /// Sets the value for the named workflow parameter.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains control settings and configurable inputs for a workflow resource.
    public struct WorkflowConfiguration: Swift.Sendable {
        /// The action to take if the workflow fails.
        public var onFailure: ImagebuilderClientTypes.OnWorkflowFailure?
        /// Test workflows are defined within named runtime groups called parallel groups. The parallel group is the named group that contains this test workflow. Test workflows within a parallel group can run at the same time. Image Builder starts up to five test workflows in the group at the same time, and starts additional workflows as others complete, until all workflows in the group have completed. This field only applies for test workflows.
        public var parallelGroup: Swift.String?
        /// Contains parameter values for each of the parameters that the workflow document defined for the workflow resource.
        public var parameters: [ImagebuilderClientTypes.WorkflowParameter]?
        /// The Amazon Resource Name (ARN) of the workflow resource.
        /// This member is required.
        public var workflowArn: Swift.String?

        public init(
            onFailure: ImagebuilderClientTypes.OnWorkflowFailure? = nil,
            parallelGroup: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.WorkflowParameter]? = nil,
            workflowArn: Swift.String? = nil
        )
        {
            self.onFailure = onFailure
            self.parallelGroup = parallelGroup
            self.parameters = parameters
            self.workflowArn = workflowArn
        }
    }
}

public struct CreateImageInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.
    public var containerRecipeArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.
    public var executionRole: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed.
    public var imageRecipeArn: Swift.String?
    /// Contains settings for vulnerability scans.
    public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
    /// The image tests configuration of the image.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The tags of the image.
    public var tags: [Swift.String: Swift.String]?
    /// Contains an array of workflow configuration objects.
    public var workflows: [ImagebuilderClientTypes.WorkflowConfiguration]?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        executionRole: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workflows: [ImagebuilderClientTypes.WorkflowConfiguration]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.executionRole = executionRole
        self.imageRecipeArn = imageRecipeArn
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.tags = tags
        self.workflows = workflows
    }
}

public struct CreateImageOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that the request created.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    public enum PipelineExecutionStartCondition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case expressionMatchAndDependencyUpdatesAvailable
        case expressionMatchOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineExecutionStartCondition] {
            return [
                .expressionMatchAndDependencyUpdatesAvailable,
                .expressionMatchOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .expressionMatchAndDependencyUpdatesAvailable: return "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
            case .expressionMatchOnly: return "EXPRESSION_MATCH_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// A schedule configures when and how often a pipeline will automatically create a new image.
    public struct Schedule: Swift.Sendable {
        /// The condition configures when the pipeline should trigger a new image build. When the pipelineExecutionStartCondition is set to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic version filters on the base image or components in your image recipe, EC2 Image Builder will build a new image only when there are new versions of the image or components in your recipe that match the semantic version filter. When it is set to EXPRESSION_MATCH_ONLY, it will build a new image every time the CRON expression matches the current time. For semantic version syntax, see [CreateComponent](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_CreateComponent.html) in the EC2 Image Builder API Reference.
        public var pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition. For information on how to format a cron expression in Image Builder, see [Use cron expressions in EC2 Image Builder](https://docs.aws.amazon.com/imagebuilder/latest/userguide/image-builder-cron.html).
        public var scheduleExpression: Swift.String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the [IANA timezone format](https://www.joda.org/joda-time/timezones.html). If not specified this defaults to UTC.
        public var timezone: Swift.String?

        public init(
            pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition? = nil,
            scheduleExpression: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }
    }
}

extension ImagebuilderClientTypes {

    public enum PipelineStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateImagePipelineInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images created by this image pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.
    public var executionRole: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images created by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// Contains settings for vulnerability scans.
    public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images created by this image pipeline.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The name of the image pipeline.
    /// This member is required.
    public var name: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?
    /// The tags of the image pipeline.
    public var tags: [Swift.String: Swift.String]?
    /// Contains an array of workflow configuration objects.
    public var workflows: [ImagebuilderClientTypes.WorkflowConfiguration]?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        executionRole: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workflows: [ImagebuilderClientTypes.WorkflowConfiguration]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.executionRole = executionRole
        self.imageRecipeArn = imageRecipeArn
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.name = name
        self.schedule = schedule
        self.status = status
        self.tags = tags
        self.workflows = workflows
    }
}

public struct CreateImagePipelineOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was created by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

public struct CreateImageRecipeInput: Swift.Sendable {
    /// Specify additional settings and launch scripts for your build instances.
    public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    /// The block device mappings of the image recipe.
    public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The components included in the image recipe.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The description of the image recipe.
    public var description: Swift.String?
    /// The name of the image recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image of the image recipe. The value of the string can be the ARN of the base image or an AMI ID. The format for the ARN follows this example: arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x. You can provide the specific version that you want to use, or you can use a wildcard in all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI, and the AMI must be in the same Region in which you are using Image Builder.
    /// This member is required.
    public var parentImage: Swift.String?
    /// The semantic version of the image recipe. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the image recipe.
    public var tags: [Swift.String: Swift.String]?
    /// The working directory used during build and test workflows.
    public var workingDirectory: Swift.String?

    public init(
        additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
        blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.additionalInstanceConfiguration = additionalInstanceConfiguration
        self.blockDeviceMappings = blockDeviceMappings
        self.clientToken = clientToken
        self.components = components
        self.description = description
        self.name = name
        self.parentImage = parentImage
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

public struct CreateImageRecipeOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that was created by this request.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    /// The instance metadata options that apply to the HTTP requests that pipeline builds use to launch EC2 build and test instances. For more information about instance metadata options, see [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the Amazon EC2 User Guide for Linux instances, or [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html) in the Amazon EC2 Windows Guide for Windows instances.
    public struct InstanceMetadataOptions: Swift.Sendable {
        /// Limit the number of hops that an instance metadata request can traverse to reach its destination. The default is one hop. However, if HTTP tokens are required, container image builds need a minimum of two hops.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows:
        ///
        /// * required – When you retrieve the IAM role credentials, version 2.0 credentials are returned in all cases.
        ///
        /// * optional – You can include a signed token header in your request to retrieve instance metadata, or you can leave it out. If you include it, version 2.0 credentials are returned for the IAM role. Otherwise, version 1.0 credentials are returned.
        ///
        ///
        /// The default setting is optional.
        public var httpTokens: Swift.String?

        public init(
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil
        )
        {
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }
    }
}

extension ImagebuilderClientTypes {

    /// Amazon S3 logging configuration.
    public struct S3Logs: Swift.Sendable {
        /// The S3 bucket in which to store the logs.
        public var s3BucketName: Swift.String?
        /// The Amazon S3 path to the bucket where the logs are stored.
        public var s3KeyPrefix: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }
}

extension ImagebuilderClientTypes {

    /// Logging configuration defines where Image Builder uploads your logs.
    public struct Logging: Swift.Sendable {
        /// The Amazon S3 logging configuration.
        public var s3Logs: ImagebuilderClientTypes.S3Logs?

        public init(
            s3Logs: ImagebuilderClientTypes.S3Logs? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }
}

extension ImagebuilderClientTypes {

    public enum TenancyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case `default`
        case host
        case sdkUnknown(Swift.String)

        public static var allCases: [TenancyType] {
            return [
                .dedicated,
                .default,
                .host
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "dedicated"
            case .default: return "default"
            case .host: return "host"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// By default, EC2 instances run on shared tenancy hardware. This means that multiple Amazon Web Services accounts might share the same physical hardware. When you use dedicated hardware, the physical server that hosts your instances is dedicated to your Amazon Web Services account. Instance placement settings contain the details for the physical hardware where instances that Image Builder launches during image creation will run.
    public struct Placement: Swift.Sendable {
        /// The Availability Zone where your build and test instances will launch.
        public var availabilityZone: Swift.String?
        /// The ID of the Dedicated Host on which build and test instances run. This only applies if tenancy is host. If you specify the host ID, you must not specify the resource group ARN. If you specify both, Image Builder returns an error.
        public var hostId: Swift.String?
        /// The Amazon Resource Name (ARN) of the host resource group in which to launch build and test instances. This only applies if tenancy is host. If you specify the resource group ARN, you must not specify the host ID. If you specify both, Image Builder returns an error.
        public var hostResourceGroupArn: Swift.String?
        /// The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware. An instance with a tenancy of host runs on a Dedicated Host. If tenancy is set to host, then you can optionally specify one target for placement – either host ID or host resource group ARN. If automatic placement is enabled for your host, and you don't specify any placement target, Amazon EC2 will try to find an available host for your build and test instances.
        public var tenancy: ImagebuilderClientTypes.TenancyType?

        public init(
            availabilityZone: Swift.String? = nil,
            hostId: Swift.String? = nil,
            hostResourceGroupArn: Swift.String? = nil,
            tenancy: ImagebuilderClientTypes.TenancyType? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.tenancy = tenancy
        }
    }
}

public struct CreateInfrastructureConfigurationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds use to launch EC2 build and test instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The name of the infrastructure configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The instance placement settings that define where the instances that are launched from your image will run.
    public var placement: ImagebuilderClientTypes.Placement?
    /// The metadata tags to assign to the Amazon EC2 instance that Image Builder launches during the build process. Tags are formatted as key value pairs.
    public var resourceTags: [Swift.String: Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
    public var snsTopicArn: Swift.String?
    /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
    public var subnetId: Swift.String?
    /// The metadata tags to assign to the infrastructure configuration resource that Image Builder creates as output. Tags are formatted as key value pairs.
    public var tags: [Swift.String: Swift.String]?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        placement: ImagebuilderClientTypes.Placement? = nil,
        resourceTags: [Swift.String: Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.name = name
        self.placement = placement
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.tags = tags
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

public struct CreateInfrastructureConfigurationOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    /// Specifies how the lifecycle policy should apply actions to selected resources.
    public struct LifecyclePolicyDetailActionIncludeResources: Swift.Sendable {
        /// Specifies whether the lifecycle action should apply to distributed AMIs.
        public var amis: Swift.Bool
        /// Specifies whether the lifecycle action should apply to distributed containers.
        public var containers: Swift.Bool
        /// Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.
        public var snapshots: Swift.Bool

        public init(
            amis: Swift.Bool = false,
            containers: Swift.Bool = false,
            snapshots: Swift.Bool = false
        )
        {
            self.amis = amis
            self.containers = containers
            self.snapshots = snapshots
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecyclePolicyDetailActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case deprecate
        case disable
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyDetailActionType] {
            return [
                .delete,
                .deprecate,
                .disable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .deprecate: return "DEPRECATE"
            case .disable: return "DISABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains selection criteria for the lifecycle policy.
    public struct LifecyclePolicyDetailAction: Swift.Sendable {
        /// Specifies the resources that the lifecycle policy applies to.
        public var includeResources: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources?
        /// Specifies the lifecycle action to take.
        /// This member is required.
        public var type: ImagebuilderClientTypes.LifecyclePolicyDetailActionType?

        public init(
            includeResources: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources? = nil,
            type: ImagebuilderClientTypes.LifecyclePolicyDetailActionType? = nil
        )
        {
            self.includeResources = includeResources
            self.type = type
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecyclePolicyTimeUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case months
        case weeks
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyTimeUnit] {
            return [
                .days,
                .months,
                .weeks,
                .years
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .weeks: return "WEEKS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines criteria to exclude AMIs from lifecycle actions based on the last time they were used to launch an instance.
    public struct LifecyclePolicyDetailExclusionRulesAmisLastLaunched: Swift.Sendable {
        /// Defines the unit of time that the lifecycle policy uses to calculate elapsed time since the last instance launched from the AMI. For example: days, weeks, months, or years.
        /// This member is required.
        public var unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit?
        /// The integer number of units for the time period. For example 6 (months).
        /// This member is required.
        public var value: Swift.Int?

        public init(
            unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines criteria for AMIs that are excluded from lifecycle actions.
    public struct LifecyclePolicyDetailExclusionRulesAmis: Swift.Sendable {
        /// Configures whether public AMIs are excluded from the lifecycle action.
        public var isPublic: Swift.Bool
        /// Specifies configuration details for Image Builder to exclude the most recent resources from lifecycle actions.
        public var lastLaunched: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched?
        /// Configures Amazon Web Services Regions that are excluded from the lifecycle action.
        public var regions: [Swift.String]?
        /// Specifies Amazon Web Services accounts whose resources are excluded from the lifecycle action.
        public var sharedAccounts: [Swift.String]?
        /// Lists tags that should be excluded from lifecycle actions for the AMIs that have them.
        public var tagMap: [Swift.String: Swift.String]?

        public init(
            isPublic: Swift.Bool = false,
            lastLaunched: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched? = nil,
            regions: [Swift.String]? = nil,
            sharedAccounts: [Swift.String]? = nil,
            tagMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.isPublic = isPublic
            self.lastLaunched = lastLaunched
            self.regions = regions
            self.sharedAccounts = sharedAccounts
            self.tagMap = tagMap
        }
    }
}

extension ImagebuilderClientTypes {

    /// Specifies resources that lifecycle policy actions should not apply to.
    public struct LifecyclePolicyDetailExclusionRules: Swift.Sendable {
        /// Lists configuration values that apply to AMIs that Image Builder should exclude from the lifecycle action.
        public var amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis?
        /// Contains a list of tags that Image Builder uses to skip lifecycle actions for Image Builder image resources that have them.
        public var tagMap: [Swift.String: Swift.String]?

        public init(
            amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis? = nil,
            tagMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.amis = amis
            self.tagMap = tagMap
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecyclePolicyDetailFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case age
        case count
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyDetailFilterType] {
            return [
                .age,
                .count
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .age: return "AGE"
            case .count: return "COUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines filters that the lifecycle policy uses to determine impacted resource.
    public struct LifecyclePolicyDetailFilter: Swift.Sendable {
        /// For age-based filters, this is the number of resources to keep on hand after the lifecycle DELETE action is applied. Impacted resources are only deleted if you have more than this number of resources. If you have fewer resources than this number, the impacted resource is not deleted.
        public var retainAtLeast: Swift.Int?
        /// Filter resources based on either age or count.
        /// This member is required.
        public var type: ImagebuilderClientTypes.LifecyclePolicyDetailFilterType?
        /// Defines the unit of time that the lifecycle policy uses to determine impacted resources. This is required for age-based rules.
        public var unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit?
        /// The number of units for the time period or for the count. For example, a value of 6 might refer to six months or six AMIs. For count-based filters, this value represents the minimum number of resources to keep on hand. If you have fewer resources than this number, the resource is excluded from lifecycle actions.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            retainAtLeast: Swift.Int? = nil,
            type: ImagebuilderClientTypes.LifecyclePolicyDetailFilterType? = nil,
            unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.retainAtLeast = retainAtLeast
            self.type = type
            self.unit = unit
            self.value = value
        }
    }
}

extension ImagebuilderClientTypes {

    /// The configuration details for a lifecycle policy resource.
    public struct LifecyclePolicyDetail: Swift.Sendable {
        /// Configuration details for the policy action.
        /// This member is required.
        public var action: ImagebuilderClientTypes.LifecyclePolicyDetailAction?
        /// Additional rules to specify resources that should be exempt from policy actions.
        public var exclusionRules: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules?
        /// Specifies the resources that the lifecycle policy applies to.
        /// This member is required.
        public var filter: ImagebuilderClientTypes.LifecyclePolicyDetailFilter?

        public init(
            action: ImagebuilderClientTypes.LifecyclePolicyDetailAction? = nil,
            exclusionRules: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules? = nil,
            filter: ImagebuilderClientTypes.LifecyclePolicyDetailFilter? = nil
        )
        {
            self.action = action
            self.exclusionRules = exclusionRules
            self.filter = filter
        }
    }
}

extension ImagebuilderClientTypes {

    /// Specifies an Image Builder recipe that the lifecycle policy uses for resource selection.
    public struct LifecyclePolicyResourceSelectionRecipe: Swift.Sendable {
        /// The name of an Image Builder recipe that the lifecycle policy uses for resource selection.
        /// This member is required.
        public var name: Swift.String?
        /// The version of the Image Builder recipe specified by the name field.
        /// This member is required.
        public var semanticVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            semanticVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.semanticVersion = semanticVersion
        }
    }
}

extension ImagebuilderClientTypes {

    /// Resource selection criteria for the lifecycle policy.
    public struct LifecyclePolicyResourceSelection: Swift.Sendable {
        /// A list of recipes that are used as selection criteria for the output images that the lifecycle policy applies to.
        public var recipes: [ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe]?
        /// A list of tags that are used as selection criteria for the Image Builder image resources that the lifecycle policy applies to.
        public var tagMap: [Swift.String: Swift.String]?

        public init(
            recipes: [ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe]? = nil,
            tagMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.recipes = recipes
            self.tagMap = tagMap
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecyclePolicyResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amiImage
        case containerImage
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyResourceType] {
            return [
                .amiImage,
                .containerImage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amiImage: return "AMI_IMAGE"
            case .containerImage: return "CONTAINER_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecyclePolicyStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLifecyclePolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Optional description for the lifecycle policy.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to run lifecycle actions.
    /// This member is required.
    public var executionRole: Swift.String?
    /// The name of the lifecycle policy to create.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration details for the lifecycle policy rules.
    /// This member is required.
    public var policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
    /// Selection criteria for the resources that the lifecycle policy applies to.
    /// This member is required.
    public var resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
    /// The type of Image Builder resource that the lifecycle policy applies to.
    /// This member is required.
    public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
    /// Indicates whether the lifecycle policy resource is enabled.
    public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?
    /// Tags to apply to the lifecycle policy resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        name: Swift.String? = nil,
        policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil,
        resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection? = nil,
        resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
        status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.executionRole = executionRole
        self.name = name
        self.policyDetails = policyDetails
        self.resourceSelection = resourceSelection
        self.resourceType = resourceType
        self.status = status
        self.tags = tags
    }
}

public struct CreateLifecyclePolicyOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the lifecycle policy that the request created.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

extension ImagebuilderClientTypes {

    public enum WorkflowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case build
        case distribution
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .build,
                .distribution,
                .test
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .distribution: return "DISTRIBUTION"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorkflowInput: Swift.Sendable {
    /// Describes what change has been made in this version of the workflow, or what makes this version different from other versions of the workflow.
    public var changeDescription: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Contains the UTF-8 encoded YAML document content for the workflow. Alternatively, you can specify the uri of a YAML document file stored in Amazon S3. However, you cannot specify both properties.
    public var data: Swift.String?
    /// Describes the workflow.
    public var description: Swift.String?
    /// The ID of the KMS key that is used to encrypt this workflow resource.
    public var kmsKeyId: Swift.String?
    /// The name of the workflow to create.
    /// This member is required.
    public var name: Swift.String?
    /// The semantic version of this workflow resource. The semantic version syntax adheres to the following rules. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that apply to the workflow resource.
    public var tags: [Swift.String: Swift.String]?
    /// The phase in the image build process for which the workflow resource is responsible.
    /// This member is required.
    public var type: ImagebuilderClientTypes.WorkflowType?
    /// The uri of a YAML component document file. This must be an S3 URL (s3://bucket/key), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component data property. You cannot specify both properties.
    public var uri: Swift.String?

    public init(
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: ImagebuilderClientTypes.WorkflowType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.type = type
        self.uri = uri
    }
}

public struct CreateWorkflowOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow resource that the request created.
    public var workflowBuildVersionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workflowBuildVersionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workflowBuildVersionArn = workflowBuildVersionArn
    }
}

extension ImagebuilderClientTypes {

    /// Amazon Inspector generates a risk score for each finding. This score helps you to prioritize findings, to focus on the most critical findings and the most vulnerable resources. The score uses the Common Vulnerability Scoring System (CVSS) format. This format is a modification of the base CVSS score that the National Vulnerability Database (NVD) provides. For more information about severity levels, see [Severity levels for Amazon Inspector findings](https://docs.aws.amazon.com/inspector/latest/user/findings-understanding-severity.html) in the Amazon Inspector User Guide.
    public struct CvssScore: Swift.Sendable {
        /// The CVSS base score.
        public var baseScore: Swift.Double?
        /// The vector string of the CVSS score.
        public var scoringVector: Swift.String?
        /// The source of the CVSS score.
        public var source: Swift.String?
        /// The CVSS version that generated the score.
        public var version: Swift.String?

        public init(
            baseScore: Swift.Double? = nil,
            scoringVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }
    }
}

extension ImagebuilderClientTypes {

    /// Details about an adjustment that Amazon Inspector made to the CVSS score for a finding.
    public struct CvssScoreAdjustment: Swift.Sendable {
        /// The metric that Amazon Inspector used to adjust the CVSS score.
        public var metric: Swift.String?
        /// The reason for the CVSS score adjustment.
        public var reason: Swift.String?

        public init(
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }
}

extension ImagebuilderClientTypes {

    /// Details about the source of the score, and the factors that determined the adjustments to create the final score.
    public struct CvssScoreDetails: Swift.Sendable {
        /// An object that contains details about an adjustment that Amazon Inspector made to the CVSS score for the finding.
        public var adjustments: [ImagebuilderClientTypes.CvssScoreAdjustment]?
        /// The source of the finding.
        public var cvssSource: Swift.String?
        /// The CVSS score.
        public var score: Swift.Double?
        /// The source for the CVSS score.
        public var scoreSource: Swift.String?
        /// A vector that measures the severity of the vulnerability.
        public var scoringVector: Swift.String?
        /// The CVSS version that generated the score.
        public var version: Swift.String?

        public init(
            adjustments: [ImagebuilderClientTypes.CvssScoreAdjustment]? = nil,
            cvssSource: Swift.String? = nil,
            score: Swift.Double? = nil,
            scoreSource: Swift.String? = nil,
            scoringVector: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }
    }
}

/// You have attempted to mutate or delete a resource with a dependency that prohibits this action. See the error message for more details.
public struct ResourceDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDependencyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteComponentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the component build version to delete.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init(
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

public struct DeleteComponentOutput: Swift.Sendable {
    /// The ARN of the component build version that this request deleted.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

public struct DeleteContainerRecipeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the container recipe to delete.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

public struct DeleteContainerRecipeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

public struct DeleteDistributionConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init(
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

public struct DeleteDistributionConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

public struct DeleteImageInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

public struct DeleteImageOutput: Swift.Sendable {
    /// The ARN of the Image Builder image resource that this request deleted.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

public struct DeleteImagePipelineInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image pipeline to delete.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init(
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

public struct DeleteImagePipelineOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

public struct DeleteImageRecipeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image recipe to delete.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

public struct DeleteImageRecipeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

public struct DeleteInfrastructureConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init(
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

public struct DeleteInfrastructureConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the lifecycle policy resource to delete.
    /// This member is required.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Sendable {
    /// The ARN of the lifecycle policy that was deleted.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

public struct DeleteWorkflowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the workflow resource to delete.
    /// This member is required.
    public var workflowBuildVersionArn: Swift.String?

    public init(
        workflowBuildVersionArn: Swift.String? = nil
    )
    {
        self.workflowBuildVersionArn = workflowBuildVersionArn
    }
}

public struct DeleteWorkflowOutput: Swift.Sendable {
    /// The ARN of the workflow resource that this request deleted.
    public var workflowBuildVersionArn: Swift.String?

    public init(
        workflowBuildVersionArn: Swift.String? = nil
    )
    {
        self.workflowBuildVersionArn = workflowBuildVersionArn
    }
}

extension ImagebuilderClientTypes {

    /// A distribution configuration.
    public struct DistributionConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which this distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which this distribution configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The distribution objects that apply Region-specific settings for the deployment of the image to targeted Regions.
        public var distributions: [ImagebuilderClientTypes.Distribution]?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// The tags of the distribution configuration.
        public var tags: [Swift.String: Swift.String]?
        /// The maximum duration in minutes for this distribution configuration.
        /// This member is required.
        public var timeoutMinutes: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributions: [ImagebuilderClientTypes.Distribution]? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }
    }
}

extension ImagebuilderClientTypes {

    /// A high-level overview of a distribution configuration.
    public struct DistributionConfigurationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which the distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the distribution configuration was updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// A list of Regions where the container image is distributed to.
        public var regions: [Swift.String]?
        /// The tags associated with the distribution configuration.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }
    }
}

extension ImagebuilderClientTypes {

    /// A filter name and value pair that is used to return a more specific list of results from a list operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Sendable {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct GetComponentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the component that you want to get. Regex requires the suffix /\d+$.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init(
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

public struct GetComponentOutput: Swift.Sendable {
    /// The component object specified in the request.
    public var component: ImagebuilderClientTypes.Component?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        component: ImagebuilderClientTypes.Component? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.component = component
        self.requestId = requestId
    }
}

/// At least one of the resources referenced by your request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetComponentPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.
    /// This member is required.
    public var componentArn: Swift.String?

    public init(
        componentArn: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
    }
}

public struct GetComponentPolicyOutput: Swift.Sendable {
    /// The component policy.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

public struct GetContainerRecipeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

public struct GetContainerRecipeOutput: Swift.Sendable {
    /// The container recipe object that is returned.
    public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipe = containerRecipe
        self.requestId = requestId
    }
}

public struct GetContainerRecipePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the container recipe for the policy being requested.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

public struct GetContainerRecipePolicyOutput: Swift.Sendable {
    /// The container recipe policy object that is returned.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

public struct GetDistributionConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to retrieve.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init(
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

public struct GetDistributionConfigurationOutput: Swift.Sendable {
    /// The distribution configuration object.
    public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfiguration = distributionConfiguration
        self.requestId = requestId
    }
}

public struct GetImageInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image that you want to get.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

extension ImagebuilderClientTypes {

    public enum ImageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ami
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .ami,
                .docker
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ami: return "AMI"
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// An image recipe.
    public struct ImageRecipe: Swift.Sendable {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test your image configuration. Instance configuration adds a layer of control over those instances. You can define settings and add scripts to run when an instance is launched from your AMI.
        public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The block device mappings to apply when creating images from this recipe.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The components that are included in the image recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the image recipe.
        public var description: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String: Swift.String]?
        /// Specifies which type of image is created by the recipe - an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image recipe.
        public var version: Swift.String?
        /// The working directory to be used during build and test workflows.
        public var workingDirectory: Swift.String?

        public init(
            additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
            arn: Swift.String? = nil,
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ImageSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonManaged
        case awsMarketplace
        case custom
        case imported
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSource] {
            return [
                .amazonManaged,
                .awsMarketplace,
                .custom,
                .imported
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonManaged: return "AMAZON_MANAGED"
            case .awsMarketplace: return "AWS_MARKETPLACE"
            case .custom: return "CUSTOM"
            case .imported: return "IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Details of the infrastructure configuration.
    public struct InfrastructureConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance metadata option settings for the infrastructure configuration.
        public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public var keyPair: Swift.String?
        /// The logging configuration of the infrastructure configuration.
        public var logging: ImagebuilderClientTypes.Logging?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The instance placement settings that define where the instances that are launched from your image will run.
        public var placement: ImagebuilderClientTypes.Placement?
        /// The tags attached to the resource created by Image Builder.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The security group IDs of the infrastructure configuration.
        public var securityGroupIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
        public var snsTopicArn: Swift.String?
        /// The subnet ID of the infrastructure configuration.
        public var subnetId: Swift.String?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String: Swift.String]?
        /// The terminate instance on failure configuration of the infrastructure configuration.
        public var terminateInstanceOnFailure: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            keyPair: Swift.String? = nil,
            logging: ImagebuilderClientTypes.Logging? = nil,
            name: Swift.String? = nil,
            placement: ImagebuilderClientTypes.Placement? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            terminateInstanceOnFailure: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.placement = placement
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }
    }
}

extension ImagebuilderClientTypes {

    /// The resources produced by this image.
    public struct OutputResources: Swift.Sendable {
        /// The Amazon EC2 AMIs created by this image.
        public var amis: [ImagebuilderClientTypes.Ami]?
        /// Container images that the pipeline has generated and stored in the output repository.
        public var containers: [ImagebuilderClientTypes.Container]?

        public init(
            amis: [ImagebuilderClientTypes.Ami]? = nil,
            containers: [ImagebuilderClientTypes.Container]? = nil
        )
        {
            self.amis = amis
            self.containers = containers
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ImageScanStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abandoned
        case collecting
        case completed
        case failed
        case pending
        case scanning
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageScanStatus] {
            return [
                .abandoned,
                .collecting,
                .completed,
                .failed,
                .pending,
                .scanning,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abandoned: return "ABANDONED"
            case .collecting: return "COLLECTING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .scanning: return "SCANNING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Shows the vulnerability scan status for a specific image, and the reason for that status.
    public struct ImageScanState: Swift.Sendable {
        /// The reason for the scan status for the image.
        public var reason: Swift.String?
        /// The current state of vulnerability scans for the image.
        public var status: ImagebuilderClientTypes.ImageScanStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ImageScanStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension ImagebuilderClientTypes {

    /// An Image Builder image. You must specify exactly one recipe for the image – either a container recipe (containerRecipe), which creates a container image, or an image recipe (imageRecipe), which creates an AMI.
    public struct Image: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the image. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.
        public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
        /// The date on which Image Builder created this image.
        public var dateCreated: Swift.String?
        /// The time when deprecation occurs for an image resource. This can be a past or future date.
        public var deprecationTime: Foundation.Date?
        /// The distribution configuration that Image Builder used to create this image.
        public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
        /// Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.
        public var executionRole: Swift.String?
        /// For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.
        public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
        /// Contains settings for vulnerability scans.
        public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
        /// The origin of the base image that Image Builder used to build this image.
        public var imageSource: ImagebuilderClientTypes.ImageSource?
        /// The image tests that ran when that Image Builder created this image.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The infrastructure that Image Builder used to create this image.
        public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
        /// Identifies the last runtime instance of the lifecycle policy to take action on the image.
        public var lifecycleExecutionId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources that Image Builder produces for this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The image operating system platform, such as Linux or Windows.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Contains information about the current state of scans for this image.
        public var scanState: ImagebuilderClientTypes.ImageScanState?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public var sourcePipelineArn: Swift.String?
        /// The name of the image pipeline that created this image.
        public var sourcePipelineName: Swift.String?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags that apply to this image.
        public var tags: [Swift.String: Swift.String]?
        /// Specifies whether this image produces an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The semantic version of the image. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?
        /// Contains the build and test workflows that are associated with the image.
        public var workflows: [ImagebuilderClientTypes.WorkflowConfiguration]?

        public init(
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
            dateCreated: Swift.String? = nil,
            deprecationTime: Foundation.Date? = nil,
            distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            executionRole: Swift.String? = nil,
            imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
            imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
            imageSource: ImagebuilderClientTypes.ImageSource? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
            lifecycleExecutionId: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            scanState: ImagebuilderClientTypes.ImageScanState? = nil,
            sourcePipelineArn: Swift.String? = nil,
            sourcePipelineName: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil,
            workflows: [ImagebuilderClientTypes.WorkflowConfiguration]? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.deprecationTime = deprecationTime
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imageRecipe = imageRecipe
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageSource = imageSource
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.lifecycleExecutionId = lifecycleExecutionId
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.scanState = scanState
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
            self.workflows = workflows
        }
    }
}

public struct GetImageOutput: Swift.Sendable {
    /// The image object.
    public var image: ImagebuilderClientTypes.Image?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        image: ImagebuilderClientTypes.Image? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.image = image
        self.requestId = requestId
    }
}

public struct GetImagePipelineInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init(
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

extension ImagebuilderClientTypes {

    /// Details of an image pipeline.
    public struct ImagePipeline: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.
        public var containerRecipeArn: Swift.String?
        /// The date on which this image pipeline was created.
        public var dateCreated: Swift.String?
        /// This is no longer supported, and does not return a value.
        public var dateLastRun: Swift.String?
        /// The next date when the pipeline is scheduled to run.
        public var dateNextRun: Swift.String?
        /// The date on which this image pipeline was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the image pipeline.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.
        public var distributionConfigurationArn: Swift.String?
        /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.
        public var executionRole: Swift.String?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.
        public var imageRecipeArn: Swift.String?
        /// Contains settings for vulnerability scans.
        public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
        /// The image tests configuration of the image pipeline.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.
        public var infrastructureConfigurationArn: Swift.String?
        /// The name of the image pipeline.
        public var name: Swift.String?
        /// The platform of the image pipeline.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The schedule of the image pipeline.
        public var schedule: ImagebuilderClientTypes.Schedule?
        /// The status of the image pipeline.
        public var status: ImagebuilderClientTypes.PipelineStatus?
        /// The tags of this image pipeline.
        public var tags: [Swift.String: Swift.String]?
        /// Contains the workflows that run for the image pipeline.
        public var workflows: [ImagebuilderClientTypes.WorkflowConfiguration]?

        public init(
            arn: Swift.String? = nil,
            containerRecipeArn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateLastRun: Swift.String? = nil,
            dateNextRun: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributionConfigurationArn: Swift.String? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            executionRole: Swift.String? = nil,
            imageRecipeArn: Swift.String? = nil,
            imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfigurationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            schedule: ImagebuilderClientTypes.Schedule? = nil,
            status: ImagebuilderClientTypes.PipelineStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            workflows: [ImagebuilderClientTypes.WorkflowConfiguration]? = nil
        )
        {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imageRecipeArn = imageRecipeArn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
            self.workflows = workflows
        }
    }
}

public struct GetImagePipelineOutput: Swift.Sendable {
    /// The image pipeline object.
    public var imagePipeline: ImagebuilderClientTypes.ImagePipeline?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePipeline: ImagebuilderClientTypes.ImagePipeline? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipeline = imagePipeline
        self.requestId = requestId
    }
}

public struct GetImagePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
    /// This member is required.
    public var imageArn: Swift.String?

    public init(
        imageArn: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
    }
}

public struct GetImagePolicyOutput: Swift.Sendable {
    /// The image policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

public struct GetImageRecipeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

public struct GetImageRecipeOutput: Swift.Sendable {
    /// The image recipe object.
    public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipe = imageRecipe
        self.requestId = requestId
    }
}

public struct GetImageRecipePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

public struct GetImageRecipePolicyOutput: Swift.Sendable {
    /// The image recipe policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

/// GetInfrastructureConfiguration request object.
public struct GetInfrastructureConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to retrieve.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init(
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

/// GetInfrastructureConfiguration response object.
public struct GetInfrastructureConfigurationOutput: Swift.Sendable {
    /// The infrastructure configuration object.
    public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfiguration = infrastructureConfiguration
        self.requestId = requestId
    }
}

public struct GetLifecycleExecutionInput: Swift.Sendable {
    /// Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    /// This member is required.
    public var lifecycleExecutionId: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
    }
}

extension ImagebuilderClientTypes {

    /// Contains details for an image resource that was identified for a lifecycle action.
    public struct LifecycleExecutionResourcesImpactedSummary: Swift.Sendable {
        /// Indicates whether an image resource that was identified for a lifecycle action has associated resources that are also impacted.
        public var hasImpactedResources: Swift.Bool

        public init(
            hasImpactedResources: Swift.Bool = false
        )
        {
            self.hasImpactedResources = hasImpactedResources
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecycleExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inProgress,
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// The current state of the runtime instance of the lifecycle policy.
    public struct LifecycleExecutionState: Swift.Sendable {
        /// The reason for the current status.
        public var reason: Swift.String?
        /// The runtime status of the lifecycle execution.
        public var status: ImagebuilderClientTypes.LifecycleExecutionStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.LifecycleExecutionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains metadata from a runtime instance of a lifecycle policy.
    public struct LifecycleExecution: Swift.Sendable {
        /// The timestamp when the lifecycle runtime instance completed.
        public var endTime: Foundation.Date?
        /// Identifies the lifecycle policy runtime instance.
        public var lifecycleExecutionId: Swift.String?
        /// The Amazon Resource Name (ARN) of the lifecycle policy that ran.
        public var lifecyclePolicyArn: Swift.String?
        /// Contains information about associated resources that are identified for action by the runtime instance of the lifecycle policy.
        public var resourcesImpactedSummary: ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary?
        /// The timestamp when the lifecycle runtime instance started.
        public var startTime: Foundation.Date?
        /// Runtime state that reports if the policy action ran successfully, failed, or was skipped.
        public var state: ImagebuilderClientTypes.LifecycleExecutionState?

        public init(
            endTime: Foundation.Date? = nil,
            lifecycleExecutionId: Swift.String? = nil,
            lifecyclePolicyArn: Swift.String? = nil,
            resourcesImpactedSummary: ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary? = nil,
            startTime: Foundation.Date? = nil,
            state: ImagebuilderClientTypes.LifecycleExecutionState? = nil
        )
        {
            self.endTime = endTime
            self.lifecycleExecutionId = lifecycleExecutionId
            self.lifecyclePolicyArn = lifecyclePolicyArn
            self.resourcesImpactedSummary = resourcesImpactedSummary
            self.startTime = startTime
            self.state = state
        }
    }
}

public struct GetLifecycleExecutionOutput: Swift.Sendable {
    /// Runtime details for the specified runtime instance of the lifecycle policy.
    public var lifecycleExecution: ImagebuilderClientTypes.LifecycleExecution?

    public init(
        lifecycleExecution: ImagebuilderClientTypes.LifecycleExecution? = nil
    )
    {
        self.lifecycleExecution = lifecycleExecution
    }
}

public struct GetLifecyclePolicyInput: Swift.Sendable {
    /// Specifies the Amazon Resource Name (ARN) of the image lifecycle policy resource to get.
    /// This member is required.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

extension ImagebuilderClientTypes {

    /// The configuration details for a lifecycle policy resource.
    public struct LifecyclePolicy: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the lifecycle policy resource.
        public var arn: Swift.String?
        /// The timestamp when Image Builder created the lifecycle policy resource.
        public var dateCreated: Foundation.Date?
        /// The timestamp for the last time Image Builder ran the lifecycle policy.
        public var dateLastRun: Foundation.Date?
        /// The timestamp when Image Builder updated the lifecycle policy resource.
        public var dateUpdated: Foundation.Date?
        /// Optional description for the lifecycle policy.
        public var description: Swift.String?
        /// The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to run the lifecycle policy. This is a custom role that you create.
        public var executionRole: Swift.String?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The configuration details for a lifecycle policy resource.
        public var policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
        /// Resource selection criteria used to run the lifecycle policy.
        public var resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
        /// The type of resources the lifecycle policy targets.
        public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
        /// Indicates whether the lifecycle policy resource is enabled.
        public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?
        /// To help manage your lifecycle policy resources, you can assign your own metadata to each resource in the form of tags. Each tag consists of a key and an optional value, both of which you define.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Foundation.Date? = nil,
            dateLastRun: Foundation.Date? = nil,
            dateUpdated: Foundation.Date? = nil,
            description: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            name: Swift.String? = nil,
            policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil,
            resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection? = nil,
            resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
            status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.policyDetails = policyDetails
            self.resourceSelection = resourceSelection
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }
    }
}

public struct GetLifecyclePolicyOutput: Swift.Sendable {
    /// The ARN of the image lifecycle policy resource that was returned.
    public var lifecyclePolicy: ImagebuilderClientTypes.LifecyclePolicy?

    public init(
        lifecyclePolicy: ImagebuilderClientTypes.LifecyclePolicy? = nil
    )
    {
        self.lifecyclePolicy = lifecyclePolicy
    }
}

public struct GetWorkflowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the workflow resource that you want to get.
    /// This member is required.
    public var workflowBuildVersionArn: Swift.String?

    public init(
        workflowBuildVersionArn: Swift.String? = nil
    )
    {
        self.workflowBuildVersionArn = workflowBuildVersionArn
    }
}

extension ImagebuilderClientTypes {

    /// Defines a parameter that's used to provide configuration details for the workflow.
    public struct WorkflowParameterDetail: Swift.Sendable {
        /// The default value of this parameter if no input is provided.
        public var defaultValue: [Swift.String]?
        /// Describes this parameter.
        public var description: Swift.String?
        /// The name of this input parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of input this parameter provides. The currently supported value is "string".
        /// This member is required.
        public var type: Swift.String?

        public init(
            defaultValue: [Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

extension ImagebuilderClientTypes {

    public enum WorkflowStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .deprecated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// A group of fields that describe the current status of workflow.
    public struct WorkflowState: Swift.Sendable {
        /// Describes how or why the workflow changed state.
        public var reason: Swift.String?
        /// The current state of the workflow.
        public var status: ImagebuilderClientTypes.WorkflowStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.WorkflowStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension ImagebuilderClientTypes {

    /// Defines a process that Image Builder uses to build and test images during the image creation process.
    public struct Workflow: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public var arn: Swift.String?
        /// Describes what change has been made in this version of the workflow, or what makes this version different from other versions of the workflow.
        public var changeDescription: Swift.String?
        /// Contains the YAML document content for the workflow.
        public var data: Swift.String?
        /// The timestamp when Image Builder created the workflow resource.
        public var dateCreated: Swift.String?
        /// The description of the workflow.
        public var description: Swift.String?
        /// The KMS key identifier used to encrypt the workflow resource.
        public var kmsKeyId: Swift.String?
        /// The name of the workflow resource.
        public var name: Swift.String?
        /// The owner of the workflow resource.
        public var owner: Swift.String?
        /// An array of input parameters that that the image workflow uses to control actions or configure settings.
        public var parameters: [ImagebuilderClientTypes.WorkflowParameterDetail]?
        /// Describes the current status of the workflow and the reason for that status.
        public var state: ImagebuilderClientTypes.WorkflowState?
        /// The tags that apply to the workflow resource
        public var tags: [Swift.String: Swift.String]?
        /// Specifies the image creation stage that the workflow applies to. Image Builder currently supports build and test workflows.
        public var type: ImagebuilderClientTypes.WorkflowType?
        /// The workflow resource version. Workflow resources are immutable. To make a change, you can clone a workflow or create a new version.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            data: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.WorkflowParameterDetail]? = nil,
            state: ImagebuilderClientTypes.WorkflowState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.WorkflowType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }
}

public struct GetWorkflowOutput: Swift.Sendable {
    /// The workflow resource specified in the request.
    public var workflow: ImagebuilderClientTypes.Workflow?

    public init(
        workflow: ImagebuilderClientTypes.Workflow? = nil
    )
    {
        self.workflow = workflow
    }
}

public struct GetWorkflowExecutionInput: Swift.Sendable {
    /// Use the unique identifier for a runtime instance of the workflow to get runtime details.
    /// This member is required.
    public var workflowExecutionId: Swift.String?

    public init(
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.workflowExecutionId = workflowExecutionId
    }
}

extension ImagebuilderClientTypes {

    public enum WorkflowExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case pending
        case rollbackCompleted
        case rollbackInProgress
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowExecutionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .pending,
                .rollbackCompleted,
                .rollbackInProgress,
                .running,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .rollbackCompleted: return "ROLLBACK_COMPLETED"
            case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWorkflowExecutionOutput: Swift.Sendable {
    /// The timestamp when the specified runtime instance of the workflow finished.
    public var endTime: Swift.String?
    /// The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.
    public var imageBuildVersionArn: Swift.String?
    /// The output message from the specified runtime instance of the workflow, if applicable.
    public var message: Swift.String?
    /// Test workflows are defined within named runtime groups. The parallel group is a named group that contains one or more test workflows.
    public var parallelGroup: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// The timestamp when the specified runtime instance of the workflow started.
    public var startTime: Swift.String?
    /// The current runtime status for the specified runtime instance of the workflow.
    public var status: ImagebuilderClientTypes.WorkflowExecutionStatus?
    /// The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.
    public var totalStepCount: Swift.Int
    /// A runtime count for the number of steps that failed in the specified runtime instance of the workflow.
    public var totalStepsFailed: Swift.Int
    /// A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.
    public var totalStepsSkipped: Swift.Int
    /// A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.
    public var totalStepsSucceeded: Swift.Int
    /// The type of workflow that Image Builder ran for the specified runtime instance of the workflow.
    public var type: ImagebuilderClientTypes.WorkflowType?
    /// The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.
    public var workflowBuildVersionArn: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    public var workflowExecutionId: Swift.String?

    public init(
        endTime: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        message: Swift.String? = nil,
        parallelGroup: Swift.String? = nil,
        requestId: Swift.String? = nil,
        startTime: Swift.String? = nil,
        status: ImagebuilderClientTypes.WorkflowExecutionStatus? = nil,
        totalStepCount: Swift.Int = 0,
        totalStepsFailed: Swift.Int = 0,
        totalStepsSkipped: Swift.Int = 0,
        totalStepsSucceeded: Swift.Int = 0,
        type: ImagebuilderClientTypes.WorkflowType? = nil,
        workflowBuildVersionArn: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.imageBuildVersionArn = imageBuildVersionArn
        self.message = message
        self.parallelGroup = parallelGroup
        self.requestId = requestId
        self.startTime = startTime
        self.status = status
        self.totalStepCount = totalStepCount
        self.totalStepsFailed = totalStepsFailed
        self.totalStepsSkipped = totalStepsSkipped
        self.totalStepsSucceeded = totalStepsSucceeded
        self.type = type
        self.workflowBuildVersionArn = workflowBuildVersionArn
        self.workflowExecutionId = workflowExecutionId
    }
}

public struct GetWorkflowStepExecutionInput: Swift.Sendable {
    /// Use the unique identifier for a specific runtime instance of the workflow step to get runtime details for that step.
    /// This member is required.
    public var stepExecutionId: Swift.String?

    public init(
        stepExecutionId: Swift.String? = nil
    )
    {
        self.stepExecutionId = stepExecutionId
    }
}

extension ImagebuilderClientTypes {

    public enum WorkflowStepExecutionRollbackStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepExecutionRollbackStatus] {
            return [
                .completed,
                .failed,
                .running,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    public enum WorkflowStepExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case pending
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepExecutionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .pending,
                .running,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWorkflowStepExecutionOutput: Swift.Sendable {
    /// The name of the action that the specified step performs.
    public var action: Swift.String?
    /// Describes the specified workflow step.
    public var description: Swift.String?
    /// The timestamp when the specified runtime instance of the workflow step finished.
    public var endTime: Swift.String?
    /// The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow step creates.
    public var imageBuildVersionArn: Swift.String?
    /// Input parameters that Image Builder provided for the specified runtime instance of the workflow step.
    public var inputs: Swift.String?
    /// The output message from the specified runtime instance of the workflow step, if applicable.
    public var message: Swift.String?
    /// The name of the specified runtime instance of the workflow step.
    public var name: Swift.String?
    /// The action to perform if the workflow step fails.
    public var onFailure: Swift.String?
    /// The file names that the specified runtime version of the workflow step created as output.
    public var outputs: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// Reports on the rollback status of the specified runtime version of the workflow step, if applicable.
    public var rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus?
    /// The timestamp when the specified runtime version of the workflow step started.
    public var startTime: Swift.String?
    /// The current status for the specified runtime version of the workflow step.
    public var status: ImagebuilderClientTypes.WorkflowStepExecutionStatus?
    /// The unique identifier for the runtime version of the workflow step that you specified in the request.
    public var stepExecutionId: Swift.String?
    /// The maximum duration in seconds for this step to complete its action.
    public var timeoutSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines this workflow step.
    public var workflowBuildVersionArn: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    public var workflowExecutionId: Swift.String?

    public init(
        action: Swift.String? = nil,
        description: Swift.String? = nil,
        endTime: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        inputs: Swift.String? = nil,
        message: Swift.String? = nil,
        name: Swift.String? = nil,
        onFailure: Swift.String? = nil,
        outputs: Swift.String? = nil,
        requestId: Swift.String? = nil,
        rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus? = nil,
        startTime: Swift.String? = nil,
        status: ImagebuilderClientTypes.WorkflowStepExecutionStatus? = nil,
        stepExecutionId: Swift.String? = nil,
        timeoutSeconds: Swift.Int? = nil,
        workflowBuildVersionArn: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.action = action
        self.description = description
        self.endTime = endTime
        self.imageBuildVersionArn = imageBuildVersionArn
        self.inputs = inputs
        self.message = message
        self.name = name
        self.onFailure = onFailure
        self.outputs = outputs
        self.requestId = requestId
        self.rollbackStatus = rollbackStatus
        self.startTime = startTime
        self.status = status
        self.stepExecutionId = stepExecutionId
        self.timeoutSeconds = timeoutSeconds
        self.workflowBuildVersionArn = workflowBuildVersionArn
        self.workflowExecutionId = workflowExecutionId
    }
}

extension ImagebuilderClientTypes {

    /// Contains vulnerability counts for a specific image.
    public struct ImageAggregation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the image for this aggregation.
        public var imageBuildVersionArn: Swift.String?
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified image.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?

        public init(
            imageBuildVersionArn: Swift.String? = nil,
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil
        )
        {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.severityCounts = severityCounts
        }
    }
}

public struct ImportComponentInput: Swift.Sendable {
    /// The change description of the component. This description indicates the change that has been made in this version, or what makes this version different from other versions of the component.
    public var changeDescription: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
    public var data: Swift.String?
    /// The description of the component. Describes the contents of the component.
    public var description: Swift.String?
    /// The format of the resource that you want to import as a component.
    /// This member is required.
    public var format: ImagebuilderClientTypes.ComponentFormat?
    /// The ID of the KMS key that should be used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the component.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the component denotes whether the component is used to build the image, or only to test it.
    /// This member is required.
    public var type: ImagebuilderClientTypes.ComponentType?
    /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component.
    public var uri: Swift.String?

    public init(
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        format: ImagebuilderClientTypes.ComponentFormat? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: ImagebuilderClientTypes.ComponentType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.type = type
        self.uri = uri
    }
}

public struct ImportComponentOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported component.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

public struct ImportVmImageInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description for the base image that is created by the import process.
    public var description: Swift.String?
    /// The name of the base image that is created by the import process.
    /// This member is required.
    public var name: Swift.String?
    /// The operating system version for the imported VM.
    public var osVersion: Swift.String?
    /// The operating system platform for the imported VM.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version to attach to the base image that was created during the import process. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the import resources.
    public var tags: [Swift.String: Swift.String]?
    /// The importTaskId (API) or ImportTaskId (CLI) from the Amazon EC2 VM import process. Image Builder retrieves information from the import process to pull in the AMI that is created from the VM source as the base image for your recipe.
    /// This member is required.
    public var vmImportTaskId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        osVersion: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vmImportTaskId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.osVersion = osVersion
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.vmImportTaskId = vmImportTaskId
    }
}

public struct ImportVmImageOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AMI that was created during the VM import process. This AMI is used as the base image for the recipe that imported the VM.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

/// You have provided an invalid pagination token in your request.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListComponentBuildVersionsInput: Swift.Sendable {
    /// The component version Amazon Resource Name (ARN) whose versions you want to list.
    /// This member is required.
    public var componentVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        componentVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersionArn = componentVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListComponentBuildVersionsOutput: Swift.Sendable {
    /// The list of component summaries for the specified semantic version.
    public var componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentSummaryList = componentSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    public enum Ownership: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazon
        case `self`
        case shared
        case thirdparty
        case sdkUnknown(Swift.String)

        public static var allCases: [Ownership] {
            return [
                .amazon,
                .self,
                .shared,
                .thirdparty
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazon: return "Amazon"
            case .self: return "Self"
            case .shared: return "Shared"
            case .thirdparty: return "ThirdParty"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListComponentsInput: Swift.Sendable {
    /// Returns the list of components for the specified name.
    public var byName: Swift.Bool?
    /// Use the following filters to streamline results:
    ///
    /// * description
    ///
    /// * name
    ///
    /// * platform
    ///
    /// * supportedOsVersion
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Filters results based on the type of owner for the component. By default, this request returns a list of components that your account owns. To see results for other types of owners, you can specify components that Amazon manages, third party components, or components that other accounts have shared with you.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        byName: Swift.Bool? = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

public struct ListComponentsOutput: Swift.Sendable {
    /// The list of component semantic versions. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them.
    public var componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentVersionList: [ImagebuilderClientTypes.ComponentVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentVersionList = componentVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListContainerRecipesInput: Swift.Sendable {
    /// Use the following filters to streamline results:
    ///
    /// * containerType
    ///
    /// * name
    ///
    /// * parentImage
    ///
    /// * platform
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

public struct ListContainerRecipesOutput: Swift.Sendable {
    /// The list of container recipes returned for the request.
    public var containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeSummaryList = containerRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListDistributionConfigurationsInput: Swift.Sendable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDistributionConfigurationsOutput: Swift.Sendable {
    /// The list of distributions.
    public var distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImageBuildVersionsInput: Swift.Sendable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * osVersion
    ///
    /// * platform
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.
    /// This member is required.
    public var imageVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imageVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imageVersionArn = imageVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// An image summary.
    public struct ImageSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the image.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The date on which Image Builder created this image.
        public var dateCreated: Swift.String?
        /// The time when deprecation occurs for an image resource. This can be a past or future date.
        public var deprecationTime: Foundation.Date?
        /// The origin of the base image that Image Builder used to build this image.
        public var imageSource: ImagebuilderClientTypes.ImageSource?
        /// Identifies the last runtime instance of the lifecycle policy to take action on the image.
        public var lifecycleExecutionId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version of the instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources that Image Builder produced when it created this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The owner of the image.
        public var owner: Swift.String?
        /// The image operating system platform, such as Linux or Windows.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags that apply to this image.
        public var tags: [Swift.String: Swift.String]?
        /// Specifies whether this image produces an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            dateCreated: Swift.String? = nil,
            deprecationTime: Foundation.Date? = nil,
            imageSource: ImagebuilderClientTypes.ImageSource? = nil,
            lifecycleExecutionId: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.deprecationTime = deprecationTime
            self.imageSource = imageSource
            self.lifecycleExecutionId = lifecycleExecutionId
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }
}

public struct ListImageBuildVersionsOutput: Swift.Sendable {
    /// The list of image build versions.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImagePackagesInput: Swift.Sendable {
    /// Filter results for the ListImagePackages request by the Image Build Version ARN
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// Represents a package installed on an Image Builder image.
    public struct ImagePackage: Swift.Sendable {
        /// The name of the package as reported to the operating system package manager.
        public var packageName: Swift.String?
        /// The version of the package as reported to the operating system package manager.
        public var packageVersion: Swift.String?

        public init(
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }
}

public struct ListImagePackagesOutput: Swift.Sendable {
    /// The list of Image Packages returned in the response.
    public var imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePackageList: [ImagebuilderClientTypes.ImagePackage]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePackageList = imagePackageList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImagePipelineImagesInput: Swift.Sendable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imagePipelineArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imagePipelineArn = imagePipelineArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListImagePipelineImagesOutput: Swift.Sendable {
    /// The list of images built by this pipeline.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImagePipelinesInput: Swift.Sendable {
    /// Use the following filters to streamline results:
    ///
    /// * description
    ///
    /// * distributionConfigurationArn
    ///
    /// * imageRecipeArn
    ///
    /// * infrastructureConfigurationArn
    ///
    /// * name
    ///
    /// * status
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListImagePipelinesOutput: Swift.Sendable {
    /// The list of image pipelines.
    public var imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineList = imagePipelineList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImageRecipesInput: Swift.Sendable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * parentImage
    ///
    /// * platform
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which image recipes you want to list. By default, this request will only show image recipes owned by your account. You can use this field to specify if you want to view image recipes owned by yourself, by Amazon, or those image recipes that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

extension ImagebuilderClientTypes {

    /// A summary of an image recipe.
    public struct ImageRecipeSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }
}

public struct ListImageRecipesOutput: Swift.Sendable {
    /// The list of image pipelines.
    public var imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeSummaryList = imageRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImagesInput: Swift.Sendable {
    /// Requests a list of images with a specific recipe name.
    public var byName: Swift.Bool?
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * osVersion
    ///
    /// * platform
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// Includes deprecated images in the response list.
    public var includeDeprecated: Swift.Bool?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which images you want to list. By default, this request will only show images owned by your account. You can use this field to specify if you want to view images owned by yourself, by Amazon, or those images that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        byName: Swift.Bool? = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        includeDeprecated: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

extension ImagebuilderClientTypes {

    /// The defining characteristics of a specific version of an Image Builder image.
    public struct ImageVersion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a specific version of an Image Builder image. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The date on which this specific version of the Image Builder image was created.
        public var dateCreated: Swift.String?
        /// The origin of the base image that Image Builder used to build this image.
        public var imageSource: ImagebuilderClientTypes.ImageSource?
        /// The name of this specific version of an Image Builder image.
        public var name: Swift.String?
        /// The operating system version of the Amazon EC2 build instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The owner of the image version.
        public var owner: Swift.String?
        /// The operating system platform of the image version, for example "Windows" or "Linux".
        public var platform: ImagebuilderClientTypes.Platform?
        /// Specifies whether this image produces an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// Details for a specific version of an Image Builder image. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            dateCreated: Swift.String? = nil,
            imageSource: ImagebuilderClientTypes.ImageSource? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.imageSource = imageSource
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }
    }
}

public struct ListImagesOutput: Swift.Sendable {
    /// The list of image semantic versions. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
    public var imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageVersionList: [ImagebuilderClientTypes.ImageVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageVersionList = imageVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListImageScanFindingAggregationsInput: Swift.Sendable {
    /// A filter name and value pair that is used to return a more specific list of results from a list operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public var filter: ImagebuilderClientTypes.Filter?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filter: ImagebuilderClientTypes.Filter? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// Contains vulnerability counts for a specific image pipeline.
    public struct ImagePipelineAggregation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the image pipeline for this aggregation.
        public var imagePipelineArn: Swift.String?
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified image pipeline.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?

        public init(
            imagePipelineArn: Swift.String? = nil,
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil
        )
        {
            self.imagePipelineArn = imagePipelineArn
            self.severityCounts = severityCounts
        }
    }
}

extension ImagebuilderClientTypes {

    /// Includes counts of image and pipeline resource findings by vulnerability.
    public struct VulnerabilityIdAggregation: Swift.Sendable {
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified vulnerability.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?
        /// The vulnerability Id for this set of counts.
        public var vulnerabilityId: Swift.String?

        public init(
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil,
            vulnerabilityId: Swift.String? = nil
        )
        {
            self.severityCounts = severityCounts
            self.vulnerabilityId = vulnerabilityId
        }
    }
}

extension ImagebuilderClientTypes {

    /// This returns exactly one type of aggregation, based on the filter that Image Builder applies in its API action.
    public struct ImageScanFindingAggregation: Swift.Sendable {
        /// Returns an object that contains severity counts based on an account ID.
        public var accountAggregation: ImagebuilderClientTypes.AccountAggregation?
        /// Returns an object that contains severity counts based on the Amazon Resource Name (ARN) for a specific image.
        public var imageAggregation: ImagebuilderClientTypes.ImageAggregation?
        /// Returns an object that contains severity counts based on an image pipeline ARN.
        public var imagePipelineAggregation: ImagebuilderClientTypes.ImagePipelineAggregation?
        /// Returns an object that contains severity counts based on vulnerability ID.
        public var vulnerabilityIdAggregation: ImagebuilderClientTypes.VulnerabilityIdAggregation?

        public init(
            accountAggregation: ImagebuilderClientTypes.AccountAggregation? = nil,
            imageAggregation: ImagebuilderClientTypes.ImageAggregation? = nil,
            imagePipelineAggregation: ImagebuilderClientTypes.ImagePipelineAggregation? = nil,
            vulnerabilityIdAggregation: ImagebuilderClientTypes.VulnerabilityIdAggregation? = nil
        )
        {
            self.accountAggregation = accountAggregation
            self.imageAggregation = imageAggregation
            self.imagePipelineAggregation = imagePipelineAggregation
            self.vulnerabilityIdAggregation = vulnerabilityIdAggregation
        }
    }
}

public struct ListImageScanFindingAggregationsOutput: Swift.Sendable {
    /// The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to accountId. Aggregation types
    ///
    /// * accountId
    ///
    /// * imageBuildVersionArn
    ///
    /// * imagePipelineArn
    ///
    /// * vulnerabilityId
    ///
    ///
    /// Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.
    public var aggregationType: Swift.String?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// An array of image scan finding aggregations that match the filter criteria.
    public var responses: [ImagebuilderClientTypes.ImageScanFindingAggregation]?

    public init(
        aggregationType: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        responses: [ImagebuilderClientTypes.ImageScanFindingAggregation]? = nil
    )
    {
        self.aggregationType = aggregationType
        self.nextToken = nextToken
        self.requestId = requestId
        self.responses = responses
    }
}

extension ImagebuilderClientTypes {

    /// A name value pair that Image Builder applies to streamline results from the vulnerability scan findings list action.
    public struct ImageScanFindingsFilter: Swift.Sendable {
        /// The name of the image scan finding filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct ListImageScanFindingsInput: Swift.Sendable {
    /// An array of name value pairs that you can use to filter your results. You can use the following filters to streamline results:
    ///
    /// * imageBuildVersionArn
    ///
    /// * imagePipelineArn
    ///
    /// * vulnerabilityId
    ///
    /// * severity
    ///
    ///
    /// If you don't request a filter, then all findings in your account are listed.
    public var filters: [ImagebuilderClientTypes.ImageScanFindingsFilter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.ImageScanFindingsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// Information about the factors that influenced the score that Amazon Inspector assigned for a finding.
    public struct InspectorScoreDetails: Swift.Sendable {
        /// An object that contains details about an adjustment that Amazon Inspector made to the CVSS score for the finding.
        public var adjustedCvss: ImagebuilderClientTypes.CvssScoreDetails?

        public init(
            adjustedCvss: ImagebuilderClientTypes.CvssScoreDetails? = nil
        )
        {
            self.adjustedCvss = adjustedCvss
        }
    }
}

extension ImagebuilderClientTypes {

    /// Information about a vulnerable package that Amazon Inspector identifies in a finding.
    public struct VulnerablePackage: Swift.Sendable {
        /// The architecture of the vulnerable package.
        public var arch: Swift.String?
        /// The epoch of the vulnerable package.
        public var epoch: Swift.Int?
        /// The file path of the vulnerable package.
        public var filePath: Swift.String?
        /// The version of the package that contains the vulnerability fix.
        public var fixedInVersion: Swift.String?
        /// The name of the vulnerable package.
        public var name: Swift.String?
        /// The package manager of the vulnerable package.
        public var packageManager: Swift.String?
        /// The release of the vulnerable package.
        public var release: Swift.String?
        /// The code to run in your environment to update packages with a fix available.
        public var remediation: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the vulnerable package.
        public var version: Swift.String?

        public init(
            arch: Swift.String? = nil,
            epoch: Swift.Int? = nil,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Swift.String? = nil,
            release: Swift.String? = nil,
            remediation: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }
}

extension ImagebuilderClientTypes {

    /// Information about package vulnerability findings.
    public struct PackageVulnerabilityDetails: Swift.Sendable {
        /// CVSS scores for one or more vulnerabilities that Amazon Inspector identified for a package.
        public var cvss: [ImagebuilderClientTypes.CvssScore]?
        /// Links to web pages that contain details about the vulnerabilities that Amazon Inspector identified for the package.
        public var referenceUrls: [Swift.String]?
        /// Vulnerabilities that are often related to the findings for the package.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        public var source: Swift.String?
        /// A link to the source of the vulnerability information.
        public var sourceUrl: Swift.String?
        /// The date and time when this vulnerability was first added to the vendor's database.
        public var vendorCreatedAt: Foundation.Date?
        /// The severity that the vendor assigned to this vulnerability type.
        public var vendorSeverity: Swift.String?
        /// The date and time when the vendor last updated this vulnerability in their database.
        public var vendorUpdatedAt: Foundation.Date?
        /// A unique identifier for this vulnerability.
        /// This member is required.
        public var vulnerabilityId: Swift.String?
        /// The packages that this vulnerability impacts.
        public var vulnerablePackages: [ImagebuilderClientTypes.VulnerablePackage]?

        public init(
            cvss: [ImagebuilderClientTypes.CvssScore]? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: Foundation.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: Foundation.Date? = nil,
            vulnerabilityId: Swift.String? = nil,
            vulnerablePackages: [ImagebuilderClientTypes.VulnerablePackage]? = nil
        )
        {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }
    }
}

extension ImagebuilderClientTypes {

    /// Details about the recommended course of action to remediate the finding.
    public struct RemediationRecommendation: Swift.Sendable {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// A link to more information about the recommended remediation for this vulnerability.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }
}

extension ImagebuilderClientTypes {

    /// Information about how to remediate a finding.
    public struct Remediation: Swift.Sendable {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public var recommendation: ImagebuilderClientTypes.RemediationRecommendation?

        public init(
            recommendation: ImagebuilderClientTypes.RemediationRecommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains details about a vulnerability scan finding.
    public struct ImageScanFinding: Swift.Sendable {
        /// The Amazon Web Services account ID that's associated with the finding.
        public var awsAccountId: Swift.String?
        /// The description of the finding.
        public var description: Swift.String?
        /// The date and time when the finding was first observed.
        public var firstObservedAt: Foundation.Date?
        /// Details about whether a fix is available for any of the packages that are identified in the finding through a version update.
        public var fixAvailable: Swift.String?
        /// The Amazon Resource Name (ARN) of the image build version that's associated with the finding.
        public var imageBuildVersionArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the image pipeline that's associated with the finding.
        public var imagePipelineArn: Swift.String?
        /// The score that Amazon Inspector assigned for the finding.
        public var inspectorScore: Swift.Double?
        /// An object that contains details of the Amazon Inspector score.
        public var inspectorScoreDetails: ImagebuilderClientTypes.InspectorScoreDetails?
        /// An object that contains the details of a package vulnerability finding.
        public var packageVulnerabilityDetails: ImagebuilderClientTypes.PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate the finding.
        public var remediation: ImagebuilderClientTypes.Remediation?
        /// The severity of the finding.
        public var severity: Swift.String?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of the finding. Image Builder looks for findings of the type PACKAGE_VULNERABILITY that apply to output images, and excludes other types.
        public var type: Swift.String?
        /// The timestamp when the finding was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            firstObservedAt: Foundation.Date? = nil,
            fixAvailable: Swift.String? = nil,
            imageBuildVersionArn: Swift.String? = nil,
            imagePipelineArn: Swift.String? = nil,
            inspectorScore: Swift.Double? = nil,
            inspectorScoreDetails: ImagebuilderClientTypes.InspectorScoreDetails? = nil,
            packageVulnerabilityDetails: ImagebuilderClientTypes.PackageVulnerabilityDetails? = nil,
            remediation: ImagebuilderClientTypes.Remediation? = nil,
            severity: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.imageBuildVersionArn = imageBuildVersionArn
            self.imagePipelineArn = imagePipelineArn
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListImageScanFindingsOutput: Swift.Sendable {
    /// The image scan findings for your account that meet your request filter criteria.
    public var findings: [ImagebuilderClientTypes.ImageScanFinding]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        findings: [ImagebuilderClientTypes.ImageScanFinding]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListInfrastructureConfigurationsInput: Swift.Sendable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// The infrastructure used when building Amazon EC2 AMIs.
    public struct InfrastructureConfigurationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The instance placement settings that define where the instances that are launched from your image will run.
        public var placement: ImagebuilderClientTypes.Placement?
        /// The tags attached to the image created by Image Builder.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            name: Swift.String? = nil,
            placement: ImagebuilderClientTypes.Placement? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.placement = placement
            self.resourceTags = resourceTags
            self.tags = tags
        }
    }
}

public struct ListInfrastructureConfigurationsOutput: Swift.Sendable {
    /// The list of infrastructure configurations.
    public var infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

public struct ListLifecycleExecutionResourcesInput: Swift.Sendable {
    /// Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    /// This member is required.
    public var lifecycleExecutionId: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// You can leave this empty to get a list of Image Builder resources that were identified for lifecycle actions. To get a list of associated resources that are impacted for an individual resource (the parent), specify its Amazon Resource Name (ARN). Associated resources are produced from your image and distributed when you run a build, such as AMIs or container images stored in ECR repositories.
    public var parentResourceId: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parentResourceId: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parentResourceId = parentResourceId
    }
}

extension ImagebuilderClientTypes {

    public enum LifecycleExecutionResourceActionName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case delete
        case deprecate
        case disable
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleExecutionResourceActionName] {
            return [
                .available,
                .delete,
                .deprecate,
                .disable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .delete: return "DELETE"
            case .deprecate: return "DEPRECATE"
            case .disable: return "DISABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// The lifecycle policy action that was identified for the impacted resource.
    public struct LifecycleExecutionResourceAction: Swift.Sendable {
        /// The name of the resource that was identified for a lifecycle policy action.
        public var name: ImagebuilderClientTypes.LifecycleExecutionResourceActionName?
        /// The reason why the lifecycle policy action is taken.
        public var reason: Swift.String?

        public init(
            name: ImagebuilderClientTypes.LifecycleExecutionResourceActionName? = nil,
            reason: Swift.String? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }
}

extension ImagebuilderClientTypes {

    public enum LifecycleExecutionResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case skipped
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleExecutionResourceStatus] {
            return [
                .failed,
                .inProgress,
                .skipped,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .skipped: return "SKIPPED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains the state of an impacted resource that the runtime instance of the lifecycle policy identified for action.
    public struct LifecycleExecutionResourceState: Swift.Sendable {
        /// Messaging that clarifies the reason for the assigned status.
        public var reason: Swift.String?
        /// The runtime status of the lifecycle action taken for the impacted resource.
        public var status: ImagebuilderClientTypes.LifecycleExecutionResourceStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.LifecycleExecutionResourceStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains the state of an impacted snapshot resource that the runtime instance of the lifecycle policy identified for action.
    public struct LifecycleExecutionSnapshotResource: Swift.Sendable {
        /// Identifies the impacted snapshot resource.
        public var snapshotId: Swift.String?
        /// The runtime status of the lifecycle action taken for the snapshot.
        public var state: ImagebuilderClientTypes.LifecycleExecutionResourceState?

        public init(
            snapshotId: Swift.String? = nil,
            state: ImagebuilderClientTypes.LifecycleExecutionResourceState? = nil
        )
        {
            self.snapshotId = snapshotId
            self.state = state
        }
    }
}

extension ImagebuilderClientTypes {

    /// Contains details for a resource that the runtime instance of the lifecycle policy identified for action.
    public struct LifecycleExecutionResource: Swift.Sendable {
        /// The account that owns the impacted resource.
        public var accountId: Swift.String?
        /// The action to take for the identified resource.
        public var action: ImagebuilderClientTypes.LifecycleExecutionResourceAction?
        /// The ending timestamp from the lifecycle action that was applied to the resource.
        public var endTime: Foundation.Date?
        /// For an impacted container image, this identifies a list of URIs for associated container images distributed to ECR repositories.
        public var imageUris: [Swift.String]?
        /// The Amazon Web Services Region where the lifecycle execution resource is stored.
        public var region: Swift.String?
        /// Identifies the impacted resource. The resource ID depends on the type of resource, as follows.
        ///
        /// * Image Builder image resources: Amazon Resource Name (ARN)
        ///
        /// * Distributed AMIs: AMI ID
        ///
        /// * Container images distributed to an ECR repository: image URI or SHA Digest
        public var resourceId: Swift.String?
        /// A list of associated resource snapshots for the impacted resource if it’s an AMI.
        public var snapshots: [ImagebuilderClientTypes.LifecycleExecutionSnapshotResource]?
        /// The starting timestamp from the lifecycle action that was applied to the resource.
        public var startTime: Foundation.Date?
        /// The runtime state for the lifecycle execution.
        public var state: ImagebuilderClientTypes.LifecycleExecutionResourceState?

        public init(
            accountId: Swift.String? = nil,
            action: ImagebuilderClientTypes.LifecycleExecutionResourceAction? = nil,
            endTime: Foundation.Date? = nil,
            imageUris: [Swift.String]? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            snapshots: [ImagebuilderClientTypes.LifecycleExecutionSnapshotResource]? = nil,
            startTime: Foundation.Date? = nil,
            state: ImagebuilderClientTypes.LifecycleExecutionResourceState? = nil
        )
        {
            self.accountId = accountId
            self.action = action
            self.endTime = endTime
            self.imageUris = imageUris
            self.region = region
            self.resourceId = resourceId
            self.snapshots = snapshots
            self.startTime = startTime
            self.state = state
        }
    }
}

public struct ListLifecycleExecutionResourcesOutput: Swift.Sendable {
    /// Runtime details for the specified runtime instance of the lifecycle policy.
    public var lifecycleExecutionId: Swift.String?
    /// The current state of the lifecycle runtime instance.
    public var lifecycleExecutionState: ImagebuilderClientTypes.LifecycleExecutionState?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// A list of resources that were identified for lifecycle actions.
    public var resources: [ImagebuilderClientTypes.LifecycleExecutionResource]?

    public init(
        lifecycleExecutionId: Swift.String? = nil,
        lifecycleExecutionState: ImagebuilderClientTypes.LifecycleExecutionState? = nil,
        nextToken: Swift.String? = nil,
        resources: [ImagebuilderClientTypes.LifecycleExecutionResource]? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
        self.lifecycleExecutionState = lifecycleExecutionState
        self.nextToken = nextToken
        self.resources = resources
    }
}

public struct ListLifecycleExecutionsInput: Swift.Sendable {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which to get a list of lifecycle runtime instances.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListLifecycleExecutionsOutput: Swift.Sendable {
    /// A list of lifecycle runtime instances for the specified resource.
    public var lifecycleExecutions: [ImagebuilderClientTypes.LifecycleExecution]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        lifecycleExecutions: [ImagebuilderClientTypes.LifecycleExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lifecycleExecutions = lifecycleExecutions
        self.nextToken = nextToken
    }
}

public struct ListLifecyclePoliciesInput: Swift.Sendable {
    /// Streamline results based on one of the following values: Name, Status.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// Contains a summary of lifecycle policy resources.
    public struct LifecyclePolicySummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the lifecycle policy summary resource.
        public var arn: Swift.String?
        /// The timestamp when Image Builder created the lifecycle policy resource.
        public var dateCreated: Foundation.Date?
        /// The timestamp for the last time Image Builder ran the lifecycle policy.
        public var dateLastRun: Foundation.Date?
        /// The timestamp when Image Builder updated the lifecycle policy resource.
        public var dateUpdated: Foundation.Date?
        /// Optional description for the lifecycle policy.
        public var description: Swift.String?
        /// The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to run the lifecycle policy.
        public var executionRole: Swift.String?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The type of resources the lifecycle policy targets.
        public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
        /// The lifecycle policy resource status.
        public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?
        /// To help manage your lifecycle policy resources, you can assign your own metadata to each resource in the form of tags. Each tag consists of a key and an optional value, both of which you define.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Foundation.Date? = nil,
            dateLastRun: Foundation.Date? = nil,
            dateUpdated: Foundation.Date? = nil,
            description: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
            status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }
    }
}

public struct ListLifecyclePoliciesOutput: Swift.Sendable {
    /// A list of lifecycle policies in your Amazon Web Services account that meet the criteria specified in the request.
    public var lifecyclePolicySummaryList: [ImagebuilderClientTypes.LifecyclePolicySummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        lifecyclePolicySummaryList: [ImagebuilderClientTypes.LifecyclePolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lifecyclePolicySummaryList = lifecyclePolicySummaryList
        self.nextToken = nextToken
    }
}

/// The specified parameter is invalid. Review the available parameters for the API request.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWaitingWorkflowStepsInput: Swift.Sendable {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// Contains runtime details for an instance of a workflow that ran for the associated image build version.
    public struct WorkflowStepExecution: Swift.Sendable {
        /// The name of the step action.
        public var action: Swift.String?
        /// The Amazon Resource Name (ARN) of the image build version that ran the workflow.
        public var imageBuildVersionArn: Swift.String?
        /// The name of the workflow step.
        public var name: Swift.String?
        /// The timestamp when the workflow step started.
        public var startTime: Swift.String?
        /// Uniquely identifies the workflow step that ran for the associated image build version.
        public var stepExecutionId: Swift.String?
        /// The ARN of the workflow resource that ran.
        public var workflowBuildVersionArn: Swift.String?
        /// Uniquely identifies the runtime instance of the workflow that contains the workflow step that ran for the associated image build version.
        public var workflowExecutionId: Swift.String?

        public init(
            action: Swift.String? = nil,
            imageBuildVersionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            startTime: Swift.String? = nil,
            stepExecutionId: Swift.String? = nil,
            workflowBuildVersionArn: Swift.String? = nil,
            workflowExecutionId: Swift.String? = nil
        )
        {
            self.action = action
            self.imageBuildVersionArn = imageBuildVersionArn
            self.name = name
            self.startTime = startTime
            self.stepExecutionId = stepExecutionId
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }
    }
}

public struct ListWaitingWorkflowStepsOutput: Swift.Sendable {
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// An array of the workflow steps that are waiting for action in your Amazon Web Services account.
    public var steps: [ImagebuilderClientTypes.WorkflowStepExecution]?

    public init(
        nextToken: Swift.String? = nil,
        steps: [ImagebuilderClientTypes.WorkflowStepExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.steps = steps
    }
}

public struct ListWorkflowBuildVersionsInput: Swift.Sendable {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow resource for which to get a list of build versions.
    /// This member is required.
    public var workflowVersionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowVersionArn = workflowVersionArn
    }
}

extension ImagebuilderClientTypes {

    /// Contains metadata about the workflow resource.
    public struct WorkflowSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public var arn: Swift.String?
        /// The change description for the current version of the workflow resource.
        public var changeDescription: Swift.String?
        /// The original creation date of the workflow resource.
        public var dateCreated: Swift.String?
        /// Describes the workflow.
        public var description: Swift.String?
        /// The name of the workflow.
        public var name: Swift.String?
        /// The owner of the workflow resource.
        public var owner: Swift.String?
        /// Describes the current state of the workflow resource.
        public var state: ImagebuilderClientTypes.WorkflowState?
        /// Contains a list of tags that are defined for the workflow.
        public var tags: [Swift.String: Swift.String]?
        /// The image creation stage that this workflow applies to. Image Builder currently supports build and test stage workflows.
        public var type: ImagebuilderClientTypes.WorkflowType?
        /// The version of the workflow.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            state: ImagebuilderClientTypes.WorkflowState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: ImagebuilderClientTypes.WorkflowType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }
}

public struct ListWorkflowBuildVersionsOutput: Swift.Sendable {
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// A list that contains metadata for the workflow builds that have run for the workflow resource specified in the request.
    public var workflowSummaryList: [ImagebuilderClientTypes.WorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaryList: [ImagebuilderClientTypes.WorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaryList = workflowSummaryList
    }
}

public struct ListWorkflowExecutionsInput: Swift.Sendable {
    /// List all workflow runtime instances for the specified image build version resource ARN.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ImagebuilderClientTypes {

    /// Metadata that includes details and status from this runtime instance of the workflow.
    public struct WorkflowExecutionMetadata: Swift.Sendable {
        /// The timestamp when this runtime instance of the workflow finished.
        public var endTime: Swift.String?
        /// The runtime output message from the workflow, if applicable.
        public var message: Swift.String?
        /// The name of the test group that included the test workflow resource at runtime.
        public var parallelGroup: Swift.String?
        /// The timestamp when the runtime instance of this workflow started.
        public var startTime: Swift.String?
        /// The current runtime status for this workflow.
        public var status: ImagebuilderClientTypes.WorkflowExecutionStatus?
        /// The total number of steps in the workflow. This should equal the sum of the step counts for steps that succeeded, were skipped, and failed.
        public var totalStepCount: Swift.Int
        /// A runtime count for the number of steps in the workflow that failed.
        public var totalStepsFailed: Swift.Int
        /// A runtime count for the number of steps in the workflow that were skipped.
        public var totalStepsSkipped: Swift.Int
        /// A runtime count for the number of steps in the workflow that ran successfully.
        public var totalStepsSucceeded: Swift.Int
        /// Indicates what type of workflow that Image Builder ran for this runtime instance of the workflow.
        public var type: ImagebuilderClientTypes.WorkflowType?
        /// The Amazon Resource Name (ARN) of the workflow resource build version that ran.
        public var workflowBuildVersionArn: Swift.String?
        /// Unique identifier that Image Builder assigns to keep track of runtime resources each time it runs a workflow.
        public var workflowExecutionId: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            message: Swift.String? = nil,
            parallelGroup: Swift.String? = nil,
            startTime: Swift.String? = nil,
            status: ImagebuilderClientTypes.WorkflowExecutionStatus? = nil,
            totalStepCount: Swift.Int = 0,
            totalStepsFailed: Swift.Int = 0,
            totalStepsSkipped: Swift.Int = 0,
            totalStepsSucceeded: Swift.Int = 0,
            type: ImagebuilderClientTypes.WorkflowType? = nil,
            workflowBuildVersionArn: Swift.String? = nil,
            workflowExecutionId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.message = message
            self.parallelGroup = parallelGroup
            self.startTime = startTime
            self.status = status
            self.totalStepCount = totalStepCount
            self.totalStepsFailed = totalStepsFailed
            self.totalStepsSkipped = totalStepsSkipped
            self.totalStepsSucceeded = totalStepsSucceeded
            self.type = type
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }
    }
}

public struct ListWorkflowExecutionsOutput: Swift.Sendable {
    /// The resource ARN of the image build version for which you requested a list of workflow runtime details.
    public var imageBuildVersionArn: Swift.String?
    /// The output message from the list action, if applicable.
    public var message: Swift.String?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// Contains an array of runtime details that represents each time a workflow ran for the requested image build version.
    public var workflowExecutions: [ImagebuilderClientTypes.WorkflowExecutionMetadata]?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        message: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        workflowExecutions: [ImagebuilderClientTypes.WorkflowExecutionMetadata]? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.message = message
        self.nextToken = nextToken
        self.requestId = requestId
        self.workflowExecutions = workflowExecutions
    }
}

public struct ListWorkflowsInput: Swift.Sendable {
    /// Specify all or part of the workflow name to streamline results.
    public var byName: Swift.Bool?
    /// Used to streamline search results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Used to get a list of workflow build version filtered by the identity of the creator.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        byName: Swift.Bool? = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

extension ImagebuilderClientTypes {

    /// Contains details about this version of the workflow.
    public struct WorkflowVersion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public var arn: Swift.String?
        /// The timestamp when Image Builder created the workflow version.
        public var dateCreated: Swift.String?
        /// Describes the workflow.
        public var description: Swift.String?
        /// The name of the workflow.
        public var name: Swift.String?
        /// The owner of the workflow resource.
        public var owner: Swift.String?
        /// The image creation stage that this workflow applies to. Image Builder currently supports build and test stage workflows.
        public var type: ImagebuilderClientTypes.WorkflowType?
        /// The semantic version of the workflow resource. The format includes three nodes: ...
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            type: ImagebuilderClientTypes.WorkflowType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.type = type
            self.version = version
        }
    }
}

public struct ListWorkflowsOutput: Swift.Sendable {
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// A list of workflow build versions that match the request criteria.
    public var workflowVersionList: [ImagebuilderClientTypes.WorkflowVersion]?

    public init(
        nextToken: Swift.String? = nil,
        workflowVersionList: [ImagebuilderClientTypes.WorkflowVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowVersionList = workflowVersionList
    }
}

public struct ListWorkflowStepExecutionsInput: Swift.Sendable {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    /// This member is required.
    public var workflowExecutionId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowExecutionId = workflowExecutionId
    }
}

extension ImagebuilderClientTypes {

    /// Runtime details and status for the workflow step.
    public struct WorkflowStepMetadata: Swift.Sendable {
        /// The step action name.
        public var action: Swift.String?
        /// Description of the workflow step.
        public var description: Swift.String?
        /// The timestamp when the workflow step finished.
        public var endTime: Swift.String?
        /// Input parameters that Image Builder provides for the workflow step.
        public var inputs: Swift.String?
        /// Detailed output message that the workflow step provides at runtime.
        public var message: Swift.String?
        /// The name of the workflow step.
        public var name: Swift.String?
        /// The file names that the workflow step created as output for this runtime instance of the workflow.
        public var outputs: Swift.String?
        /// Reports on the rollback status of the step, if applicable.
        public var rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus?
        /// The timestamp when the workflow step started.
        public var startTime: Swift.String?
        /// Runtime status for the workflow step.
        public var status: ImagebuilderClientTypes.WorkflowStepExecutionStatus?
        /// A unique identifier for the workflow step, assigned at runtime.
        public var stepExecutionId: Swift.String?

        public init(
            action: Swift.String? = nil,
            description: Swift.String? = nil,
            endTime: Swift.String? = nil,
            inputs: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            outputs: Swift.String? = nil,
            rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus? = nil,
            startTime: Swift.String? = nil,
            status: ImagebuilderClientTypes.WorkflowStepExecutionStatus? = nil,
            stepExecutionId: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.endTime = endTime
            self.inputs = inputs
            self.message = message
            self.name = name
            self.outputs = outputs
            self.rollbackStatus = rollbackStatus
            self.startTime = startTime
            self.status = status
            self.stepExecutionId = stepExecutionId
        }
    }
}

public struct ListWorkflowStepExecutionsOutput: Swift.Sendable {
    /// The image build version resource ARN that's associated with the specified runtime instance of the workflow.
    public var imageBuildVersionArn: Swift.String?
    /// The output message from the list action, if applicable.
    public var message: Swift.String?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// Contains an array of runtime details that represents each step in this runtime instance of the workflow.
    public var steps: [ImagebuilderClientTypes.WorkflowStepMetadata]?
    /// The build version ARN for the Image Builder workflow resource that defines the steps for this runtime instance of the workflow.
    public var workflowBuildVersionArn: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    public var workflowExecutionId: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        message: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        steps: [ImagebuilderClientTypes.WorkflowStepMetadata]? = nil,
        workflowBuildVersionArn: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.message = message
        self.nextToken = nextToken
        self.requestId = requestId
        self.steps = steps
        self.workflowBuildVersionArn = workflowBuildVersionArn
        self.workflowExecutionId = workflowExecutionId
    }
}

/// The value that you provided for the specified parameter is invalid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutComponentPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the component that this policy should be applied to.
    /// This member is required.
    public var componentArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        componentArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.policy = policy
    }
}

public struct PutComponentPolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the component that this policy was applied to.
    public var componentArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.requestId = requestId
    }
}

public struct PutContainerRecipePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.
    /// This member is required.
    public var containerRecipeArn: Swift.String?
    /// The policy to apply to the container recipe.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.policy = policy
    }
}

public struct PutContainerRecipePolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

public struct PutImagePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image that this policy should be applied to.
    /// This member is required.
    public var imageArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        imageArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.policy = policy
    }
}

public struct PutImagePolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

public struct PutImageRecipePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.
    /// This member is required.
    public var imageRecipeArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.policy = policy
    }
}

public struct PutImageRecipePolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    public enum WorkflowStepActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resume
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepActionType] {
            return [
                .resume,
                .stop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resume: return "RESUME"
            case .stop: return "STOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SendWorkflowStepActionInput: Swift.Sendable {
    /// The action for the image creation process to take while a workflow WaitForAction step waits for an asynchronous action to complete.
    /// This member is required.
    public var action: ImagebuilderClientTypes.WorkflowStepActionType?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image build version to send action for.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The reason why this action is sent.
    public var reason: Swift.String?
    /// Uniquely identifies the workflow step that sent the step action.
    /// This member is required.
    public var stepExecutionId: Swift.String?

    public init(
        action: ImagebuilderClientTypes.WorkflowStepActionType? = nil,
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        reason: Swift.String? = nil,
        stepExecutionId: Swift.String? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.reason = reason
        self.stepExecutionId = stepExecutionId
    }
}

public struct SendWorkflowStepActionOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image build version that received the action request.
    public var imageBuildVersionArn: Swift.String?
    /// The workflow step that sent the step action.
    public var stepExecutionId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        stepExecutionId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.stepExecutionId = stepExecutionId
    }
}

public struct StartImagePipelineExecutionInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
    }
}

public struct StartImagePipelineExecutionOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that the request created.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

extension ImagebuilderClientTypes {

    /// Additional rules to specify resources that should be exempt from ad-hoc lifecycle actions.
    public struct ResourceStateUpdateExclusionRules: Swift.Sendable {
        /// Defines criteria for AMIs that are excluded from lifecycle actions.
        public var amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis?

        public init(
            amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis? = nil
        )
        {
            self.amis = amis
        }
    }
}

extension ImagebuilderClientTypes {

    /// Specifies if the lifecycle policy should apply actions to selected resources.
    public struct ResourceStateUpdateIncludeResources: Swift.Sendable {
        /// Specifies whether the lifecycle action should apply to distributed AMIs
        public var amis: Swift.Bool
        /// Specifies whether the lifecycle action should apply to distributed containers.
        public var containers: Swift.Bool
        /// Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.
        public var snapshots: Swift.Bool

        public init(
            amis: Swift.Bool = false,
            containers: Swift.Bool = false,
            snapshots: Swift.Bool = false
        )
        {
            self.amis = amis
            self.containers = containers
            self.snapshots = snapshots
        }
    }
}

extension ImagebuilderClientTypes {

    public enum ResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deprecated
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .deleted,
                .deprecated,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ImagebuilderClientTypes {

    /// The current state of an impacted resource.
    public struct ResourceState: Swift.Sendable {
        /// Shows the current lifecycle policy action that was applied to an impacted resource.
        public var status: ImagebuilderClientTypes.ResourceStatus?

        public init(
            status: ImagebuilderClientTypes.ResourceStatus? = nil
        )
        {
            self.status = status
        }
    }
}

public struct StartResourceStateUpdateInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Skip action on the image resource and associated resources if specified exclusion rules are met.
    public var exclusionRules: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules?
    /// The name or Amazon Resource Name (ARN) of the IAM role that’s used to update image state.
    public var executionRole: Swift.String?
    /// A list of image resources to update state for.
    public var includeResources: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources?
    /// The ARN of the Image Builder resource that is updated. The state update might also impact associated resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Indicates the lifecycle action to take for this request.
    /// This member is required.
    public var state: ImagebuilderClientTypes.ResourceState?
    /// The timestamp that indicates when resources are updated by a lifecycle action.
    public var updateAt: Foundation.Date?

    public init(
        clientToken: Swift.String? = nil,
        exclusionRules: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules? = nil,
        executionRole: Swift.String? = nil,
        includeResources: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources? = nil,
        resourceArn: Swift.String? = nil,
        state: ImagebuilderClientTypes.ResourceState? = nil,
        updateAt: Foundation.Date? = nil
    )
    {
        self.clientToken = clientToken
        self.exclusionRules = exclusionRules
        self.executionRole = executionRole
        self.includeResources = includeResources
        self.resourceArn = resourceArn
        self.state = state
        self.updateAt = updateAt
    }
}

public struct StartResourceStateUpdateOutput: Swift.Sendable {
    /// Identifies the lifecycle runtime instance that started the resource state update.
    public var lifecycleExecutionId: Swift.String?
    /// The requested ARN of the Image Builder resource for the asynchronous update.
    public var resourceArn: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
        self.resourceArn = resourceArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDistributionConfigurationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.distributions = distributions
    }
}

public struct UpdateDistributionConfigurationOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

public struct UpdateImagePipelineInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container pipeline to update.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that Image Builder uses to configure and distribute images that this image pipeline has updated.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.
    public var executionRole: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images updated by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// Contains settings for vulnerability scans.
    public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that Image Builder uses to build images that this image pipeline has updated.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?
    /// Contains the workflows to run for the pipeline.
    public var workflows: [ImagebuilderClientTypes.WorkflowConfiguration]?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        executionRole: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil,
        workflows: [ImagebuilderClientTypes.WorkflowConfiguration]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.executionRole = executionRole
        self.imagePipelineArn = imagePipelineArn
        self.imageRecipeArn = imageRecipeArn
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.schedule = schedule
        self.status = status
        self.workflows = workflows
    }
}

public struct UpdateImagePipelineOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

public struct UpdateInfrastructureConfigurationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to update.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds use to launch EC2 build and test instances. For more information about instance metadata options, see one of the following links:
    ///
    /// * [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the Amazon EC2 User Guide for Linux instances.
    ///
    /// * [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html) in the Amazon EC2 Windows Guide for Windows instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The instance placement settings that define where the instances that are launched from your image will run.
    public var placement: ImagebuilderClientTypes.Placement?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String: Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
    public var snsTopicArn: Swift.String?
    /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
    public var subnetId: Swift.String?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        placement: ImagebuilderClientTypes.Placement? = nil,
        resourceTags: [Swift.String: Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.placement = placement
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

public struct UpdateInfrastructureConfigurationOutput: Swift.Sendable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

public struct UpdateLifecyclePolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Optional description for the lifecycle policy.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to update the lifecycle policy.
    /// This member is required.
    public var executionRole: Swift.String?
    /// The Amazon Resource Name (ARN) of the lifecycle policy resource.
    /// This member is required.
    public var lifecyclePolicyArn: Swift.String?
    /// The configuration details for a lifecycle policy resource.
    /// This member is required.
    public var policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
    /// Selection criteria for resources that the lifecycle policy applies to.
    /// This member is required.
    public var resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
    /// The type of image resource that the lifecycle policy applies to.
    /// This member is required.
    public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
    /// Indicates whether the lifecycle policy resource is enabled.
    public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        lifecyclePolicyArn: Swift.String? = nil,
        policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil,
        resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection? = nil,
        resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
        status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.executionRole = executionRole
        self.lifecyclePolicyArn = lifecyclePolicyArn
        self.policyDetails = policyDetails
        self.resourceSelection = resourceSelection
        self.resourceType = resourceType
        self.status = status
    }
}

public struct UpdateLifecyclePolicyOutput: Swift.Sendable {
    /// The ARN of the image lifecycle policy resource that was updated.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

extension CancelImageCreationInput {

    static func urlPathProvider(_ value: CancelImageCreationInput) -> Swift.String? {
        return "/CancelImageCreation"
    }
}

extension CancelLifecycleExecutionInput {

    static func urlPathProvider(_ value: CancelLifecycleExecutionInput) -> Swift.String? {
        return "/CancelLifecycleExecution"
    }
}

extension CreateComponentInput {

    static func urlPathProvider(_ value: CreateComponentInput) -> Swift.String? {
        return "/CreateComponent"
    }
}

extension CreateContainerRecipeInput {

    static func urlPathProvider(_ value: CreateContainerRecipeInput) -> Swift.String? {
        return "/CreateContainerRecipe"
    }
}

extension CreateDistributionConfigurationInput {

    static func urlPathProvider(_ value: CreateDistributionConfigurationInput) -> Swift.String? {
        return "/CreateDistributionConfiguration"
    }
}

extension CreateImageInput {

    static func urlPathProvider(_ value: CreateImageInput) -> Swift.String? {
        return "/CreateImage"
    }
}

extension CreateImagePipelineInput {

    static func urlPathProvider(_ value: CreateImagePipelineInput) -> Swift.String? {
        return "/CreateImagePipeline"
    }
}

extension CreateImageRecipeInput {

    static func urlPathProvider(_ value: CreateImageRecipeInput) -> Swift.String? {
        return "/CreateImageRecipe"
    }
}

extension CreateInfrastructureConfigurationInput {

    static func urlPathProvider(_ value: CreateInfrastructureConfigurationInput) -> Swift.String? {
        return "/CreateInfrastructureConfiguration"
    }
}

extension CreateLifecyclePolicyInput {

    static func urlPathProvider(_ value: CreateLifecyclePolicyInput) -> Swift.String? {
        return "/CreateLifecyclePolicy"
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/CreateWorkflow"
    }
}

extension DeleteComponentInput {

    static func urlPathProvider(_ value: DeleteComponentInput) -> Swift.String? {
        return "/DeleteComponent"
    }
}

extension DeleteComponentInput {

    static func queryItemProvider(_ value: DeleteComponentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let componentBuildVersionArn = value.componentBuildVersionArn else {
            let message = "Creating a URL Query Item failed. componentBuildVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let componentBuildVersionArnQueryItem = Smithy.URIQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
        items.append(componentBuildVersionArnQueryItem)
        return items
    }
}

extension DeleteContainerRecipeInput {

    static func urlPathProvider(_ value: DeleteContainerRecipeInput) -> Swift.String? {
        return "/DeleteContainerRecipe"
    }
}

extension DeleteContainerRecipeInput {

    static func queryItemProvider(_ value: DeleteContainerRecipeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let containerRecipeArn = value.containerRecipeArn else {
            let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let containerRecipeArnQueryItem = Smithy.URIQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
        items.append(containerRecipeArnQueryItem)
        return items
    }
}

extension DeleteDistributionConfigurationInput {

    static func urlPathProvider(_ value: DeleteDistributionConfigurationInput) -> Swift.String? {
        return "/DeleteDistributionConfiguration"
    }
}

extension DeleteDistributionConfigurationInput {

    static func queryItemProvider(_ value: DeleteDistributionConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let distributionConfigurationArn = value.distributionConfigurationArn else {
            let message = "Creating a URL Query Item failed. distributionConfigurationArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let distributionConfigurationArnQueryItem = Smithy.URIQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
        items.append(distributionConfigurationArnQueryItem)
        return items
    }
}

extension DeleteImageInput {

    static func urlPathProvider(_ value: DeleteImageInput) -> Swift.String? {
        return "/DeleteImage"
    }
}

extension DeleteImageInput {

    static func queryItemProvider(_ value: DeleteImageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imageBuildVersionArn = value.imageBuildVersionArn else {
            let message = "Creating a URL Query Item failed. imageBuildVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imageBuildVersionArnQueryItem = Smithy.URIQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
        items.append(imageBuildVersionArnQueryItem)
        return items
    }
}

extension DeleteImagePipelineInput {

    static func urlPathProvider(_ value: DeleteImagePipelineInput) -> Swift.String? {
        return "/DeleteImagePipeline"
    }
}

extension DeleteImagePipelineInput {

    static func queryItemProvider(_ value: DeleteImagePipelineInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imagePipelineArn = value.imagePipelineArn else {
            let message = "Creating a URL Query Item failed. imagePipelineArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imagePipelineArnQueryItem = Smithy.URIQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
        items.append(imagePipelineArnQueryItem)
        return items
    }
}

extension DeleteImageRecipeInput {

    static func urlPathProvider(_ value: DeleteImageRecipeInput) -> Swift.String? {
        return "/DeleteImageRecipe"
    }
}

extension DeleteImageRecipeInput {

    static func queryItemProvider(_ value: DeleteImageRecipeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imageRecipeArn = value.imageRecipeArn else {
            let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imageRecipeArnQueryItem = Smithy.URIQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
        items.append(imageRecipeArnQueryItem)
        return items
    }
}

extension DeleteInfrastructureConfigurationInput {

    static func urlPathProvider(_ value: DeleteInfrastructureConfigurationInput) -> Swift.String? {
        return "/DeleteInfrastructureConfiguration"
    }
}

extension DeleteInfrastructureConfigurationInput {

    static func queryItemProvider(_ value: DeleteInfrastructureConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let infrastructureConfigurationArn = value.infrastructureConfigurationArn else {
            let message = "Creating a URL Query Item failed. infrastructureConfigurationArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let infrastructureConfigurationArnQueryItem = Smithy.URIQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
        items.append(infrastructureConfigurationArnQueryItem)
        return items
    }
}

extension DeleteLifecyclePolicyInput {

    static func urlPathProvider(_ value: DeleteLifecyclePolicyInput) -> Swift.String? {
        return "/DeleteLifecyclePolicy"
    }
}

extension DeleteLifecyclePolicyInput {

    static func queryItemProvider(_ value: DeleteLifecyclePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lifecyclePolicyArn = value.lifecyclePolicyArn else {
            let message = "Creating a URL Query Item failed. lifecyclePolicyArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lifecyclePolicyArnQueryItem = Smithy.URIQueryItem(name: "lifecyclePolicyArn".urlPercentEncoding(), value: Swift.String(lifecyclePolicyArn).urlPercentEncoding())
        items.append(lifecyclePolicyArnQueryItem)
        return items
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        return "/DeleteWorkflow"
    }
}

extension DeleteWorkflowInput {

    static func queryItemProvider(_ value: DeleteWorkflowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let workflowBuildVersionArn = value.workflowBuildVersionArn else {
            let message = "Creating a URL Query Item failed. workflowBuildVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let workflowBuildVersionArnQueryItem = Smithy.URIQueryItem(name: "workflowBuildVersionArn".urlPercentEncoding(), value: Swift.String(workflowBuildVersionArn).urlPercentEncoding())
        items.append(workflowBuildVersionArnQueryItem)
        return items
    }
}

extension GetComponentInput {

    static func urlPathProvider(_ value: GetComponentInput) -> Swift.String? {
        return "/GetComponent"
    }
}

extension GetComponentInput {

    static func queryItemProvider(_ value: GetComponentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let componentBuildVersionArn = value.componentBuildVersionArn else {
            let message = "Creating a URL Query Item failed. componentBuildVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let componentBuildVersionArnQueryItem = Smithy.URIQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
        items.append(componentBuildVersionArnQueryItem)
        return items
    }
}

extension GetComponentPolicyInput {

    static func urlPathProvider(_ value: GetComponentPolicyInput) -> Swift.String? {
        return "/GetComponentPolicy"
    }
}

extension GetComponentPolicyInput {

    static func queryItemProvider(_ value: GetComponentPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let componentArn = value.componentArn else {
            let message = "Creating a URL Query Item failed. componentArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let componentArnQueryItem = Smithy.URIQueryItem(name: "componentArn".urlPercentEncoding(), value: Swift.String(componentArn).urlPercentEncoding())
        items.append(componentArnQueryItem)
        return items
    }
}

extension GetContainerRecipeInput {

    static func urlPathProvider(_ value: GetContainerRecipeInput) -> Swift.String? {
        return "/GetContainerRecipe"
    }
}

extension GetContainerRecipeInput {

    static func queryItemProvider(_ value: GetContainerRecipeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let containerRecipeArn = value.containerRecipeArn else {
            let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let containerRecipeArnQueryItem = Smithy.URIQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
        items.append(containerRecipeArnQueryItem)
        return items
    }
}

extension GetContainerRecipePolicyInput {

    static func urlPathProvider(_ value: GetContainerRecipePolicyInput) -> Swift.String? {
        return "/GetContainerRecipePolicy"
    }
}

extension GetContainerRecipePolicyInput {

    static func queryItemProvider(_ value: GetContainerRecipePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let containerRecipeArn = value.containerRecipeArn else {
            let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let containerRecipeArnQueryItem = Smithy.URIQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
        items.append(containerRecipeArnQueryItem)
        return items
    }
}

extension GetDistributionConfigurationInput {

    static func urlPathProvider(_ value: GetDistributionConfigurationInput) -> Swift.String? {
        return "/GetDistributionConfiguration"
    }
}

extension GetDistributionConfigurationInput {

    static func queryItemProvider(_ value: GetDistributionConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let distributionConfigurationArn = value.distributionConfigurationArn else {
            let message = "Creating a URL Query Item failed. distributionConfigurationArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let distributionConfigurationArnQueryItem = Smithy.URIQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
        items.append(distributionConfigurationArnQueryItem)
        return items
    }
}

extension GetImageInput {

    static func urlPathProvider(_ value: GetImageInput) -> Swift.String? {
        return "/GetImage"
    }
}

extension GetImageInput {

    static func queryItemProvider(_ value: GetImageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imageBuildVersionArn = value.imageBuildVersionArn else {
            let message = "Creating a URL Query Item failed. imageBuildVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imageBuildVersionArnQueryItem = Smithy.URIQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
        items.append(imageBuildVersionArnQueryItem)
        return items
    }
}

extension GetImagePipelineInput {

    static func urlPathProvider(_ value: GetImagePipelineInput) -> Swift.String? {
        return "/GetImagePipeline"
    }
}

extension GetImagePipelineInput {

    static func queryItemProvider(_ value: GetImagePipelineInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imagePipelineArn = value.imagePipelineArn else {
            let message = "Creating a URL Query Item failed. imagePipelineArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imagePipelineArnQueryItem = Smithy.URIQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
        items.append(imagePipelineArnQueryItem)
        return items
    }
}

extension GetImagePolicyInput {

    static func urlPathProvider(_ value: GetImagePolicyInput) -> Swift.String? {
        return "/GetImagePolicy"
    }
}

extension GetImagePolicyInput {

    static func queryItemProvider(_ value: GetImagePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imageArn = value.imageArn else {
            let message = "Creating a URL Query Item failed. imageArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imageArnQueryItem = Smithy.URIQueryItem(name: "imageArn".urlPercentEncoding(), value: Swift.String(imageArn).urlPercentEncoding())
        items.append(imageArnQueryItem)
        return items
    }
}

extension GetImageRecipeInput {

    static func urlPathProvider(_ value: GetImageRecipeInput) -> Swift.String? {
        return "/GetImageRecipe"
    }
}

extension GetImageRecipeInput {

    static func queryItemProvider(_ value: GetImageRecipeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imageRecipeArn = value.imageRecipeArn else {
            let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imageRecipeArnQueryItem = Smithy.URIQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
        items.append(imageRecipeArnQueryItem)
        return items
    }
}

extension GetImageRecipePolicyInput {

    static func urlPathProvider(_ value: GetImageRecipePolicyInput) -> Swift.String? {
        return "/GetImageRecipePolicy"
    }
}

extension GetImageRecipePolicyInput {

    static func queryItemProvider(_ value: GetImageRecipePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let imageRecipeArn = value.imageRecipeArn else {
            let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let imageRecipeArnQueryItem = Smithy.URIQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
        items.append(imageRecipeArnQueryItem)
        return items
    }
}

extension GetInfrastructureConfigurationInput {

    static func urlPathProvider(_ value: GetInfrastructureConfigurationInput) -> Swift.String? {
        return "/GetInfrastructureConfiguration"
    }
}

extension GetInfrastructureConfigurationInput {

    static func queryItemProvider(_ value: GetInfrastructureConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let infrastructureConfigurationArn = value.infrastructureConfigurationArn else {
            let message = "Creating a URL Query Item failed. infrastructureConfigurationArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let infrastructureConfigurationArnQueryItem = Smithy.URIQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
        items.append(infrastructureConfigurationArnQueryItem)
        return items
    }
}

extension GetLifecycleExecutionInput {

    static func urlPathProvider(_ value: GetLifecycleExecutionInput) -> Swift.String? {
        return "/GetLifecycleExecution"
    }
}

extension GetLifecycleExecutionInput {

    static func queryItemProvider(_ value: GetLifecycleExecutionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lifecycleExecutionId = value.lifecycleExecutionId else {
            let message = "Creating a URL Query Item failed. lifecycleExecutionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lifecycleExecutionIdQueryItem = Smithy.URIQueryItem(name: "lifecycleExecutionId".urlPercentEncoding(), value: Swift.String(lifecycleExecutionId).urlPercentEncoding())
        items.append(lifecycleExecutionIdQueryItem)
        return items
    }
}

extension GetLifecyclePolicyInput {

    static func urlPathProvider(_ value: GetLifecyclePolicyInput) -> Swift.String? {
        return "/GetLifecyclePolicy"
    }
}

extension GetLifecyclePolicyInput {

    static func queryItemProvider(_ value: GetLifecyclePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lifecyclePolicyArn = value.lifecyclePolicyArn else {
            let message = "Creating a URL Query Item failed. lifecyclePolicyArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lifecyclePolicyArnQueryItem = Smithy.URIQueryItem(name: "lifecyclePolicyArn".urlPercentEncoding(), value: Swift.String(lifecyclePolicyArn).urlPercentEncoding())
        items.append(lifecyclePolicyArnQueryItem)
        return items
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        return "/GetWorkflow"
    }
}

extension GetWorkflowInput {

    static func queryItemProvider(_ value: GetWorkflowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let workflowBuildVersionArn = value.workflowBuildVersionArn else {
            let message = "Creating a URL Query Item failed. workflowBuildVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let workflowBuildVersionArnQueryItem = Smithy.URIQueryItem(name: "workflowBuildVersionArn".urlPercentEncoding(), value: Swift.String(workflowBuildVersionArn).urlPercentEncoding())
        items.append(workflowBuildVersionArnQueryItem)
        return items
    }
}

extension GetWorkflowExecutionInput {

    static func urlPathProvider(_ value: GetWorkflowExecutionInput) -> Swift.String? {
        return "/GetWorkflowExecution"
    }
}

extension GetWorkflowExecutionInput {

    static func queryItemProvider(_ value: GetWorkflowExecutionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let workflowExecutionId = value.workflowExecutionId else {
            let message = "Creating a URL Query Item failed. workflowExecutionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let workflowExecutionIdQueryItem = Smithy.URIQueryItem(name: "workflowExecutionId".urlPercentEncoding(), value: Swift.String(workflowExecutionId).urlPercentEncoding())
        items.append(workflowExecutionIdQueryItem)
        return items
    }
}

extension GetWorkflowStepExecutionInput {

    static func urlPathProvider(_ value: GetWorkflowStepExecutionInput) -> Swift.String? {
        return "/GetWorkflowStepExecution"
    }
}

extension GetWorkflowStepExecutionInput {

    static func queryItemProvider(_ value: GetWorkflowStepExecutionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let stepExecutionId = value.stepExecutionId else {
            let message = "Creating a URL Query Item failed. stepExecutionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let stepExecutionIdQueryItem = Smithy.URIQueryItem(name: "stepExecutionId".urlPercentEncoding(), value: Swift.String(stepExecutionId).urlPercentEncoding())
        items.append(stepExecutionIdQueryItem)
        return items
    }
}

extension ImportComponentInput {

    static func urlPathProvider(_ value: ImportComponentInput) -> Swift.String? {
        return "/ImportComponent"
    }
}

extension ImportVmImageInput {

    static func urlPathProvider(_ value: ImportVmImageInput) -> Swift.String? {
        return "/ImportVmImage"
    }
}

extension ListComponentBuildVersionsInput {

    static func urlPathProvider(_ value: ListComponentBuildVersionsInput) -> Swift.String? {
        return "/ListComponentBuildVersions"
    }
}

extension ListComponentsInput {

    static func urlPathProvider(_ value: ListComponentsInput) -> Swift.String? {
        return "/ListComponents"
    }
}

extension ListContainerRecipesInput {

    static func urlPathProvider(_ value: ListContainerRecipesInput) -> Swift.String? {
        return "/ListContainerRecipes"
    }
}

extension ListDistributionConfigurationsInput {

    static func urlPathProvider(_ value: ListDistributionConfigurationsInput) -> Swift.String? {
        return "/ListDistributionConfigurations"
    }
}

extension ListImageBuildVersionsInput {

    static func urlPathProvider(_ value: ListImageBuildVersionsInput) -> Swift.String? {
        return "/ListImageBuildVersions"
    }
}

extension ListImagePackagesInput {

    static func urlPathProvider(_ value: ListImagePackagesInput) -> Swift.String? {
        return "/ListImagePackages"
    }
}

extension ListImagePipelineImagesInput {

    static func urlPathProvider(_ value: ListImagePipelineImagesInput) -> Swift.String? {
        return "/ListImagePipelineImages"
    }
}

extension ListImagePipelinesInput {

    static func urlPathProvider(_ value: ListImagePipelinesInput) -> Swift.String? {
        return "/ListImagePipelines"
    }
}

extension ListImageRecipesInput {

    static func urlPathProvider(_ value: ListImageRecipesInput) -> Swift.String? {
        return "/ListImageRecipes"
    }
}

extension ListImagesInput {

    static func urlPathProvider(_ value: ListImagesInput) -> Swift.String? {
        return "/ListImages"
    }
}

extension ListImageScanFindingAggregationsInput {

    static func urlPathProvider(_ value: ListImageScanFindingAggregationsInput) -> Swift.String? {
        return "/ListImageScanFindingAggregations"
    }
}

extension ListImageScanFindingsInput {

    static func urlPathProvider(_ value: ListImageScanFindingsInput) -> Swift.String? {
        return "/ListImageScanFindings"
    }
}

extension ListInfrastructureConfigurationsInput {

    static func urlPathProvider(_ value: ListInfrastructureConfigurationsInput) -> Swift.String? {
        return "/ListInfrastructureConfigurations"
    }
}

extension ListLifecycleExecutionResourcesInput {

    static func urlPathProvider(_ value: ListLifecycleExecutionResourcesInput) -> Swift.String? {
        return "/ListLifecycleExecutionResources"
    }
}

extension ListLifecycleExecutionsInput {

    static func urlPathProvider(_ value: ListLifecycleExecutionsInput) -> Swift.String? {
        return "/ListLifecycleExecutions"
    }
}

extension ListLifecyclePoliciesInput {

    static func urlPathProvider(_ value: ListLifecyclePoliciesInput) -> Swift.String? {
        return "/ListLifecyclePolicies"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWaitingWorkflowStepsInput {

    static func urlPathProvider(_ value: ListWaitingWorkflowStepsInput) -> Swift.String? {
        return "/ListWaitingWorkflowSteps"
    }
}

extension ListWorkflowBuildVersionsInput {

    static func urlPathProvider(_ value: ListWorkflowBuildVersionsInput) -> Swift.String? {
        return "/ListWorkflowBuildVersions"
    }
}

extension ListWorkflowExecutionsInput {

    static func urlPathProvider(_ value: ListWorkflowExecutionsInput) -> Swift.String? {
        return "/ListWorkflowExecutions"
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/ListWorkflows"
    }
}

extension ListWorkflowStepExecutionsInput {

    static func urlPathProvider(_ value: ListWorkflowStepExecutionsInput) -> Swift.String? {
        return "/ListWorkflowStepExecutions"
    }
}

extension PutComponentPolicyInput {

    static func urlPathProvider(_ value: PutComponentPolicyInput) -> Swift.String? {
        return "/PutComponentPolicy"
    }
}

extension PutContainerRecipePolicyInput {

    static func urlPathProvider(_ value: PutContainerRecipePolicyInput) -> Swift.String? {
        return "/PutContainerRecipePolicy"
    }
}

extension PutImagePolicyInput {

    static func urlPathProvider(_ value: PutImagePolicyInput) -> Swift.String? {
        return "/PutImagePolicy"
    }
}

extension PutImageRecipePolicyInput {

    static func urlPathProvider(_ value: PutImageRecipePolicyInput) -> Swift.String? {
        return "/PutImageRecipePolicy"
    }
}

extension SendWorkflowStepActionInput {

    static func urlPathProvider(_ value: SendWorkflowStepActionInput) -> Swift.String? {
        return "/SendWorkflowStepAction"
    }
}

extension StartImagePipelineExecutionInput {

    static func urlPathProvider(_ value: StartImagePipelineExecutionInput) -> Swift.String? {
        return "/StartImagePipelineExecution"
    }
}

extension StartResourceStateUpdateInput {

    static func urlPathProvider(_ value: StartResourceStateUpdateInput) -> Swift.String? {
        return "/StartResourceStateUpdate"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDistributionConfigurationInput {

    static func urlPathProvider(_ value: UpdateDistributionConfigurationInput) -> Swift.String? {
        return "/UpdateDistributionConfiguration"
    }
}

extension UpdateImagePipelineInput {

    static func urlPathProvider(_ value: UpdateImagePipelineInput) -> Swift.String? {
        return "/UpdateImagePipeline"
    }
}

extension UpdateInfrastructureConfigurationInput {

    static func urlPathProvider(_ value: UpdateInfrastructureConfigurationInput) -> Swift.String? {
        return "/UpdateInfrastructureConfiguration"
    }
}

extension UpdateLifecyclePolicyInput {

    static func urlPathProvider(_ value: UpdateLifecyclePolicyInput) -> Swift.String? {
        return "/UpdateLifecyclePolicy"
    }
}

extension CancelImageCreationInput {

    static func write(value: CancelImageCreationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["imageBuildVersionArn"].write(value.imageBuildVersionArn)
    }
}

extension CancelLifecycleExecutionInput {

    static func write(value: CancelLifecycleExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["lifecycleExecutionId"].write(value.lifecycleExecutionId)
    }
}

extension CreateComponentInput {

    static func write(value: CreateComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changeDescription"].write(value.changeDescription)
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["platform"].write(value.platform)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["supportedOsVersions"].writeList(value.supportedOsVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["uri"].write(value.uri)
    }
}

extension CreateContainerRecipeInput {

    static func write(value: CreateContainerRecipeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["components"].writeList(value.components, memberWritingClosure: ImagebuilderClientTypes.ComponentConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["containerType"].write(value.containerType)
        try writer["description"].write(value.description)
        try writer["dockerfileTemplateData"].write(value.dockerfileTemplateData)
        try writer["dockerfileTemplateUri"].write(value.dockerfileTemplateUri)
        try writer["imageOsVersionOverride"].write(value.imageOsVersionOverride)
        try writer["instanceConfiguration"].write(value.instanceConfiguration, with: ImagebuilderClientTypes.InstanceConfiguration.write(value:to:))
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["parentImage"].write(value.parentImage)
        try writer["platformOverride"].write(value.platformOverride)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetRepository"].write(value.targetRepository, with: ImagebuilderClientTypes.TargetContainerRepository.write(value:to:))
        try writer["workingDirectory"].write(value.workingDirectory)
    }
}

extension CreateDistributionConfigurationInput {

    static func write(value: CreateDistributionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["distributions"].writeList(value.distributions, memberWritingClosure: ImagebuilderClientTypes.Distribution.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateImageInput {

    static func write(value: CreateImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["containerRecipeArn"].write(value.containerRecipeArn)
        try writer["distributionConfigurationArn"].write(value.distributionConfigurationArn)
        try writer["enhancedImageMetadataEnabled"].write(value.enhancedImageMetadataEnabled)
        try writer["executionRole"].write(value.executionRole)
        try writer["imageRecipeArn"].write(value.imageRecipeArn)
        try writer["imageScanningConfiguration"].write(value.imageScanningConfiguration, with: ImagebuilderClientTypes.ImageScanningConfiguration.write(value:to:))
        try writer["imageTestsConfiguration"].write(value.imageTestsConfiguration, with: ImagebuilderClientTypes.ImageTestsConfiguration.write(value:to:))
        try writer["infrastructureConfigurationArn"].write(value.infrastructureConfigurationArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workflows"].writeList(value.workflows, memberWritingClosure: ImagebuilderClientTypes.WorkflowConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateImagePipelineInput {

    static func write(value: CreateImagePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["containerRecipeArn"].write(value.containerRecipeArn)
        try writer["description"].write(value.description)
        try writer["distributionConfigurationArn"].write(value.distributionConfigurationArn)
        try writer["enhancedImageMetadataEnabled"].write(value.enhancedImageMetadataEnabled)
        try writer["executionRole"].write(value.executionRole)
        try writer["imageRecipeArn"].write(value.imageRecipeArn)
        try writer["imageScanningConfiguration"].write(value.imageScanningConfiguration, with: ImagebuilderClientTypes.ImageScanningConfiguration.write(value:to:))
        try writer["imageTestsConfiguration"].write(value.imageTestsConfiguration, with: ImagebuilderClientTypes.ImageTestsConfiguration.write(value:to:))
        try writer["infrastructureConfigurationArn"].write(value.infrastructureConfigurationArn)
        try writer["name"].write(value.name)
        try writer["schedule"].write(value.schedule, with: ImagebuilderClientTypes.Schedule.write(value:to:))
        try writer["status"].write(value.status)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workflows"].writeList(value.workflows, memberWritingClosure: ImagebuilderClientTypes.WorkflowConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateImageRecipeInput {

    static func write(value: CreateImageRecipeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalInstanceConfiguration"].write(value.additionalInstanceConfiguration, with: ImagebuilderClientTypes.AdditionalInstanceConfiguration.write(value:to:))
        try writer["blockDeviceMappings"].writeList(value.blockDeviceMappings, memberWritingClosure: ImagebuilderClientTypes.InstanceBlockDeviceMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["components"].writeList(value.components, memberWritingClosure: ImagebuilderClientTypes.ComponentConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parentImage"].write(value.parentImage)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workingDirectory"].write(value.workingDirectory)
    }
}

extension CreateInfrastructureConfigurationInput {

    static func write(value: CreateInfrastructureConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["instanceMetadataOptions"].write(value.instanceMetadataOptions, with: ImagebuilderClientTypes.InstanceMetadataOptions.write(value:to:))
        try writer["instanceProfileName"].write(value.instanceProfileName)
        try writer["instanceTypes"].writeList(value.instanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["keyPair"].write(value.keyPair)
        try writer["logging"].write(value.logging, with: ImagebuilderClientTypes.Logging.write(value:to:))
        try writer["name"].write(value.name)
        try writer["placement"].write(value.placement, with: ImagebuilderClientTypes.Placement.write(value:to:))
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["snsTopicArn"].write(value.snsTopicArn)
        try writer["subnetId"].write(value.subnetId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["terminateInstanceOnFailure"].write(value.terminateInstanceOnFailure)
    }
}

extension CreateLifecyclePolicyInput {

    static func write(value: CreateLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["executionRole"].write(value.executionRole)
        try writer["name"].write(value.name)
        try writer["policyDetails"].writeList(value.policyDetails, memberWritingClosure: ImagebuilderClientTypes.LifecyclePolicyDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceSelection"].write(value.resourceSelection, with: ImagebuilderClientTypes.LifecyclePolicyResourceSelection.write(value:to:))
        try writer["resourceType"].write(value.resourceType)
        try writer["status"].write(value.status)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateWorkflowInput {

    static func write(value: CreateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changeDescription"].write(value.changeDescription)
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
        try writer["uri"].write(value.uri)
    }
}

extension ImportComponentInput {

    static func write(value: ImportComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["changeDescription"].write(value.changeDescription)
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
        try writer["description"].write(value.description)
        try writer["format"].write(value.format)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["platform"].write(value.platform)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
        try writer["uri"].write(value.uri)
    }
}

extension ImportVmImageInput {

    static func write(value: ImportVmImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["osVersion"].write(value.osVersion)
        try writer["platform"].write(value.platform)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vmImportTaskId"].write(value.vmImportTaskId)
    }
}

extension ListComponentBuildVersionsInput {

    static func write(value: ListComponentBuildVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentVersionArn"].write(value.componentVersionArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListComponentsInput {

    static func write(value: ListComponentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byName"].write(value.byName)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owner"].write(value.owner)
    }
}

extension ListContainerRecipesInput {

    static func write(value: ListContainerRecipesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owner"].write(value.owner)
    }
}

extension ListDistributionConfigurationsInput {

    static func write(value: ListDistributionConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImageBuildVersionsInput {

    static func write(value: ListImageBuildVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["imageVersionArn"].write(value.imageVersionArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImagePackagesInput {

    static func write(value: ListImagePackagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageBuildVersionArn"].write(value.imageBuildVersionArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImagePipelineImagesInput {

    static func write(value: ListImagePipelineImagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["imagePipelineArn"].write(value.imagePipelineArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImagePipelinesInput {

    static func write(value: ListImagePipelinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImageRecipesInput {

    static func write(value: ListImageRecipesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owner"].write(value.owner)
    }
}

extension ListImagesInput {

    static func write(value: ListImagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byName"].write(value.byName)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["includeDeprecated"].write(value.includeDeprecated)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owner"].write(value.owner)
    }
}

extension ListImageScanFindingAggregationsInput {

    static func write(value: ListImageScanFindingAggregationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: ImagebuilderClientTypes.Filter.write(value:to:))
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListImageScanFindingsInput {

    static func write(value: ListImageScanFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.ImageScanFindingsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListInfrastructureConfigurationsInput {

    static func write(value: ListInfrastructureConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListLifecycleExecutionResourcesInput {

    static func write(value: ListLifecycleExecutionResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lifecycleExecutionId"].write(value.lifecycleExecutionId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["parentResourceId"].write(value.parentResourceId)
    }
}

extension ListLifecycleExecutionsInput {

    static func write(value: ListLifecycleExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension ListLifecyclePoliciesInput {

    static func write(value: ListLifecyclePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWaitingWorkflowStepsInput {

    static func write(value: ListWaitingWorkflowStepsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorkflowBuildVersionsInput {

    static func write(value: ListWorkflowBuildVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["workflowVersionArn"].write(value.workflowVersionArn)
    }
}

extension ListWorkflowExecutionsInput {

    static func write(value: ListWorkflowExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageBuildVersionArn"].write(value.imageBuildVersionArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorkflowsInput {

    static func write(value: ListWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byName"].write(value.byName)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ImagebuilderClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owner"].write(value.owner)
    }
}

extension ListWorkflowStepExecutionsInput {

    static func write(value: ListWorkflowStepExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["workflowExecutionId"].write(value.workflowExecutionId)
    }
}

extension PutComponentPolicyInput {

    static func write(value: PutComponentPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentArn"].write(value.componentArn)
        try writer["policy"].write(value.policy)
    }
}

extension PutContainerRecipePolicyInput {

    static func write(value: PutContainerRecipePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerRecipeArn"].write(value.containerRecipeArn)
        try writer["policy"].write(value.policy)
    }
}

extension PutImagePolicyInput {

    static func write(value: PutImagePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageArn"].write(value.imageArn)
        try writer["policy"].write(value.policy)
    }
}

extension PutImageRecipePolicyInput {

    static func write(value: PutImageRecipePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageRecipeArn"].write(value.imageRecipeArn)
        try writer["policy"].write(value.policy)
    }
}

extension SendWorkflowStepActionInput {

    static func write(value: SendWorkflowStepActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["clientToken"].write(value.clientToken)
        try writer["imageBuildVersionArn"].write(value.imageBuildVersionArn)
        try writer["reason"].write(value.reason)
        try writer["stepExecutionId"].write(value.stepExecutionId)
    }
}

extension StartImagePipelineExecutionInput {

    static func write(value: StartImagePipelineExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["imagePipelineArn"].write(value.imagePipelineArn)
    }
}

extension StartResourceStateUpdateInput {

    static func write(value: StartResourceStateUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["exclusionRules"].write(value.exclusionRules, with: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules.write(value:to:))
        try writer["executionRole"].write(value.executionRole)
        try writer["includeResources"].write(value.includeResources, with: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources.write(value:to:))
        try writer["resourceArn"].write(value.resourceArn)
        try writer["state"].write(value.state, with: ImagebuilderClientTypes.ResourceState.write(value:to:))
        try writer["updateAt"].writeTimestamp(value.updateAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDistributionConfigurationInput {

    static func write(value: UpdateDistributionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["distributionConfigurationArn"].write(value.distributionConfigurationArn)
        try writer["distributions"].writeList(value.distributions, memberWritingClosure: ImagebuilderClientTypes.Distribution.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateImagePipelineInput {

    static func write(value: UpdateImagePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["containerRecipeArn"].write(value.containerRecipeArn)
        try writer["description"].write(value.description)
        try writer["distributionConfigurationArn"].write(value.distributionConfigurationArn)
        try writer["enhancedImageMetadataEnabled"].write(value.enhancedImageMetadataEnabled)
        try writer["executionRole"].write(value.executionRole)
        try writer["imagePipelineArn"].write(value.imagePipelineArn)
        try writer["imageRecipeArn"].write(value.imageRecipeArn)
        try writer["imageScanningConfiguration"].write(value.imageScanningConfiguration, with: ImagebuilderClientTypes.ImageScanningConfiguration.write(value:to:))
        try writer["imageTestsConfiguration"].write(value.imageTestsConfiguration, with: ImagebuilderClientTypes.ImageTestsConfiguration.write(value:to:))
        try writer["infrastructureConfigurationArn"].write(value.infrastructureConfigurationArn)
        try writer["schedule"].write(value.schedule, with: ImagebuilderClientTypes.Schedule.write(value:to:))
        try writer["status"].write(value.status)
        try writer["workflows"].writeList(value.workflows, memberWritingClosure: ImagebuilderClientTypes.WorkflowConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateInfrastructureConfigurationInput {

    static func write(value: UpdateInfrastructureConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["infrastructureConfigurationArn"].write(value.infrastructureConfigurationArn)
        try writer["instanceMetadataOptions"].write(value.instanceMetadataOptions, with: ImagebuilderClientTypes.InstanceMetadataOptions.write(value:to:))
        try writer["instanceProfileName"].write(value.instanceProfileName)
        try writer["instanceTypes"].writeList(value.instanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["keyPair"].write(value.keyPair)
        try writer["logging"].write(value.logging, with: ImagebuilderClientTypes.Logging.write(value:to:))
        try writer["placement"].write(value.placement, with: ImagebuilderClientTypes.Placement.write(value:to:))
        try writer["resourceTags"].writeMap(value.resourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["snsTopicArn"].write(value.snsTopicArn)
        try writer["subnetId"].write(value.subnetId)
        try writer["terminateInstanceOnFailure"].write(value.terminateInstanceOnFailure)
    }
}

extension UpdateLifecyclePolicyInput {

    static func write(value: UpdateLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["executionRole"].write(value.executionRole)
        try writer["lifecyclePolicyArn"].write(value.lifecyclePolicyArn)
        try writer["policyDetails"].writeList(value.policyDetails, memberWritingClosure: ImagebuilderClientTypes.LifecyclePolicyDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceSelection"].write(value.resourceSelection, with: ImagebuilderClientTypes.LifecyclePolicyResourceSelection.write(value:to:))
        try writer["resourceType"].write(value.resourceType)
        try writer["status"].write(value.status)
    }
}

extension CancelImageCreationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelImageCreationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelImageCreationOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CancelLifecycleExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelLifecycleExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelLifecycleExecutionOutput()
        value.lifecycleExecutionId = try reader["lifecycleExecutionId"].readIfPresent()
        return value
    }
}

extension CreateComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateComponentOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.componentBuildVersionArn = try reader["componentBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateContainerRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContainerRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContainerRecipeOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.containerRecipeArn = try reader["containerRecipeArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateDistributionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDistributionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDistributionConfigurationOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.distributionConfigurationArn = try reader["distributionConfigurationArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImageOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateImagePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImagePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImagePipelineOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imagePipelineArn = try reader["imagePipelineArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateImageRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImageRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImageRecipeOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imageRecipeArn = try reader["imageRecipeArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateInfrastructureConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInfrastructureConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInfrastructureConfigurationOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.infrastructureConfigurationArn = try reader["infrastructureConfigurationArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension CreateLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLifecyclePolicyOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.lifecyclePolicyArn = try reader["lifecyclePolicyArn"].readIfPresent()
        return value
    }
}

extension CreateWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        return value
    }
}

extension DeleteComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteComponentOutput()
        value.componentBuildVersionArn = try reader["componentBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteContainerRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContainerRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteContainerRecipeOutput()
        value.containerRecipeArn = try reader["containerRecipeArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteDistributionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDistributionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDistributionConfigurationOutput()
        value.distributionConfigurationArn = try reader["distributionConfigurationArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteImageOutput()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteImagePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImagePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteImagePipelineOutput()
        value.imagePipelineArn = try reader["imagePipelineArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteImageRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImageRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteImageRecipeOutput()
        value.imageRecipeArn = try reader["imageRecipeArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteInfrastructureConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInfrastructureConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInfrastructureConfigurationOutput()
        value.infrastructureConfigurationArn = try reader["infrastructureConfigurationArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension DeleteLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLifecyclePolicyOutput()
        value.lifecyclePolicyArn = try reader["lifecyclePolicyArn"].readIfPresent()
        return value
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkflowOutput()
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        return value
    }
}

extension GetComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComponentOutput()
        value.component = try reader["component"].readIfPresent(with: ImagebuilderClientTypes.Component.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetComponentPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComponentPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComponentPolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetContainerRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContainerRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContainerRecipeOutput()
        value.containerRecipe = try reader["containerRecipe"].readIfPresent(with: ImagebuilderClientTypes.ContainerRecipe.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetContainerRecipePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContainerRecipePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContainerRecipePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetDistributionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDistributionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDistributionConfigurationOutput()
        value.distributionConfiguration = try reader["distributionConfiguration"].readIfPresent(with: ImagebuilderClientTypes.DistributionConfiguration.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImageOutput()
        value.image = try reader["image"].readIfPresent(with: ImagebuilderClientTypes.Image.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetImagePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImagePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImagePipelineOutput()
        value.imagePipeline = try reader["imagePipeline"].readIfPresent(with: ImagebuilderClientTypes.ImagePipeline.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetImagePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImagePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImagePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetImageRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImageRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImageRecipeOutput()
        value.imageRecipe = try reader["imageRecipe"].readIfPresent(with: ImagebuilderClientTypes.ImageRecipe.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetImageRecipePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImageRecipePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImageRecipePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetInfrastructureConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInfrastructureConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInfrastructureConfigurationOutput()
        value.infrastructureConfiguration = try reader["infrastructureConfiguration"].readIfPresent(with: ImagebuilderClientTypes.InfrastructureConfiguration.read(from:))
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension GetLifecycleExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLifecycleExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLifecycleExecutionOutput()
        value.lifecycleExecution = try reader["lifecycleExecution"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecution.read(from:))
        return value
    }
}

extension GetLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLifecyclePolicyOutput()
        value.lifecyclePolicy = try reader["lifecyclePolicy"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicy.read(from:))
        return value
    }
}

extension GetWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowOutput()
        value.workflow = try reader["workflow"].readIfPresent(with: ImagebuilderClientTypes.Workflow.read(from:))
        return value
    }
}

extension GetWorkflowExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowExecutionOutput()
        value.endTime = try reader["endTime"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.parallelGroup = try reader["parallelGroup"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.totalStepCount = try reader["totalStepCount"].readIfPresent() ?? 0
        value.totalStepsFailed = try reader["totalStepsFailed"].readIfPresent() ?? 0
        value.totalStepsSkipped = try reader["totalStepsSkipped"].readIfPresent() ?? 0
        value.totalStepsSucceeded = try reader["totalStepsSucceeded"].readIfPresent() ?? 0
        value.type = try reader["type"].readIfPresent()
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        value.workflowExecutionId = try reader["workflowExecutionId"].readIfPresent()
        return value
    }
}

extension GetWorkflowStepExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowStepExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowStepExecutionOutput()
        value.action = try reader["action"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.inputs = try reader["inputs"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.onFailure = try reader["onFailure"].readIfPresent()
        value.outputs = try reader["outputs"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        value.rollbackStatus = try reader["rollbackStatus"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.stepExecutionId = try reader["stepExecutionId"].readIfPresent()
        value.timeoutSeconds = try reader["timeoutSeconds"].readIfPresent()
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        value.workflowExecutionId = try reader["workflowExecutionId"].readIfPresent()
        return value
    }
}

extension ImportComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportComponentOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.componentBuildVersionArn = try reader["componentBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ImportVmImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportVmImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportVmImageOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imageArn = try reader["imageArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListComponentBuildVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentBuildVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentBuildVersionsOutput()
        value.componentSummaryList = try reader["componentSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ComponentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentsOutput()
        value.componentVersionList = try reader["componentVersionList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ComponentVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListContainerRecipesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContainerRecipesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContainerRecipesOutput()
        value.containerRecipeSummaryList = try reader["containerRecipeSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ContainerRecipeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListDistributionConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionConfigurationsOutput()
        value.distributionConfigurationSummaryList = try reader["distributionConfigurationSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.DistributionConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImageBuildVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImageBuildVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImageBuildVersionsOutput()
        value.imageSummaryList = try reader["imageSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImagePackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImagePackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImagePackagesOutput()
        value.imagePackageList = try reader["imagePackageList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImagePackage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImagePipelineImagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImagePipelineImagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImagePipelineImagesOutput()
        value.imageSummaryList = try reader["imageSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImagePipelinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImagePipelinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImagePipelinesOutput()
        value.imagePipelineList = try reader["imagePipelineList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImagePipeline.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImageRecipesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImageRecipesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImageRecipesOutput()
        value.imageRecipeSummaryList = try reader["imageRecipeSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImageRecipeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImagesOutput()
        value.imageVersionList = try reader["imageVersionList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImageVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListImageScanFindingAggregationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImageScanFindingAggregationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImageScanFindingAggregationsOutput()
        value.aggregationType = try reader["aggregationType"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        value.responses = try reader["responses"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImageScanFindingAggregation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListImageScanFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImageScanFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImageScanFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ImageScanFinding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListInfrastructureConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInfrastructureConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInfrastructureConfigurationsOutput()
        value.infrastructureConfigurationSummaryList = try reader["infrastructureConfigurationSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.InfrastructureConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension ListLifecycleExecutionResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLifecycleExecutionResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLifecycleExecutionResourcesOutput()
        value.lifecycleExecutionId = try reader["lifecycleExecutionId"].readIfPresent()
        value.lifecycleExecutionState = try reader["lifecycleExecutionState"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecutionState.read(from:))
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LifecycleExecutionResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListLifecycleExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLifecycleExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLifecycleExecutionsOutput()
        value.lifecycleExecutions = try reader["lifecycleExecutions"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LifecycleExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLifecyclePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLifecyclePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLifecyclePoliciesOutput()
        value.lifecyclePolicySummaryList = try reader["lifecyclePolicySummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LifecyclePolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWaitingWorkflowStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWaitingWorkflowStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWaitingWorkflowStepsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowStepExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowBuildVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowBuildVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowBuildVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workflowSummaryList = try reader["workflowSummaryList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowExecutionsOutput()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        value.workflowExecutions = try reader["workflowExecutions"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowExecutionMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workflowVersionList = try reader["workflowVersionList"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowStepExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowStepExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowStepExecutionsOutput()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowStepMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        value.workflowExecutionId = try reader["workflowExecutionId"].readIfPresent()
        return value
    }
}

extension PutComponentPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutComponentPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutComponentPolicyOutput()
        value.componentArn = try reader["componentArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension PutContainerRecipePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutContainerRecipePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutContainerRecipePolicyOutput()
        value.containerRecipeArn = try reader["containerRecipeArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension PutImagePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutImagePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutImagePolicyOutput()
        value.imageArn = try reader["imageArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension PutImageRecipePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutImageRecipePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutImageRecipePolicyOutput()
        value.imageRecipeArn = try reader["imageRecipeArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension SendWorkflowStepActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendWorkflowStepActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendWorkflowStepActionOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.stepExecutionId = try reader["stepExecutionId"].readIfPresent()
        return value
    }
}

extension StartImagePipelineExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImagePipelineExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImagePipelineExecutionOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension StartResourceStateUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartResourceStateUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartResourceStateUpdateOutput()
        value.lifecycleExecutionId = try reader["lifecycleExecutionId"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDistributionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDistributionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDistributionConfigurationOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.distributionConfigurationArn = try reader["distributionConfigurationArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension UpdateImagePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateImagePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateImagePipelineOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.imagePipelineArn = try reader["imagePipelineArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension UpdateInfrastructureConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInfrastructureConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInfrastructureConfigurationOutput()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.infrastructureConfigurationArn = try reader["infrastructureConfigurationArn"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        return value
    }
}

extension UpdateLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLifecyclePolicyOutput()
        value.lifecyclePolicyArn = try reader["lifecyclePolicyArn"].readIfPresent()
        return value
    }
}

enum CancelImageCreationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelLifecycleExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidVersionNumberException": return try InvalidVersionNumberException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContainerRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidVersionNumberException": return try InvalidVersionNumberException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDistributionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImagePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImageRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidVersionNumberException": return try InvalidVersionNumberException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInfrastructureConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidVersionNumberException": return try InvalidVersionNumberException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContainerRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDistributionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImagePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImageRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInfrastructureConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceDependencyException": return try ResourceDependencyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComponentPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContainerRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContainerRecipePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDistributionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImagePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImagePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImageRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImageRecipePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInfrastructureConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLifecycleExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowStepExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidVersionNumberException": return try InvalidVersionNumberException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportVmImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentBuildVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContainerRecipesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImageBuildVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImagePackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImagePipelineImagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImagePipelinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImageRecipesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImageScanFindingAggregationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImageScanFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInfrastructureConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLifecycleExecutionResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLifecycleExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLifecyclePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWaitingWorkflowStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowBuildVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowStepExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutComponentPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutContainerRecipePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutImagePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutImageRecipePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendWorkflowStepActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImagePipelineExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartResourceStateUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDistributionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateImagePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInfrastructureConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallRateLimitExceededException": return try CallRateLimitExceededException.makeError(baseError: baseError)
            case "ClientException": return try ClientException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InvalidParameterCombinationException": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CallRateLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CallRateLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CallRateLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotentParameterMismatchException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IdempotentParameterMismatchException {
        let reader = baseError.errorBodyReader
        var value = IdempotentParameterMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ClientException {
        let reader = baseError.errorBodyReader
        var value = ClientException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterCombinationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterCombinationException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterCombinationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidVersionNumberException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidVersionNumberException {
        let reader = baseError.errorBodyReader
        var value = InvalidVersionNumberException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceDependencyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceDependencyException {
        let reader = baseError.errorBodyReader
        var value = ResourceDependencyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidPaginationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ImagebuilderClientTypes.Component {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Component {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Component()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.changeDescription = try reader["changeDescription"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.supportedOsVersions = try reader["supportedOsVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.ComponentState.read(from:))
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ComponentParameterDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owner = try reader["owner"].readIfPresent()
        value.data = try reader["data"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.encrypted = try reader["encrypted"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.publisher = try reader["publisher"].readIfPresent()
        value.obfuscate = try reader["obfuscate"].readIfPresent() ?? false
        return value
    }
}

extension ImagebuilderClientTypes.ComponentParameterDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ComponentParameterDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ComponentParameterDetail()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.defaultValue = try reader["defaultValue"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ComponentState {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ComponentState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ComponentState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ContainerRecipe {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ContainerRecipe {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ContainerRecipe()
        value.arn = try reader["arn"].readIfPresent()
        value.containerType = try reader["containerType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.components = try reader["components"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ComponentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceConfiguration = try reader["instanceConfiguration"].readIfPresent(with: ImagebuilderClientTypes.InstanceConfiguration.read(from:))
        value.dockerfileTemplateData = try reader["dockerfileTemplateData"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.encrypted = try reader["encrypted"].readIfPresent()
        value.parentImage = try reader["parentImage"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workingDirectory = try reader["workingDirectory"].readIfPresent()
        value.targetRepository = try reader["targetRepository"].readIfPresent(with: ImagebuilderClientTypes.TargetContainerRepository.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.TargetContainerRepository {

    static func write(value: ImagebuilderClientTypes.TargetContainerRepository?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryName"].write(value.repositoryName)
        try writer["service"].write(value.service)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.TargetContainerRepository {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.TargetContainerRepository()
        value.service = try reader["service"].readIfPresent() ?? .sdkUnknown("")
        value.repositoryName = try reader["repositoryName"].readIfPresent() ?? ""
        return value
    }
}

extension ImagebuilderClientTypes.InstanceConfiguration {

    static func write(value: ImagebuilderClientTypes.InstanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockDeviceMappings"].writeList(value.blockDeviceMappings, memberWritingClosure: ImagebuilderClientTypes.InstanceBlockDeviceMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["image"].write(value.image)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.InstanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.InstanceConfiguration()
        value.image = try reader["image"].readIfPresent()
        value.blockDeviceMappings = try reader["blockDeviceMappings"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.InstanceBlockDeviceMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.InstanceBlockDeviceMapping {

    static func write(value: ImagebuilderClientTypes.InstanceBlockDeviceMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deviceName"].write(value.deviceName)
        try writer["ebs"].write(value.ebs, with: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification.write(value:to:))
        try writer["noDevice"].write(value.noDevice)
        try writer["virtualName"].write(value.virtualName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.InstanceBlockDeviceMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.InstanceBlockDeviceMapping()
        value.deviceName = try reader["deviceName"].readIfPresent()
        value.ebs = try reader["ebs"].readIfPresent(with: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification.read(from:))
        value.virtualName = try reader["virtualName"].readIfPresent()
        value.noDevice = try reader["noDevice"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification {

    static func write(value: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteOnTermination"].write(value.deleteOnTermination)
        try writer["encrypted"].write(value.encrypted)
        try writer["iops"].write(value.iops)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["snapshotId"].write(value.snapshotId)
        try writer["throughput"].write(value.throughput)
        try writer["volumeSize"].write(value.volumeSize)
        try writer["volumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification()
        value.encrypted = try reader["encrypted"].readIfPresent()
        value.deleteOnTermination = try reader["deleteOnTermination"].readIfPresent()
        value.iops = try reader["iops"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.snapshotId = try reader["snapshotId"].readIfPresent()
        value.volumeSize = try reader["volumeSize"].readIfPresent()
        value.volumeType = try reader["volumeType"].readIfPresent()
        value.throughput = try reader["throughput"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ComponentConfiguration {

    static func write(value: ImagebuilderClientTypes.ComponentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentArn"].write(value.componentArn)
        try writer["parameters"].writeList(value.parameters, memberWritingClosure: ImagebuilderClientTypes.ComponentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ComponentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ComponentConfiguration()
        value.componentArn = try reader["componentArn"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ComponentParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.ComponentParameter {

    static func write(value: ImagebuilderClientTypes.ComponentParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ComponentParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ComponentParameter()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ImagebuilderClientTypes.DistributionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.DistributionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.DistributionConfiguration()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.distributions = try reader["distributions"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.Distribution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 0
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.dateUpdated = try reader["dateUpdated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.Distribution {

    static func write(value: ImagebuilderClientTypes.Distribution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amiDistributionConfiguration"].write(value.amiDistributionConfiguration, with: ImagebuilderClientTypes.AmiDistributionConfiguration.write(value:to:))
        try writer["containerDistributionConfiguration"].write(value.containerDistributionConfiguration, with: ImagebuilderClientTypes.ContainerDistributionConfiguration.write(value:to:))
        try writer["fastLaunchConfigurations"].writeList(value.fastLaunchConfigurations, memberWritingClosure: ImagebuilderClientTypes.FastLaunchConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["launchTemplateConfigurations"].writeList(value.launchTemplateConfigurations, memberWritingClosure: ImagebuilderClientTypes.LaunchTemplateConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["licenseConfigurationArns"].writeList(value.licenseConfigurationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["region"].write(value.region)
        try writer["s3ExportConfiguration"].write(value.s3ExportConfiguration, with: ImagebuilderClientTypes.S3ExportConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Distribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Distribution()
        value.region = try reader["region"].readIfPresent() ?? ""
        value.amiDistributionConfiguration = try reader["amiDistributionConfiguration"].readIfPresent(with: ImagebuilderClientTypes.AmiDistributionConfiguration.read(from:))
        value.containerDistributionConfiguration = try reader["containerDistributionConfiguration"].readIfPresent(with: ImagebuilderClientTypes.ContainerDistributionConfiguration.read(from:))
        value.licenseConfigurationArns = try reader["licenseConfigurationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.launchTemplateConfigurations = try reader["launchTemplateConfigurations"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LaunchTemplateConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.s3ExportConfiguration = try reader["s3ExportConfiguration"].readIfPresent(with: ImagebuilderClientTypes.S3ExportConfiguration.read(from:))
        value.fastLaunchConfigurations = try reader["fastLaunchConfigurations"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.FastLaunchConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.FastLaunchConfiguration {

    static func write(value: ImagebuilderClientTypes.FastLaunchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["enabled"].write(value.enabled)
        try writer["launchTemplate"].write(value.launchTemplate, with: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification.write(value:to:))
        try writer["maxParallelLaunches"].write(value.maxParallelLaunches)
        try writer["snapshotConfiguration"].write(value.snapshotConfiguration, with: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.FastLaunchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.FastLaunchConfiguration()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.snapshotConfiguration = try reader["snapshotConfiguration"].readIfPresent(with: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration.read(from:))
        value.maxParallelLaunches = try reader["maxParallelLaunches"].readIfPresent()
        value.launchTemplate = try reader["launchTemplate"].readIfPresent(with: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification.read(from:))
        value.accountId = try reader["accountId"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification {

    static func write(value: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["launchTemplateId"].write(value.launchTemplateId)
        try writer["launchTemplateName"].write(value.launchTemplateName)
        try writer["launchTemplateVersion"].write(value.launchTemplateVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification()
        value.launchTemplateId = try reader["launchTemplateId"].readIfPresent()
        value.launchTemplateName = try reader["launchTemplateName"].readIfPresent()
        value.launchTemplateVersion = try reader["launchTemplateVersion"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.FastLaunchSnapshotConfiguration {

    static func write(value: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetResourceCount"].write(value.targetResourceCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.FastLaunchSnapshotConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.FastLaunchSnapshotConfiguration()
        value.targetResourceCount = try reader["targetResourceCount"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.S3ExportConfiguration {

    static func write(value: ImagebuilderClientTypes.S3ExportConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["diskImageFormat"].write(value.diskImageFormat)
        try writer["roleName"].write(value.roleName)
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3Prefix"].write(value.s3Prefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.S3ExportConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.S3ExportConfiguration()
        value.roleName = try reader["roleName"].readIfPresent() ?? ""
        value.diskImageFormat = try reader["diskImageFormat"].readIfPresent() ?? .sdkUnknown("")
        value.s3Bucket = try reader["s3Bucket"].readIfPresent() ?? ""
        value.s3Prefix = try reader["s3Prefix"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.LaunchTemplateConfiguration {

    static func write(value: ImagebuilderClientTypes.LaunchTemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["launchTemplateId"].write(value.launchTemplateId)
        try writer["setDefaultVersion"].write(value.setDefaultVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LaunchTemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LaunchTemplateConfiguration()
        value.launchTemplateId = try reader["launchTemplateId"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent()
        value.setDefaultVersion = try reader["setDefaultVersion"].readIfPresent() ?? false
        return value
    }
}

extension ImagebuilderClientTypes.ContainerDistributionConfiguration {

    static func write(value: ImagebuilderClientTypes.ContainerDistributionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerTags"].writeList(value.containerTags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["targetRepository"].write(value.targetRepository, with: ImagebuilderClientTypes.TargetContainerRepository.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ContainerDistributionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ContainerDistributionConfiguration()
        value.description = try reader["description"].readIfPresent()
        value.containerTags = try reader["containerTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetRepository = try reader["targetRepository"].readIfPresent(with: ImagebuilderClientTypes.TargetContainerRepository.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.AmiDistributionConfiguration {

    static func write(value: ImagebuilderClientTypes.AmiDistributionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amiTags"].writeMap(value.amiTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["launchPermission"].write(value.launchPermission, with: ImagebuilderClientTypes.LaunchPermissionConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["targetAccountIds"].writeList(value.targetAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.AmiDistributionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.AmiDistributionConfiguration()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targetAccountIds = try reader["targetAccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.amiTags = try reader["amiTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.launchPermission = try reader["launchPermission"].readIfPresent(with: ImagebuilderClientTypes.LaunchPermissionConfiguration.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.LaunchPermissionConfiguration {

    static func write(value: ImagebuilderClientTypes.LaunchPermissionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["organizationArns"].writeList(value.organizationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["organizationalUnitArns"].writeList(value.organizationalUnitArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userGroups"].writeList(value.userGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LaunchPermissionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LaunchPermissionConfiguration()
        value.userIds = try reader["userIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userGroups = try reader["userGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationArns = try reader["organizationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationalUnitArns = try reader["organizationalUnitArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.Image {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Image {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Image()
        value.arn = try reader["arn"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.enhancedImageMetadataEnabled = try reader["enhancedImageMetadataEnabled"].readIfPresent()
        value.osVersion = try reader["osVersion"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.ImageState.read(from:))
        value.imageRecipe = try reader["imageRecipe"].readIfPresent(with: ImagebuilderClientTypes.ImageRecipe.read(from:))
        value.containerRecipe = try reader["containerRecipe"].readIfPresent(with: ImagebuilderClientTypes.ContainerRecipe.read(from:))
        value.sourcePipelineName = try reader["sourcePipelineName"].readIfPresent()
        value.sourcePipelineArn = try reader["sourcePipelineArn"].readIfPresent()
        value.infrastructureConfiguration = try reader["infrastructureConfiguration"].readIfPresent(with: ImagebuilderClientTypes.InfrastructureConfiguration.read(from:))
        value.distributionConfiguration = try reader["distributionConfiguration"].readIfPresent(with: ImagebuilderClientTypes.DistributionConfiguration.read(from:))
        value.imageTestsConfiguration = try reader["imageTestsConfiguration"].readIfPresent(with: ImagebuilderClientTypes.ImageTestsConfiguration.read(from:))
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.outputResources = try reader["outputResources"].readIfPresent(with: ImagebuilderClientTypes.OutputResources.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.buildType = try reader["buildType"].readIfPresent()
        value.imageSource = try reader["imageSource"].readIfPresent()
        value.scanState = try reader["scanState"].readIfPresent(with: ImagebuilderClientTypes.ImageScanState.read(from:))
        value.imageScanningConfiguration = try reader["imageScanningConfiguration"].readIfPresent(with: ImagebuilderClientTypes.ImageScanningConfiguration.read(from:))
        value.deprecationTime = try reader["deprecationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lifecycleExecutionId = try reader["lifecycleExecutionId"].readIfPresent()
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.workflows = try reader["workflows"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowConfiguration {

    static func write(value: ImagebuilderClientTypes.WorkflowConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["onFailure"].write(value.onFailure)
        try writer["parallelGroup"].write(value.parallelGroup)
        try writer["parameters"].writeList(value.parameters, memberWritingClosure: ImagebuilderClientTypes.WorkflowParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workflowArn"].write(value.workflowArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowConfiguration()
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parallelGroup = try reader["parallelGroup"].readIfPresent()
        value.onFailure = try reader["onFailure"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowParameter {

    static func write(value: ImagebuilderClientTypes.WorkflowParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowParameter()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ImagebuilderClientTypes.ImageScanningConfiguration {

    static func write(value: ImagebuilderClientTypes.ImageScanningConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ecrConfiguration"].write(value.ecrConfiguration, with: ImagebuilderClientTypes.EcrConfiguration.write(value:to:))
        try writer["imageScanningEnabled"].write(value.imageScanningEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageScanningConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageScanningConfiguration()
        value.imageScanningEnabled = try reader["imageScanningEnabled"].readIfPresent()
        value.ecrConfiguration = try reader["ecrConfiguration"].readIfPresent(with: ImagebuilderClientTypes.EcrConfiguration.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.EcrConfiguration {

    static func write(value: ImagebuilderClientTypes.EcrConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerTags"].writeList(value.containerTags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["repositoryName"].write(value.repositoryName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.EcrConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.EcrConfiguration()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.containerTags = try reader["containerTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.ImageScanState {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageScanState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageScanState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.OutputResources {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.OutputResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.OutputResources()
        value.amis = try reader["amis"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.Ami.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.containers = try reader["containers"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.Container.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.Container {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Container {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Container()
        value.region = try reader["region"].readIfPresent()
        value.imageUris = try reader["imageUris"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.Ami {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Ami {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Ami()
        value.region = try reader["region"].readIfPresent()
        value.image = try reader["image"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.ImageState.read(from:))
        value.accountId = try reader["accountId"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImageState {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImageTestsConfiguration {

    static func write(value: ImagebuilderClientTypes.ImageTestsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["imageTestsEnabled"].write(value.imageTestsEnabled)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageTestsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageTestsConfiguration()
        value.imageTestsEnabled = try reader["imageTestsEnabled"].readIfPresent()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.InfrastructureConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.InfrastructureConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.InfrastructureConfiguration()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.instanceTypes = try reader["instanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceProfileName = try reader["instanceProfileName"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetId = try reader["subnetId"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent(with: ImagebuilderClientTypes.Logging.read(from:))
        value.keyPair = try reader["keyPair"].readIfPresent()
        value.terminateInstanceOnFailure = try reader["terminateInstanceOnFailure"].readIfPresent()
        value.snsTopicArn = try reader["snsTopicArn"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.dateUpdated = try reader["dateUpdated"].readIfPresent()
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.instanceMetadataOptions = try reader["instanceMetadataOptions"].readIfPresent(with: ImagebuilderClientTypes.InstanceMetadataOptions.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.placement = try reader["placement"].readIfPresent(with: ImagebuilderClientTypes.Placement.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.Placement {

    static func write(value: ImagebuilderClientTypes.Placement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["hostId"].write(value.hostId)
        try writer["hostResourceGroupArn"].write(value.hostResourceGroupArn)
        try writer["tenancy"].write(value.tenancy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Placement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Placement()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.tenancy = try reader["tenancy"].readIfPresent()
        value.hostId = try reader["hostId"].readIfPresent()
        value.hostResourceGroupArn = try reader["hostResourceGroupArn"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.InstanceMetadataOptions {

    static func write(value: ImagebuilderClientTypes.InstanceMetadataOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["httpPutResponseHopLimit"].write(value.httpPutResponseHopLimit)
        try writer["httpTokens"].write(value.httpTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.InstanceMetadataOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.InstanceMetadataOptions()
        value.httpTokens = try reader["httpTokens"].readIfPresent()
        value.httpPutResponseHopLimit = try reader["httpPutResponseHopLimit"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.Logging {

    static func write(value: ImagebuilderClientTypes.Logging?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Logs"].write(value.s3Logs, with: ImagebuilderClientTypes.S3Logs.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Logging {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Logging()
        value.s3Logs = try reader["s3Logs"].readIfPresent(with: ImagebuilderClientTypes.S3Logs.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.S3Logs {

    static func write(value: ImagebuilderClientTypes.S3Logs?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["s3KeyPrefix"].write(value.s3KeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.S3Logs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.S3Logs()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["s3KeyPrefix"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImageRecipe {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageRecipe {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageRecipe()
        value.arn = try reader["arn"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.components = try reader["components"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.ComponentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parentImage = try reader["parentImage"].readIfPresent()
        value.blockDeviceMappings = try reader["blockDeviceMappings"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.InstanceBlockDeviceMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workingDirectory = try reader["workingDirectory"].readIfPresent()
        value.additionalInstanceConfiguration = try reader["additionalInstanceConfiguration"].readIfPresent(with: ImagebuilderClientTypes.AdditionalInstanceConfiguration.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.AdditionalInstanceConfiguration {

    static func write(value: ImagebuilderClientTypes.AdditionalInstanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["systemsManagerAgent"].write(value.systemsManagerAgent, with: ImagebuilderClientTypes.SystemsManagerAgent.write(value:to:))
        try writer["userDataOverride"].write(value.userDataOverride)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.AdditionalInstanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.AdditionalInstanceConfiguration()
        value.systemsManagerAgent = try reader["systemsManagerAgent"].readIfPresent(with: ImagebuilderClientTypes.SystemsManagerAgent.read(from:))
        value.userDataOverride = try reader["userDataOverride"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.SystemsManagerAgent {

    static func write(value: ImagebuilderClientTypes.SystemsManagerAgent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uninstallAfterBuild"].write(value.uninstallAfterBuild)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.SystemsManagerAgent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.SystemsManagerAgent()
        value.uninstallAfterBuild = try reader["uninstallAfterBuild"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImagePipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImagePipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImagePipeline()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.enhancedImageMetadataEnabled = try reader["enhancedImageMetadataEnabled"].readIfPresent()
        value.imageRecipeArn = try reader["imageRecipeArn"].readIfPresent()
        value.containerRecipeArn = try reader["containerRecipeArn"].readIfPresent()
        value.infrastructureConfigurationArn = try reader["infrastructureConfigurationArn"].readIfPresent()
        value.distributionConfigurationArn = try reader["distributionConfigurationArn"].readIfPresent()
        value.imageTestsConfiguration = try reader["imageTestsConfiguration"].readIfPresent(with: ImagebuilderClientTypes.ImageTestsConfiguration.read(from:))
        value.schedule = try reader["schedule"].readIfPresent(with: ImagebuilderClientTypes.Schedule.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.dateUpdated = try reader["dateUpdated"].readIfPresent()
        value.dateLastRun = try reader["dateLastRun"].readIfPresent()
        value.dateNextRun = try reader["dateNextRun"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.imageScanningConfiguration = try reader["imageScanningConfiguration"].readIfPresent(with: ImagebuilderClientTypes.ImageScanningConfiguration.read(from:))
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.workflows = try reader["workflows"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.Schedule {

    static func write(value: ImagebuilderClientTypes.Schedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pipelineExecutionStartCondition"].write(value.pipelineExecutionStartCondition)
        try writer["scheduleExpression"].write(value.scheduleExpression)
        try writer["timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Schedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Schedule()
        value.scheduleExpression = try reader["scheduleExpression"].readIfPresent()
        value.timezone = try reader["timezone"].readIfPresent()
        value.pipelineExecutionStartCondition = try reader["pipelineExecutionStartCondition"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecution()
        value.lifecycleExecutionId = try reader["lifecycleExecutionId"].readIfPresent()
        value.lifecyclePolicyArn = try reader["lifecyclePolicyArn"].readIfPresent()
        value.resourcesImpactedSummary = try reader["resourcesImpactedSummary"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary.read(from:))
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecutionState.read(from:))
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionState {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecutionState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecutionState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary()
        value.hasImpactedResources = try reader["hasImpactedResources"].readIfPresent() ?? false
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicy()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.policyDetails = try reader["policyDetails"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LifecyclePolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceSelection = try reader["resourceSelection"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyResourceSelection.read(from:))
        value.dateCreated = try reader["dateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateUpdated = try reader["dateUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateLastRun = try reader["dateLastRun"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyResourceSelection {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recipes"].writeList(value.recipes, memberWritingClosure: ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tagMap"].writeMap(value.tagMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyResourceSelection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyResourceSelection()
        value.recipes = try reader["recipes"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tagMap = try reader["tagMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["semanticVersion"].write(value.semanticVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.semanticVersion = try reader["semanticVersion"].readIfPresent() ?? ""
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetail {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: ImagebuilderClientTypes.LifecyclePolicyDetailAction.write(value:to:))
        try writer["exclusionRules"].write(value.exclusionRules, with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules.write(value:to:))
        try writer["filter"].write(value.filter, with: ImagebuilderClientTypes.LifecyclePolicyDetailFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetail()
        value.action = try reader["action"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyDetailAction.read(from:))
        value.filter = try reader["filter"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyDetailFilter.read(from:))
        value.exclusionRules = try reader["exclusionRules"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amis"].write(value.amis, with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis.write(value:to:))
        try writer["tagMap"].writeMap(value.tagMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules()
        value.tagMap = try reader["tagMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.amis = try reader["amis"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isPublic"].write(value.isPublic)
        try writer["lastLaunched"].write(value.lastLaunched, with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched.write(value:to:))
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sharedAccounts"].writeList(value.sharedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tagMap"].writeMap(value.tagMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis()
        value.isPublic = try reader["isPublic"].readIfPresent() ?? false
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sharedAccounts = try reader["sharedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastLaunched = try reader["lastLaunched"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched.read(from:))
        value.tagMap = try reader["tagMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unit"].write(value.unit)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched()
        value.value = try reader["value"].readIfPresent() ?? 0
        value.unit = try reader["unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailFilter {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetailFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["retainAtLeast"].write(value.retainAtLeast)
        try writer["type"].write(value.type)
        try writer["unit"].write(value.unit)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetailFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetailFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent() ?? 0
        value.unit = try reader["unit"].readIfPresent()
        value.retainAtLeast = try reader["retainAtLeast"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailAction {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetailAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeResources"].write(value.includeResources, with: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetailAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetailAction()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.includeResources = try reader["includeResources"].readIfPresent(with: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources {

    static func write(value: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amis"].write(value.amis)
        try writer["containers"].write(value.containers)
        try writer["snapshots"].write(value.snapshots)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources()
        value.amis = try reader["amis"].readIfPresent() ?? false
        value.snapshots = try reader["snapshots"].readIfPresent() ?? false
        value.containers = try reader["containers"].readIfPresent() ?? false
        return value
    }
}

extension ImagebuilderClientTypes.Workflow {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Workflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Workflow()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.changeDescription = try reader["changeDescription"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.WorkflowState.read(from:))
        value.owner = try reader["owner"].readIfPresent()
        value.data = try reader["data"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.WorkflowParameterDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowParameterDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowParameterDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowParameterDetail()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.defaultValue = try reader["defaultValue"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowState {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ComponentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ComponentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ComponentSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.supportedOsVersions = try reader["supportedOsVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.ComponentState.read(from:))
        value.type = try reader["type"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.changeDescription = try reader["changeDescription"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.publisher = try reader["publisher"].readIfPresent()
        value.obfuscate = try reader["obfuscate"].readIfPresent() ?? false
        return value
    }
}

extension ImagebuilderClientTypes.ComponentVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ComponentVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ComponentVersion()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.supportedOsVersions = try reader["supportedOsVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ContainerRecipeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ContainerRecipeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ContainerRecipeSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.containerType = try reader["containerType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.parentImage = try reader["parentImage"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.DistributionConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.DistributionConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.DistributionConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.dateUpdated = try reader["dateUpdated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.ImageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.osVersion = try reader["osVersion"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.ImageState.read(from:))
        value.owner = try reader["owner"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.outputResources = try reader["outputResources"].readIfPresent(with: ImagebuilderClientTypes.OutputResources.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.buildType = try reader["buildType"].readIfPresent()
        value.imageSource = try reader["imageSource"].readIfPresent()
        value.deprecationTime = try reader["deprecationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lifecycleExecutionId = try reader["lifecycleExecutionId"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImagePackage {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImagePackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImagePackage()
        value.packageName = try reader["packageName"].readIfPresent()
        value.packageVersion = try reader["packageVersion"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImageRecipeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageRecipeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageRecipeSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.parentImage = try reader["parentImage"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.ImageVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageVersion()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.osVersion = try reader["osVersion"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.buildType = try reader["buildType"].readIfPresent()
        value.imageSource = try reader["imageSource"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImageScanFindingAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageScanFindingAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageScanFindingAggregation()
        value.accountAggregation = try reader["accountAggregation"].readIfPresent(with: ImagebuilderClientTypes.AccountAggregation.read(from:))
        value.imageAggregation = try reader["imageAggregation"].readIfPresent(with: ImagebuilderClientTypes.ImageAggregation.read(from:))
        value.imagePipelineAggregation = try reader["imagePipelineAggregation"].readIfPresent(with: ImagebuilderClientTypes.ImagePipelineAggregation.read(from:))
        value.vulnerabilityIdAggregation = try reader["vulnerabilityIdAggregation"].readIfPresent(with: ImagebuilderClientTypes.VulnerabilityIdAggregation.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.VulnerabilityIdAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.VulnerabilityIdAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.VulnerabilityIdAggregation()
        value.vulnerabilityId = try reader["vulnerabilityId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: ImagebuilderClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.SeverityCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.SeverityCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.SeverityCounts()
        value.all = try reader["all"].readIfPresent()
        value.critical = try reader["critical"].readIfPresent()
        value.high = try reader["high"].readIfPresent()
        value.medium = try reader["medium"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.ImagePipelineAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImagePipelineAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImagePipelineAggregation()
        value.imagePipelineArn = try reader["imagePipelineArn"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: ImagebuilderClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.ImageAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageAggregation()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: ImagebuilderClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.AccountAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.AccountAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.AccountAggregation()
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: ImagebuilderClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.ImageScanFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.ImageScanFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.ImageScanFinding()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.imagePipelineArn = try reader["imagePipelineArn"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.remediation = try reader["remediation"].readIfPresent(with: ImagebuilderClientTypes.Remediation.read(from:))
        value.severity = try reader["severity"].readIfPresent()
        value.firstObservedAt = try reader["firstObservedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inspectorScore = try reader["inspectorScore"].readIfPresent()
        value.inspectorScoreDetails = try reader["inspectorScoreDetails"].readIfPresent(with: ImagebuilderClientTypes.InspectorScoreDetails.read(from:))
        value.packageVulnerabilityDetails = try reader["packageVulnerabilityDetails"].readIfPresent(with: ImagebuilderClientTypes.PackageVulnerabilityDetails.read(from:))
        value.fixAvailable = try reader["fixAvailable"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.PackageVulnerabilityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.PackageVulnerabilityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.PackageVulnerabilityDetails()
        value.vulnerabilityId = try reader["vulnerabilityId"].readIfPresent() ?? ""
        value.vulnerablePackages = try reader["vulnerablePackages"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.VulnerablePackage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent()
        value.cvss = try reader["cvss"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.CvssScore.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedVulnerabilities = try reader["relatedVulnerabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceUrl = try reader["sourceUrl"].readIfPresent()
        value.vendorSeverity = try reader["vendorSeverity"].readIfPresent()
        value.vendorCreatedAt = try reader["vendorCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vendorUpdatedAt = try reader["vendorUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.referenceUrls = try reader["referenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.CvssScore {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.CvssScore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.CvssScore()
        value.baseScore = try reader["baseScore"].readIfPresent()
        value.scoringVector = try reader["scoringVector"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.source = try reader["source"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.VulnerablePackage {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.VulnerablePackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.VulnerablePackage()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.sourceLayerHash = try reader["sourceLayerHash"].readIfPresent()
        value.epoch = try reader["epoch"].readIfPresent()
        value.release = try reader["release"].readIfPresent()
        value.arch = try reader["arch"].readIfPresent()
        value.packageManager = try reader["packageManager"].readIfPresent()
        value.filePath = try reader["filePath"].readIfPresent()
        value.fixedInVersion = try reader["fixedInVersion"].readIfPresent()
        value.remediation = try reader["remediation"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.InspectorScoreDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.InspectorScoreDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.InspectorScoreDetails()
        value.adjustedCvss = try reader["adjustedCvss"].readIfPresent(with: ImagebuilderClientTypes.CvssScoreDetails.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.CvssScoreDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.CvssScoreDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.CvssScoreDetails()
        value.scoreSource = try reader["scoreSource"].readIfPresent()
        value.cvssSource = try reader["cvssSource"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.score = try reader["score"].readIfPresent()
        value.scoringVector = try reader["scoringVector"].readIfPresent()
        value.adjustments = try reader["adjustments"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.CvssScoreAdjustment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.CvssScoreAdjustment {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.CvssScoreAdjustment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.CvssScoreAdjustment()
        value.metric = try reader["metric"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.Remediation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.Remediation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.Remediation()
        value.recommendation = try reader["recommendation"].readIfPresent(with: ImagebuilderClientTypes.RemediationRecommendation.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.RemediationRecommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.RemediationRecommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.RemediationRecommendation()
        value.text = try reader["text"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.InfrastructureConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.InfrastructureConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.InfrastructureConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.dateUpdated = try reader["dateUpdated"].readIfPresent()
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.instanceTypes = try reader["instanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceProfileName = try reader["instanceProfileName"].readIfPresent()
        value.placement = try reader["placement"].readIfPresent(with: ImagebuilderClientTypes.Placement.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionResource {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecutionResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecutionResource()
        value.accountId = try reader["accountId"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecutionResourceState.read(from:))
        value.action = try reader["action"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecutionResourceAction.read(from:))
        value.region = try reader["region"].readIfPresent()
        value.snapshots = try reader["snapshots"].readListIfPresent(memberReadingClosure: ImagebuilderClientTypes.LifecycleExecutionSnapshotResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.imageUris = try reader["imageUris"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionSnapshotResource {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecutionSnapshotResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecutionSnapshotResource()
        value.snapshotId = try reader["snapshotId"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.LifecycleExecutionResourceState.read(from:))
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionResourceState {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecutionResourceState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecutionResourceState()
        value.status = try reader["status"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionResourceAction {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecycleExecutionResourceAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecycleExecutionResourceAction()
        value.name = try reader["name"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.LifecyclePolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.LifecyclePolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.LifecyclePolicySummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateUpdated = try reader["dateUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateLastRun = try reader["dateLastRun"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowStepExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowStepExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowStepExecution()
        value.stepExecutionId = try reader["stepExecutionId"].readIfPresent()
        value.imageBuildVersionArn = try reader["imageBuildVersionArn"].readIfPresent()
        value.workflowExecutionId = try reader["workflowExecutionId"].readIfPresent()
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.changeDescription = try reader["changeDescription"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: ImagebuilderClientTypes.WorkflowState.read(from:))
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowExecutionMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowExecutionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowExecutionMetadata()
        value.workflowBuildVersionArn = try reader["workflowBuildVersionArn"].readIfPresent()
        value.workflowExecutionId = try reader["workflowExecutionId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.totalStepCount = try reader["totalStepCount"].readIfPresent() ?? 0
        value.totalStepsSucceeded = try reader["totalStepsSucceeded"].readIfPresent() ?? 0
        value.totalStepsFailed = try reader["totalStepsFailed"].readIfPresent() ?? 0
        value.totalStepsSkipped = try reader["totalStepsSkipped"].readIfPresent() ?? 0
        value.startTime = try reader["startTime"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.parallelGroup = try reader["parallelGroup"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowVersion()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.dateCreated = try reader["dateCreated"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.WorkflowStepMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ImagebuilderClientTypes.WorkflowStepMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ImagebuilderClientTypes.WorkflowStepMetadata()
        value.stepExecutionId = try reader["stepExecutionId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.rollbackStatus = try reader["rollbackStatus"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.inputs = try reader["inputs"].readIfPresent()
        value.outputs = try reader["outputs"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        return value
    }
}

extension ImagebuilderClientTypes.Filter {

    static func write(value: ImagebuilderClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImagebuilderClientTypes.ImageScanFindingsFilter {

    static func write(value: ImagebuilderClientTypes.ImageScanFindingsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImagebuilderClientTypes.ResourceState {

    static func write(value: ImagebuilderClientTypes.ResourceState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension ImagebuilderClientTypes.ResourceStateUpdateIncludeResources {

    static func write(value: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amis"].write(value.amis)
        try writer["containers"].write(value.containers)
        try writer["snapshots"].write(value.snapshots)
    }
}

extension ImagebuilderClientTypes.ResourceStateUpdateExclusionRules {

    static func write(value: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amis"].write(value.amis, with: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis.write(value:to:))
    }
}

public enum ImagebuilderClientTypes {}
