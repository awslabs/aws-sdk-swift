// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ImagebuilderClient {
    /// Paginate over `[ListComponentBuildVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentBuildVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentBuildVersionsOutput`
    public func listComponentBuildVersionsPaginated(input: ListComponentBuildVersionsInput) -> ClientRuntime.PaginatorSequence<ListComponentBuildVersionsInput, ListComponentBuildVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentBuildVersionsInput, ListComponentBuildVersionsOutput>(input: input, inputKey: \ListComponentBuildVersionsInput.nextToken, outputKey: \ListComponentBuildVersionsOutput.nextToken, paginationFunction: self.listComponentBuildVersions(input:))
    }
}

extension ListComponentBuildVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentBuildVersionsInput {
        return ListComponentBuildVersionsInput(
            componentVersionArn: self.componentVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListComponentBuildVersionsInput, Output == ListComponentBuildVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComponentBuildVersionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ComponentSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ComponentSummary]`
    public func componentSummaryList() async throws -> [ImagebuilderClientTypes.ComponentSummary] {
        return try await self.asyncCompactMap { item in item.componentSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListComponentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentsOutput`
    public func listComponentsPaginated(input: ListComponentsInput) -> ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutput>(input: input, inputKey: \ListComponentsInput.nextToken, outputKey: \ListComponentsOutput.nextToken, paginationFunction: self.listComponents(input:))
    }
}

extension ListComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentsInput {
        return ListComponentsInput(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where Input == ListComponentsInput, Output == ListComponentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComponentsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ComponentVersion]`
    /// - Returns: `[ImagebuilderClientTypes.ComponentVersion]`
    public func componentVersionList() async throws -> [ImagebuilderClientTypes.ComponentVersion] {
        return try await self.asyncCompactMap { item in item.componentVersionList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListContainerRecipesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListContainerRecipesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListContainerRecipesOutput`
    public func listContainerRecipesPaginated(input: ListContainerRecipesInput) -> ClientRuntime.PaginatorSequence<ListContainerRecipesInput, ListContainerRecipesOutput> {
        return ClientRuntime.PaginatorSequence<ListContainerRecipesInput, ListContainerRecipesOutput>(input: input, inputKey: \ListContainerRecipesInput.nextToken, outputKey: \ListContainerRecipesOutput.nextToken, paginationFunction: self.listContainerRecipes(input:))
    }
}

extension ListContainerRecipesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContainerRecipesInput {
        return ListContainerRecipesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where Input == ListContainerRecipesInput, Output == ListContainerRecipesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listContainerRecipesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ContainerRecipeSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ContainerRecipeSummary]`
    public func containerRecipeSummaryList() async throws -> [ImagebuilderClientTypes.ContainerRecipeSummary] {
        return try await self.asyncCompactMap { item in item.containerRecipeSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListDistributionConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDistributionConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDistributionConfigurationsOutput`
    public func listDistributionConfigurationsPaginated(input: ListDistributionConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListDistributionConfigurationsInput, ListDistributionConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListDistributionConfigurationsInput, ListDistributionConfigurationsOutput>(input: input, inputKey: \ListDistributionConfigurationsInput.nextToken, outputKey: \ListDistributionConfigurationsOutput.nextToken, paginationFunction: self.listDistributionConfigurations(input:))
    }
}

extension ListDistributionConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDistributionConfigurationsInput {
        return ListDistributionConfigurationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDistributionConfigurationsInput, Output == ListDistributionConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDistributionConfigurationsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.DistributionConfigurationSummary]`
    /// - Returns: `[ImagebuilderClientTypes.DistributionConfigurationSummary]`
    public func distributionConfigurationSummaryList() async throws -> [ImagebuilderClientTypes.DistributionConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.distributionConfigurationSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageBuildVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageBuildVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageBuildVersionsOutput`
    public func listImageBuildVersionsPaginated(input: ListImageBuildVersionsInput) -> ClientRuntime.PaginatorSequence<ListImageBuildVersionsInput, ListImageBuildVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageBuildVersionsInput, ListImageBuildVersionsOutput>(input: input, inputKey: \ListImageBuildVersionsInput.nextToken, outputKey: \ListImageBuildVersionsOutput.nextToken, paginationFunction: self.listImageBuildVersions(input:))
    }
}

extension ListImageBuildVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageBuildVersionsInput {
        return ListImageBuildVersionsInput(
            filters: self.filters,
            imageVersionArn: self.imageVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListImageBuildVersionsInput, Output == ListImageBuildVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageBuildVersionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ImageSummary]`
    public func imageSummaryList() async throws -> [ImagebuilderClientTypes.ImageSummary] {
        return try await self.asyncCompactMap { item in item.imageSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagePackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagePackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagePackagesOutput`
    public func listImagePackagesPaginated(input: ListImagePackagesInput) -> ClientRuntime.PaginatorSequence<ListImagePackagesInput, ListImagePackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagePackagesInput, ListImagePackagesOutput>(input: input, inputKey: \ListImagePackagesInput.nextToken, outputKey: \ListImagePackagesOutput.nextToken, paginationFunction: self.listImagePackages(input:))
    }
}

extension ListImagePackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagePackagesInput {
        return ListImagePackagesInput(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListImagePackagesInput, Output == ListImagePackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagePackagesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImagePackage]`
    /// - Returns: `[ImagebuilderClientTypes.ImagePackage]`
    public func imagePackageList() async throws -> [ImagebuilderClientTypes.ImagePackage] {
        return try await self.asyncCompactMap { item in item.imagePackageList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagePipelineImagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagePipelineImagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagePipelineImagesOutput`
    public func listImagePipelineImagesPaginated(input: ListImagePipelineImagesInput) -> ClientRuntime.PaginatorSequence<ListImagePipelineImagesInput, ListImagePipelineImagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagePipelineImagesInput, ListImagePipelineImagesOutput>(input: input, inputKey: \ListImagePipelineImagesInput.nextToken, outputKey: \ListImagePipelineImagesOutput.nextToken, paginationFunction: self.listImagePipelineImages(input:))
    }
}

extension ListImagePipelineImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagePipelineImagesInput {
        return ListImagePipelineImagesInput(
            filters: self.filters,
            imagePipelineArn: self.imagePipelineArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListImagePipelineImagesInput, Output == ListImagePipelineImagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagePipelineImagesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ImageSummary]`
    public func imageSummaryList() async throws -> [ImagebuilderClientTypes.ImageSummary] {
        return try await self.asyncCompactMap { item in item.imageSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagePipelinesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagePipelinesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagePipelinesOutput`
    public func listImagePipelinesPaginated(input: ListImagePipelinesInput) -> ClientRuntime.PaginatorSequence<ListImagePipelinesInput, ListImagePipelinesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagePipelinesInput, ListImagePipelinesOutput>(input: input, inputKey: \ListImagePipelinesInput.nextToken, outputKey: \ListImagePipelinesOutput.nextToken, paginationFunction: self.listImagePipelines(input:))
    }
}

extension ListImagePipelinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagePipelinesInput {
        return ListImagePipelinesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListImagePipelinesInput, Output == ListImagePipelinesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagePipelinesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImagePipeline]`
    /// - Returns: `[ImagebuilderClientTypes.ImagePipeline]`
    public func imagePipelineList() async throws -> [ImagebuilderClientTypes.ImagePipeline] {
        return try await self.asyncCompactMap { item in item.imagePipelineList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageRecipesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageRecipesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageRecipesOutput`
    public func listImageRecipesPaginated(input: ListImageRecipesInput) -> ClientRuntime.PaginatorSequence<ListImageRecipesInput, ListImageRecipesOutput> {
        return ClientRuntime.PaginatorSequence<ListImageRecipesInput, ListImageRecipesOutput>(input: input, inputKey: \ListImageRecipesInput.nextToken, outputKey: \ListImageRecipesOutput.nextToken, paginationFunction: self.listImageRecipes(input:))
    }
}

extension ListImageRecipesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageRecipesInput {
        return ListImageRecipesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where Input == ListImageRecipesInput, Output == ListImageRecipesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageRecipesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageRecipeSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ImageRecipeSummary]`
    public func imageRecipeSummaryList() async throws -> [ImagebuilderClientTypes.ImageRecipeSummary] {
        return try await self.asyncCompactMap { item in item.imageRecipeSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagesOutput`
    public func listImagesPaginated(input: ListImagesInput) -> ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutput>(input: input, inputKey: \ListImagesInput.nextToken, outputKey: \ListImagesOutput.nextToken, paginationFunction: self.listImages(input:))
    }
}

extension ListImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagesInput {
        return ListImagesInput(
            byName: self.byName,
            filters: self.filters,
            includeDeprecated: self.includeDeprecated,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where Input == ListImagesInput, Output == ListImagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageVersion]`
    /// - Returns: `[ImagebuilderClientTypes.ImageVersion]`
    public func imageVersionList() async throws -> [ImagebuilderClientTypes.ImageVersion] {
        return try await self.asyncCompactMap { item in item.imageVersionList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageScanFindingAggregationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageScanFindingAggregationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageScanFindingAggregationsOutput`
    public func listImageScanFindingAggregationsPaginated(input: ListImageScanFindingAggregationsInput) -> ClientRuntime.PaginatorSequence<ListImageScanFindingAggregationsInput, ListImageScanFindingAggregationsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageScanFindingAggregationsInput, ListImageScanFindingAggregationsOutput>(input: input, inputKey: \ListImageScanFindingAggregationsInput.nextToken, outputKey: \ListImageScanFindingAggregationsOutput.nextToken, paginationFunction: self.listImageScanFindingAggregations(input:))
    }
}

extension ListImageScanFindingAggregationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageScanFindingAggregationsInput {
        return ListImageScanFindingAggregationsInput(
            filter: self.filter,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListImageScanFindingAggregationsInput, Output == ListImageScanFindingAggregationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageScanFindingAggregationsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageScanFindingAggregation]`
    /// - Returns: `[ImagebuilderClientTypes.ImageScanFindingAggregation]`
    public func responses() async throws -> [ImagebuilderClientTypes.ImageScanFindingAggregation] {
        return try await self.asyncCompactMap { item in item.responses }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageScanFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageScanFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageScanFindingsOutput`
    public func listImageScanFindingsPaginated(input: ListImageScanFindingsInput) -> ClientRuntime.PaginatorSequence<ListImageScanFindingsInput, ListImageScanFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageScanFindingsInput, ListImageScanFindingsOutput>(input: input, inputKey: \ListImageScanFindingsInput.nextToken, outputKey: \ListImageScanFindingsOutput.nextToken, paginationFunction: self.listImageScanFindings(input:))
    }
}

extension ListImageScanFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageScanFindingsInput {
        return ListImageScanFindingsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListImageScanFindingsInput, Output == ListImageScanFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageScanFindingsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageScanFinding]`
    /// - Returns: `[ImagebuilderClientTypes.ImageScanFinding]`
    public func findings() async throws -> [ImagebuilderClientTypes.ImageScanFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListInfrastructureConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInfrastructureConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInfrastructureConfigurationsOutput`
    public func listInfrastructureConfigurationsPaginated(input: ListInfrastructureConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListInfrastructureConfigurationsInput, ListInfrastructureConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListInfrastructureConfigurationsInput, ListInfrastructureConfigurationsOutput>(input: input, inputKey: \ListInfrastructureConfigurationsInput.nextToken, outputKey: \ListInfrastructureConfigurationsOutput.nextToken, paginationFunction: self.listInfrastructureConfigurations(input:))
    }
}

extension ListInfrastructureConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInfrastructureConfigurationsInput {
        return ListInfrastructureConfigurationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListInfrastructureConfigurationsInput, Output == ListInfrastructureConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInfrastructureConfigurationsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.InfrastructureConfigurationSummary]`
    /// - Returns: `[ImagebuilderClientTypes.InfrastructureConfigurationSummary]`
    public func infrastructureConfigurationSummaryList() async throws -> [ImagebuilderClientTypes.InfrastructureConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.infrastructureConfigurationSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWorkflowExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowExecutionsOutput`
    public func listWorkflowExecutionsPaginated(input: ListWorkflowExecutionsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowExecutionsInput, ListWorkflowExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowExecutionsInput, ListWorkflowExecutionsOutput>(input: input, inputKey: \ListWorkflowExecutionsInput.nextToken, outputKey: \ListWorkflowExecutionsOutput.nextToken, paginationFunction: self.listWorkflowExecutions(input:))
    }
}

extension ListWorkflowExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowExecutionsInput {
        return ListWorkflowExecutionsInput(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListWorkflowExecutionsInput, Output == ListWorkflowExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowExecutionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowExecutionMetadata]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowExecutionMetadata]`
    public func workflowExecutions() async throws -> [ImagebuilderClientTypes.WorkflowExecutionMetadata] {
        return try await self.asyncCompactMap { item in item.workflowExecutions }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWorkflowStepExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowStepExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowStepExecutionsOutput`
    public func listWorkflowStepExecutionsPaginated(input: ListWorkflowStepExecutionsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowStepExecutionsInput, ListWorkflowStepExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowStepExecutionsInput, ListWorkflowStepExecutionsOutput>(input: input, inputKey: \ListWorkflowStepExecutionsInput.nextToken, outputKey: \ListWorkflowStepExecutionsOutput.nextToken, paginationFunction: self.listWorkflowStepExecutions(input:))
    }
}

extension ListWorkflowStepExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowStepExecutionsInput {
        return ListWorkflowStepExecutionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workflowExecutionId: self.workflowExecutionId
        )}
}

extension PaginatorSequence where Input == ListWorkflowStepExecutionsInput, Output == ListWorkflowStepExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowStepExecutionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowStepMetadata]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowStepMetadata]`
    public func steps() async throws -> [ImagebuilderClientTypes.WorkflowStepMetadata] {
        return try await self.asyncCompactMap { item in item.steps }
    }
}
