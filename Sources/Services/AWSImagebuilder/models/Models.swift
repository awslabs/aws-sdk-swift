// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ImagebuilderClientTypes.AccountAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains counts of vulnerability findings from image scans that run when you create new Image Builder images, or build new versions of existing images. The vulnerability counts are grouped by severity level. The counts are aggregated across resources to create the final tally for the account that owns them.
    public struct AccountAggregation: Swift.Equatable {
        /// Identifies the account that owns the aggregated resource findings.
        public var accountId: Swift.String?
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }
    }

}

extension ImagebuilderClientTypes.AdditionalInstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case systemsManagerAgent
        case userDataOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let systemsManagerAgent = self.systemsManagerAgent {
            try encodeContainer.encode(systemsManagerAgent, forKey: .systemsManagerAgent)
        }
        if let userDataOverride = self.userDataOverride {
            try encodeContainer.encode(userDataOverride, forKey: .userDataOverride)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemsManagerAgentDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SystemsManagerAgent.self, forKey: .systemsManagerAgent)
        systemsManagerAgent = systemsManagerAgentDecoded
        let userDataOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userDataOverride)
        userDataOverride = userDataOverrideDecoded
    }
}

extension ImagebuilderClientTypes {
    /// In addition to your infrastructure configuration, these settings provide an extra layer of control over your build instances. You can also specify commands to run on launch for all of your build instances. Image Builder does not automatically install the Systems Manager agent on Windows instances. If your base image includes the Systems Manager agent, then the AMI that you create will also include the agent. For Linux instances, if the base image does not already include the Systems Manager agent, Image Builder installs it. For Linux instances where Image Builder installs the Systems Manager agent, you can choose whether to keep it for the AMI that you create.
    public struct AdditionalInstanceConfiguration: Swift.Equatable {
        /// Contains settings for the Systems Manager agent on your build instance.
        public var systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch your build instance. The userDataOverride property replaces any commands that Image Builder might have added to ensure that Systems Manager is installed on your Linux build instance. If you override the user data, make sure that you add commands to install Systems Manager, if it is not pre-installed on your base image. The user data is always base 64 encoded. For example, the following commands are encoded as IyEvYmluL2Jhc2gKbWtkaXIgLXAgL3Zhci9iYi8KdG91Y2ggL3Zhci$: #!/bin/bash mkdir -p /var/bb/ touch /var
        public var userDataOverride: Swift.String?

        public init(
            systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent? = nil,
            userDataOverride: Swift.String? = nil
        )
        {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }
    }

}

extension ImagebuilderClientTypes.Ami: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case description
        case image
        case name
        case region
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Details of an Amazon EC2 AMI.
    public struct Ami: Swift.Equatable {
        /// The account ID of the owner of the AMI.
        public var accountId: Swift.String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The AMI ID of the Amazon EC2 AMI.
        public var image: Swift.String?
        /// The name of the Amazon EC2 AMI.
        public var name: Swift.String?
        /// The Amazon Web Services Region of the Amazon EC2 AMI.
        public var region: Swift.String?
        /// Image status and the reason for that status.
        public var state: ImagebuilderClientTypes.ImageState?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            image: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }
    }

}

extension ImagebuilderClientTypes.AmiDistributionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiTags
        case description
        case kmsKeyId
        case launchPermission
        case name
        case targetAccountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiTags = amiTags {
            var amiTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .amiTags)
            for (dictKey0, tagMap0) in amiTags {
                try amiTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let launchPermission = self.launchPermission {
            try encodeContainer.encode(launchPermission, forKey: .launchPermission)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetAccountIds = targetAccountIds {
            var targetAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccountIds)
            for accountid0 in targetAccountIds {
                try targetAccountIdsContainer.encode(accountid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetAccountIds)
        var targetAccountIdsDecoded0:[Swift.String]? = nil
        if let targetAccountIdsContainer = targetAccountIdsContainer {
            targetAccountIdsDecoded0 = [Swift.String]()
            for string0 in targetAccountIdsContainer {
                if let string0 = string0 {
                    targetAccountIdsDecoded0?.append(string0)
                }
            }
        }
        targetAccountIds = targetAccountIdsDecoded0
        let amiTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .amiTags)
        var amiTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let amiTagsContainer = amiTagsContainer {
            amiTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in amiTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    amiTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        amiTags = amiTagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let launchPermissionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LaunchPermissionConfiguration.self, forKey: .launchPermission)
        launchPermission = launchPermissionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Define and configure the output AMIs of the pipeline.
    public struct AmiDistributionConfiguration: Swift.Equatable {
        /// The tags to apply to AMIs distributed to this Region.
        public var amiTags: [Swift.String:Swift.String]?
        /// The description of the AMI distribution configuration. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The KMS key identifier used to encrypt the distributed image.
        public var kmsKeyId: Swift.String?
        /// Launch permissions can be used to configure which Amazon Web Services accounts can use the AMI to launch instances.
        public var launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration?
        /// The name of the output AMI.
        public var name: Swift.String?
        /// The ID of an account to which you want to distribute an image.
        public var targetAccountIds: [Swift.String]?

        public init(
            amiTags: [Swift.String:Swift.String]? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration? = nil,
            name: Swift.String? = nil,
            targetAccountIds: [Swift.String]? = nil
        )
        {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }
    }

}

extension ImagebuilderClientTypes {
    public enum BuildType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `import`
        case scheduled
        case userInitiated
        case sdkUnknown(Swift.String)

        public static var allCases: [BuildType] {
            return [
                .import,
                .scheduled,
                .userInitiated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .import: return "IMPORT"
            case .scheduled: return "SCHEDULED"
            case .userInitiated: return "USER_INITIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BuildType(rawValue: rawValue) ?? BuildType.sdkUnknown(rawValue)
        }
    }
}

extension CallRateLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CallRateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the permitted request rate for the specific operation.
public struct CallRateLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CallRateLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CallRateLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CallRateLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelImageCreationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
    }
}

extension CancelImageCreationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CancelImageCreation"
    }
}

public struct CancelImageCreationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that you want to cancel creation for.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct CancelImageCreationInputBody: Swift.Equatable {
    let imageBuildVersionArn: Swift.String?
    let clientToken: Swift.String?
}

extension CancelImageCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelImageCreationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelImageCreationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CancelImageCreationOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The ARN of the image whose creation this request canceled.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CancelImageCreationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension CancelImageCreationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

enum CancelImageCreationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelLifecycleExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case lifecycleExecutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let lifecycleExecutionId = self.lifecycleExecutionId {
            try encodeContainer.encode(lifecycleExecutionId, forKey: .lifecycleExecutionId)
        }
    }
}

extension CancelLifecycleExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CancelLifecycleExecution"
    }
}

public struct CancelLifecycleExecutionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Identifies the specific runtime instance of the image lifecycle to cancel.
    /// This member is required.
    public var lifecycleExecutionId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        lifecycleExecutionId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.lifecycleExecutionId = lifecycleExecutionId
    }
}

struct CancelLifecycleExecutionInputBody: Swift.Equatable {
    let lifecycleExecutionId: Swift.String?
    let clientToken: Swift.String?
}

extension CancelLifecycleExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case lifecycleExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelLifecycleExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelLifecycleExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecycleExecutionId = output.lifecycleExecutionId
        } else {
            self.lifecycleExecutionId = nil
        }
    }
}

public struct CancelLifecycleExecutionOutput: Swift.Equatable {
    /// The unique identifier for the image lifecycle runtime instance that was canceled.
    public var lifecycleExecutionId: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
    }
}

struct CancelLifecycleExecutionOutputBody: Swift.Equatable {
    let lifecycleExecutionId: Swift.String?
}

extension CancelLifecycleExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
    }
}

enum CancelLifecycleExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// These errors are usually caused by a client action, such as using an action or resource on behalf of a user that doesn't have permissions to use the action or resource, or specifying an invalid resource identifier.
public struct ClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClientExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case changeDescription
        case data
        case dateCreated
        case description
        case encrypted
        case kmsKeyId
        case name
        case obfuscate
        case owner
        case parameters
        case platform
        case publisher
        case state
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if obfuscate != false {
            try encodeContainer.encode(obfuscate, forKey: .obfuscate)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for componentparameterdetail0 in parameters {
                try parametersContainer.encode(componentparameterdetail0)
            }
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let publisher = self.publisher {
            try encodeContainer.encode(publisher, forKey: .publisher)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentState.self, forKey: .state)
        state = stateDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentParameterDetail?].self, forKey: .parameters)
        var parametersDecoded0:[ImagebuilderClientTypes.ComponentParameterDetail]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ImagebuilderClientTypes.ComponentParameterDetail]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let publisherDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publisher)
        publisher = publisherDecoded
        let obfuscateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .obfuscate) ?? false
        obfuscate = obfuscateDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A detailed view of a component.
    public struct Component: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description of the component.
        public var changeDescription: Swift.String?
        /// Component data contains the YAML document content for the component.
        public var data: Swift.String?
        /// The date that Image Builder created the component.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The encryption status of the component.
        public var encrypted: Swift.Bool?
        /// The KMS key identifier used to encrypt the component.
        public var kmsKeyId: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// Indicates whether component source is hidden from view in the console, and from component detail results for API, CLI, or SDK operations.
        public var obfuscate: Swift.Bool
        /// The owner of the component.
        public var owner: Swift.String?
        /// Contains parameter details for each of the parameters that the component document defined for the component.
        public var parameters: [ImagebuilderClientTypes.ComponentParameterDetail]?
        /// The operating system platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Contains the name of the publisher if this is a third-party component. Otherwise, this property is empty.
        public var publisher: Swift.String?
        /// Describes the current status of the component. This is used for components that are no longer active.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is available, Image Builder performs a prefix match against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags that apply to the component.
        public var tags: [Swift.String:Swift.String]?
        /// The component type specifies whether Image Builder uses the component to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            data: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            obfuscate: Swift.Bool = false,
            owner: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameterDetail]? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            publisher: Swift.String? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.obfuscate = obfuscate
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.publisher = publisher
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ComponentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = self.componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for componentparameter0 in parameters {
                try parametersContainer.encode(componentparameter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ImagebuilderClientTypes.ComponentParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ImagebuilderClientTypes.ComponentParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Configuration details of the component.
    public struct ComponentConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        /// This member is required.
        public var componentArn: Swift.String?
        /// A group of parameter settings that Image Builder uses to configure the component for a specific recipe.
        public var parameters: [ImagebuilderClientTypes.ComponentParameter]?

        public init(
            componentArn: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameter]? = nil
        )
        {
            self.componentArn = componentArn
            self.parameters = parameters
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shell
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentFormat] {
            return [
                .shell,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shell: return "SHELL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentFormat(rawValue: rawValue) ?? ComponentFormat.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for componentparametervalue0 in value {
                try valueContainer.encode(componentparametervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Contains a key/value pair that sets the named component parameter.
    public struct ComponentParameter: Swift.Equatable {
        /// The name of the component parameter to set.
        /// This member is required.
        public var name: Swift.String?
        /// Sets the value for the named component parameter.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ImagebuilderClientTypes.ComponentParameterDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            var defaultValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValue)
            for componentparametervalue0 in defaultValue {
                try defaultValueContainer.encode(componentparametervalue0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let defaultValueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultValue)
        var defaultValueDecoded0:[Swift.String]? = nil
        if let defaultValueContainer = defaultValueContainer {
            defaultValueDecoded0 = [Swift.String]()
            for string0 in defaultValueContainer {
                if let string0 = string0 {
                    defaultValueDecoded0?.append(string0)
                }
            }
        }
        defaultValue = defaultValueDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Defines a parameter that is used to provide configuration details for the component.
    public struct ComponentParameterDetail: Swift.Equatable {
        /// The default value of this parameter if no input is provided.
        public var defaultValue: [Swift.String]?
        /// Describes this parameter.
        public var description: Swift.String?
        /// The name of this input parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of input this parameter provides. The currently supported value is "string".
        /// This member is required.
        public var type: Swift.String?

        public init(
            defaultValue: [Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension ImagebuilderClientTypes.ComponentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A group of fields that describe the current status of components that are no longer active.
    public struct ComponentState: Swift.Equatable {
        /// Describes how or why the component changed state.
        public var reason: Swift.String?
        /// The current state of the component.
        public var status: ImagebuilderClientTypes.ComponentStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ComponentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentStatus(rawValue: rawValue) ?? ComponentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case changeDescription
        case dateCreated
        case description
        case name
        case obfuscate
        case owner
        case platform
        case publisher
        case state
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if obfuscate != false {
            try encodeContainer.encode(obfuscate, forKey: .obfuscate)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let publisher = self.publisher {
            try encodeContainer.encode(publisher, forKey: .publisher)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let publisherDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publisher)
        publisher = publisherDecoded
        let obfuscateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .obfuscate) ?? false
        obfuscate = obfuscateDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A high-level summary of a component.
    public struct ComponentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description for the current version of the component.
        public var changeDescription: Swift.String?
        /// The original creation date of the component.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// Indicates whether component source is hidden from view in the console, and from component detail results for API, CLI, or SDK operations.
        public var obfuscate: Swift.Bool
        /// The owner of the component.
        public var owner: Swift.String?
        /// The operating system platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Contains the name of the publisher if this is a third-party component. Otherwise, this property is empty.
        public var publisher: Swift.String?
        /// Describes the current status of the component.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version that the component supports. If the OS information is available, Image Builder performs a prefix match against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags that apply to the component.
        public var tags: [Swift.String:Swift.String]?
        /// The component type specifies whether Image Builder uses the component to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            obfuscate: Swift.Bool = false,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            publisher: Swift.String? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.obfuscate = obfuscate
            self.owner = owner
            self.platform = platform
            self.publisher = publisher
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case build
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .build,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentType(rawValue: rawValue) ?? ComponentType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case description
        case name
        case owner
        case platform
        case supportedOsVersions
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The defining characteristics of a specific version of an Amazon Web Services TOE component.
    public struct ComponentVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// he operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The semantic version of the component. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.Container: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUris
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUris = imageUris {
            var imageUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageUris)
            for nonemptystring0 in imageUris {
                try imageUrisContainer.encode(nonemptystring0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let imageUrisContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageUris)
        var imageUrisDecoded0:[Swift.String]? = nil
        if let imageUrisContainer = imageUrisContainer {
            imageUrisDecoded0 = [Swift.String]()
            for string0 in imageUrisContainer {
                if let string0 = string0 {
                    imageUrisDecoded0?.append(string0)
                }
            }
        }
        imageUris = imageUrisDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A container encapsulates the runtime environment for an application.
    public struct Container: Swift.Equatable {
        /// A list of URIs for containers created in the context Region.
        public var imageUris: [Swift.String]?
        /// Containers and container images are Region-specific. This is the Region context for the container.
        public var region: Swift.String?

        public init(
            imageUris: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.imageUris = imageUris
            self.region = region
        }
    }

}

extension ImagebuilderClientTypes.ContainerDistributionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerTags
        case description
        case targetRepository
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerTags = containerTags {
            var containerTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerTags)
            for nonemptystring0 in containerTags {
                try containerTagsContainer.encode(nonemptystring0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targetRepository = self.targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let containerTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .containerTags)
        var containerTagsDecoded0:[Swift.String]? = nil
        if let containerTagsContainer = containerTagsContainer {
            containerTagsDecoded0 = [Swift.String]()
            for string0 in containerTagsContainer {
                if let string0 = string0 {
                    containerTagsDecoded0?.append(string0)
                }
            }
        }
        containerTags = containerTagsDecoded0
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
    public struct ContainerDistributionConfiguration: Swift.Equatable {
        /// Tags that are attached to the container distribution configuration.
        public var containerTags: [Swift.String]?
        /// The description of the container distribution configuration.
        public var description: Swift.String?
        /// The destination repository for the container distribution configuration.
        /// This member is required.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?

        public init(
            containerTags: [Swift.String]? = nil,
            description: Swift.String? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil
        )
        {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }
    }

}

extension ImagebuilderClientTypes.ContainerRecipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case components
        case containerType
        case dateCreated
        case description
        case dockerfileTemplateData
        case encrypted
        case instanceConfiguration
        case kmsKeyId
        case name
        case owner
        case parentImage
        case platform
        case tags
        case targetRepository
        case version
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = self.dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = self.targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A container recipe.
    public struct ContainerRecipe: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the container recipe. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the container recipe.
        public var description: Swift.String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
        public var dockerfileTemplateData: Swift.String?
        /// A flag that indicates if the target container is encrypted.
        public var encrypted: Swift.Bool?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to the target Region.
        public var kmsKeyId: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String:Swift.String]?
        /// The destination repository for the container image.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
        /// The semantic version of the container recipe. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?
        /// The working directory for use during build and test workflows.
        public var workingDirectory: Swift.String?

        public init(
            arn: Swift.String? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            dockerfileTemplateData: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }

}

extension ImagebuilderClientTypes.ContainerRecipeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerType
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A summary of a container recipe
    public struct ContainerRecipeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public var arn: Swift.String?
        /// Specifies the type of container, such as "Docker".
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ContainerRepositoryService: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerRepositoryService] {
            return [
                .ecr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerRepositoryService(rawValue: rawValue) ?? ContainerRepositoryService.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum ContainerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerType] {
            return [
                .docker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerType(rawValue: rawValue) ?? ContainerType.sdkUnknown(rawValue)
        }
    }
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateComponent"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.
    public var changeDescription: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Component data contains inline YAML document content for the component. Alternatively, you can specify the uri of a YAML document file stored in Amazon S3. However, you cannot specify both properties.
    public var data: Swift.String?
    /// Describes the contents of the component.
    public var description: Swift.String?
    /// The ID of the KMS key that is used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The operating system platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
    public var supportedOsVersions: [Swift.String]?
    /// The tags that apply to the component.
    public var tags: [Swift.String:Swift.String]?
    /// The uri of a YAML component document file. This must be an S3 URL (s3://bucket/key), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component data property. You cannot specify both properties.
    public var uri: Swift.String?

    public init(
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        supportedOsVersions: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.uri = uri
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let name: Swift.String?
    let semanticVersion: Swift.String?
    let description: Swift.String?
    let changeDescription: Swift.String?
    let platform: ImagebuilderClientTypes.Platform?
    let supportedOsVersions: [Swift.String]?
    let data: Swift.String?
    let uri: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateComponentOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the component that the request created.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateComponentOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let componentBuildVersionArn: Swift.String?
}

extension CreateComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

enum CreateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidVersionNumberException": return try await InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateContainerRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = self.dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let dockerfileTemplateUri = self.dockerfileTemplateUri {
            try encodeContainer.encode(dockerfileTemplateUri, forKey: .dockerfileTemplateUri)
        }
        if let imageOsVersionOverride = self.imageOsVersionOverride {
            try encodeContainer.encode(imageOsVersionOverride, forKey: .imageOsVersionOverride)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platformOverride = self.platformOverride {
            try encodeContainer.encode(platformOverride.rawValue, forKey: .platformOverride)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = self.targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension CreateContainerRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateContainerRecipe"
    }
}

public struct CreateContainerRecipeInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Components for build and test that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The type of container to create.
    /// This member is required.
    public var containerType: ImagebuilderClientTypes.ContainerType?
    /// The description of the container recipe.
    public var description: Swift.String?
    /// The Dockerfile template used to build your image as an inline data blob.
    public var dockerfileTemplateData: Swift.String?
    /// The Amazon S3 URI for the Dockerfile that will be used to build your container image.
    public var dockerfileTemplateUri: Swift.String?
    /// Specifies the operating system version for the base image.
    public var imageOsVersionOverride: Swift.String?
    /// A group of options that can be used to configure an instance for building and testing container images.
    public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    /// Identifies which KMS key is used to encrypt the container image.
    public var kmsKeyId: Swift.String?
    /// The name of the container recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image for the container recipe.
    /// This member is required.
    public var parentImage: Swift.String?
    /// Specifies the operating system platform when you use a custom base image.
    public var platformOverride: ImagebuilderClientTypes.Platform?
    /// The semantic version of the container recipe. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the container recipe.
    public var tags: [Swift.String:Swift.String]?
    /// The destination repository for the container image.
    /// This member is required.
    public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    /// The working directory for use during build and test workflows.
    public var workingDirectory: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        containerType: ImagebuilderClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        dockerfileTemplateData: Swift.String? = nil,
        dockerfileTemplateUri: Swift.String? = nil,
        imageOsVersionOverride: Swift.String? = nil,
        instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        platformOverride: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.containerType = containerType
        self.description = description
        self.dockerfileTemplateData = dockerfileTemplateData
        self.dockerfileTemplateUri = dockerfileTemplateUri
        self.imageOsVersionOverride = imageOsVersionOverride
        self.instanceConfiguration = instanceConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.parentImage = parentImage
        self.platformOverride = platformOverride
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.targetRepository = targetRepository
        self.workingDirectory = workingDirectory
    }
}

struct CreateContainerRecipeInputBody: Swift.Equatable {
    let containerType: ImagebuilderClientTypes.ContainerType?
    let name: Swift.String?
    let description: Swift.String?
    let semanticVersion: Swift.String?
    let components: [ImagebuilderClientTypes.ComponentConfiguration]?
    let instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    let dockerfileTemplateData: Swift.String?
    let dockerfileTemplateUri: Swift.String?
    let platformOverride: ImagebuilderClientTypes.Platform?
    let imageOsVersionOverride: Swift.String?
    let parentImage: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let workingDirectory: Swift.String?
    let targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    let kmsKeyId: Swift.String?
    let clientToken: Swift.String?
}

extension CreateContainerRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let dockerfileTemplateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateUri)
        dockerfileTemplateUri = dockerfileTemplateUriDecoded
        let platformOverrideDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platformOverride)
        platformOverride = platformOverrideDecoded
        let imageOsVersionOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageOsVersionOverride)
        imageOsVersionOverride = imageOsVersionOverrideDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateContainerRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContainerRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateContainerRecipeOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// Returns the Amazon Resource Name (ARN) of the container recipe that the request created.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct CreateContainerRecipeOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let containerRecipeArn: Swift.String?
}

extension CreateContainerRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

enum CreateContainerRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidVersionNumberException": return try await InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDistributionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateDistributionConfiguration"
    }
}

public struct CreateDistributionConfigurationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?
    /// The name of the distribution configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags of the distribution configuration.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributions = distributions
        self.name = name
        self.tags = tags
    }
}

struct CreateDistributionConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let distributions: [ImagebuilderClientTypes.Distribution]?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateDistributionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDistributionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDistributionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateDistributionConfigurationOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was created by this request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct CreateDistributionConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let distributionConfigurationArn: Swift.String?
}

extension CreateDistributionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

enum CreateDistributionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateImage"
    }
}

public struct CreateImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.
    public var containerRecipeArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed.
    public var imageRecipeArn: Swift.String?
    /// Contains settings for vulnerability scans.
    public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
    /// The image tests configuration of the image.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The tags of the image.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.tags = tags
    }
}

struct CreateImageInputBody: Swift.Equatable {
    let imageRecipeArn: Swift.String?
    let containerRecipeArn: Swift.String?
    let distributionConfigurationArn: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
    let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    let enhancedImageMetadataEnabled: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
}

extension CreateImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension CreateImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that the request created.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateImageOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension CreateImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

enum CreateImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateImagePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateImagePipeline"
    }
}

public struct CreateImagePipelineInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images created by this image pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images created by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// Contains settings for vulnerability scans.
    public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images created by this image pipeline.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The name of the image pipeline.
    /// This member is required.
    public var name: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?
    /// The tags of the image pipeline.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.name = name
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

struct CreateImagePipelineInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let imageRecipeArn: Swift.String?
    let containerRecipeArn: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
    let distributionConfigurationArn: Swift.String?
    let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    let enhancedImageMetadataEnabled: Swift.Bool?
    let schedule: ImagebuilderClientTypes.Schedule?
    let status: ImagebuilderClientTypes.PipelineStatus?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
}

extension CreateImagePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension CreateImagePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateImagePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImagePipelineOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was created by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct CreateImagePipelineOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imagePipelineArn: Swift.String?
}

extension CreateImagePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

enum CreateImagePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateImageRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInstanceConfiguration = self.additionalInstanceConfiguration {
            try encodeContainer.encode(additionalInstanceConfiguration, forKey: .additionalInstanceConfiguration)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension CreateImageRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateImageRecipe"
    }
}

public struct CreateImageRecipeInput: Swift.Equatable {
    /// Specify additional settings and launch scripts for your build instances.
    public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    /// The block device mappings of the image recipe.
    public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The components included in the image recipe.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The description of the image recipe.
    public var description: Swift.String?
    /// The name of the image recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image of the image recipe. The value of the string can be the ARN of the base image or an AMI ID. The format for the ARN follows this example: arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x. You can provide the specific version that you want to use, or you can use a wildcard in all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI, and the AMI must be in the same Region in which you are using Image Builder.
    /// This member is required.
    public var parentImage: Swift.String?
    /// The semantic version of the image recipe. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the image recipe.
    public var tags: [Swift.String:Swift.String]?
    /// The working directory used during build and test workflows.
    public var workingDirectory: Swift.String?

    public init(
        additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
        blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.additionalInstanceConfiguration = additionalInstanceConfiguration
        self.blockDeviceMappings = blockDeviceMappings
        self.clientToken = clientToken
        self.components = components
        self.description = description
        self.name = name
        self.parentImage = parentImage
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

struct CreateImageRecipeInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let semanticVersion: Swift.String?
    let components: [ImagebuilderClientTypes.ComponentConfiguration]?
    let parentImage: Swift.String?
    let blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    let tags: [Swift.String:Swift.String]?
    let workingDirectory: Swift.String?
    let additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    let clientToken: Swift.String?
}

extension CreateImageRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let additionalInstanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AdditionalInstanceConfiguration.self, forKey: .additionalInstanceConfiguration)
        additionalInstanceConfiguration = additionalInstanceConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateImageRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageRecipeOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that was created by this request.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct CreateImageRecipeOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageRecipeArn: Swift.String?
}

extension CreateImageRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageRecipeArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

enum CreateImageRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidVersionNumberException": return try await InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInfrastructureConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceMetadataOptions = self.instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = self.terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

extension CreateInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateInfrastructureConfiguration"
    }
}

public struct CreateInfrastructureConfigurationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds use to launch EC2 build and test instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The name of the infrastructure configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String:Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
    public var snsTopicArn: Swift.String?
    /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
    public var subnetId: Swift.String?
    /// The tags of the infrastructure configuration.
    public var tags: [Swift.String:Swift.String]?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        resourceTags: [Swift.String:Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.name = name
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.tags = tags
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct CreateInfrastructureConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let instanceTypes: [Swift.String]?
    let instanceProfileName: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetId: Swift.String?
    let logging: ImagebuilderClientTypes.Logging?
    let keyPair: Swift.String?
    let terminateInstanceOnFailure: Swift.Bool?
    let snsTopicArn: Swift.String?
    let resourceTags: [Swift.String:Swift.String]?
    let instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateInfrastructureConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateInfrastructureConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInfrastructureConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateInfrastructureConfigurationOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct CreateInfrastructureConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
}

extension CreateInfrastructureConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

enum CreateInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case executionRole
        case name
        case policyDetails
        case resourceSelection
        case resourceType
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyDetails = policyDetails {
            var policyDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyDetails)
            for lifecyclepolicydetail0 in policyDetails {
                try policyDetailsContainer.encode(lifecyclepolicydetail0)
            }
        }
        if let resourceSelection = self.resourceSelection {
            try encodeContainer.encode(resourceSelection, forKey: .resourceSelection)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLifecyclePolicy"
    }
}

public struct CreateLifecyclePolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Optional description for the lifecycle policy.
    public var description: Swift.String?
    /// The role name or Amazon Resource Name (ARN) for the IAM role that grants Image Builder access to run lifecycle actions.
    /// This member is required.
    public var executionRole: Swift.String?
    /// The name of the lifecycle policy to create.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration details for the lifecycle policy rules.
    /// This member is required.
    public var policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
    /// Selection criteria for the resources that the lifecycle policy applies to.
    /// This member is required.
    public var resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
    /// The type of Image Builder resource that the lifecycle policy applies to.
    /// This member is required.
    public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
    /// Indicates whether the lifecycle policy resource is enabled.
    public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?
    /// Tags to apply to the lifecycle policy resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        name: Swift.String? = nil,
        policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil,
        resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection? = nil,
        resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
        status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.executionRole = executionRole
        self.name = name
        self.policyDetails = policyDetails
        self.resourceSelection = resourceSelection
        self.resourceType = resourceType
        self.status = status
        self.tags = tags
    }
}

struct CreateLifecyclePolicyInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let status: ImagebuilderClientTypes.LifecyclePolicyStatus?
    let executionRole: Swift.String?
    let resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
    let policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
    let resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case executionRole
        case name
        case policyDetails
        case resourceSelection
        case resourceType
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyStatus.self, forKey: .status)
        status = statusDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let policyDetailsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecyclePolicyDetail?].self, forKey: .policyDetails)
        var policyDetailsDecoded0:[ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil
        if let policyDetailsContainer = policyDetailsContainer {
            policyDetailsDecoded0 = [ImagebuilderClientTypes.LifecyclePolicyDetail]()
            for structure0 in policyDetailsContainer {
                if let structure0 = structure0 {
                    policyDetailsDecoded0?.append(structure0)
                }
            }
        }
        policyDetails = policyDetailsDecoded0
        let resourceSelectionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceSelection.self, forKey: .resourceSelection)
        resourceSelection = resourceSelectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.lifecyclePolicyArn = output.lifecyclePolicyArn
        } else {
            self.clientToken = nil
            self.lifecyclePolicyArn = nil
        }
    }
}

public struct CreateLifecyclePolicyOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the lifecycle policy that the request created.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

struct CreateLifecyclePolicyOutputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let lifecyclePolicyArn: Swift.String?
}

extension CreateLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case lifecyclePolicyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let lifecyclePolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyArn)
        lifecyclePolicyArn = lifecyclePolicyArnDecoded
    }
}

enum CreateLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.CvssScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseScore
        case scoringVector
        case source
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseScore = self.baseScore {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore)
        baseScore = baseScoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Amazon Inspector generates a risk score for each finding. This score helps you to prioritize findings, to focus on the most critical findings and the most vulnerable resources. The score uses the Common Vulnerability Scoring System (CVSS) format. This format is a modification of the base CVSS score that the National Vulnerability Database (NVD) provides. For more information about severity levels, see [Severity levels for Amazon Inspector findings](https://docs.aws.amazon.com/inspector/latest/user/findings-understanding-severity.html) in the Amazon Inspector User Guide.
    public struct CvssScore: Swift.Equatable {
        /// The CVSS base score.
        public var baseScore: Swift.Double?
        /// The vector string of the CVSS score.
        public var scoringVector: Swift.String?
        /// The source of the CVSS score.
        public var source: Swift.String?
        /// The CVSS version that generated the score.
        public var version: Swift.String?

        public init(
            baseScore: Swift.Double? = nil,
            scoringVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.CvssScoreAdjustment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Details about an adjustment that Amazon Inspector made to the CVSS score for a finding.
    public struct CvssScoreAdjustment: Swift.Equatable {
        /// The metric that Amazon Inspector used to adjust the CVSS score.
        public var metric: Swift.String?
        /// The reason for the CVSS score adjustment.
        public var reason: Swift.String?

        public init(
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension ImagebuilderClientTypes.CvssScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustments
        case cvssSource
        case score
        case scoreSource
        case scoringVector
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustments = adjustments {
            var adjustmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adjustments)
            for cvssscoreadjustment0 in adjustments {
                try adjustmentsContainer.encode(cvssscoreadjustment0)
            }
        }
        if let cvssSource = self.cvssSource {
            try encodeContainer.encode(cvssSource, forKey: .cvssSource)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let scoreSource = self.scoreSource {
            try encodeContainer.encode(scoreSource, forKey: .scoreSource)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoreSource)
        scoreSource = scoreSourceDecoded
        let cvssSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cvssSource)
        cvssSource = cvssSourceDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let adjustmentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.CvssScoreAdjustment?].self, forKey: .adjustments)
        var adjustmentsDecoded0:[ImagebuilderClientTypes.CvssScoreAdjustment]? = nil
        if let adjustmentsContainer = adjustmentsContainer {
            adjustmentsDecoded0 = [ImagebuilderClientTypes.CvssScoreAdjustment]()
            for structure0 in adjustmentsContainer {
                if let structure0 = structure0 {
                    adjustmentsDecoded0?.append(structure0)
                }
            }
        }
        adjustments = adjustmentsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Details about the source of the score, and the factors that determined the adjustments to create the final score.
    public struct CvssScoreDetails: Swift.Equatable {
        /// An object that contains details about an adjustment that Amazon Inspector made to the CVSS score for the finding.
        public var adjustments: [ImagebuilderClientTypes.CvssScoreAdjustment]?
        /// The source of the finding.
        public var cvssSource: Swift.String?
        /// The CVSS score.
        public var score: Swift.Double?
        /// The source for the CVSS score.
        public var scoreSource: Swift.String?
        /// A vector that measures the severity of the vulnerability.
        public var scoringVector: Swift.String?
        /// The CVSS version that generated the score.
        public var version: Swift.String?

        public init(
            adjustments: [ImagebuilderClientTypes.CvssScoreAdjustment]? = nil,
            cvssSource: Swift.String? = nil,
            score: Swift.Double? = nil,
            scoreSource: Swift.String? = nil,
            scoringVector: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }
    }

}

extension DeleteComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let componentBuildVersionArn = componentBuildVersionArn else {
                let message = "Creating a URL Query Item failed. componentBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let componentBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
            items.append(componentBuildVersionArnQueryItem)
            return items
        }
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteComponent"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component build version to delete.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init(
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteComponentOutput: Swift.Equatable {
    /// The ARN of the component build version that this request deleted.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteComponentOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentBuildVersionArn: Swift.String?
}

extension DeleteComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

enum DeleteComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContainerRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let containerRecipeArn = containerRecipeArn else {
                let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            items.append(containerRecipeArnQueryItem)
            return items
        }
    }
}

extension DeleteContainerRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteContainerRecipe"
    }
}

public struct DeleteContainerRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe to delete.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct DeleteContainerRecipeInputBody: Swift.Equatable {
}

extension DeleteContainerRecipeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContainerRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteContainerRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteContainerRecipeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct DeleteContainerRecipeOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipeArn: Swift.String?
}

extension DeleteContainerRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

enum DeleteContainerRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDistributionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let distributionConfigurationArn = distributionConfigurationArn else {
                let message = "Creating a URL Query Item failed. distributionConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let distributionConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
            items.append(distributionConfigurationArnQueryItem)
            return items
        }
    }
}

extension DeleteDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteDistributionConfiguration"
    }
}

public struct DeleteDistributionConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init(
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct DeleteDistributionConfigurationInputBody: Swift.Equatable {
}

extension DeleteDistributionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDistributionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteDistributionConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteDistributionConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let distributionConfigurationArn: Swift.String?
}

extension DeleteDistributionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigurationArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

enum DeleteDistributionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageBuildVersionArn = imageBuildVersionArn else {
                let message = "Creating a URL Query Item failed. imageBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imageBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
            items.append(imageBuildVersionArnQueryItem)
            return items
        }
    }
}

extension DeleteImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteImage"
    }
}

public struct DeleteImageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct DeleteImageInputBody: Swift.Equatable {
}

extension DeleteImageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageOutput: Swift.Equatable {
    /// The ARN of the Image Builder image resource that this request deleted.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteImageOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension DeleteImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

enum DeleteImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImagePipelineInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imagePipelineArn = imagePipelineArn else {
                let message = "Creating a URL Query Item failed. imagePipelineArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imagePipelineArnQueryItem = ClientRuntime.URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
            items.append(imagePipelineArnQueryItem)
            return items
        }
    }
}

extension DeleteImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteImagePipeline"
    }
}

public struct DeleteImagePipelineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline to delete.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init(
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct DeleteImagePipelineInputBody: Swift.Equatable {
}

extension DeleteImagePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImagePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImagePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImagePipelineOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct DeleteImagePipelineOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePipelineArn: Swift.String?
}

extension DeleteImagePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

enum DeleteImagePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImageRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageRecipeArn = imageRecipeArn else {
                let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            items.append(imageRecipeArnQueryItem)
            return items
        }
    }
}

extension DeleteImageRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteImageRecipe"
    }
}

public struct DeleteImageRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe to delete.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct DeleteImageRecipeInputBody: Swift.Equatable {
}

extension DeleteImageRecipeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteImageRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageRecipeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct DeleteImageRecipeOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipeArn: Swift.String?
}

extension DeleteImageRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

enum DeleteImageRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInfrastructureConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let infrastructureConfigurationArn = infrastructureConfigurationArn else {
                let message = "Creating a URL Query Item failed. infrastructureConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let infrastructureConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
            items.append(infrastructureConfigurationArnQueryItem)
            return items
        }
    }
}

extension DeleteInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteInfrastructureConfiguration"
    }
}

public struct DeleteInfrastructureConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init(
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct DeleteInfrastructureConfigurationInputBody: Swift.Equatable {
}

extension DeleteInfrastructureConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInfrastructureConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteInfrastructureConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteInfrastructureConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteInfrastructureConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
}

extension DeleteInfrastructureConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfigurationArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

enum DeleteInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLifecyclePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let lifecyclePolicyArn = lifecyclePolicyArn else {
                let message = "Creating a URL Query Item failed. lifecyclePolicyArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let lifecyclePolicyArnQueryItem = ClientRuntime.URLQueryItem(name: "lifecyclePolicyArn".urlPercentEncoding(), value: Swift.String(lifecyclePolicyArn).urlPercentEncoding())
            items.append(lifecyclePolicyArnQueryItem)
            return items
        }
    }
}

extension DeleteLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLifecyclePolicy"
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the lifecycle policy resource to delete.
    /// This member is required.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyArn = output.lifecyclePolicyArn
        } else {
            self.lifecyclePolicyArn = nil
        }
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Equatable {
    /// The ARN of the lifecycle policy that was deleted.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

struct DeleteLifecyclePolicyOutputBody: Swift.Equatable {
    let lifecyclePolicyArn: Swift.String?
}

extension DeleteLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyArn)
        lifecyclePolicyArn = lifecyclePolicyArnDecoded
    }
}

enum DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceDependencyException": return try await ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum DiskImageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case raw
        case vhd
        case vmdk
        case sdkUnknown(Swift.String)

        public static var allCases: [DiskImageFormat] {
            return [
                .raw,
                .vhd,
                .vmdk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .raw: return "RAW"
            case .vhd: return "VHD"
            case .vmdk: return "VMDK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiskImageFormat(rawValue: rawValue) ?? DiskImageFormat.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.Distribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiDistributionConfiguration
        case containerDistributionConfiguration
        case fastLaunchConfigurations
        case launchTemplateConfigurations
        case licenseConfigurationArns
        case region
        case s3ExportConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiDistributionConfiguration = self.amiDistributionConfiguration {
            try encodeContainer.encode(amiDistributionConfiguration, forKey: .amiDistributionConfiguration)
        }
        if let containerDistributionConfiguration = self.containerDistributionConfiguration {
            try encodeContainer.encode(containerDistributionConfiguration, forKey: .containerDistributionConfiguration)
        }
        if let fastLaunchConfigurations = fastLaunchConfigurations {
            var fastLaunchConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fastLaunchConfigurations)
            for fastlaunchconfiguration0 in fastLaunchConfigurations {
                try fastLaunchConfigurationsContainer.encode(fastlaunchconfiguration0)
            }
        }
        if let launchTemplateConfigurations = launchTemplateConfigurations {
            var launchTemplateConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchTemplateConfigurations)
            for launchtemplateconfiguration0 in launchTemplateConfigurations {
                try launchTemplateConfigurationsContainer.encode(launchtemplateconfiguration0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for licenseconfigurationarn0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(licenseconfigurationarn0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let s3ExportConfiguration = self.s3ExportConfiguration {
            try encodeContainer.encode(s3ExportConfiguration, forKey: .s3ExportConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let amiDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AmiDistributionConfiguration.self, forKey: .amiDistributionConfiguration)
        amiDistributionConfiguration = amiDistributionConfigurationDecoded
        let containerDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerDistributionConfiguration.self, forKey: .containerDistributionConfiguration)
        containerDistributionConfiguration = containerDistributionConfigurationDecoded
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let launchTemplateConfigurationsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LaunchTemplateConfiguration?].self, forKey: .launchTemplateConfigurations)
        var launchTemplateConfigurationsDecoded0:[ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil
        if let launchTemplateConfigurationsContainer = launchTemplateConfigurationsContainer {
            launchTemplateConfigurationsDecoded0 = [ImagebuilderClientTypes.LaunchTemplateConfiguration]()
            for structure0 in launchTemplateConfigurationsContainer {
                if let structure0 = structure0 {
                    launchTemplateConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        launchTemplateConfigurations = launchTemplateConfigurationsDecoded0
        let s3ExportConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.S3ExportConfiguration.self, forKey: .s3ExportConfiguration)
        s3ExportConfiguration = s3ExportConfigurationDecoded
        let fastLaunchConfigurationsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.FastLaunchConfiguration?].self, forKey: .fastLaunchConfigurations)
        var fastLaunchConfigurationsDecoded0:[ImagebuilderClientTypes.FastLaunchConfiguration]? = nil
        if let fastLaunchConfigurationsContainer = fastLaunchConfigurationsContainer {
            fastLaunchConfigurationsDecoded0 = [ImagebuilderClientTypes.FastLaunchConfiguration]()
            for structure0 in fastLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    fastLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        fastLaunchConfigurations = fastLaunchConfigurationsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Defines the settings for a specific Region.
    public struct Distribution: Swift.Equatable {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public var amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
        public var containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration?
        /// The Windows faster-launching configurations to use for AMI distribution.
        public var fastLaunchConfigurations: [ImagebuilderClientTypes.FastLaunchConfiguration]?
        /// A group of launchTemplateConfiguration settings that apply to image distribution for specified accounts.
        public var launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified Region.
        public var licenseConfigurationArns: [Swift.String]?
        /// The target Region.
        /// This member is required.
        public var region: Swift.String?
        /// Configure export settings to deliver disk images created from your image build, using a file format that is compatible with your VMs in that Region.
        public var s3ExportConfiguration: ImagebuilderClientTypes.S3ExportConfiguration?

        public init(
            amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration? = nil,
            containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration? = nil,
            fastLaunchConfigurations: [ImagebuilderClientTypes.FastLaunchConfiguration]? = nil,
            launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil,
            licenseConfigurationArns: [Swift.String]? = nil,
            region: Swift.String? = nil,
            s3ExportConfiguration: ImagebuilderClientTypes.S3ExportConfiguration? = nil
        )
        {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.fastLaunchConfigurations = fastLaunchConfigurations
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
            self.s3ExportConfiguration = s3ExportConfiguration
        }
    }

}

extension ImagebuilderClientTypes.DistributionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case distributions
        case name
        case tags
        case timeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeoutMinutes = self.timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A distribution configuration.
    public struct DistributionConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which this distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which this distribution configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The distribution objects that apply Region-specific settings for the deployment of the image to targeted Regions.
        public var distributions: [ImagebuilderClientTypes.Distribution]?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// The tags of the distribution configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The maximum duration in minutes for this distribution configuration.
        /// This member is required.
        public var timeoutMinutes: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributions: [ImagebuilderClientTypes.Distribution]? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }
    }

}

extension ImagebuilderClientTypes.DistributionConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case name
        case regions
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for nonemptystring0 in regions {
                try regionsContainer.encode(nonemptystring0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A high-level overview of a distribution configuration.
    public struct DistributionConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which the distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the distribution configuration was updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// A list of Regions where the container image is distributed to.
        public var regions: [Swift.String]?
        /// The tags associated with the distribution configuration.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = self.deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let throughput = self.throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if let volumeSize = self.volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EbsVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Amazon EBS-specific block device mapping specifications.
    public struct EbsInstanceBlockDeviceSpecification: Swift.Equatable {
        /// Use to configure delete on termination of the associated device.
        public var deleteOnTermination: Swift.Bool?
        /// Use to configure device encryption.
        public var encrypted: Swift.Bool?
        /// Use to configure device IOPS.
        public var iops: Swift.Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public var kmsKeyId: Swift.String?
        /// The snapshot that defines the device contents.
        public var snapshotId: Swift.String?
        /// For GP3 volumes only – The throughput in MiB/s that the volume supports.
        public var throughput: Swift.Int?
        /// Use to override the device's volume size.
        public var volumeSize: Swift.Int?
        /// Use to override the device's volume type.
        public var volumeType: ImagebuilderClientTypes.EbsVolumeType?

        public init(
            deleteOnTermination: Swift.Bool? = nil,
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: ImagebuilderClientTypes.EbsVolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension ImagebuilderClientTypes {
    public enum EbsVolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [EbsVolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EbsVolumeType(rawValue: rawValue) ?? EbsVolumeType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.EcrConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerTags
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerTags = containerTags {
            var containerTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerTags)
            for nonemptystring0 in containerTags {
                try containerTagsContainer.encode(nonemptystring0)
            }
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let containerTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .containerTags)
        var containerTagsDecoded0:[Swift.String]? = nil
        if let containerTagsContainer = containerTagsContainer {
            containerTagsDecoded0 = [Swift.String]()
            for string0 in containerTagsContainer {
                if let string0 = string0 {
                    containerTagsDecoded0?.append(string0)
                }
            }
        }
        containerTags = containerTagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Settings that Image Builder uses to configure the ECR repository and the output container images that Amazon Inspector scans.
    public struct EcrConfiguration: Swift.Equatable {
        /// Tags for Image Builder to apply to the output container image that &INS; scans. Tags can help you identify and manage your scanned images.
        public var containerTags: [Swift.String]?
        /// The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you don’t provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository for vulnerability scans of your output container images.
        public var repositoryName: Swift.String?

        public init(
            containerTags: [Swift.String]? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.containerTags = containerTags
            self.repositoryName = repositoryName
        }
    }

}

extension ImagebuilderClientTypes.FastLaunchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case enabled
        case launchTemplate
        case maxParallelLaunches
        case snapshotConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let launchTemplate = self.launchTemplate {
            try encodeContainer.encode(launchTemplate, forKey: .launchTemplate)
        }
        if let maxParallelLaunches = self.maxParallelLaunches {
            try encodeContainer.encode(maxParallelLaunches, forKey: .maxParallelLaunches)
        }
        if let snapshotConfiguration = self.snapshotConfiguration {
            try encodeContainer.encode(snapshotConfiguration, forKey: .snapshotConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let snapshotConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.FastLaunchSnapshotConfiguration.self, forKey: .snapshotConfiguration)
        snapshotConfiguration = snapshotConfigurationDecoded
        let maxParallelLaunchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxParallelLaunches)
        maxParallelLaunches = maxParallelLaunchesDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Define and configure faster launching for output Windows AMIs.
    public struct FastLaunchConfiguration: Swift.Equatable {
        /// The owner account ID for the fast-launch enabled Windows AMI.
        public var accountId: Swift.String?
        /// A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        public var launchTemplate: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification?
        /// The maximum number of parallel instances that are launched for creating resources.
        public var maxParallelLaunches: Swift.Int?
        /// Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        public var snapshotConfiguration: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration?

        public init(
            accountId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            launchTemplate: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification? = nil,
            maxParallelLaunches: Swift.Int? = nil,
            snapshotConfiguration: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration? = nil
        )
        {
            self.accountId = accountId
            self.enabled = enabled
            self.launchTemplate = launchTemplate
            self.maxParallelLaunches = maxParallelLaunches
            self.snapshotConfiguration = snapshotConfiguration
        }
    }

}

extension ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchTemplateId
        case launchTemplateName
        case launchTemplateVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchTemplateId = self.launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if let launchTemplateName = self.launchTemplateName {
            try encodeContainer.encode(launchTemplateName, forKey: .launchTemplateName)
        }
        if let launchTemplateVersion = self.launchTemplateVersion {
            try encodeContainer.encode(launchTemplateVersion, forKey: .launchTemplateVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let launchTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateName)
        launchTemplateName = launchTemplateNameDecoded
        let launchTemplateVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateVersion)
        launchTemplateVersion = launchTemplateVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Identifies the launch template that the associated Windows AMI uses for launching an instance when faster launching is enabled. You can specify either the launchTemplateName or the launchTemplateId, but not both.
    public struct FastLaunchLaunchTemplateSpecification: Swift.Equatable {
        /// The ID of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateName: Swift.String?
        /// The version of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateVersion: Swift.String?

        public init(
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            launchTemplateVersion: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.launchTemplateVersion = launchTemplateVersion
        }
    }

}

extension ImagebuilderClientTypes.FastLaunchSnapshotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetResourceCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetResourceCount = self.targetResourceCount {
            try encodeContainer.encode(targetResourceCount, forKey: .targetResourceCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetResourceCount)
        targetResourceCount = targetResourceCountDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Configuration settings for creating and managing pre-provisioned snapshots for a fast-launch enabled Windows AMI.
    public struct FastLaunchSnapshotConfiguration: Swift.Equatable {
        /// The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
        public var targetResourceCount: Swift.Int?

        public init(
            targetResourceCount: Swift.Int? = nil
        )
        {
            self.targetResourceCount = targetResourceCount
        }
    }

}

extension ImagebuilderClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results from a list operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to perform the requested operation.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let componentBuildVersionArn = componentBuildVersionArn else {
                let message = "Creating a URL Query Item failed. componentBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let componentBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
            items.append(componentBuildVersionArnQueryItem)
            return items
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetComponent"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that you want to get. Regex requires the suffix /\d+$.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init(
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
            self.requestId = output.requestId
        } else {
            self.component = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentOutput: Swift.Equatable {
    /// The component object associated with the specified ARN.
    public var component: ImagebuilderClientTypes.Component?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        component: ImagebuilderClientTypes.Component? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.component = component
        self.requestId = requestId
    }
}

struct GetComponentOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let component: ImagebuilderClientTypes.Component?
}

extension GetComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum GetComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetComponentPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let componentArn = componentArn else {
                let message = "Creating a URL Query Item failed. componentArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let componentArnQueryItem = ClientRuntime.URLQueryItem(name: "componentArn".urlPercentEncoding(), value: Swift.String(componentArn).urlPercentEncoding())
            items.append(componentArnQueryItem)
            return items
        }
    }
}

extension GetComponentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetComponentPolicy"
    }
}

public struct GetComponentPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.
    /// This member is required.
    public var componentArn: Swift.String?

    public init(
        componentArn: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
    }
}

struct GetComponentPolicyInputBody: Swift.Equatable {
}

extension GetComponentPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentPolicyOutput: Swift.Equatable {
    /// The component policy.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetComponentPolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetComponentPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetComponentPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContainerRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let containerRecipeArn = containerRecipeArn else {
                let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            items.append(containerRecipeArnQueryItem)
            return items
        }
    }
}

extension GetContainerRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetContainerRecipe"
    }
}

public struct GetContainerRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipeInputBody: Swift.Equatable {
}

extension GetContainerRecipeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContainerRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContainerRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipe = output.containerRecipe
            self.requestId = output.requestId
        } else {
            self.containerRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipeOutput: Swift.Equatable {
    /// The container recipe object that is returned.
    public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipe = containerRecipe
        self.requestId = requestId
    }
}

struct GetContainerRecipeOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
}

extension GetContainerRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipe
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
    }
}

enum GetContainerRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContainerRecipePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let containerRecipeArn = containerRecipeArn else {
                let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            items.append(containerRecipeArnQueryItem)
            return items
        }
    }
}

extension GetContainerRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetContainerRecipePolicy"
    }
}

public struct GetContainerRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe for the policy being requested.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipePolicyInputBody: Swift.Equatable {
}

extension GetContainerRecipePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContainerRecipePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContainerRecipePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipePolicyOutput: Swift.Equatable {
    /// The container recipe policy object that is returned.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetContainerRecipePolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetContainerRecipePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetContainerRecipePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDistributionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let distributionConfigurationArn = distributionConfigurationArn else {
                let message = "Creating a URL Query Item failed. distributionConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let distributionConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
            items.append(distributionConfigurationArnQueryItem)
            return items
        }
    }
}

extension GetDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDistributionConfiguration"
    }
}

public struct GetDistributionConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to retrieve.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init(
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct GetDistributionConfigurationInputBody: Swift.Equatable {
}

extension GetDistributionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDistributionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfiguration = output.distributionConfiguration
            self.requestId = output.requestId
        } else {
            self.distributionConfiguration = nil
            self.requestId = nil
        }
    }
}

public struct GetDistributionConfigurationOutput: Swift.Equatable {
    /// The distribution configuration object.
    public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfiguration = distributionConfiguration
        self.requestId = requestId
    }
}

struct GetDistributionConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
}

extension GetDistributionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfiguration
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
    }
}

enum GetDistributionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageBuildVersionArn = imageBuildVersionArn else {
                let message = "Creating a URL Query Item failed. imageBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imageBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
            items.append(imageBuildVersionArnQueryItem)
            return items
        }
    }
}

extension GetImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImage"
    }
}

public struct GetImageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that you want to get.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct GetImageInputBody: Swift.Equatable {
}

extension GetImageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
            self.requestId = output.requestId
        } else {
            self.image = nil
            self.requestId = nil
        }
    }
}

public struct GetImageOutput: Swift.Equatable {
    /// The image object.
    public var image: ImagebuilderClientTypes.Image?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        image: ImagebuilderClientTypes.Image? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.image = image
        self.requestId = requestId
    }
}

struct GetImageOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let image: ImagebuilderClientTypes.Image?
}

extension GetImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

enum GetImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImagePipelineInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imagePipelineArn = imagePipelineArn else {
                let message = "Creating a URL Query Item failed. imagePipelineArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imagePipelineArnQueryItem = ClientRuntime.URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
            items.append(imagePipelineArnQueryItem)
            return items
        }
    }
}

extension GetImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImagePipeline"
    }
}

public struct GetImagePipelineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init(
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct GetImagePipelineInputBody: Swift.Equatable {
}

extension GetImagePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImagePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImagePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.imagePipeline = output.imagePipeline
            self.requestId = output.requestId
        } else {
            self.imagePipeline = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePipelineOutput: Swift.Equatable {
    /// The image pipeline object.
    public var imagePipeline: ImagebuilderClientTypes.ImagePipeline?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePipeline: ImagebuilderClientTypes.ImagePipeline? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipeline = imagePipeline
        self.requestId = requestId
    }
}

struct GetImagePipelineOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePipeline: ImagebuilderClientTypes.ImagePipeline?
}

extension GetImagePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipeline
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImagePipeline.self, forKey: .imagePipeline)
        imagePipeline = imagePipelineDecoded
    }
}

enum GetImagePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImagePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageArn = imageArn else {
                let message = "Creating a URL Query Item failed. imageArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imageArnQueryItem = ClientRuntime.URLQueryItem(name: "imageArn".urlPercentEncoding(), value: Swift.String(imageArn).urlPercentEncoding())
            items.append(imageArnQueryItem)
            return items
        }
    }
}

extension GetImagePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImagePolicy"
    }
}

public struct GetImagePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
    /// This member is required.
    public var imageArn: Swift.String?

    public init(
        imageArn: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
    }
}

struct GetImagePolicyInputBody: Swift.Equatable {
}

extension GetImagePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImagePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImagePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePolicyOutput: Swift.Equatable {
    /// The image policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImagePolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetImagePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetImagePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImageRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageRecipeArn = imageRecipeArn else {
                let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            items.append(imageRecipeArnQueryItem)
            return items
        }
    }
}

extension GetImageRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImageRecipe"
    }
}

public struct GetImageRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipeInputBody: Swift.Equatable {
}

extension GetImageRecipeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImageRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImageRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipe = output.imageRecipe
            self.requestId = output.requestId
        } else {
            self.imageRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipeOutput: Swift.Equatable {
    /// The image recipe object.
    public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipe = imageRecipe
        self.requestId = requestId
    }
}

struct GetImageRecipeOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipe: ImagebuilderClientTypes.ImageRecipe?
}

extension GetImageRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipe
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
    }
}

enum GetImageRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImageRecipePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageRecipeArn = imageRecipeArn else {
                let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            items.append(imageRecipeArnQueryItem)
            return items
        }
    }
}

extension GetImageRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImageRecipePolicy"
    }
}

public struct GetImageRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipePolicyInputBody: Swift.Equatable {
}

extension GetImageRecipePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImageRecipePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImageRecipePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipePolicyOutput: Swift.Equatable {
    /// The image recipe policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImageRecipePolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetImageRecipePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetImageRecipePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInfrastructureConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let infrastructureConfigurationArn = infrastructureConfigurationArn else {
                let message = "Creating a URL Query Item failed. infrastructureConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let infrastructureConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
            items.append(infrastructureConfigurationArnQueryItem)
            return items
        }
    }
}

extension GetInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetInfrastructureConfiguration"
    }
}

/// GetInfrastructureConfiguration request object.
public struct GetInfrastructureConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to retrieve.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init(
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct GetInfrastructureConfigurationInputBody: Swift.Equatable {
}

extension GetInfrastructureConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInfrastructureConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInfrastructureConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfiguration = output.infrastructureConfiguration
            self.requestId = output.requestId
        } else {
            self.infrastructureConfiguration = nil
            self.requestId = nil
        }
    }
}

/// GetInfrastructureConfiguration response object.
public struct GetInfrastructureConfigurationOutput: Swift.Equatable {
    /// The infrastructure configuration object.
    public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfiguration = infrastructureConfiguration
        self.requestId = requestId
    }
}

struct GetInfrastructureConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
}

extension GetInfrastructureConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfiguration
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
    }
}

enum GetInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLifecycleExecutionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let lifecycleExecutionId = lifecycleExecutionId else {
                let message = "Creating a URL Query Item failed. lifecycleExecutionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let lifecycleExecutionIdQueryItem = ClientRuntime.URLQueryItem(name: "lifecycleExecutionId".urlPercentEncoding(), value: Swift.String(lifecycleExecutionId).urlPercentEncoding())
            items.append(lifecycleExecutionIdQueryItem)
            return items
        }
    }
}

extension GetLifecycleExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLifecycleExecution"
    }
}

public struct GetLifecycleExecutionInput: Swift.Equatable {
    /// Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    /// This member is required.
    public var lifecycleExecutionId: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
    }
}

struct GetLifecycleExecutionInputBody: Swift.Equatable {
}

extension GetLifecycleExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLifecycleExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecycleExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecycleExecution = output.lifecycleExecution
        } else {
            self.lifecycleExecution = nil
        }
    }
}

public struct GetLifecycleExecutionOutput: Swift.Equatable {
    /// Runtime details for the specified runtime instance of the lifecycle policy.
    public var lifecycleExecution: ImagebuilderClientTypes.LifecycleExecution?

    public init(
        lifecycleExecution: ImagebuilderClientTypes.LifecycleExecution? = nil
    )
    {
        self.lifecycleExecution = lifecycleExecution
    }
}

struct GetLifecycleExecutionOutputBody: Swift.Equatable {
    let lifecycleExecution: ImagebuilderClientTypes.LifecycleExecution?
}

extension GetLifecycleExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecution
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecution.self, forKey: .lifecycleExecution)
        lifecycleExecution = lifecycleExecutionDecoded
    }
}

enum GetLifecycleExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLifecyclePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let lifecyclePolicyArn = lifecyclePolicyArn else {
                let message = "Creating a URL Query Item failed. lifecyclePolicyArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let lifecyclePolicyArnQueryItem = ClientRuntime.URLQueryItem(name: "lifecyclePolicyArn".urlPercentEncoding(), value: Swift.String(lifecyclePolicyArn).urlPercentEncoding())
            items.append(lifecyclePolicyArnQueryItem)
            return items
        }
    }
}

extension GetLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLifecyclePolicy"
    }
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the image lifecycle policy resource to get.
    /// This member is required.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicy = output.lifecyclePolicy
        } else {
            self.lifecyclePolicy = nil
        }
    }
}

public struct GetLifecyclePolicyOutput: Swift.Equatable {
    /// The ARN of the image lifecycle policy resource that was returned.
    public var lifecyclePolicy: ImagebuilderClientTypes.LifecyclePolicy?

    public init(
        lifecyclePolicy: ImagebuilderClientTypes.LifecyclePolicy? = nil
    )
    {
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct GetLifecyclePolicyOutputBody: Swift.Equatable {
    let lifecyclePolicy: ImagebuilderClientTypes.LifecyclePolicy?
}

extension GetLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicy.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

enum GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowExecutionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let workflowExecutionId = workflowExecutionId else {
                let message = "Creating a URL Query Item failed. workflowExecutionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let workflowExecutionIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowExecutionId".urlPercentEncoding(), value: Swift.String(workflowExecutionId).urlPercentEncoding())
            items.append(workflowExecutionIdQueryItem)
            return items
        }
    }
}

extension GetWorkflowExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetWorkflowExecution"
    }
}

public struct GetWorkflowExecutionInput: Swift.Equatable {
    /// Use the unique identifier for a runtime instance of the workflow to get runtime details.
    /// This member is required.
    public var workflowExecutionId: Swift.String?

    public init(
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.workflowExecutionId = workflowExecutionId
    }
}

struct GetWorkflowExecutionInputBody: Swift.Equatable {
}

extension GetWorkflowExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.message = output.message
            self.requestId = output.requestId
            self.startTime = output.startTime
            self.status = output.status
            self.totalStepCount = output.totalStepCount
            self.totalStepsFailed = output.totalStepsFailed
            self.totalStepsSkipped = output.totalStepsSkipped
            self.totalStepsSucceeded = output.totalStepsSucceeded
            self.type = output.type
            self.workflowBuildVersionArn = output.workflowBuildVersionArn
            self.workflowExecutionId = output.workflowExecutionId
        } else {
            self.endTime = nil
            self.imageBuildVersionArn = nil
            self.message = nil
            self.requestId = nil
            self.startTime = nil
            self.status = nil
            self.totalStepCount = 0
            self.totalStepsFailed = 0
            self.totalStepsSkipped = 0
            self.totalStepsSucceeded = 0
            self.type = nil
            self.workflowBuildVersionArn = nil
            self.workflowExecutionId = nil
        }
    }
}

public struct GetWorkflowExecutionOutput: Swift.Equatable {
    /// The timestamp when the specified runtime instance of the workflow finished.
    public var endTime: Swift.String?
    /// The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.
    public var imageBuildVersionArn: Swift.String?
    /// The output message from the specified runtime instance of the workflow, if applicable.
    public var message: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// The timestamp when the specified runtime instance of the workflow started.
    public var startTime: Swift.String?
    /// The current runtime status for the specified runtime instance of the workflow.
    public var status: ImagebuilderClientTypes.WorkflowExecutionStatus?
    /// The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.
    public var totalStepCount: Swift.Int
    /// A runtime count for the number of steps that failed in the specified runtime instance of the workflow.
    public var totalStepsFailed: Swift.Int
    /// A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.
    public var totalStepsSkipped: Swift.Int
    /// A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.
    public var totalStepsSucceeded: Swift.Int
    /// The type of workflow that Image Builder ran for the specified runtime instance of the workflow.
    public var type: ImagebuilderClientTypes.WorkflowType?
    /// The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.
    public var workflowBuildVersionArn: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    public var workflowExecutionId: Swift.String?

    public init(
        endTime: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        startTime: Swift.String? = nil,
        status: ImagebuilderClientTypes.WorkflowExecutionStatus? = nil,
        totalStepCount: Swift.Int = 0,
        totalStepsFailed: Swift.Int = 0,
        totalStepsSkipped: Swift.Int = 0,
        totalStepsSucceeded: Swift.Int = 0,
        type: ImagebuilderClientTypes.WorkflowType? = nil,
        workflowBuildVersionArn: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.imageBuildVersionArn = imageBuildVersionArn
        self.message = message
        self.requestId = requestId
        self.startTime = startTime
        self.status = status
        self.totalStepCount = totalStepCount
        self.totalStepsFailed = totalStepsFailed
        self.totalStepsSkipped = totalStepsSkipped
        self.totalStepsSucceeded = totalStepsSucceeded
        self.type = type
        self.workflowBuildVersionArn = workflowBuildVersionArn
        self.workflowExecutionId = workflowExecutionId
    }
}

struct GetWorkflowExecutionOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let workflowBuildVersionArn: Swift.String?
    let workflowExecutionId: Swift.String?
    let imageBuildVersionArn: Swift.String?
    let type: ImagebuilderClientTypes.WorkflowType?
    let status: ImagebuilderClientTypes.WorkflowExecutionStatus?
    let message: Swift.String?
    let totalStepCount: Swift.Int
    let totalStepsSucceeded: Swift.Int
    let totalStepsFailed: Swift.Int
    let totalStepsSkipped: Swift.Int
    let startTime: Swift.String?
    let endTime: Swift.String?
}

extension GetWorkflowExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case imageBuildVersionArn
        case message
        case requestId
        case startTime
        case status
        case totalStepCount
        case totalStepsFailed
        case totalStepsSkipped
        case totalStepsSucceeded
        case type
        case workflowBuildVersionArn
        case workflowExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let workflowBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowBuildVersionArn)
        workflowBuildVersionArn = workflowBuildVersionArnDecoded
        let workflowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowExecutionId)
        workflowExecutionId = workflowExecutionIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let totalStepCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepCount) ?? 0
        totalStepCount = totalStepCountDecoded
        let totalStepsSucceededDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepsSucceeded) ?? 0
        totalStepsSucceeded = totalStepsSucceededDecoded
        let totalStepsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepsFailed) ?? 0
        totalStepsFailed = totalStepsFailedDecoded
        let totalStepsSkippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepsSkipped) ?? 0
        totalStepsSkipped = totalStepsSkippedDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

enum GetWorkflowExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowStepExecutionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let stepExecutionId = stepExecutionId else {
                let message = "Creating a URL Query Item failed. stepExecutionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let stepExecutionIdQueryItem = ClientRuntime.URLQueryItem(name: "stepExecutionId".urlPercentEncoding(), value: Swift.String(stepExecutionId).urlPercentEncoding())
            items.append(stepExecutionIdQueryItem)
            return items
        }
    }
}

extension GetWorkflowStepExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetWorkflowStepExecution"
    }
}

public struct GetWorkflowStepExecutionInput: Swift.Equatable {
    /// Use the unique identifier for a specific runtime instance of the workflow step to get runtime details for that step.
    /// This member is required.
    public var stepExecutionId: Swift.String?

    public init(
        stepExecutionId: Swift.String? = nil
    )
    {
        self.stepExecutionId = stepExecutionId
    }
}

struct GetWorkflowStepExecutionInputBody: Swift.Equatable {
}

extension GetWorkflowStepExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowStepExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowStepExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.description = output.description
            self.endTime = output.endTime
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.inputs = output.inputs
            self.message = output.message
            self.name = output.name
            self.onFailure = output.onFailure
            self.outputs = output.outputs
            self.requestId = output.requestId
            self.rollbackStatus = output.rollbackStatus
            self.startTime = output.startTime
            self.status = output.status
            self.stepExecutionId = output.stepExecutionId
            self.timeoutSeconds = output.timeoutSeconds
            self.workflowBuildVersionArn = output.workflowBuildVersionArn
            self.workflowExecutionId = output.workflowExecutionId
        } else {
            self.action = nil
            self.description = nil
            self.endTime = nil
            self.imageBuildVersionArn = nil
            self.inputs = nil
            self.message = nil
            self.name = nil
            self.onFailure = nil
            self.outputs = nil
            self.requestId = nil
            self.rollbackStatus = nil
            self.startTime = nil
            self.status = nil
            self.stepExecutionId = nil
            self.timeoutSeconds = nil
            self.workflowBuildVersionArn = nil
            self.workflowExecutionId = nil
        }
    }
}

public struct GetWorkflowStepExecutionOutput: Swift.Equatable {
    /// The name of the action that the specified step performs.
    public var action: Swift.String?
    /// Describes the specified workflow step.
    public var description: Swift.String?
    /// The timestamp when the specified runtime instance of the workflow step finished.
    public var endTime: Swift.String?
    /// The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow step creates.
    public var imageBuildVersionArn: Swift.String?
    /// Input parameters that Image Builder provided for the specified runtime instance of the workflow step.
    public var inputs: Swift.String?
    /// The output message from the specified runtime instance of the workflow step, if applicable.
    public var message: Swift.String?
    /// The name of the specified runtime instance of the workflow step.
    public var name: Swift.String?
    /// The action to perform if the workflow step fails.
    public var onFailure: Swift.String?
    /// The file names that the specified runtime version of the workflow step created as output.
    public var outputs: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// Reports on the rollback status of the specified runtime version of the workflow step, if applicable.
    public var rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus?
    /// The timestamp when the specified runtime version of the workflow step started.
    public var startTime: Swift.String?
    /// The current status for the specified runtime version of the workflow step.
    public var status: ImagebuilderClientTypes.WorkflowStepExecutionStatus?
    /// The unique identifier for the runtime version of the workflow step that you specified in the request.
    public var stepExecutionId: Swift.String?
    /// The maximum duration in seconds for this step to complete its action.
    public var timeoutSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines this workflow step.
    public var workflowBuildVersionArn: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    public var workflowExecutionId: Swift.String?

    public init(
        action: Swift.String? = nil,
        description: Swift.String? = nil,
        endTime: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        inputs: Swift.String? = nil,
        message: Swift.String? = nil,
        name: Swift.String? = nil,
        onFailure: Swift.String? = nil,
        outputs: Swift.String? = nil,
        requestId: Swift.String? = nil,
        rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus? = nil,
        startTime: Swift.String? = nil,
        status: ImagebuilderClientTypes.WorkflowStepExecutionStatus? = nil,
        stepExecutionId: Swift.String? = nil,
        timeoutSeconds: Swift.Int? = nil,
        workflowBuildVersionArn: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.action = action
        self.description = description
        self.endTime = endTime
        self.imageBuildVersionArn = imageBuildVersionArn
        self.inputs = inputs
        self.message = message
        self.name = name
        self.onFailure = onFailure
        self.outputs = outputs
        self.requestId = requestId
        self.rollbackStatus = rollbackStatus
        self.startTime = startTime
        self.status = status
        self.stepExecutionId = stepExecutionId
        self.timeoutSeconds = timeoutSeconds
        self.workflowBuildVersionArn = workflowBuildVersionArn
        self.workflowExecutionId = workflowExecutionId
    }
}

struct GetWorkflowStepExecutionOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let stepExecutionId: Swift.String?
    let workflowBuildVersionArn: Swift.String?
    let workflowExecutionId: Swift.String?
    let imageBuildVersionArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let action: Swift.String?
    let status: ImagebuilderClientTypes.WorkflowStepExecutionStatus?
    let rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus?
    let message: Swift.String?
    let inputs: Swift.String?
    let outputs: Swift.String?
    let startTime: Swift.String?
    let endTime: Swift.String?
    let onFailure: Swift.String?
    let timeoutSeconds: Swift.Int?
}

extension GetWorkflowStepExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case endTime
        case imageBuildVersionArn
        case inputs
        case message
        case name
        case onFailure
        case outputs
        case requestId
        case rollbackStatus
        case startTime
        case status
        case stepExecutionId
        case timeoutSeconds
        case workflowBuildVersionArn
        case workflowExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let stepExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepExecutionId)
        stepExecutionId = stepExecutionIdDecoded
        let workflowBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowBuildVersionArn)
        workflowBuildVersionArn = workflowBuildVersionArnDecoded
        let workflowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowExecutionId)
        workflowExecutionId = workflowExecutionIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowStepExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let rollbackStatusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus.self, forKey: .rollbackStatus)
        rollbackStatus = rollbackStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let inputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputs)
        inputs = inputsDecoded
        let outputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputs)
        outputs = outputsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onFailure)
        onFailure = onFailureDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

enum GetWorkflowStepExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdempotentParameterMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have specified a client token for an operation using parameter values that differ from a previous request that used the same client token.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildType
        case containerRecipe
        case dateCreated
        case deprecationTime
        case distributionConfiguration
        case enhancedImageMetadataEnabled
        case imageRecipe
        case imageScanningConfiguration
        case imageSource
        case imageTestsConfiguration
        case infrastructureConfiguration
        case lifecycleExecutionId
        case name
        case osVersion
        case outputResources
        case platform
        case scanState
        case sourcePipelineArn
        case sourcePipelineName
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let containerRecipe = self.containerRecipe {
            try encodeContainer.encode(containerRecipe, forKey: .containerRecipe)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let deprecationTime = self.deprecationTime {
            try encodeContainer.encodeTimestamp(deprecationTime, format: .epochSeconds, forKey: .deprecationTime)
        }
        if let distributionConfiguration = self.distributionConfiguration {
            try encodeContainer.encode(distributionConfiguration, forKey: .distributionConfiguration)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipe = self.imageRecipe {
            try encodeContainer.encode(imageRecipe, forKey: .imageRecipe)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageSource = self.imageSource {
            try encodeContainer.encode(imageSource.rawValue, forKey: .imageSource)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfiguration = self.infrastructureConfiguration {
            try encodeContainer.encode(infrastructureConfiguration, forKey: .infrastructureConfiguration)
        }
        if let lifecycleExecutionId = self.lifecycleExecutionId {
            try encodeContainer.encode(lifecycleExecutionId, forKey: .lifecycleExecutionId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = self.outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let scanState = self.scanState {
            try encodeContainer.encode(scanState, forKey: .scanState)
        }
        if let sourcePipelineArn = self.sourcePipelineArn {
            try encodeContainer.encode(sourcePipelineArn, forKey: .sourcePipelineArn)
        }
        if let sourcePipelineName = self.sourcePipelineName {
            try encodeContainer.encode(sourcePipelineName, forKey: .sourcePipelineName)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
        let sourcePipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePipelineName)
        sourcePipelineName = sourcePipelineNameDecoded
        let sourcePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePipelineArn)
        sourcePipelineArn = sourcePipelineArnDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.BuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
        let imageSourceDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageSource.self, forKey: .imageSource)
        imageSource = imageSourceDecoded
        let scanStateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanState.self, forKey: .scanState)
        scanState = scanStateDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let deprecationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deprecationTime)
        deprecationTime = deprecationTimeDecoded
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
    }
}

extension ImagebuilderClientTypes {
    /// An Image Builder image. You must specify exactly one recipe for the image – either a container recipe (containerRecipe), which creates a container image, or an image recipe (imageRecipe), which creates an AMI.
    public struct Image: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.
        public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
        /// The date on which Image Builder created this image.
        public var dateCreated: Swift.String?
        /// The time when deprecation occurs for an image resource. This can be a past or future date.
        public var deprecationTime: ClientRuntime.Date?
        /// The distribution configuration that Image Builder used to create this image.
        public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
        /// Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.
        public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
        /// Contains settings for vulnerability scans.
        public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
        /// The origin of the base image that Image Builder used to build this image.
        public var imageSource: ImagebuilderClientTypes.ImageSource?
        /// The image tests that ran when that Image Builder created this image.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The infrastructure that Image Builder used to create this image.
        public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
        /// Identifies the last runtime instance of the lifecycle policy to take action on the image.
        public var lifecycleExecutionId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources that Image Builder produces for this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The image operating system platform, such as Linux or Windows.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Contains information about the current state of scans for this image.
        public var scanState: ImagebuilderClientTypes.ImageScanState?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public var sourcePipelineArn: Swift.String?
        /// The name of the image pipeline that created this image.
        public var sourcePipelineName: Swift.String?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags that apply to this image.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether this image produces an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The semantic version of the image. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
            dateCreated: Swift.String? = nil,
            deprecationTime: ClientRuntime.Date? = nil,
            distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
            imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
            imageSource: ImagebuilderClientTypes.ImageSource? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
            lifecycleExecutionId: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            scanState: ImagebuilderClientTypes.ImageScanState? = nil,
            sourcePipelineArn: Swift.String? = nil,
            sourcePipelineName: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.deprecationTime = deprecationTime
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipe = imageRecipe
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageSource = imageSource
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.lifecycleExecutionId = lifecycleExecutionId
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.scanState = scanState
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ImageAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains vulnerability counts for a specific image.
    public struct ImageAggregation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the image for this aggregation.
        public var imageBuildVersionArn: Swift.String?
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified image.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?

        public init(
            imageBuildVersionArn: Swift.String? = nil,
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil
        )
        {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.severityCounts = severityCounts
        }
    }

}

extension ImagebuilderClientTypes.ImagePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName
        case packageVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Represents a package installed on an Image Builder image.
    public struct ImagePackage: Swift.Equatable {
        /// The name of the package as reported to the operating system package manager.
        public var packageName: Swift.String?
        /// The version of the package as reported to the operating system package manager.
        public var packageVersion: Swift.String?

        public init(
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }

}

extension ImagebuilderClientTypes.ImagePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerRecipeArn
        case dateCreated
        case dateLastRun
        case dateNextRun
        case dateUpdated
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case platform
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateLastRun = self.dateLastRun {
            try encodeContainer.encode(dateLastRun, forKey: .dateLastRun)
        }
        if let dateNextRun = self.dateNextRun {
            try encodeContainer.encode(dateNextRun, forKey: .dateNextRun)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let dateLastRunDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateLastRun)
        dateLastRun = dateLastRunDecoded
        let dateNextRunDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateNextRun)
        dateNextRun = dateNextRunDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Details of an image pipeline.
    public struct ImagePipeline: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.
        public var containerRecipeArn: Swift.String?
        /// The date on which this image pipeline was created.
        public var dateCreated: Swift.String?
        /// This is no longer supported, and does not return a value.
        public var dateLastRun: Swift.String?
        /// The next date when the pipeline is scheduled to run.
        public var dateNextRun: Swift.String?
        /// The date on which this image pipeline was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the image pipeline.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.
        public var distributionConfigurationArn: Swift.String?
        /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.
        public var imageRecipeArn: Swift.String?
        /// Contains settings for vulnerability scans.
        public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
        /// The image tests configuration of the image pipeline.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.
        public var infrastructureConfigurationArn: Swift.String?
        /// The name of the image pipeline.
        public var name: Swift.String?
        /// The platform of the image pipeline.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The schedule of the image pipeline.
        public var schedule: ImagebuilderClientTypes.Schedule?
        /// The status of the image pipeline.
        public var status: ImagebuilderClientTypes.PipelineStatus?
        /// The tags of this image pipeline.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            containerRecipeArn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateLastRun: Swift.String? = nil,
            dateNextRun: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributionConfigurationArn: Swift.String? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            imageRecipeArn: Swift.String? = nil,
            imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfigurationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            schedule: ImagebuilderClientTypes.Schedule? = nil,
            status: ImagebuilderClientTypes.PipelineStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.ImagePipelineAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineArn
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains vulnerability counts for a specific image pipeline.
    public struct ImagePipelineAggregation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the image pipeline for this aggregation.
        public var imagePipelineArn: Swift.String?
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified image pipeline.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?

        public init(
            imagePipelineArn: Swift.String? = nil,
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil
        )
        {
            self.imagePipelineArn = imagePipelineArn
            self.severityCounts = severityCounts
        }
    }

}

extension ImagebuilderClientTypes.ImageRecipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case arn
        case blockDeviceMappings
        case components
        case dateCreated
        case description
        case name
        case owner
        case parentImage
        case platform
        case tags
        case type
        case version
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInstanceConfiguration = self.additionalInstanceConfiguration {
            try encodeContainer.encode(additionalInstanceConfiguration, forKey: .additionalInstanceConfiguration)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let additionalInstanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AdditionalInstanceConfiguration.self, forKey: .additionalInstanceConfiguration)
        additionalInstanceConfiguration = additionalInstanceConfigurationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// An image recipe.
    public struct ImageRecipe: Swift.Equatable {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test your image configuration. Instance configuration adds a layer of control over those instances. You can define settings and add scripts to run when an instance is launched from your AMI.
        public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The block device mappings to apply when creating images from this recipe.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The components that are included in the image recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the image recipe.
        public var description: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies which type of image is created by the recipe - an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image recipe.
        public var version: Swift.String?
        /// The working directory to be used during build and test workflows.
        public var workingDirectory: Swift.String?

        public init(
            additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
            arn: Swift.String? = nil,
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }

}

extension ImagebuilderClientTypes.ImageRecipeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A summary of an image recipe.
    public struct ImageRecipeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.ImageScanFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case description
        case firstObservedAt
        case fixAvailable
        case imageBuildVersionArn
        case imagePipelineArn
        case inspectorScore
        case inspectorScoreDetails
        case packageVulnerabilityDetails
        case remediation
        case severity
        case title
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firstObservedAt = self.firstObservedAt {
            try encodeContainer.encodeTimestamp(firstObservedAt, format: .epochSeconds, forKey: .firstObservedAt)
        }
        if let fixAvailable = self.fixAvailable {
            try encodeContainer.encode(fixAvailable, forKey: .fixAvailable)
        }
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let inspectorScore = self.inspectorScore {
            try encodeContainer.encode(inspectorScore, forKey: .inspectorScore)
        }
        if let inspectorScoreDetails = self.inspectorScoreDetails {
            try encodeContainer.encode(inspectorScoreDetails, forKey: .inspectorScoreDetails)
        }
        if let packageVulnerabilityDetails = self.packageVulnerabilityDetails {
            try encodeContainer.encode(packageVulnerabilityDetails, forKey: .packageVulnerabilityDetails)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let firstObservedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let inspectorScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .inspectorScore)
        inspectorScore = inspectorScoreDecoded
        let inspectorScoreDetailsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InspectorScoreDetails.self, forKey: .inspectorScoreDetails)
        inspectorScoreDetails = inspectorScoreDetailsDecoded
        let packageVulnerabilityDetailsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PackageVulnerabilityDetails.self, forKey: .packageVulnerabilityDetails)
        packageVulnerabilityDetails = packageVulnerabilityDetailsDecoded
        let fixAvailableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fixAvailable)
        fixAvailable = fixAvailableDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains details about a vulnerability scan finding.
    public struct ImageScanFinding: Swift.Equatable {
        /// The Amazon Web Services account ID that's associated with the finding.
        public var awsAccountId: Swift.String?
        /// The description of the finding.
        public var description: Swift.String?
        /// The date and time when the finding was first observed.
        public var firstObservedAt: ClientRuntime.Date?
        /// Details about whether a fix is available for any of the packages that are identified in the finding through a version update.
        public var fixAvailable: Swift.String?
        /// The Amazon Resource Name (ARN) of the image build version that's associated with the finding.
        public var imageBuildVersionArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the image pipeline that's associated with the finding.
        public var imagePipelineArn: Swift.String?
        /// The score that Amazon Inspector assigned for the finding.
        public var inspectorScore: Swift.Double?
        /// An object that contains details of the Amazon Inspector score.
        public var inspectorScoreDetails: ImagebuilderClientTypes.InspectorScoreDetails?
        /// An object that contains the details of a package vulnerability finding.
        public var packageVulnerabilityDetails: ImagebuilderClientTypes.PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate the finding.
        public var remediation: ImagebuilderClientTypes.Remediation?
        /// The severity of the finding.
        public var severity: Swift.String?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of the finding. Image Builder looks for findings of the type PACKAGE_VULNERABILITY that apply to output images, and excludes other types.
        public var type: Swift.String?
        /// The timestamp when the finding was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            firstObservedAt: ClientRuntime.Date? = nil,
            fixAvailable: Swift.String? = nil,
            imageBuildVersionArn: Swift.String? = nil,
            imagePipelineArn: Swift.String? = nil,
            inspectorScore: Swift.Double? = nil,
            inspectorScoreDetails: ImagebuilderClientTypes.InspectorScoreDetails? = nil,
            packageVulnerabilityDetails: ImagebuilderClientTypes.PackageVulnerabilityDetails? = nil,
            remediation: ImagebuilderClientTypes.Remediation? = nil,
            severity: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.imageBuildVersionArn = imageBuildVersionArn
            self.imagePipelineArn = imagePipelineArn
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension ImagebuilderClientTypes.ImageScanFindingAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAggregation
        case imageAggregation
        case imagePipelineAggregation
        case vulnerabilityIdAggregation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAggregation = self.accountAggregation {
            try encodeContainer.encode(accountAggregation, forKey: .accountAggregation)
        }
        if let imageAggregation = self.imageAggregation {
            try encodeContainer.encode(imageAggregation, forKey: .imageAggregation)
        }
        if let imagePipelineAggregation = self.imagePipelineAggregation {
            try encodeContainer.encode(imagePipelineAggregation, forKey: .imagePipelineAggregation)
        }
        if let vulnerabilityIdAggregation = self.vulnerabilityIdAggregation {
            try encodeContainer.encode(vulnerabilityIdAggregation, forKey: .vulnerabilityIdAggregation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAggregationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AccountAggregation.self, forKey: .accountAggregation)
        accountAggregation = accountAggregationDecoded
        let imageAggregationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageAggregation.self, forKey: .imageAggregation)
        imageAggregation = imageAggregationDecoded
        let imagePipelineAggregationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImagePipelineAggregation.self, forKey: .imagePipelineAggregation)
        imagePipelineAggregation = imagePipelineAggregationDecoded
        let vulnerabilityIdAggregationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.VulnerabilityIdAggregation.self, forKey: .vulnerabilityIdAggregation)
        vulnerabilityIdAggregation = vulnerabilityIdAggregationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// This returns exactly one type of aggregation, based on the filter that Image Builder applies in its API action.
    public struct ImageScanFindingAggregation: Swift.Equatable {
        /// Returns an object that contains severity counts based on an account ID.
        public var accountAggregation: ImagebuilderClientTypes.AccountAggregation?
        /// Returns an object that contains severity counts based on the Amazon Resource Name (ARN) for a specific image.
        public var imageAggregation: ImagebuilderClientTypes.ImageAggregation?
        /// Returns an object that contains severity counts based on an image pipeline ARN.
        public var imagePipelineAggregation: ImagebuilderClientTypes.ImagePipelineAggregation?
        /// Returns an object that contains severity counts based on vulnerability ID.
        public var vulnerabilityIdAggregation: ImagebuilderClientTypes.VulnerabilityIdAggregation?

        public init(
            accountAggregation: ImagebuilderClientTypes.AccountAggregation? = nil,
            imageAggregation: ImagebuilderClientTypes.ImageAggregation? = nil,
            imagePipelineAggregation: ImagebuilderClientTypes.ImagePipelineAggregation? = nil,
            vulnerabilityIdAggregation: ImagebuilderClientTypes.VulnerabilityIdAggregation? = nil
        )
        {
            self.accountAggregation = accountAggregation
            self.imageAggregation = imageAggregation
            self.imagePipelineAggregation = imagePipelineAggregation
            self.vulnerabilityIdAggregation = vulnerabilityIdAggregation
        }
    }

}

extension ImagebuilderClientTypes.ImageScanFindingsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A name value pair that Image Builder applies to streamline results from the vulnerability scan findings list action.
    public struct ImageScanFindingsFilter: Swift.Equatable {
        /// The name of the image scan finding filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ImagebuilderClientTypes.ImageScanState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Shows the vulnerability scan status for a specific image, and the reason for that status.
    public struct ImageScanState: Swift.Equatable {
        /// The reason for the scan status for the image.
        public var reason: Swift.String?
        /// The current state of vulnerability scans for the image.
        public var status: ImagebuilderClientTypes.ImageScanStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ImageScanStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageScanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abandoned
        case collecting
        case completed
        case failed
        case pending
        case scanning
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageScanStatus] {
            return [
                .abandoned,
                .collecting,
                .completed,
                .failed,
                .pending,
                .scanning,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abandoned: return "ABANDONED"
            case .collecting: return "COLLECTING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .scanning: return "SCANNING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageScanStatus(rawValue: rawValue) ?? ImageScanStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageScanningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrConfiguration
        case imageScanningEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecrConfiguration = self.ecrConfiguration {
            try encodeContainer.encode(ecrConfiguration, forKey: .ecrConfiguration)
        }
        if let imageScanningEnabled = self.imageScanningEnabled {
            try encodeContainer.encode(imageScanningEnabled, forKey: .imageScanningEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanningEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imageScanningEnabled)
        imageScanningEnabled = imageScanningEnabledDecoded
        let ecrConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EcrConfiguration.self, forKey: .ecrConfiguration)
        ecrConfiguration = ecrConfigurationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains settings for Image Builder image resource and container image scans.
    public struct ImageScanningConfiguration: Swift.Equatable {
        /// Contains Amazon ECR settings for vulnerability scans.
        public var ecrConfiguration: ImagebuilderClientTypes.EcrConfiguration?
        /// A setting that indicates whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
        public var imageScanningEnabled: Swift.Bool?

        public init(
            ecrConfiguration: ImagebuilderClientTypes.EcrConfiguration? = nil,
            imageScanningEnabled: Swift.Bool? = nil
        )
        {
            self.ecrConfiguration = ecrConfiguration
            self.imageScanningEnabled = imageScanningEnabled
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonManaged
        case awsMarketplace
        case custom
        case imported
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSource] {
            return [
                .amazonManaged,
                .awsMarketplace,
                .custom,
                .imported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonManaged: return "AMAZON_MANAGED"
            case .awsMarketplace: return "AWS_MARKETPLACE"
            case .custom: return "CUSTOM"
            case .imported: return "IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageSource(rawValue: rawValue) ?? ImageSource.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Image status and the reason for that status.
    public struct ImageState: Swift.Equatable {
        /// The reason for the status of the image.
        public var reason: Swift.String?
        /// The status of the image.
        public var status: ImagebuilderClientTypes.ImageStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ImageStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case building
        case cancelled
        case creating
        case deleted
        case deprecated
        case disabled
        case distributing
        case failed
        case integrating
        case pending
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStatus] {
            return [
                .available,
                .building,
                .cancelled,
                .creating,
                .deleted,
                .deprecated,
                .disabled,
                .distributing,
                .failed,
                .integrating,
                .pending,
                .testing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .disabled: return "DISABLED"
            case .distributing: return "DISTRIBUTING"
            case .failed: return "FAILED"
            case .integrating: return "INTEGRATING"
            case .pending: return "PENDING"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageStatus(rawValue: rawValue) ?? ImageStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildType
        case dateCreated
        case deprecationTime
        case imageSource
        case lifecycleExecutionId
        case name
        case osVersion
        case outputResources
        case owner
        case platform
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let deprecationTime = self.deprecationTime {
            try encodeContainer.encodeTimestamp(deprecationTime, format: .epochSeconds, forKey: .deprecationTime)
        }
        if let imageSource = self.imageSource {
            try encodeContainer.encode(imageSource.rawValue, forKey: .imageSource)
        }
        if let lifecycleExecutionId = self.lifecycleExecutionId {
            try encodeContainer.encode(lifecycleExecutionId, forKey: .lifecycleExecutionId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = self.outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.BuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
        let imageSourceDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageSource.self, forKey: .imageSource)
        imageSource = imageSourceDecoded
        let deprecationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deprecationTime)
        deprecationTime = deprecationTimeDecoded
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
    }
}

extension ImagebuilderClientTypes {
    /// An image summary.
    public struct ImageSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The date on which Image Builder created this image.
        public var dateCreated: Swift.String?
        /// The time when deprecation occurs for an image resource. This can be a past or future date.
        public var deprecationTime: ClientRuntime.Date?
        /// The origin of the base image that Image Builder used to build this image.
        public var imageSource: ImagebuilderClientTypes.ImageSource?
        /// Identifies the last runtime instance of the lifecycle policy to take action on the image.
        public var lifecycleExecutionId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version of the instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources that Image Builder produced when it created this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The owner of the image.
        public var owner: Swift.String?
        /// The image operating system platform, such as Linux or Windows.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags that apply to this image.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether this image produces an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            dateCreated: Swift.String? = nil,
            deprecationTime: ClientRuntime.Date? = nil,
            imageSource: ImagebuilderClientTypes.ImageSource? = nil,
            lifecycleExecutionId: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.deprecationTime = deprecationTime
            self.imageSource = imageSource
            self.lifecycleExecutionId = lifecycleExecutionId
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ImageTestsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTestsEnabled
        case timeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTestsEnabled = self.imageTestsEnabled {
            try encodeContainer.encode(imageTestsEnabled, forKey: .imageTestsEnabled)
        }
        if let timeoutMinutes = self.timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTestsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imageTestsEnabled)
        imageTestsEnabled = imageTestsEnabledDecoded
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Configure image tests for your pipeline build. Tests run after building the image, to verify that the AMI or container image is valid before distributing it.
    public struct ImageTestsConfiguration: Swift.Equatable {
        /// Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.
        public var imageTestsEnabled: Swift.Bool?
        /// The maximum time in minutes that tests are permitted to run. The timeoutMinutes attribute is not currently active. This value is ignored.
        public var timeoutMinutes: Swift.Int?

        public init(
            imageTestsEnabled: Swift.Bool? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ami
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .ami,
                .docker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ami: return "AMI"
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildType
        case dateCreated
        case imageSource
        case name
        case osVersion
        case owner
        case platform
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let imageSource = self.imageSource {
            try encodeContainer.encode(imageSource.rawValue, forKey: .imageSource)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let buildTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.BuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
        let imageSourceDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageSource.self, forKey: .imageSource)
        imageSource = imageSourceDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The defining characteristics of a specific version of an Image Builder image.
    public struct ImageVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a specific version of an Image Builder image. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The date on which this specific version of the Image Builder image was created.
        public var dateCreated: Swift.String?
        /// The origin of the base image that Image Builder used to build this image.
        public var imageSource: ImagebuilderClientTypes.ImageSource?
        /// The name of this specific version of an Image Builder image.
        public var name: Swift.String?
        /// The operating system version of the Amazon EC2 build instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The owner of the image version.
        public var owner: Swift.String?
        /// The operating system platform of the image version, for example "Windows" or "Linux".
        public var platform: ImagebuilderClientTypes.Platform?
        /// Specifies whether this image produces an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// Details for a specific version of an Image Builder image. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            dateCreated: Swift.String? = nil,
            imageSource: ImagebuilderClientTypes.ImageSource? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.imageSource = imageSource
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }
    }

}

extension ImportComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension ImportComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ImportComponent"
    }
}

public struct ImportComponentInput: Swift.Equatable {
    /// The change description of the component. This description indicates the change that has been made in this version, or what makes this version different from other versions of this component.
    public var changeDescription: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
    public var data: Swift.String?
    /// The description of the component. Describes the contents of the component.
    public var description: Swift.String?
    /// The format of the resource that you want to import as a component.
    /// This member is required.
    public var format: ImagebuilderClientTypes.ComponentFormat?
    /// The ID of the KMS key that should be used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the component.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the component denotes whether the component is used to build the image, or only to test it.
    /// This member is required.
    public var type: ImagebuilderClientTypes.ComponentType?
    /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component.
    public var uri: Swift.String?

    public init(
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        format: ImagebuilderClientTypes.ComponentFormat? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: ImagebuilderClientTypes.ComponentType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.type = type
        self.uri = uri
    }
}

struct ImportComponentInputBody: Swift.Equatable {
    let name: Swift.String?
    let semanticVersion: Swift.String?
    let description: Swift.String?
    let changeDescription: Swift.String?
    let type: ImagebuilderClientTypes.ComponentType?
    let format: ImagebuilderClientTypes.ComponentFormat?
    let platform: ImagebuilderClientTypes.Platform?
    let data: Swift.String?
    let uri: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension ImportComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentFormat.self, forKey: .format)
        format = formatDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct ImportComponentOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported component.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct ImportComponentOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let componentBuildVersionArn: Swift.String?
}

extension ImportComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

enum ImportComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidVersionNumberException": return try await InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportVmImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case osVersion
        case platform
        case semanticVersion
        case tags
        case vmImportTaskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vmImportTaskId = self.vmImportTaskId {
            try encodeContainer.encode(vmImportTaskId, forKey: .vmImportTaskId)
        }
    }
}

extension ImportVmImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ImportVmImage"
    }
}

public struct ImportVmImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description for the base image that is created by the import process.
    public var description: Swift.String?
    /// The name of the base image that is created by the import process.
    /// This member is required.
    public var name: Swift.String?
    /// The operating system version for the imported VM.
    public var osVersion: Swift.String?
    /// The operating system platform for the imported VM.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version to attach to the base image that was created during the import process. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the import resources.
    public var tags: [Swift.String:Swift.String]?
    /// The importTaskId (API) or ImportTaskId (CLI) from the Amazon EC2 VM import process. Image Builder retrieves information from the import process to pull in the AMI that is created from the VM source as the base image for your recipe.
    /// This member is required.
    public var vmImportTaskId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        osVersion: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vmImportTaskId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.osVersion = osVersion
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.vmImportTaskId = vmImportTaskId
    }
}

struct ImportVmImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let semanticVersion: Swift.String?
    let description: Swift.String?
    let platform: ImagebuilderClientTypes.Platform?
    let osVersion: Swift.String?
    let vmImportTaskId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension ImportVmImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case osVersion
        case platform
        case semanticVersion
        case tags
        case vmImportTaskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let vmImportTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmImportTaskId)
        vmImportTaskId = vmImportTaskIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportVmImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportVmImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageArn = output.imageArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageArn = nil
            self.requestId = nil
        }
    }
}

public struct ImportVmImageOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AMI that was created during the VM import process. This AMI is used as the base image for the recipe that imported the VM.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

struct ImportVmImageOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageArn: Swift.String?
    let clientToken: Swift.String?
}

extension ImportVmImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

enum ImportVmImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.InfrastructureConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceMetadataOptions = self.instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = self.terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Details of the infrastructure configuration.
    public struct InfrastructureConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance metadata option settings for the infrastructure configuration.
        public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public var keyPair: Swift.String?
        /// The logging configuration of the infrastructure configuration.
        public var logging: ImagebuilderClientTypes.Logging?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The tags attached to the resource created by Image Builder.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The security group IDs of the infrastructure configuration.
        public var securityGroupIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
        public var snsTopicArn: Swift.String?
        /// The subnet ID of the infrastructure configuration.
        public var subnetId: Swift.String?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The terminate instance on failure configuration of the infrastructure configuration.
        public var terminateInstanceOnFailure: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            keyPair: Swift.String? = nil,
            logging: ImagebuilderClientTypes.Logging? = nil,
            name: Swift.String? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            terminateInstanceOnFailure: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }
    }

}

extension ImagebuilderClientTypes.InfrastructureConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceProfileName
        case instanceTypes
        case name
        case resourceTags
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The infrastructure used when building Amazon EC2 AMIs.
    public struct InfrastructureConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The tags attached to the image created by Image Builder.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            name: Swift.String? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.resourceTags = resourceTags
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.InspectorScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustedCvss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustedCvss = self.adjustedCvss {
            try encodeContainer.encode(adjustedCvss, forKey: .adjustedCvss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adjustedCvssDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.CvssScoreDetails.self, forKey: .adjustedCvss)
        adjustedCvss = adjustedCvssDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Information about the factors that influenced the score that Amazon Inspector assigned for a finding.
    public struct InspectorScoreDetails: Swift.Equatable {
        /// An object that contains details about an adjustment that Amazon Inspector made to the CVSS score for the finding.
        public var adjustedCvss: ImagebuilderClientTypes.CvssScoreDetails?

        public init(
            adjustedCvss: ImagebuilderClientTypes.CvssScoreDetails? = nil
        )
        {
            self.adjustedCvss = adjustedCvss
        }
    }

}

extension ImagebuilderClientTypes.InstanceBlockDeviceMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = self.ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = self.noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = self.virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification.self, forKey: .ebs)
        ebs = ebsDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Defines block device mappings for the instance used to configure your image.
    public struct InstanceBlockDeviceMapping: Swift.Equatable {
        /// The device to which these mappings apply.
        public var deviceName: Swift.String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public var ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the base image.
        public var noDevice: Swift.String?
        /// Use to manage instance ephemeral devices.
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension ImagebuilderClientTypes.InstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappings
        case image
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Defines a custom base AMI and block device mapping configurations of an instance used for building and testing container images.
    public struct InstanceConfiguration: Swift.Equatable {
        /// Defines the block devices to attach for building an instance from this Image Builder AMI.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public var image: Swift.String?

        public init(
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            image: Swift.String? = nil
        )
        {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }
    }

}

extension ImagebuilderClientTypes.InstanceMetadataOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPutResponseHopLimit
        case httpTokens
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPutResponseHopLimit = self.httpPutResponseHopLimit {
            try encodeContainer.encode(httpPutResponseHopLimit, forKey: .httpPutResponseHopLimit)
        }
        if let httpTokens = self.httpTokens {
            try encodeContainer.encode(httpTokens, forKey: .httpTokens)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpTokensDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpTokens)
        httpTokens = httpTokensDecoded
        let httpPutResponseHopLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPutResponseHopLimit)
        httpPutResponseHopLimit = httpPutResponseHopLimitDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The instance metadata options that apply to the HTTP requests that pipeline builds use to launch EC2 build and test instances. For more information about instance metadata options, see [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the Amazon EC2 User Guide for Linux instances, or [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html) in the Amazon EC2 Windows Guide for Windows instances.
    public struct InstanceMetadataOptions: Swift.Equatable {
        /// Limit the number of hops that an instance metadata request can traverse to reach its destination. The default is one hop. However, if HTTP tokens are required, container image builds need a minimum of two hops.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows:
        ///
        /// * required – When you retrieve the IAM role credentials, version 2.0 credentials are returned in all cases.
        ///
        /// * optional – You can include a signed token header in your request to retrieve instance metadata, or you can leave it out. If you include it, version 2.0 credentials are returned for the IAM role. Otherwise, version 1.0 credentials are returned.
        ///
        ///
        /// The default setting is optional.
        public var httpTokens: Swift.String?

        public init(
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil
        )
        {
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }
    }

}

extension InvalidPaginationTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have provided an invalid pagination token in your request.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have specified two or more mutually exclusive parameters. Review the error message for details.
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombinationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API request.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value that you provided for the specified parameter is invalid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have requested an action that that the service doesn't support.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVersionNumberException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidVersionNumberExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your version number is out of bounds or does not follow the required syntax.
public struct InvalidVersionNumberException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidVersionNumberException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidVersionNumberExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidVersionNumberExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.LaunchPermissionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationArns
        case organizationalUnitArns
        case userGroups
        case userIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationArns = organizationArns {
            var organizationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationArns)
            for organizationarn0 in organizationArns {
                try organizationArnsContainer.encode(organizationarn0)
            }
        }
        if let organizationalUnitArns = organizationalUnitArns {
            var organizationalUnitArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitArns)
            for organizationalunitarn0 in organizationalUnitArns {
                try organizationalUnitArnsContainer.encode(organizationalunitarn0)
            }
        }
        if let userGroups = userGroups {
            var userGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userGroups)
            for nonemptystring0 in userGroups {
                try userGroupsContainer.encode(nonemptystring0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for accountid0 in userIds {
                try userIdsContainer.encode(accountid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let userGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userGroups)
        var userGroupsDecoded0:[Swift.String]? = nil
        if let userGroupsContainer = userGroupsContainer {
            userGroupsDecoded0 = [Swift.String]()
            for string0 in userGroupsContainer {
                if let string0 = string0 {
                    userGroupsDecoded0?.append(string0)
                }
            }
        }
        userGroups = userGroupsDecoded0
        let organizationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationArns)
        var organizationArnsDecoded0:[Swift.String]? = nil
        if let organizationArnsContainer = organizationArnsContainer {
            organizationArnsDecoded0 = [Swift.String]()
            for string0 in organizationArnsContainer {
                if let string0 = string0 {
                    organizationArnsDecoded0?.append(string0)
                }
            }
        }
        organizationArns = organizationArnsDecoded0
        let organizationalUnitArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitArns)
        var organizationalUnitArnsDecoded0:[Swift.String]? = nil
        if let organizationalUnitArnsContainer = organizationalUnitArnsContainer {
            organizationalUnitArnsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitArnsContainer {
                if let string0 = string0 {
                    organizationalUnitArnsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitArns = organizationalUnitArnsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Describes the configuration for a launch permission. The launch permission modification request is sent to the [Amazon EC2 ModifyImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html) API on behalf of the user for each Region they have selected to distribute the AMI. To make an AMI public, set the launch permission authorized accounts to all. See the examples for making an AMI public at [Amazon EC2 ModifyImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html).
    public struct LaunchPermissionConfiguration: Swift.Equatable {
        /// The ARN for an Amazon Web Services Organization that you want to share your AMI with. For more information, see [What is Organizations?](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html).
        public var organizationArns: [Swift.String]?
        /// The ARN for an Organizations organizational unit (OU) that you want to share your AMI with. For more information about key concepts for Organizations, see [Organizations terminology and concepts](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html).
        public var organizationalUnitArns: [Swift.String]?
        /// The name of the group.
        public var userGroups: [Swift.String]?
        /// The Amazon Web Services account ID.
        public var userIds: [Swift.String]?

        public init(
            organizationArns: [Swift.String]? = nil,
            organizationalUnitArns: [Swift.String]? = nil,
            userGroups: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.organizationArns = organizationArns
            self.organizationalUnitArns = organizationalUnitArns
            self.userGroups = userGroups
            self.userIds = userIds
        }
    }

}

extension ImagebuilderClientTypes.LaunchTemplateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case launchTemplateId
        case setDefaultVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let launchTemplateId = self.launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if setDefaultVersion != false {
            try encodeContainer.encode(setDefaultVersion, forKey: .setDefaultVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let setDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setDefaultVersion) ?? false
        setDefaultVersion = setDefaultVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Identifies an Amazon EC2 launch template to use for a specific account.
    public struct LaunchTemplateConfiguration: Swift.Equatable {
        /// The account ID that this configuration applies to.
        public var accountId: Swift.String?
        /// Identifies the Amazon EC2 launch template to use.
        /// This member is required.
        public var launchTemplateId: Swift.String?
        /// Set the specified Amazon EC2 launch template as the default launch template for the specified account.
        public var setDefaultVersion: Swift.Bool

        public init(
            accountId: Swift.String? = nil,
            launchTemplateId: Swift.String? = nil,
            setDefaultVersion: Swift.Bool = false
        )
        {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }
    }

}

extension ImagebuilderClientTypes.LifecycleExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case lifecycleExecutionId
        case lifecyclePolicyArn
        case resourcesImpactedSummary
        case startTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let lifecycleExecutionId = self.lifecycleExecutionId {
            try encodeContainer.encode(lifecycleExecutionId, forKey: .lifecycleExecutionId)
        }
        if let lifecyclePolicyArn = self.lifecyclePolicyArn {
            try encodeContainer.encode(lifecyclePolicyArn, forKey: .lifecyclePolicyArn)
        }
        if let resourcesImpactedSummary = self.resourcesImpactedSummary {
            try encodeContainer.encode(resourcesImpactedSummary, forKey: .resourcesImpactedSummary)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
        let lifecyclePolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyArn)
        lifecyclePolicyArn = lifecyclePolicyArnDecoded
        let resourcesImpactedSummaryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary.self, forKey: .resourcesImpactedSummary)
        resourcesImpactedSummary = resourcesImpactedSummaryDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains metadata from a runtime instance of a lifecycle policy.
    public struct LifecycleExecution: Swift.Equatable {
        /// The timestamp when the lifecycle runtime instance completed.
        public var endTime: ClientRuntime.Date?
        /// Identifies the lifecycle policy runtime instance.
        public var lifecycleExecutionId: Swift.String?
        /// The Amazon Resource Name (ARN) of the lifecycle policy that ran.
        public var lifecyclePolicyArn: Swift.String?
        /// Contains information about associated resources that are identified for action by the runtime instance of the lifecycle policy.
        public var resourcesImpactedSummary: ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary?
        /// The timestamp when the lifecycle runtime instance started.
        public var startTime: ClientRuntime.Date?
        /// Runtime state that reports if the policy action ran successfully, failed, or was skipped.
        public var state: ImagebuilderClientTypes.LifecycleExecutionState?

        public init(
            endTime: ClientRuntime.Date? = nil,
            lifecycleExecutionId: Swift.String? = nil,
            lifecyclePolicyArn: Swift.String? = nil,
            resourcesImpactedSummary: ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: ImagebuilderClientTypes.LifecycleExecutionState? = nil
        )
        {
            self.endTime = endTime
            self.lifecycleExecutionId = lifecycleExecutionId
            self.lifecyclePolicyArn = lifecyclePolicyArn
            self.resourcesImpactedSummary = resourcesImpactedSummary
            self.startTime = startTime
            self.state = state
        }
    }

}

extension ImagebuilderClientTypes.LifecycleExecutionResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case action
        case imageUris
        case region
        case resourceId
        case snapshots
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let imageUris = imageUris {
            var imageUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageUris)
            for nonemptystring0 in imageUris {
                try imageUrisContainer.encode(nonemptystring0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let snapshots = snapshots {
            var snapshotsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshots)
            for lifecycleexecutionsnapshotresource0 in snapshots {
                try snapshotsContainer.encode(lifecycleexecutionsnapshotresource0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionResourceState.self, forKey: .state)
        state = stateDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionResourceAction.self, forKey: .action)
        action = actionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let snapshotsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecycleExecutionSnapshotResource?].self, forKey: .snapshots)
        var snapshotsDecoded0:[ImagebuilderClientTypes.LifecycleExecutionSnapshotResource]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [ImagebuilderClientTypes.LifecycleExecutionSnapshotResource]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
        let imageUrisContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageUris)
        var imageUrisDecoded0:[Swift.String]? = nil
        if let imageUrisContainer = imageUrisContainer {
            imageUrisDecoded0 = [Swift.String]()
            for string0 in imageUrisContainer {
                if let string0 = string0 {
                    imageUrisDecoded0?.append(string0)
                }
            }
        }
        imageUris = imageUrisDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Contains details for a resource that the runtime instance of the lifecycle policy identified for action.
    public struct LifecycleExecutionResource: Swift.Equatable {
        /// The account that owns the impacted resource.
        public var accountId: Swift.String?
        /// The action to take for the identified resource.
        public var action: ImagebuilderClientTypes.LifecycleExecutionResourceAction?
        /// For an impacted container image, this identifies a list of URIs for associated container images distributed to ECR repositories.
        public var imageUris: [Swift.String]?
        /// The Amazon Web Services Region where the lifecycle execution resource is stored.
        public var region: Swift.String?
        /// Identifies the impacted resource. The resource ID depends on the type of resource, as follows.
        ///
        /// * Image Builder image resources: Amazon Resource Name (ARN)
        ///
        /// * Distributed AMIs: AMI ID
        ///
        /// * Container images distributed to an ECR repository: image URI or SHA Digest
        public var resourceId: Swift.String?
        /// A list of associated resource snapshots for the impacted resource if it’s an AMI.
        public var snapshots: [ImagebuilderClientTypes.LifecycleExecutionSnapshotResource]?
        /// The runtime state for the lifecycle execution.
        public var state: ImagebuilderClientTypes.LifecycleExecutionResourceState?

        public init(
            accountId: Swift.String? = nil,
            action: ImagebuilderClientTypes.LifecycleExecutionResourceAction? = nil,
            imageUris: [Swift.String]? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            snapshots: [ImagebuilderClientTypes.LifecycleExecutionSnapshotResource]? = nil,
            state: ImagebuilderClientTypes.LifecycleExecutionResourceState? = nil
        )
        {
            self.accountId = accountId
            self.action = action
            self.imageUris = imageUris
            self.region = region
            self.resourceId = resourceId
            self.snapshots = snapshots
            self.state = state
        }
    }

}

extension ImagebuilderClientTypes.LifecycleExecutionResourceAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionResourceActionName.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The lifecycle policy action that was identified for the impacted resource.
    public struct LifecycleExecutionResourceAction: Swift.Equatable {
        /// The name of the resource that was identified for a lifecycle policy action.
        public var name: ImagebuilderClientTypes.LifecycleExecutionResourceActionName?
        /// The reason why the lifecycle policy action is taken.
        public var reason: Swift.String?

        public init(
            name: ImagebuilderClientTypes.LifecycleExecutionResourceActionName? = nil,
            reason: Swift.String? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecycleExecutionResourceActionName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case delete
        case deprecate
        case disable
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleExecutionResourceActionName] {
            return [
                .available,
                .delete,
                .deprecate,
                .disable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .delete: return "DELETE"
            case .deprecate: return "DEPRECATE"
            case .disable: return "DISABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecycleExecutionResourceActionName(rawValue: rawValue) ?? LifecycleExecutionResourceActionName.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionResourceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionResourceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains the state of an impacted resource that the runtime instance of the lifecycle policy identified for action.
    public struct LifecycleExecutionResourceState: Swift.Equatable {
        /// Messaging that clarifies the reason for the assigned status.
        public var reason: Swift.String?
        /// The runtime status of the lifecycle action taken for the impacted resource.
        public var status: ImagebuilderClientTypes.LifecycleExecutionResourceStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.LifecycleExecutionResourceStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecycleExecutionResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case skipped
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleExecutionResourceStatus] {
            return [
                .failed,
                .inProgress,
                .skipped,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .skipped: return "SKIPPED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecycleExecutionResourceStatus(rawValue: rawValue) ?? LifecycleExecutionResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.LifecycleExecutionResourcesImpactedSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasImpactedResources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hasImpactedResources != false {
            try encodeContainer.encode(hasImpactedResources, forKey: .hasImpactedResources)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hasImpactedResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasImpactedResources) ?? false
        hasImpactedResources = hasImpactedResourcesDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains details for an image resource that was identified for a lifecycle action.
    public struct LifecycleExecutionResourcesImpactedSummary: Swift.Equatable {
        /// Indicates whether an image resource that was identified for a lifecycle action has associated resources that are also impacted.
        public var hasImpactedResources: Swift.Bool

        public init(
            hasImpactedResources: Swift.Bool = false
        )
        {
            self.hasImpactedResources = hasImpactedResources
        }
    }

}

extension ImagebuilderClientTypes.LifecycleExecutionSnapshotResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionResourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains the state of an impacted snapshot resource that the runtime instance of the lifecycle policy identified for action.
    public struct LifecycleExecutionSnapshotResource: Swift.Equatable {
        /// Identifies the impacted snapshot resource.
        public var snapshotId: Swift.String?
        /// The runtime status of the lifecycle action taken for the snapshot.
        public var state: ImagebuilderClientTypes.LifecycleExecutionResourceState?

        public init(
            snapshotId: Swift.String? = nil,
            state: ImagebuilderClientTypes.LifecycleExecutionResourceState? = nil
        )
        {
            self.snapshotId = snapshotId
            self.state = state
        }
    }

}

extension ImagebuilderClientTypes.LifecycleExecutionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The current state of the runtime instance of the lifecycle policy.
    public struct LifecycleExecutionState: Swift.Equatable {
        /// The reason for the current status.
        public var reason: Swift.String?
        /// The runtime status of the lifecycle execution.
        public var status: ImagebuilderClientTypes.LifecycleExecutionStatus?

        public init(
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.LifecycleExecutionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecycleExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecycleExecutionStatus(rawValue: rawValue) ?? LifecycleExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.LifecyclePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateLastRun
        case dateUpdated
        case description
        case executionRole
        case name
        case policyDetails
        case resourceSelection
        case resourceType
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateLastRun = self.dateLastRun {
            try encodeContainer.encodeTimestamp(dateLastRun, format: .epochSeconds, forKey: .dateLastRun)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encodeTimestamp(dateUpdated, format: .epochSeconds, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyDetails = policyDetails {
            var policyDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyDetails)
            for lifecyclepolicydetail0 in policyDetails {
                try policyDetailsContainer.encode(lifecyclepolicydetail0)
            }
        }
        if let resourceSelection = self.resourceSelection {
            try encodeContainer.encode(resourceSelection, forKey: .resourceSelection)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyStatus.self, forKey: .status)
        status = statusDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let policyDetailsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecyclePolicyDetail?].self, forKey: .policyDetails)
        var policyDetailsDecoded0:[ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil
        if let policyDetailsContainer = policyDetailsContainer {
            policyDetailsDecoded0 = [ImagebuilderClientTypes.LifecyclePolicyDetail]()
            for structure0 in policyDetailsContainer {
                if let structure0 = structure0 {
                    policyDetailsDecoded0?.append(structure0)
                }
            }
        }
        policyDetails = policyDetailsDecoded0
        let resourceSelectionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceSelection.self, forKey: .resourceSelection)
        resourceSelection = resourceSelectionDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let dateLastRunDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateLastRun)
        dateLastRun = dateLastRunDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// The configuration details for a lifecycle policy resource.
    public struct LifecyclePolicy: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the lifecycle policy resource.
        public var arn: Swift.String?
        /// The timestamp when Image Builder created the lifecycle policy resource.
        public var dateCreated: ClientRuntime.Date?
        /// The timestamp for the last time Image Builder ran the lifecycle policy.
        public var dateLastRun: ClientRuntime.Date?
        /// The timestamp when Image Builder updated the lifecycle policy resource.
        public var dateUpdated: ClientRuntime.Date?
        /// Optional description for the lifecycle policy.
        public var description: Swift.String?
        /// The name of the IAM role that Image Builder uses to run the lifecycle policy. This is a custom role that you create.
        public var executionRole: Swift.String?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The configuration details for a lifecycle policy resource.
        public var policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
        /// Resource selection criteria used to run the lifecycle policy.
        public var resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
        /// The type of resources the lifecycle policy targets.
        public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
        /// Indicates whether the lifecycle policy resource is enabled.
        public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?
        /// To help manage your lifecycle policy resources, you can assign your own metadata to each resource in the form of tags. Each tag consists of a key and an optional value, both of which you define.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: ClientRuntime.Date? = nil,
            dateLastRun: ClientRuntime.Date? = nil,
            dateUpdated: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            name: Swift.String? = nil,
            policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil,
            resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection? = nil,
            resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
            status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.policyDetails = policyDetails
            self.resourceSelection = resourceSelection
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case exclusionRules
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let exclusionRules = self.exclusionRules {
            try encodeContainer.encode(exclusionRules, forKey: .exclusionRules)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailAction.self, forKey: .action)
        action = actionDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailFilter.self, forKey: .filter)
        filter = filterDecoded
        let exclusionRulesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules.self, forKey: .exclusionRules)
        exclusionRules = exclusionRulesDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The configuration details for a lifecycle policy resource.
    public struct LifecyclePolicyDetail: Swift.Equatable {
        /// Configuration details for the policy action.
        /// This member is required.
        public var action: ImagebuilderClientTypes.LifecyclePolicyDetailAction?
        /// Additional rules to specify resources that should be exempt from policy actions.
        public var exclusionRules: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules?
        /// Specifies the resources that the lifecycle policy applies to.
        /// This member is required.
        public var filter: ImagebuilderClientTypes.LifecyclePolicyDetailFilter?

        public init(
            action: ImagebuilderClientTypes.LifecyclePolicyDetailAction? = nil,
            exclusionRules: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules? = nil,
            filter: ImagebuilderClientTypes.LifecyclePolicyDetailFilter? = nil
        )
        {
            self.action = action
            self.exclusionRules = exclusionRules
            self.filter = filter
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyDetailAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeResources
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeResources = self.includeResources {
            try encodeContainer.encode(includeResources, forKey: .includeResources)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailActionType.self, forKey: .type)
        type = typeDecoded
        let includeResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources.self, forKey: .includeResources)
        includeResources = includeResourcesDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains selection criteria for the lifecycle policy.
    public struct LifecyclePolicyDetailAction: Swift.Equatable {
        /// Specifies the resources that the lifecycle policy applies to.
        public var includeResources: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources?
        /// Specifies the lifecycle action to take.
        /// This member is required.
        public var type: ImagebuilderClientTypes.LifecyclePolicyDetailActionType?

        public init(
            includeResources: ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources? = nil,
            type: ImagebuilderClientTypes.LifecyclePolicyDetailActionType? = nil
        )
        {
            self.includeResources = includeResources
            self.type = type
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyDetailActionIncludeResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case containers
        case snapshots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if amis != false {
            try encodeContainer.encode(amis, forKey: .amis)
        }
        if containers != false {
            try encodeContainer.encode(containers, forKey: .containers)
        }
        if snapshots != false {
            try encodeContainer.encode(snapshots, forKey: .snapshots)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .amis) ?? false
        amis = amisDecoded
        let snapshotsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .snapshots) ?? false
        snapshots = snapshotsDecoded
        let containersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containers) ?? false
        containers = containersDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Specifies how the lifecycle policy should apply actions to selected resources.
    public struct LifecyclePolicyDetailActionIncludeResources: Swift.Equatable {
        /// Specifies whether the lifecycle action should apply to distributed AMIs.
        public var amis: Swift.Bool
        /// Specifies whether the lifecycle action should apply to distributed containers.
        public var containers: Swift.Bool
        /// Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.
        public var snapshots: Swift.Bool

        public init(
            amis: Swift.Bool = false,
            containers: Swift.Bool = false,
            snapshots: Swift.Bool = false
        )
        {
            self.amis = amis
            self.containers = containers
            self.snapshots = snapshots
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecyclePolicyDetailActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case deprecate
        case disable
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyDetailActionType] {
            return [
                .delete,
                .deprecate,
                .disable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .deprecate: return "DEPRECATE"
            case .disable: return "DISABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyDetailActionType(rawValue: rawValue) ?? LifecyclePolicyDetailActionType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRules: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case tagMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = self.amis {
            try encodeContainer.encode(amis, forKey: .amis)
        }
        if let tagMap = tagMap {
            var tagMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagMap)
            for (dictKey0, tagMap0) in tagMap {
                try tagMapContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagMap)
        var tagMapDecoded0: [Swift.String:Swift.String]? = nil
        if let tagMapContainer = tagMapContainer {
            tagMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagMapContainer {
                if let tagvalue0 = tagvalue0 {
                    tagMapDecoded0?[key0] = tagvalue0
                }
            }
        }
        tagMap = tagMapDecoded0
        let amisDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis.self, forKey: .amis)
        amis = amisDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Specifies resources that lifecycle policy actions should not apply to.
    public struct LifecyclePolicyDetailExclusionRules: Swift.Equatable {
        /// Lists configuration values that apply to AMIs that Image Builder should exclude from the lifecycle action.
        public var amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis?
        /// Contains a list of tags that Image Builder uses to skip lifecycle actions for AMIs that have them.
        public var tagMap: [Swift.String:Swift.String]?

        public init(
            amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis? = nil,
            tagMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.amis = amis
            self.tagMap = tagMap
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPublic
        case lastLaunched
        case regions
        case sharedAccounts
        case tagMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isPublic != false {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let lastLaunched = self.lastLaunched {
            try encodeContainer.encode(lastLaunched, forKey: .lastLaunched)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for nonemptystring0 in regions {
                try regionsContainer.encode(nonemptystring0)
            }
        }
        if let sharedAccounts = sharedAccounts {
            var sharedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAccounts)
            for accountid0 in sharedAccounts {
                try sharedAccountsContainer.encode(accountid0)
            }
        }
        if let tagMap = tagMap {
            var tagMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagMap)
            for (dictKey0, tagMap0) in tagMap {
                try tagMapContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic) ?? false
        isPublic = isPublicDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let sharedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedAccounts)
        var sharedAccountsDecoded0:[Swift.String]? = nil
        if let sharedAccountsContainer = sharedAccountsContainer {
            sharedAccountsDecoded0 = [Swift.String]()
            for string0 in sharedAccountsContainer {
                if let string0 = string0 {
                    sharedAccountsDecoded0?.append(string0)
                }
            }
        }
        sharedAccounts = sharedAccountsDecoded0
        let lastLaunchedDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched.self, forKey: .lastLaunched)
        lastLaunched = lastLaunchedDecoded
        let tagMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagMap)
        var tagMapDecoded0: [Swift.String:Swift.String]? = nil
        if let tagMapContainer = tagMapContainer {
            tagMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagMapContainer {
                if let tagvalue0 = tagvalue0 {
                    tagMapDecoded0?[key0] = tagvalue0
                }
            }
        }
        tagMap = tagMapDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Defines criteria for AMIs that are excluded from lifecycle actions.
    public struct LifecyclePolicyDetailExclusionRulesAmis: Swift.Equatable {
        /// Configures whether public AMIs are excluded from the lifecycle action.
        public var isPublic: Swift.Bool
        /// Configures Amazon Web Services Regions that are excluded from the lifecycle action.
        public var lastLaunched: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched?
        /// Specifies Amazon Web Services accounts whose resources are excluded from the lifecycle action.
        public var regions: [Swift.String]?
        /// Specifies configuration details for Image Builder to exclude the most recent resources from lifecycle actions.
        public var sharedAccounts: [Swift.String]?
        /// Lists tags that should be excluded from lifecycle actions for the AMIs that have them.
        public var tagMap: [Swift.String:Swift.String]?

        public init(
            isPublic: Swift.Bool = false,
            lastLaunched: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched? = nil,
            regions: [Swift.String]? = nil,
            sharedAccounts: [Swift.String]? = nil,
            tagMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.isPublic = isPublic
            self.lastLaunched = lastLaunched
            self.regions = regions
            self.sharedAccounts = sharedAccounts
            self.tagMap = tagMap
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmisLastLaunched: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyTimeUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Defines criteria to exclude AMIs from lifecycle actions based on the last time they were used to launch an instance.
    public struct LifecyclePolicyDetailExclusionRulesAmisLastLaunched: Swift.Equatable {
        /// Defines the unit of time that the lifecycle policy uses to calculate elapsed time since the last instance launched from the AMI. For example: days, weeks, months, or years.
        /// This member is required.
        public var unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit?
        /// The integer number of units for the time period. For example 6 (months).
        /// This member is required.
        public var value: Swift.Int?

        public init(
            unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyDetailFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retainAtLeast
        case type
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retainAtLeast = self.retainAtLeast {
            try encodeContainer.encode(retainAtLeast, forKey: .retainAtLeast)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailFilterType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyTimeUnit.self, forKey: .unit)
        unit = unitDecoded
        let retainAtLeastDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retainAtLeast)
        retainAtLeast = retainAtLeastDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Defines filters that the lifecycle policy uses to determine impacted resource.
    public struct LifecyclePolicyDetailFilter: Swift.Equatable {
        /// For age-based filters, this is the number of resources to keep on hand after the lifecycle DELETE action is applied. Impacted resources are only deleted if you have more than this number of resources. If you have fewer resources than this number, the impacted resource is not deleted.
        public var retainAtLeast: Swift.Int?
        /// Filter resources based on either age or count.
        /// This member is required.
        public var type: ImagebuilderClientTypes.LifecyclePolicyDetailFilterType?
        /// Defines the unit of time that the lifecycle policy uses to determine impacted resources. This is required for age-based rules.
        public var unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit?
        /// The number of units for the time period or for the count. For example, a value of 6 might refer to six months or six AMIs. For count-based filters, this value represents the minimum number of resources to keep on hand. If you have fewer resources than this number, the resource is excluded from lifecycle actions.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            retainAtLeast: Swift.Int? = nil,
            type: ImagebuilderClientTypes.LifecyclePolicyDetailFilterType? = nil,
            unit: ImagebuilderClientTypes.LifecyclePolicyTimeUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.retainAtLeast = retainAtLeast
            self.type = type
            self.unit = unit
            self.value = value
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecyclePolicyDetailFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case age
        case count
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyDetailFilterType] {
            return [
                .age,
                .count,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .age: return "AGE"
            case .count: return "COUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyDetailFilterType(rawValue: rawValue) ?? LifecyclePolicyDetailFilterType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.LifecyclePolicyResourceSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipes
        case tagMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipes = recipes {
            var recipesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipes)
            for lifecyclepolicyresourceselectionrecipe0 in recipes {
                try recipesContainer.encode(lifecyclepolicyresourceselectionrecipe0)
            }
        }
        if let tagMap = tagMap {
            var tagMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagMap)
            for (dictKey0, tagMap0) in tagMap {
                try tagMapContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe?].self, forKey: .recipes)
        var recipesDecoded0:[ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let tagMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagMap)
        var tagMapDecoded0: [Swift.String:Swift.String]? = nil
        if let tagMapContainer = tagMapContainer {
            tagMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagMapContainer {
                if let tagvalue0 = tagvalue0 {
                    tagMapDecoded0?[key0] = tagvalue0
                }
            }
        }
        tagMap = tagMapDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Resource selection criteria for the lifecycle policy.
    public struct LifecyclePolicyResourceSelection: Swift.Equatable {
        /// A list of recipes that are used as selection criteria for the output images that the lifecycle policy applies to.
        public var recipes: [ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe]?
        /// A list of tags that are used as selection criteria for the resources that the lifecycle policy applies to.
        public var tagMap: [Swift.String:Swift.String]?

        public init(
            recipes: [ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe]? = nil,
            tagMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.recipes = recipes
            self.tagMap = tagMap
        }
    }

}

extension ImagebuilderClientTypes.LifecyclePolicyResourceSelectionRecipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case semanticVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Specifies an Image Builder recipe that the lifecycle policy uses for resource selection.
    public struct LifecyclePolicyResourceSelectionRecipe: Swift.Equatable {
        /// The name of an Image Builder recipe that the lifecycle policy uses for resource selection.
        /// This member is required.
        public var name: Swift.String?
        /// The version of the Image Builder recipe specified by the name field.
        /// This member is required.
        public var semanticVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            semanticVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.semanticVersion = semanticVersion
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecyclePolicyResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amiImage
        case containerImage
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyResourceType] {
            return [
                .amiImage,
                .containerImage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amiImage: return "AMI_IMAGE"
            case .containerImage: return "CONTAINER_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyResourceType(rawValue: rawValue) ?? LifecyclePolicyResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum LifecyclePolicyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyStatus(rawValue: rawValue) ?? LifecyclePolicyStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.LifecyclePolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateLastRun
        case dateUpdated
        case description
        case executionRole
        case name
        case resourceType
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateLastRun = self.dateLastRun {
            try encodeContainer.encodeTimestamp(dateLastRun, format: .epochSeconds, forKey: .dateLastRun)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encodeTimestamp(dateUpdated, format: .epochSeconds, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyStatus.self, forKey: .status)
        status = statusDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let dateLastRunDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateLastRun)
        dateLastRun = dateLastRunDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Contains a summary of lifecycle policy resources.
    public struct LifecyclePolicySummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the lifecycle policy summary resource.
        public var arn: Swift.String?
        /// The timestamp when Image Builder created the lifecycle policy resource.
        public var dateCreated: ClientRuntime.Date?
        /// The timestamp for the last time Image Builder ran the lifecycle policy.
        public var dateLastRun: ClientRuntime.Date?
        /// The timestamp when Image Builder updated the lifecycle policy resource.
        public var dateUpdated: ClientRuntime.Date?
        /// Optional description for the lifecycle policy.
        public var description: Swift.String?
        /// The name of the IAM role that Image Builder uses to run the lifecycle policy.
        public var executionRole: Swift.String?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The type of resources the lifecycle policy targets.
        public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
        /// The lifecycle policy resource status.
        public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?
        /// To help manage your lifecycle policy resources, you can assign your own metadata to each resource in the form of tags. Each tag consists of a key and an optional value, both of which you define.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dateCreated: ClientRuntime.Date? = nil,
            dateLastRun: ClientRuntime.Date? = nil,
            dateUpdated: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
            status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes {
    public enum LifecyclePolicyTimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case months
        case weeks
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyTimeUnit] {
            return [
                .days,
                .months,
                .weeks,
                .years,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .weeks: return "WEEKS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyTimeUnit(rawValue: rawValue) ?? LifecyclePolicyTimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension ListComponentBuildVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersionArn = self.componentVersionArn {
            try encodeContainer.encode(componentVersionArn, forKey: .componentVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentBuildVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListComponentBuildVersions"
    }
}

public struct ListComponentBuildVersionsInput: Swift.Equatable {
    /// The component version Amazon Resource Name (ARN) whose versions you want to list.
    /// This member is required.
    public var componentVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        componentVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersionArn = componentVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentBuildVersionsInputBody: Swift.Equatable {
    let componentVersionArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListComponentBuildVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersionArn)
        componentVersionArn = componentVersionArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentBuildVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentBuildVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentSummaryList = output.componentSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentBuildVersionsOutput: Swift.Equatable {
    /// The list of component summaries for the specified semantic version.
    public var componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentSummaryList = componentSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentBuildVersionsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentBuildVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentSummary?].self, forKey: .componentSummaryList)
        var componentSummaryListDecoded0:[ImagebuilderClientTypes.ComponentSummary]? = nil
        if let componentSummaryListContainer = componentSummaryListContainer {
            componentSummaryListDecoded0 = [ImagebuilderClientTypes.ComponentSummary]()
            for structure0 in componentSummaryListContainer {
                if let structure0 = structure0 {
                    componentSummaryListDecoded0?.append(structure0)
                }
            }
        }
        componentSummaryList = componentSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentBuildVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byName = self.byName {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListComponents"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// Returns the list of components for the specified name.
    public var byName: Swift.Bool?
    /// Use the following filters to streamline results:
    ///
    /// * description
    ///
    /// * name
    ///
    /// * platform
    ///
    /// * supportedOsVersion
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Filters results based on the type of owner for the component. By default, this request returns a list of components that your account owns. To see results for other types of owners, you can specify components that Amazon manages, third party components, or components that other accounts have shared with you.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        byName: Swift.Bool? = nil,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let byName: Swift.Bool?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .byName)
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentVersionList = output.componentVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// The list of component semantic versions. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them.
    public var componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentVersionList: [ImagebuilderClientTypes.ComponentVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentVersionList = componentVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentVersionListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentVersion?].self, forKey: .componentVersionList)
        var componentVersionListDecoded0:[ImagebuilderClientTypes.ComponentVersion]? = nil
        if let componentVersionListContainer = componentVersionListContainer {
            componentVersionListDecoded0 = [ImagebuilderClientTypes.ComponentVersion]()
            for structure0 in componentVersionListContainer {
                if let structure0 = structure0 {
                    componentVersionListDecoded0?.append(structure0)
                }
            }
        }
        componentVersionList = componentVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContainerRecipesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListContainerRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListContainerRecipes"
    }
}

public struct ListContainerRecipesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * containerType
    ///
    /// * name
    ///
    /// * parentImage
    ///
    /// * platform
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListContainerRecipesInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListContainerRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContainerRecipesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContainerRecipesOutputBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeSummaryList = output.containerRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.containerRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListContainerRecipesOutput: Swift.Equatable {
    /// The list of container recipes returned for the request.
    public var containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeSummaryList = containerRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListContainerRecipesOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    let nextToken: Swift.String?
}

extension ListContainerRecipesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ContainerRecipeSummary?].self, forKey: .containerRecipeSummaryList)
        var containerRecipeSummaryListDecoded0:[ImagebuilderClientTypes.ContainerRecipeSummary]? = nil
        if let containerRecipeSummaryListContainer = containerRecipeSummaryListContainer {
            containerRecipeSummaryListDecoded0 = [ImagebuilderClientTypes.ContainerRecipeSummary]()
            for structure0 in containerRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    containerRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        containerRecipeSummaryList = containerRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContainerRecipesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDistributionConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDistributionConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListDistributionConfigurations"
    }
}

public struct ListDistributionConfigurationsInput: Swift.Equatable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributionConfigurationsInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDistributionConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDistributionConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDistributionConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfigurationSummaryList = output.distributionConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListDistributionConfigurationsOutput: Swift.Equatable {
    /// The list of distributions.
    public var distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListDistributionConfigurationsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListDistributionConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.DistributionConfigurationSummary?].self, forKey: .distributionConfigurationSummaryList)
        var distributionConfigurationSummaryListDecoded0:[ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil
        if let distributionConfigurationSummaryListContainer = distributionConfigurationSummaryListContainer {
            distributionConfigurationSummaryListDecoded0 = [ImagebuilderClientTypes.DistributionConfigurationSummary]()
            for structure0 in distributionConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    distributionConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        distributionConfigurationSummaryList = distributionConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDistributionConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImageBuildVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let imageVersionArn = self.imageVersionArn {
            try encodeContainer.encode(imageVersionArn, forKey: .imageVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImageBuildVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImageBuildVersions"
    }
}

public struct ListImageBuildVersionsInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * osVersion
    ///
    /// * platform
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.
    /// This member is required.
    public var imageVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imageVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imageVersionArn = imageVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImageBuildVersionsInputBody: Swift.Equatable {
    let imageVersionArn: Swift.String?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImageBuildVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersionArn)
        imageVersionArn = imageVersionArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageBuildVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImageBuildVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageBuildVersionsOutput: Swift.Equatable {
    /// The list of image build versions.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageBuildVersionsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    let nextToken: Swift.String?
}

extension ListImageBuildVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImagebuilderClientTypes.ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImagebuilderClientTypes.ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImageBuildVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImagePackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImagePackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImagePackages"
    }
}

public struct ListImagePackagesInput: Swift.Equatable {
    /// Filter results for the ListImagePackages request by the Image Build Version ARN
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePackagesInputBody: Swift.Equatable {
    let imageBuildVersionArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImagePackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImagePackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imagePackageList = output.imagePackageList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePackageList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePackagesOutput: Swift.Equatable {
    /// The list of Image Packages returned in the response.
    public var imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePackageList: [ImagebuilderClientTypes.ImagePackage]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePackageList = imagePackageList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePackagesOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    let nextToken: Swift.String?
}

extension ListImagePackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePackageList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePackageListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImagePackage?].self, forKey: .imagePackageList)
        var imagePackageListDecoded0:[ImagebuilderClientTypes.ImagePackage]? = nil
        if let imagePackageListContainer = imagePackageListContainer {
            imagePackageListDecoded0 = [ImagebuilderClientTypes.ImagePackage]()
            for structure0 in imagePackageListContainer {
                if let structure0 = structure0 {
                    imagePackageListDecoded0?.append(structure0)
                }
            }
        }
        imagePackageList = imagePackageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImagePackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImagePipelineImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImagePipelineImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImagePipelineImages"
    }
}

public struct ListImagePipelineImagesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imagePipelineArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imagePipelineArn = imagePipelineArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelineImagesInputBody: Swift.Equatable {
    let imagePipelineArn: Swift.String?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImagePipelineImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelineImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImagePipelineImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelineImagesOutput: Swift.Equatable {
    /// The list of images built by this pipeline.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelineImagesOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    let nextToken: Swift.String?
}

extension ListImagePipelineImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImagebuilderClientTypes.ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImagebuilderClientTypes.ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImagePipelineImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImagePipelinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImagePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImagePipelines"
    }
}

public struct ListImagePipelinesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * description
    ///
    /// * distributionConfigurationArn
    ///
    /// * imageRecipeArn
    ///
    /// * infrastructureConfigurationArn
    ///
    /// * name
    ///
    /// * status
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelinesInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImagePipelinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImagePipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imagePipelineList = output.imagePipelineList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePipelineList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelinesOutput: Swift.Equatable {
    /// The list of image pipelines.
    public var imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineList = imagePipelineList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelinesOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    let nextToken: Swift.String?
}

extension ListImagePipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImagePipeline?].self, forKey: .imagePipelineList)
        var imagePipelineListDecoded0:[ImagebuilderClientTypes.ImagePipeline]? = nil
        if let imagePipelineListContainer = imagePipelineListContainer {
            imagePipelineListDecoded0 = [ImagebuilderClientTypes.ImagePipeline]()
            for structure0 in imagePipelineListContainer {
                if let structure0 = structure0 {
                    imagePipelineListDecoded0?.append(structure0)
                }
            }
        }
        imagePipelineList = imagePipelineListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImagePipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImageRecipesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListImageRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImageRecipes"
    }
}

public struct ListImageRecipesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * parentImage
    ///
    /// * platform
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which image recipes you want to list. By default, this request will only show image recipes owned by your account. You can use this field to specify if you want to view image recipes owned by yourself, by Amazon, or those image recipes that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImageRecipesInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImageRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageRecipesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImageRecipesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeSummaryList = output.imageRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageRecipesOutput: Swift.Equatable {
    /// The list of image pipelines.
    public var imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeSummaryList = imageRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageRecipesOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    let nextToken: Swift.String?
}

extension ListImageRecipesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageRecipeSummary?].self, forKey: .imageRecipeSummaryList)
        var imageRecipeSummaryListDecoded0:[ImagebuilderClientTypes.ImageRecipeSummary]? = nil
        if let imageRecipeSummaryListContainer = imageRecipeSummaryListContainer {
            imageRecipeSummaryListDecoded0 = [ImagebuilderClientTypes.ImageRecipeSummary]()
            for structure0 in imageRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    imageRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageRecipeSummaryList = imageRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImageRecipesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImageScanFindingAggregationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImageScanFindingAggregationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImageScanFindingAggregations"
    }
}

public struct ListImageScanFindingAggregationsInput: Swift.Equatable {
    /// A filter name and value pair that is used to return a more specific list of results from a list operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public var filter: ImagebuilderClientTypes.Filter?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filter: ImagebuilderClientTypes.Filter? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.nextToken = nextToken
    }
}

struct ListImageScanFindingAggregationsInputBody: Swift.Equatable {
    let filter: ImagebuilderClientTypes.Filter?
    let nextToken: Swift.String?
}

extension ListImageScanFindingAggregationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageScanFindingAggregationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImageScanFindingAggregationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationType = output.aggregationType
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.responses = output.responses
        } else {
            self.aggregationType = nil
            self.nextToken = nil
            self.requestId = nil
            self.responses = nil
        }
    }
}

public struct ListImageScanFindingAggregationsOutput: Swift.Equatable {
    /// The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to accountId. Aggregation types
    ///
    /// * accountId
    ///
    /// * imageBuildVersionArn
    ///
    /// * imagePipelineArn
    ///
    /// * vulnerabilityId
    ///
    ///
    /// Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.
    public var aggregationType: Swift.String?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// An array of image scan finding aggregations that match the filter criteria.
    public var responses: [ImagebuilderClientTypes.ImageScanFindingAggregation]?

    public init(
        aggregationType: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        responses: [ImagebuilderClientTypes.ImageScanFindingAggregation]? = nil
    )
    {
        self.aggregationType = aggregationType
        self.nextToken = nextToken
        self.requestId = requestId
        self.responses = responses
    }
}

struct ListImageScanFindingAggregationsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let aggregationType: Swift.String?
    let responses: [ImagebuilderClientTypes.ImageScanFindingAggregation]?
    let nextToken: Swift.String?
}

extension ListImageScanFindingAggregationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationType
        case nextToken
        case requestId
        case responses
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let responsesContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageScanFindingAggregation?].self, forKey: .responses)
        var responsesDecoded0:[ImagebuilderClientTypes.ImageScanFindingAggregation]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [ImagebuilderClientTypes.ImageScanFindingAggregation]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImageScanFindingAggregationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImageScanFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for imagescanfindingsfilter0 in filters {
                try filtersContainer.encode(imagescanfindingsfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImageScanFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImageScanFindings"
    }
}

public struct ListImageScanFindingsInput: Swift.Equatable {
    /// An array of name value pairs that you can use to filter your results. You can use the following filters to streamline results:
    ///
    /// * imageBuildVersionArn
    ///
    /// * imagePipelineArn
    ///
    /// * vulnerabilityId
    ///
    /// * severity
    ///
    ///
    /// If you don't request a filter, then all findings in your account are listed.
    public var filters: [ImagebuilderClientTypes.ImageScanFindingsFilter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.ImageScanFindingsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImageScanFindingsInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.ImageScanFindingsFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImageScanFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageScanFindingsFilter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.ImageScanFindingsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.ImageScanFindingsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageScanFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImageScanFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.findings = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageScanFindingsOutput: Swift.Equatable {
    /// The image scan findings for your account that meet your request filter criteria.
    public var findings: [ImagebuilderClientTypes.ImageScanFinding]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        findings: [ImagebuilderClientTypes.ImageScanFinding]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageScanFindingsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let findings: [ImagebuilderClientTypes.ImageScanFinding]?
    let nextToken: Swift.String?
}

extension ListImageScanFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let findingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageScanFinding?].self, forKey: .findings)
        var findingsDecoded0:[ImagebuilderClientTypes.ImageScanFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [ImagebuilderClientTypes.ImageScanFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImageScanFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byName = self.byName {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let includeDeprecated = self.includeDeprecated {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImages"
    }
}

public struct ListImagesInput: Swift.Equatable {
    /// Requests a list of images with a specific recipe name.
    public var byName: Swift.Bool?
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * osVersion
    ///
    /// * platform
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// Includes deprecated images in the response list.
    public var includeDeprecated: Swift.Bool?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which images you want to list. By default, this request will only show images owned by your account. You can use this field to specify if you want to view images owned by yourself, by Amazon, or those images that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init(
        byName: Swift.Bool? = nil,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        includeDeprecated: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImagesInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let byName: Swift.Bool?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let includeDeprecated: Swift.Bool?
}

extension ListImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .byName)
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageVersionList = output.imageVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagesOutput: Swift.Equatable {
    /// The list of image semantic versions. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
    public var imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageVersionList: [ImagebuilderClientTypes.ImageVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageVersionList = imageVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagesOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    let nextToken: Swift.String?
}

extension ListImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageVersionList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageVersionListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageVersion?].self, forKey: .imageVersionList)
        var imageVersionListDecoded0:[ImagebuilderClientTypes.ImageVersion]? = nil
        if let imageVersionListContainer = imageVersionListContainer {
            imageVersionListDecoded0 = [ImagebuilderClientTypes.ImageVersion]()
            for structure0 in imageVersionListContainer {
                if let structure0 = structure0 {
                    imageVersionListDecoded0?.append(structure0)
                }
            }
        }
        imageVersionList = imageVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInfrastructureConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInfrastructureConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListInfrastructureConfigurations"
    }
}

public struct ListInfrastructureConfigurationsInput: Swift.Equatable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInfrastructureConfigurationsInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInfrastructureConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInfrastructureConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInfrastructureConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfigurationSummaryList = output.infrastructureConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListInfrastructureConfigurationsOutput: Swift.Equatable {
    /// The list of infrastructure configurations.
    public var infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListInfrastructureConfigurationsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListInfrastructureConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InfrastructureConfigurationSummary?].self, forKey: .infrastructureConfigurationSummaryList)
        var infrastructureConfigurationSummaryListDecoded0:[ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil
        if let infrastructureConfigurationSummaryListContainer = infrastructureConfigurationSummaryListContainer {
            infrastructureConfigurationSummaryListDecoded0 = [ImagebuilderClientTypes.InfrastructureConfigurationSummary]()
            for structure0 in infrastructureConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    infrastructureConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInfrastructureConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLifecycleExecutionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecutionId
        case maxResults
        case nextToken
        case parentResourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycleExecutionId = self.lifecycleExecutionId {
            try encodeContainer.encode(lifecycleExecutionId, forKey: .lifecycleExecutionId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parentResourceId = self.parentResourceId {
            try encodeContainer.encode(parentResourceId, forKey: .parentResourceId)
        }
    }
}

extension ListLifecycleExecutionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLifecycleExecutionResources"
    }
}

public struct ListLifecycleExecutionResourcesInput: Swift.Equatable {
    /// Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    /// This member is required.
    public var lifecycleExecutionId: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// You can leave this empty to get a list of Image Builder resources that were identified for lifecycle actions. To get a list of associated resources that are impacted for an individual resource (the parent), specify its Amazon Resource Name (ARN). Associated resources are produced from your image and distributed when you run a build, such as AMIs or container images stored in ECR repositories.
    public var parentResourceId: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parentResourceId: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parentResourceId = parentResourceId
    }
}

struct ListLifecycleExecutionResourcesInputBody: Swift.Equatable {
    let lifecycleExecutionId: Swift.String?
    let parentResourceId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLifecycleExecutionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecutionId
        case maxResults
        case nextToken
        case parentResourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
        let parentResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentResourceId)
        parentResourceId = parentResourceIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLifecycleExecutionResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLifecycleExecutionResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecycleExecutionId = output.lifecycleExecutionId
            self.lifecycleExecutionState = output.lifecycleExecutionState
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.lifecycleExecutionId = nil
            self.lifecycleExecutionState = nil
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListLifecycleExecutionResourcesOutput: Swift.Equatable {
    /// Runtime details for the specified runtime instance of the lifecycle policy.
    public var lifecycleExecutionId: Swift.String?
    /// The current state of the lifecycle runtime instance.
    public var lifecycleExecutionState: ImagebuilderClientTypes.LifecycleExecutionState?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// A list of resources that were identified for lifecycle actions.
    public var resources: [ImagebuilderClientTypes.LifecycleExecutionResource]?

    public init(
        lifecycleExecutionId: Swift.String? = nil,
        lifecycleExecutionState: ImagebuilderClientTypes.LifecycleExecutionState? = nil,
        nextToken: Swift.String? = nil,
        resources: [ImagebuilderClientTypes.LifecycleExecutionResource]? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
        self.lifecycleExecutionState = lifecycleExecutionState
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListLifecycleExecutionResourcesOutputBody: Swift.Equatable {
    let lifecycleExecutionId: Swift.String?
    let lifecycleExecutionState: ImagebuilderClientTypes.LifecycleExecutionState?
    let resources: [ImagebuilderClientTypes.LifecycleExecutionResource]?
    let nextToken: Swift.String?
}

extension ListLifecycleExecutionResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecutionId
        case lifecycleExecutionState
        case nextToken
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
        let lifecycleExecutionStateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecycleExecutionState.self, forKey: .lifecycleExecutionState)
        lifecycleExecutionState = lifecycleExecutionStateDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecycleExecutionResource?].self, forKey: .resources)
        var resourcesDecoded0:[ImagebuilderClientTypes.LifecycleExecutionResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [ImagebuilderClientTypes.LifecycleExecutionResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLifecycleExecutionResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLifecycleExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListLifecycleExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLifecycleExecutions"
    }
}

public struct ListLifecycleExecutionsInput: Swift.Equatable {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which to get a list of lifecycle runtime instances.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListLifecycleExecutionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let resourceArn: Swift.String?
}

extension ListLifecycleExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListLifecycleExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLifecycleExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecycleExecutions = output.lifecycleExecutions
            self.nextToken = output.nextToken
        } else {
            self.lifecycleExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLifecycleExecutionsOutput: Swift.Equatable {
    /// A list of lifecycle runtime instances for the specified resource.
    public var lifecycleExecutions: [ImagebuilderClientTypes.LifecycleExecution]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        lifecycleExecutions: [ImagebuilderClientTypes.LifecycleExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lifecycleExecutions = lifecycleExecutions
        self.nextToken = nextToken
    }
}

struct ListLifecycleExecutionsOutputBody: Swift.Equatable {
    let lifecycleExecutions: [ImagebuilderClientTypes.LifecycleExecution]?
    let nextToken: Swift.String?
}

extension ListLifecycleExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecutions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecycleExecution?].self, forKey: .lifecycleExecutions)
        var lifecycleExecutionsDecoded0:[ImagebuilderClientTypes.LifecycleExecution]? = nil
        if let lifecycleExecutionsContainer = lifecycleExecutionsContainer {
            lifecycleExecutionsDecoded0 = [ImagebuilderClientTypes.LifecycleExecution]()
            for structure0 in lifecycleExecutionsContainer {
                if let structure0 = structure0 {
                    lifecycleExecutionsDecoded0?.append(structure0)
                }
            }
        }
        lifecycleExecutions = lifecycleExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLifecycleExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLifecyclePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLifecyclePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLifecyclePolicies"
    }
}

public struct ListLifecyclePoliciesInput: Swift.Equatable {
    /// Streamline results based on one of the following values: Name, Status.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLifecyclePoliciesInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLifecyclePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLifecyclePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLifecyclePoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicySummaryList = output.lifecyclePolicySummaryList
            self.nextToken = output.nextToken
        } else {
            self.lifecyclePolicySummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListLifecyclePoliciesOutput: Swift.Equatable {
    /// A list of lifecycle policies in your Amazon Web Services account that meet the criteria specified in the request.
    public var lifecyclePolicySummaryList: [ImagebuilderClientTypes.LifecyclePolicySummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        lifecyclePolicySummaryList: [ImagebuilderClientTypes.LifecyclePolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lifecyclePolicySummaryList = lifecyclePolicySummaryList
        self.nextToken = nextToken
    }
}

struct ListLifecyclePoliciesOutputBody: Swift.Equatable {
    let lifecyclePolicySummaryList: [ImagebuilderClientTypes.LifecyclePolicySummary]?
    let nextToken: Swift.String?
}

extension ListLifecyclePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicySummaryList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicySummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecyclePolicySummary?].self, forKey: .lifecyclePolicySummaryList)
        var lifecyclePolicySummaryListDecoded0:[ImagebuilderClientTypes.LifecyclePolicySummary]? = nil
        if let lifecyclePolicySummaryListContainer = lifecyclePolicySummaryListContainer {
            lifecyclePolicySummaryListDecoded0 = [ImagebuilderClientTypes.LifecyclePolicySummary]()
            for structure0 in lifecyclePolicySummaryListContainer {
                if let structure0 = structure0 {
                    lifecyclePolicySummaryListDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicySummaryList = lifecyclePolicySummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLifecyclePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkflowExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListWorkflowExecutions"
    }
}

public struct ListWorkflowExecutionsInput: Swift.Equatable {
    /// List all workflow runtime instances for the specified image build version resource ARN.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkflowExecutionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension ListWorkflowExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension ListWorkflowExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.message = output.message
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.workflowExecutions = output.workflowExecutions
        } else {
            self.imageBuildVersionArn = nil
            self.message = nil
            self.nextToken = nil
            self.requestId = nil
            self.workflowExecutions = nil
        }
    }
}

public struct ListWorkflowExecutionsOutput: Swift.Equatable {
    /// The resource ARN of the image build version for which you requested a list of workflow runtime details.
    public var imageBuildVersionArn: Swift.String?
    /// The output message from the list action, if applicable.
    public var message: Swift.String?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// Contains an array of runtime details that represents each time a workflow ran for the requested image build version.
    public var workflowExecutions: [ImagebuilderClientTypes.WorkflowExecutionMetadata]?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        message: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        workflowExecutions: [ImagebuilderClientTypes.WorkflowExecutionMetadata]? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.message = message
        self.nextToken = nextToken
        self.requestId = requestId
        self.workflowExecutions = workflowExecutions
    }
}

struct ListWorkflowExecutionsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let workflowExecutions: [ImagebuilderClientTypes.WorkflowExecutionMetadata]?
    let imageBuildVersionArn: Swift.String?
    let message: Swift.String?
    let nextToken: Swift.String?
}

extension ListWorkflowExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case message
        case nextToken
        case requestId
        case workflowExecutions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let workflowExecutionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.WorkflowExecutionMetadata?].self, forKey: .workflowExecutions)
        var workflowExecutionsDecoded0:[ImagebuilderClientTypes.WorkflowExecutionMetadata]? = nil
        if let workflowExecutionsContainer = workflowExecutionsContainer {
            workflowExecutionsDecoded0 = [ImagebuilderClientTypes.WorkflowExecutionMetadata]()
            for structure0 in workflowExecutionsContainer {
                if let structure0 = structure0 {
                    workflowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        workflowExecutions = workflowExecutionsDecoded0
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkflowExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowStepExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case workflowExecutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workflowExecutionId = self.workflowExecutionId {
            try encodeContainer.encode(workflowExecutionId, forKey: .workflowExecutionId)
        }
    }
}

extension ListWorkflowStepExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListWorkflowStepExecutions"
    }
}

public struct ListWorkflowStepExecutionsInput: Swift.Equatable {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    /// This member is required.
    public var workflowExecutionId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowExecutionId = workflowExecutionId
    }
}

struct ListWorkflowStepExecutionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let workflowExecutionId: Swift.String?
}

extension ListWorkflowStepExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case workflowExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowExecutionId)
        workflowExecutionId = workflowExecutionIdDecoded
    }
}

extension ListWorkflowStepExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowStepExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.message = output.message
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.steps = output.steps
            self.workflowBuildVersionArn = output.workflowBuildVersionArn
            self.workflowExecutionId = output.workflowExecutionId
        } else {
            self.imageBuildVersionArn = nil
            self.message = nil
            self.nextToken = nil
            self.requestId = nil
            self.steps = nil
            self.workflowBuildVersionArn = nil
            self.workflowExecutionId = nil
        }
    }
}

public struct ListWorkflowStepExecutionsOutput: Swift.Equatable {
    /// The image build version resource ARN that's associated with the specified runtime instance of the workflow.
    public var imageBuildVersionArn: Swift.String?
    /// The output message from the list action, if applicable.
    public var message: Swift.String?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?
    /// Contains an array of runtime details that represents each step in this runtime instance of the workflow.
    public var steps: [ImagebuilderClientTypes.WorkflowStepMetadata]?
    /// The build version ARN for the Image Builder workflow resource that defines the steps for this runtime instance of the workflow.
    public var workflowBuildVersionArn: Swift.String?
    /// The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.
    public var workflowExecutionId: Swift.String?

    public init(
        imageBuildVersionArn: Swift.String? = nil,
        message: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        steps: [ImagebuilderClientTypes.WorkflowStepMetadata]? = nil,
        workflowBuildVersionArn: Swift.String? = nil,
        workflowExecutionId: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.message = message
        self.nextToken = nextToken
        self.requestId = requestId
        self.steps = steps
        self.workflowBuildVersionArn = workflowBuildVersionArn
        self.workflowExecutionId = workflowExecutionId
    }
}

struct ListWorkflowStepExecutionsOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let steps: [ImagebuilderClientTypes.WorkflowStepMetadata]?
    let workflowBuildVersionArn: Swift.String?
    let workflowExecutionId: Swift.String?
    let imageBuildVersionArn: Swift.String?
    let message: Swift.String?
    let nextToken: Swift.String?
}

extension ListWorkflowStepExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case message
        case nextToken
        case requestId
        case steps
        case workflowBuildVersionArn
        case workflowExecutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let stepsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.WorkflowStepMetadata?].self, forKey: .steps)
        var stepsDecoded0:[ImagebuilderClientTypes.WorkflowStepMetadata]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [ImagebuilderClientTypes.WorkflowStepMetadata]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let workflowBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowBuildVersionArn)
        workflowBuildVersionArn = workflowBuildVersionArnDecoded
        let workflowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowExecutionId)
        workflowExecutionId = workflowExecutionIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkflowStepExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.Logging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Logs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.S3Logs.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Logging configuration defines where Image Builder uploads your logs.
    public struct Logging: Swift.Equatable {
        /// The Amazon S3 logging configuration.
        public var s3Logs: ImagebuilderClientTypes.S3Logs?

        public init(
            s3Logs: ImagebuilderClientTypes.S3Logs? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }

}

extension ImagebuilderClientTypes.OutputResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case containers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for ami0 in amis {
                try amisContainer.encode(ami0)
            }
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for container0 in containers {
                try containersContainer.encode(container0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Ami?].self, forKey: .amis)
        var amisDecoded0:[ImagebuilderClientTypes.Ami]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [ImagebuilderClientTypes.Ami]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let containersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[ImagebuilderClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [ImagebuilderClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// The resources produced by this image.
    public struct OutputResources: Swift.Equatable {
        /// The Amazon EC2 AMIs created by this image.
        public var amis: [ImagebuilderClientTypes.Ami]?
        /// Container images that the pipeline has generated and stored in the output repository.
        public var containers: [ImagebuilderClientTypes.Container]?

        public init(
            amis: [ImagebuilderClientTypes.Ami]? = nil,
            containers: [ImagebuilderClientTypes.Container]? = nil
        )
        {
            self.amis = amis
            self.containers = containers
        }
    }

}

extension ImagebuilderClientTypes {
    public enum Ownership: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazon
        case `self`
        case shared
        case thirdparty
        case sdkUnknown(Swift.String)

        public static var allCases: [Ownership] {
            return [
                .amazon,
                .self,
                .shared,
                .thirdparty,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazon: return "Amazon"
            case .self: return "Self"
            case .shared: return "Shared"
            case .thirdparty: return "ThirdParty"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ownership(rawValue: rawValue) ?? Ownership.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.PackageVulnerabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss
        case referenceUrls
        case relatedVulnerabilities
        case source
        case sourceUrl
        case vendorCreatedAt
        case vendorSeverity
        case vendorUpdatedAt
        case vulnerabilityId
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvssscore0 in cvss {
                try cvssContainer.encode(cvssscore0)
            }
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for nonemptystring0 in referenceUrls {
                try referenceUrlsContainer.encode(nonemptystring0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for vulnerabilityid0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(vulnerabilityid0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let vendorCreatedAt = self.vendorCreatedAt {
            try encodeContainer.encodeTimestamp(vendorCreatedAt, format: .epochSeconds, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = self.vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = self.vendorUpdatedAt {
            try encodeContainer.encodeTimestamp(vendorUpdatedAt, format: .epochSeconds, forKey: .vendorUpdatedAt)
        }
        if let vulnerabilityId = self.vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for vulnerablepackage0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(vulnerablepackage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.VulnerablePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[ImagebuilderClientTypes.VulnerablePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [ImagebuilderClientTypes.VulnerablePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let cvssContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.CvssScore?].self, forKey: .cvss)
        var cvssDecoded0:[ImagebuilderClientTypes.CvssScore]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [ImagebuilderClientTypes.CvssScore]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Information about package vulnerability findings.
    public struct PackageVulnerabilityDetails: Swift.Equatable {
        /// CVSS scores for one or more vulnerabilities that Amazon Inspector identified for a package.
        public var cvss: [ImagebuilderClientTypes.CvssScore]?
        /// Links to web pages that contain details about the vulnerabilities that Amazon Inspector identified for the package.
        public var referenceUrls: [Swift.String]?
        /// Vulnerabilities that are often related to the findings for the package.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        public var source: Swift.String?
        /// A link to the source of the vulnerability information.
        public var sourceUrl: Swift.String?
        /// The date and time when this vulnerability was first added to the vendor's database.
        public var vendorCreatedAt: ClientRuntime.Date?
        /// The severity that the vendor assigned to this vulnerability type.
        public var vendorSeverity: Swift.String?
        /// The date and time when the vendor last updated this vulnerability in their database.
        public var vendorUpdatedAt: ClientRuntime.Date?
        /// A unique identifier for this vulnerability.
        /// This member is required.
        public var vulnerabilityId: Swift.String?
        /// The packages that this vulnerability impacts.
        public var vulnerablePackages: [ImagebuilderClientTypes.VulnerablePackage]?

        public init(
            cvss: [ImagebuilderClientTypes.CvssScore]? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: ClientRuntime.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: ClientRuntime.Date? = nil,
            vulnerabilityId: Swift.String? = nil,
            vulnerablePackages: [ImagebuilderClientTypes.VulnerablePackage]? = nil
        )
        {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension ImagebuilderClientTypes {
    public enum PipelineExecutionStartCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case expressionMatchAndDependencyUpdatesAvailable
        case expressionMatchOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineExecutionStartCondition] {
            return [
                .expressionMatchAndDependencyUpdatesAvailable,
                .expressionMatchOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .expressionMatchAndDependencyUpdatesAvailable: return "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
            case .expressionMatchOnly: return "EXPRESSION_MATCH_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineExecutionStartCondition(rawValue: rawValue) ?? PipelineExecutionStartCondition.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum PipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineStatus(rawValue: rawValue) ?? PipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension PutComponentPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = self.componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutComponentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutComponentPolicy"
    }
}

public struct PutComponentPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that this policy should be applied to.
    /// This member is required.
    public var componentArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        componentArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.policy = policy
    }
}

struct PutComponentPolicyInputBody: Swift.Equatable {
    let componentArn: Swift.String?
    let policy: Swift.String?
}

extension PutComponentPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutComponentPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutComponentPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentArn = output.componentArn
            self.requestId = output.requestId
        } else {
            self.componentArn = nil
            self.requestId = nil
        }
    }
}

public struct PutComponentPolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that this policy was applied to.
    public var componentArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        componentArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.requestId = requestId
    }
}

struct PutComponentPolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentArn: Swift.String?
}

extension PutComponentPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
    }
}

enum PutComponentPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutContainerRecipePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutContainerRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutContainerRecipePolicy"
    }
}

public struct PutContainerRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.
    /// This member is required.
    public var containerRecipeArn: Swift.String?
    /// The policy to apply to the container recipe.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.policy = policy
    }
}

struct PutContainerRecipePolicyInputBody: Swift.Equatable {
    let containerRecipeArn: Swift.String?
    let policy: Swift.String?
}

extension PutContainerRecipePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerRecipePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutContainerRecipePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutContainerRecipePolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct PutContainerRecipePolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipeArn: Swift.String?
}

extension PutContainerRecipePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

enum PutContainerRecipePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutImagePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutImagePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutImagePolicy"
    }
}

public struct PutImagePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that this policy should be applied to.
    /// This member is required.
    public var imageArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        imageArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.policy = policy
    }
}

struct PutImagePolicyInputBody: Swift.Equatable {
    let imageArn: Swift.String?
    let policy: Swift.String?
}

extension PutImagePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImagePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutImagePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageArn = output.imageArn
            self.requestId = output.requestId
        } else {
            self.imageArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImagePolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

struct PutImagePolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageArn: Swift.String?
}

extension PutImagePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
    }
}

enum PutImagePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutImageRecipePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutImageRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutImageRecipePolicy"
    }
}

public struct PutImageRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.
    /// This member is required.
    public var imageRecipeArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.policy = policy
    }
}

struct PutImageRecipePolicyInputBody: Swift.Equatable {
    let imageRecipeArn: Swift.String?
    let policy: Swift.String?
}

extension PutImageRecipePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImageRecipePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutImageRecipePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImageRecipePolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct PutImageRecipePolicyOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipeArn: Swift.String?
}

extension PutImageRecipePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

enum PutImageRecipePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.Remediation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.RemediationRecommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Information about how to remediate a finding.
    public struct Remediation: Swift.Equatable {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public var recommendation: ImagebuilderClientTypes.RemediationRecommendation?

        public init(
            recommendation: ImagebuilderClientTypes.RemediationRecommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension ImagebuilderClientTypes.RemediationRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Details about the recommended course of action to remediate the finding.
    public struct RemediationRecommendation: Swift.Equatable {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// A link to more information about the recommended remediation for this vulnerability.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that you are trying to create already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDependencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have attempted to mutate or delete a resource with a dependency that prohibits this action. See the error message for more details.
public struct ResourceDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDependencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that you are trying to operate on is currently in use. Review the message details and retry later.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// At least one of the resources referenced by your request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.ResourceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The current state of an impacted resource.
    public struct ResourceState: Swift.Equatable {
        /// Shows the current lifecycle policy action that was applied to an impacted resource.
        public var status: ImagebuilderClientTypes.ResourceStatus?

        public init(
            status: ImagebuilderClientTypes.ResourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes.ResourceStateUpdateExclusionRules: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = self.amis {
            try encodeContainer.encode(amis, forKey: .amis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis.self, forKey: .amis)
        amis = amisDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Additional rules to specify resources that should be exempt from ad-hoc lifecycle actions.
    public struct ResourceStateUpdateExclusionRules: Swift.Equatable {
        /// Defines criteria for AMIs that are excluded from lifecycle actions.
        public var amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis?

        public init(
            amis: ImagebuilderClientTypes.LifecyclePolicyDetailExclusionRulesAmis? = nil
        )
        {
            self.amis = amis
        }
    }

}

extension ImagebuilderClientTypes.ResourceStateUpdateIncludeResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case containers
        case snapshots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if amis != false {
            try encodeContainer.encode(amis, forKey: .amis)
        }
        if containers != false {
            try encodeContainer.encode(containers, forKey: .containers)
        }
        if snapshots != false {
            try encodeContainer.encode(snapshots, forKey: .snapshots)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .amis) ?? false
        amis = amisDecoded
        let snapshotsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .snapshots) ?? false
        snapshots = snapshotsDecoded
        let containersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containers) ?? false
        containers = containersDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Specifies if the lifecycle policy should apply actions to selected resources.
    public struct ResourceStateUpdateIncludeResources: Swift.Equatable {
        /// Specifies whether the lifecycle action should apply to distributed AMIs
        public var amis: Swift.Bool
        /// Specifies whether the lifecycle action should apply to distributed containers.
        public var containers: Swift.Bool
        /// Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.
        public var snapshots: Swift.Bool

        public init(
            amis: Swift.Bool = false,
            containers: Swift.Bool = false,
            snapshots: Swift.Bool = false
        )
        {
            self.amis = amis
            self.containers = containers
            self.snapshots = snapshots
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case deprecated
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .deleted,
                .deprecated,
                .disabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.S3ExportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskImageFormat
        case roleName
        case s3Bucket
        case s3Prefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskImageFormat = self.diskImageFormat {
            try encodeContainer.encode(diskImageFormat.rawValue, forKey: .diskImageFormat)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let diskImageFormatDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DiskImageFormat.self, forKey: .diskImageFormat)
        diskImageFormat = diskImageFormatDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Properties that configure export from your build instance to a compatible file format for your VM.
    public struct S3ExportConfiguration: Swift.Equatable {
        /// Export the updated image to one of the following supported disk image formats:
        ///
        /// * Virtual Hard Disk (VHD) – Compatible with Citrix Xen and Microsoft Hyper-V virtualization products.
        ///
        /// * Stream-optimized ESX Virtual Machine Disk (VMDK) – Compatible with VMware ESX and VMware vSphere versions 4, 5, and 6.
        ///
        /// * Raw – Raw format.
        /// This member is required.
        public var diskImageFormat: ImagebuilderClientTypes.DiskImageFormat?
        /// The name of the role that grants VM Import/Export permission to export images to your S3 bucket.
        /// This member is required.
        public var roleName: Swift.String?
        /// The S3 bucket in which to store the output disk images for your VM.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 path for the bucket where the output disk images for your VM are stored.
        public var s3Prefix: Swift.String?

        public init(
            diskImageFormat: ImagebuilderClientTypes.DiskImageFormat? = nil,
            roleName: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.diskImageFormat = diskImageFormat
            self.roleName = roleName
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension ImagebuilderClientTypes.S3Logs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName
        case s3KeyPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Amazon S3 logging configuration.
    public struct S3Logs: Swift.Equatable {
        /// The S3 bucket in which to store the logs.
        public var s3BucketName: Swift.String?
        /// The Amazon S3 path to the bucket where the logs are stored.
        public var s3KeyPrefix: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension ImagebuilderClientTypes.Schedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionStartCondition
        case scheduleExpression
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionStartCondition = self.pipelineExecutionStartCondition {
            try encodeContainer.encode(pipelineExecutionStartCondition.rawValue, forKey: .pipelineExecutionStartCondition)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let pipelineExecutionStartConditionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineExecutionStartCondition.self, forKey: .pipelineExecutionStartCondition)
        pipelineExecutionStartCondition = pipelineExecutionStartConditionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A schedule configures how often and when a pipeline will automatically create a new image.
    public struct Schedule: Swift.Equatable {
        /// The condition configures when the pipeline should trigger a new image build. When the pipelineExecutionStartCondition is set to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic version filters on the base image or components in your image recipe, EC2 Image Builder will build a new image only when there are new versions of the image or components in your recipe that match the semantic version filter. When it is set to EXPRESSION_MATCH_ONLY, it will build a new image every time the CRON expression matches the current time. For semantic version syntax, see [CreateComponent](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_CreateComponent.html) in the EC2 Image Builder API Reference.
        public var pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition. For information on how to format a cron expression in Image Builder, see [Use cron expressions in EC2 Image Builder](https://docs.aws.amazon.com/imagebuilder/latest/userguide/image-builder-cron.html).
        public var scheduleExpression: Swift.String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the [IANA timezone format](https://www.joda.org/joda-time/timezones.html). If not specified this defaults to UTC.
        public var timezone: Swift.String?

        public init(
            pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition? = nil,
            scheduleExpression: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }
    }

}

extension ServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the service encounters an unrecoverable exception.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the number of permitted resources or operations for this service. For service quotas, see [EC2 Image Builder endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/imagebuilder.html#limits_imagebuilder).
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is unable to process your request at this time.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.SeverityCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case all
        case critical
        case high
        case medium
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let all = self.all {
            try encodeContainer.encode(all, forKey: .all)
        }
        if let critical = self.critical {
            try encodeContainer.encode(critical, forKey: .critical)
        }
        if let high = self.high {
            try encodeContainer.encode(high, forKey: .high)
        }
        if let medium = self.medium {
            try encodeContainer.encode(medium, forKey: .medium)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .all)
        all = allDecoded
        let criticalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .critical)
        critical = criticalDecoded
        let highDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .high)
        high = highDecoded
        let mediumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .medium)
        medium = mediumDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified filter.
    public struct SeverityCounts: Swift.Equatable {
        /// The total number of findings across all severity levels for the specified filter.
        public var all: Swift.Int?
        /// The number of critical severity findings for the specified filter.
        public var critical: Swift.Int?
        /// The number of high severity findings for the specified filter.
        public var high: Swift.Int?
        /// The number of medium severity findings for the specified filter.
        public var medium: Swift.Int?

        public init(
            all: Swift.Int? = nil,
            critical: Swift.Int? = nil,
            high: Swift.Int? = nil,
            medium: Swift.Int? = nil
        )
        {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }
    }

}

extension StartImagePipelineExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
    }
}

extension StartImagePipelineExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartImagePipelineExecution"
    }
}

public struct StartImagePipelineExecutionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
    }
}

struct StartImagePipelineExecutionInputBody: Swift.Equatable {
    let imagePipelineArn: Swift.String?
    let clientToken: Swift.String?
}

extension StartImagePipelineExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartImagePipelineExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImagePipelineExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct StartImagePipelineExecutionOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that the request created.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct StartImagePipelineExecutionOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension StartImagePipelineExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

enum StartImagePipelineExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartResourceStateUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case exclusionRules
        case executionRole
        case includeResources
        case resourceArn
        case state
        case updateAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let exclusionRules = self.exclusionRules {
            try encodeContainer.encode(exclusionRules, forKey: .exclusionRules)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let includeResources = self.includeResources {
            try encodeContainer.encode(includeResources, forKey: .includeResources)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let updateAt = self.updateAt {
            try encodeContainer.encodeTimestamp(updateAt, format: .epochSeconds, forKey: .updateAt)
        }
    }
}

extension StartResourceStateUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartResourceStateUpdate"
    }
}

public struct StartResourceStateUpdateInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Skip action on the image resource and associated resources if specified exclusion rules are met.
    public var exclusionRules: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules?
    /// The name or Amazon Resource Name (ARN) of the IAM role that’s used to update image state.
    public var executionRole: Swift.String?
    /// A list of image resources to update state for.
    public var includeResources: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources?
    /// The ARN of the Image Builder resource that is updated. The state update might also impact associated resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Indicates the lifecycle action to take for this request.
    /// This member is required.
    public var state: ImagebuilderClientTypes.ResourceState?
    /// The timestamp that indicates when resources are updated by a lifecycle action.
    public var updateAt: ClientRuntime.Date?

    public init(
        clientToken: Swift.String? = nil,
        exclusionRules: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules? = nil,
        executionRole: Swift.String? = nil,
        includeResources: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources? = nil,
        resourceArn: Swift.String? = nil,
        state: ImagebuilderClientTypes.ResourceState? = nil,
        updateAt: ClientRuntime.Date? = nil
    )
    {
        self.clientToken = clientToken
        self.exclusionRules = exclusionRules
        self.executionRole = executionRole
        self.includeResources = includeResources
        self.resourceArn = resourceArn
        self.state = state
        self.updateAt = updateAt
    }
}

struct StartResourceStateUpdateInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let state: ImagebuilderClientTypes.ResourceState?
    let executionRole: Swift.String?
    let includeResources: ImagebuilderClientTypes.ResourceStateUpdateIncludeResources?
    let exclusionRules: ImagebuilderClientTypes.ResourceStateUpdateExclusionRules?
    let updateAt: ClientRuntime.Date?
    let clientToken: Swift.String?
}

extension StartResourceStateUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case exclusionRules
        case executionRole
        case includeResources
        case resourceArn
        case state
        case updateAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ResourceState.self, forKey: .state)
        state = stateDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let includeResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ResourceStateUpdateIncludeResources.self, forKey: .includeResources)
        includeResources = includeResourcesDecoded
        let exclusionRulesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ResourceStateUpdateExclusionRules.self, forKey: .exclusionRules)
        exclusionRules = exclusionRulesDecoded
        let updateAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateAt)
        updateAt = updateAtDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartResourceStateUpdateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartResourceStateUpdateOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecycleExecutionId = output.lifecycleExecutionId
            self.resourceArn = output.resourceArn
        } else {
            self.lifecycleExecutionId = nil
            self.resourceArn = nil
        }
    }
}

public struct StartResourceStateUpdateOutput: Swift.Equatable {
    /// Identifies the lifecycle runtime instance that started the resource state update.
    public var lifecycleExecutionId: Swift.String?
    /// The requested ARN of the Image Builder resource for the asynchronous update.
    public var resourceArn: Swift.String?

    public init(
        lifecycleExecutionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.lifecycleExecutionId = lifecycleExecutionId
        self.resourceArn = resourceArn
    }
}

struct StartResourceStateUpdateOutputBody: Swift.Equatable {
    let lifecycleExecutionId: Swift.String?
    let resourceArn: Swift.String?
}

extension StartResourceStateUpdateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleExecutionId
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleExecutionId)
        lifecycleExecutionId = lifecycleExecutionIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum StartResourceStateUpdateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.SystemsManagerAgent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uninstallAfterBuild
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uninstallAfterBuild = self.uninstallAfterBuild {
            try encodeContainer.encode(uninstallAfterBuild, forKey: .uninstallAfterBuild)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uninstallAfterBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .uninstallAfterBuild)
        uninstallAfterBuild = uninstallAfterBuildDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains settings for the Systems Manager agent on your build instance.
    public struct SystemsManagerAgent: Swift.Equatable {
        /// Controls whether the Systems Manager agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
        public var uninstallAfterBuild: Swift.Bool?

        public init(
            uninstallAfterBuild: Swift.Bool? = nil
        )
        {
            self.uninstallAfterBuild = uninstallAfterBuild
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.TargetContainerRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRepositoryService.self, forKey: .service)
        service = serviceDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The container repository where the output container image is stored.
    public struct TargetContainerRepository: Swift.Equatable {
        /// The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// Specifies the service in which this image was registered.
        /// This member is required.
        public var service: ImagebuilderClientTypes.ContainerRepositoryService?

        public init(
            repositoryName: Swift.String? = nil,
            service: ImagebuilderClientTypes.ContainerRepositoryService? = nil
        )
        {
            self.repositoryName = repositoryName
            self.service = service
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDistributionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
    }
}

extension UpdateDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateDistributionConfiguration"
    }
}

public struct UpdateDistributionConfigurationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.distributions = distributions
    }
}

struct UpdateDistributionConfigurationInputBody: Swift.Equatable {
    let distributionConfigurationArn: Swift.String?
    let description: Swift.String?
    let distributions: [ImagebuilderClientTypes.Distribution]?
    let clientToken: Swift.String?
}

extension UpdateDistributionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDistributionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDistributionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateDistributionConfigurationOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateDistributionConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let distributionConfigurationArn: Swift.String?
}

extension UpdateDistributionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

enum UpdateDistributionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateImagePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateImagePipeline"
    }
}

public struct UpdateImagePipelineInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container pipeline to update.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that Image Builder uses to configure and distribute images that this image pipeline has updated.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images updated by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// Contains settings for vulnerability scans.
    public var imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that Image Builder uses to build images that this image pipeline has updated.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?

    public init(
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imagePipelineArn: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imagePipelineArn = imagePipelineArn
        self.imageRecipeArn = imageRecipeArn
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.schedule = schedule
        self.status = status
    }
}

struct UpdateImagePipelineInputBody: Swift.Equatable {
    let imagePipelineArn: Swift.String?
    let description: Swift.String?
    let imageRecipeArn: Swift.String?
    let containerRecipeArn: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
    let distributionConfigurationArn: Swift.String?
    let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    let enhancedImageMetadataEnabled: Swift.Bool?
    let schedule: ImagebuilderClientTypes.Schedule?
    let status: ImagebuilderClientTypes.PipelineStatus?
    let clientToken: Swift.String?
    let imageScanningConfiguration: ImagebuilderClientTypes.ImageScanningConfiguration?
}

extension UpdateImagePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageScanningConfiguration
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension UpdateImagePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateImagePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateImagePipelineOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct UpdateImagePipelineOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imagePipelineArn: Swift.String?
}

extension UpdateImagePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

enum UpdateImagePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateInfrastructureConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let instanceMetadataOptions = self.instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let terminateInstanceOnFailure = self.terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

extension UpdateInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateInfrastructureConfiguration"
    }
}

public struct UpdateInfrastructureConfigurationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to update.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds use to launch EC2 build and test instances. For more information about instance metadata options, see one of the following links:
    ///
    /// * [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the Amazon EC2 User Guide for Linux instances.
    ///
    /// * [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html) in the Amazon EC2 Windows Guide for Windows instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String:Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
    public var snsTopicArn: Swift.String?
    /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
    public var subnetId: Swift.String?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        resourceTags: [Swift.String:Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct UpdateInfrastructureConfigurationInputBody: Swift.Equatable {
    let infrastructureConfigurationArn: Swift.String?
    let description: Swift.String?
    let instanceTypes: [Swift.String]?
    let instanceProfileName: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetId: Swift.String?
    let logging: ImagebuilderClientTypes.Logging?
    let keyPair: Swift.String?
    let terminateInstanceOnFailure: Swift.Bool?
    let snsTopicArn: Swift.String?
    let clientToken: Swift.String?
    let resourceTags: [Swift.String:Swift.String]?
    let instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
}

extension UpdateInfrastructureConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
    }
}

extension UpdateInfrastructureConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateInfrastructureConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateInfrastructureConfigurationOutput: Swift.Equatable {
    /// The client token that uniquely identifies the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateInfrastructureConfigurationOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
}

extension UpdateInfrastructureConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

enum UpdateInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case executionRole
        case lifecyclePolicyArn
        case policyDetails
        case resourceSelection
        case resourceType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let lifecyclePolicyArn = self.lifecyclePolicyArn {
            try encodeContainer.encode(lifecyclePolicyArn, forKey: .lifecyclePolicyArn)
        }
        if let policyDetails = policyDetails {
            var policyDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyDetails)
            for lifecyclepolicydetail0 in policyDetails {
                try policyDetailsContainer.encode(lifecyclepolicydetail0)
            }
        }
        if let resourceSelection = self.resourceSelection {
            try encodeContainer.encode(resourceSelection, forKey: .resourceSelection)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLifecyclePolicy"
    }
}

public struct UpdateLifecyclePolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Optional description for the lifecycle policy.
    public var description: Swift.String?
    /// The name of the IAM role that Image Builder should use to update the lifecycle policy.
    /// This member is required.
    public var executionRole: Swift.String?
    /// The Amazon Resource Name (ARN) of the lifecycle policy resource.
    /// This member is required.
    public var lifecyclePolicyArn: Swift.String?
    /// The configuration details for a lifecycle policy resource.
    /// This member is required.
    public var policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
    /// Selection criteria for resources that the lifecycle policy applies to.
    /// This member is required.
    public var resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
    /// The type of image resource that the lifecycle policy applies to.
    /// This member is required.
    public var resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
    /// Indicates whether the lifecycle policy resource is enabled.
    public var status: ImagebuilderClientTypes.LifecyclePolicyStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        lifecyclePolicyArn: Swift.String? = nil,
        policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil,
        resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection? = nil,
        resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType? = nil,
        status: ImagebuilderClientTypes.LifecyclePolicyStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.executionRole = executionRole
        self.lifecyclePolicyArn = lifecyclePolicyArn
        self.policyDetails = policyDetails
        self.resourceSelection = resourceSelection
        self.resourceType = resourceType
        self.status = status
    }
}

struct UpdateLifecyclePolicyInputBody: Swift.Equatable {
    let lifecyclePolicyArn: Swift.String?
    let description: Swift.String?
    let status: ImagebuilderClientTypes.LifecyclePolicyStatus?
    let executionRole: Swift.String?
    let resourceType: ImagebuilderClientTypes.LifecyclePolicyResourceType?
    let policyDetails: [ImagebuilderClientTypes.LifecyclePolicyDetail]?
    let resourceSelection: ImagebuilderClientTypes.LifecyclePolicyResourceSelection?
    let clientToken: Swift.String?
}

extension UpdateLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case executionRole
        case lifecyclePolicyArn
        case policyDetails
        case resourceSelection
        case resourceType
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyArn)
        lifecyclePolicyArn = lifecyclePolicyArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyStatus.self, forKey: .status)
        status = statusDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let policyDetailsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LifecyclePolicyDetail?].self, forKey: .policyDetails)
        var policyDetailsDecoded0:[ImagebuilderClientTypes.LifecyclePolicyDetail]? = nil
        if let policyDetailsContainer = policyDetailsContainer {
            policyDetailsDecoded0 = [ImagebuilderClientTypes.LifecyclePolicyDetail]()
            for structure0 in policyDetailsContainer {
                if let structure0 = structure0 {
                    policyDetailsDecoded0?.append(structure0)
                }
            }
        }
        policyDetails = policyDetailsDecoded0
        let resourceSelectionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LifecyclePolicyResourceSelection.self, forKey: .resourceSelection)
        resourceSelection = resourceSelectionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyArn = output.lifecyclePolicyArn
        } else {
            self.lifecyclePolicyArn = nil
        }
    }
}

public struct UpdateLifecyclePolicyOutput: Swift.Equatable {
    /// The ARN of the image lifecycle policy resource that was updated.
    public var lifecyclePolicyArn: Swift.String?

    public init(
        lifecyclePolicyArn: Swift.String? = nil
    )
    {
        self.lifecyclePolicyArn = lifecyclePolicyArn
    }
}

struct UpdateLifecyclePolicyOutputBody: Swift.Equatable {
    let lifecyclePolicyArn: Swift.String?
}

extension UpdateLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyArn)
        lifecyclePolicyArn = lifecyclePolicyArnDecoded
    }
}

enum UpdateLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CallRateLimitExceededException": return try await CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationException": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImagebuilderClientTypes.VulnerabilityIdAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case severityCounts
        case vulnerabilityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
        if let vulnerabilityId = self.vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Includes counts of image and pipeline resource findings by vulnerability.
    public struct VulnerabilityIdAggregation: Swift.Equatable {
        /// Counts by severity level for medium severity and higher level findings, plus a total for all of the findings for the specified vulnerability.
        public var severityCounts: ImagebuilderClientTypes.SeverityCounts?
        /// The vulnerability Id for this set of counts.
        public var vulnerabilityId: Swift.String?

        public init(
            severityCounts: ImagebuilderClientTypes.SeverityCounts? = nil,
            vulnerabilityId: Swift.String? = nil
        )
        {
            self.severityCounts = severityCounts
            self.vulnerabilityId = vulnerabilityId
        }
    }

}

extension ImagebuilderClientTypes.VulnerablePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arch
        case epoch
        case filePath
        case fixedInVersion
        case name
        case packageManager
        case release
        case remediation
        case sourceLayerHash
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arch = self.arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if let epoch = self.epoch {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fixedInVersion = self.fixedInVersion {
            try encodeContainer.encode(fixedInVersion, forKey: .fixedInVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageManager = self.packageManager {
            try encodeContainer.encode(packageManager, forKey: .packageManager)
        }
        if let release = self.release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let sourceLayerHash = self.sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
        let epochDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epoch)
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let archDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arch)
        arch = archDecoded
        let packageManagerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageManager)
        packageManager = packageManagerDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fixedInVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fixedInVersion)
        fixedInVersion = fixedInVersionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remediation)
        remediation = remediationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Information about a vulnerable package that Amazon Inspector identifies in a finding.
    public struct VulnerablePackage: Swift.Equatable {
        /// The architecture of the vulnerable package.
        public var arch: Swift.String?
        /// The epoch of the vulnerable package.
        public var epoch: Swift.Int?
        /// The file path of the vulnerable package.
        public var filePath: Swift.String?
        /// The version of the package that contains the vulnerability fix.
        public var fixedInVersion: Swift.String?
        /// The name of the vulnerable package.
        public var name: Swift.String?
        /// The package manager of the vulnerable package.
        public var packageManager: Swift.String?
        /// The release of the vulnerable package.
        public var release: Swift.String?
        /// The code to run in your environment to update packages with a fix available.
        public var remediation: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the vulnerable package.
        public var version: Swift.String?

        public init(
            arch: Swift.String? = nil,
            epoch: Swift.Int? = nil,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Swift.String? = nil,
            release: Swift.String? = nil,
            remediation: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.WorkflowExecutionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case message
        case startTime
        case status
        case totalStepCount
        case totalStepsFailed
        case totalStepsSkipped
        case totalStepsSucceeded
        case type
        case workflowBuildVersionArn
        case workflowExecutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if totalStepCount != 0 {
            try encodeContainer.encode(totalStepCount, forKey: .totalStepCount)
        }
        if totalStepsFailed != 0 {
            try encodeContainer.encode(totalStepsFailed, forKey: .totalStepsFailed)
        }
        if totalStepsSkipped != 0 {
            try encodeContainer.encode(totalStepsSkipped, forKey: .totalStepsSkipped)
        }
        if totalStepsSucceeded != 0 {
            try encodeContainer.encode(totalStepsSucceeded, forKey: .totalStepsSucceeded)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workflowBuildVersionArn = self.workflowBuildVersionArn {
            try encodeContainer.encode(workflowBuildVersionArn, forKey: .workflowBuildVersionArn)
        }
        if let workflowExecutionId = self.workflowExecutionId {
            try encodeContainer.encode(workflowExecutionId, forKey: .workflowExecutionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowBuildVersionArn)
        workflowBuildVersionArn = workflowBuildVersionArnDecoded
        let workflowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowExecutionId)
        workflowExecutionId = workflowExecutionIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let totalStepCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepCount) ?? 0
        totalStepCount = totalStepCountDecoded
        let totalStepsSucceededDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepsSucceeded) ?? 0
        totalStepsSucceeded = totalStepsSucceededDecoded
        let totalStepsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepsFailed) ?? 0
        totalStepsFailed = totalStepsFailedDecoded
        let totalStepsSkippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStepsSkipped) ?? 0
        totalStepsSkipped = totalStepsSkippedDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Metadata that includes details and status from this runtime instance of the workflow.
    public struct WorkflowExecutionMetadata: Swift.Equatable {
        /// The timestamp when this runtime instance of the workflow finished.
        public var endTime: Swift.String?
        /// The runtime output message from the workflow, if applicable.
        public var message: Swift.String?
        /// The timestamp when the runtime instance of this workflow started.
        public var startTime: Swift.String?
        /// The current runtime status for this workflow.
        public var status: ImagebuilderClientTypes.WorkflowExecutionStatus?
        /// The total number of steps in the workflow. This should equal the sum of the step counts for steps that succeeded, were skipped, and failed.
        public var totalStepCount: Swift.Int
        /// A runtime count for the number of steps in the workflow that failed.
        public var totalStepsFailed: Swift.Int
        /// A runtime count for the number of steps in the workflow that were skipped.
        public var totalStepsSkipped: Swift.Int
        /// A runtime count for the number of steps in the workflow that ran successfully.
        public var totalStepsSucceeded: Swift.Int
        /// Indicates what type of workflow that Image Builder ran for this runtime instance of the workflow.
        public var type: ImagebuilderClientTypes.WorkflowType?
        /// The Amazon Resource Name (ARN) of the workflow resource build version that ran.
        public var workflowBuildVersionArn: Swift.String?
        /// Unique identifier that Image Builder assigns to keep track of runtime resources each time it runs a workflow.
        public var workflowExecutionId: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            message: Swift.String? = nil,
            startTime: Swift.String? = nil,
            status: ImagebuilderClientTypes.WorkflowExecutionStatus? = nil,
            totalStepCount: Swift.Int = 0,
            totalStepsFailed: Swift.Int = 0,
            totalStepsSkipped: Swift.Int = 0,
            totalStepsSucceeded: Swift.Int = 0,
            type: ImagebuilderClientTypes.WorkflowType? = nil,
            workflowBuildVersionArn: Swift.String? = nil,
            workflowExecutionId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.message = message
            self.startTime = startTime
            self.status = status
            self.totalStepCount = totalStepCount
            self.totalStepsFailed = totalStepsFailed
            self.totalStepsSkipped = totalStepsSkipped
            self.totalStepsSucceeded = totalStepsSucceeded
            self.type = type
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }
    }

}

extension ImagebuilderClientTypes {
    public enum WorkflowExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case rollbackCompleted
        case rollbackInProgress
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowExecutionStatus] {
            return [
                .completed,
                .failed,
                .pending,
                .rollbackCompleted,
                .rollbackInProgress,
                .running,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .rollbackCompleted: return "ROLLBACK_COMPLETED"
            case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowExecutionStatus(rawValue: rawValue) ?? WorkflowExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum WorkflowStepExecutionRollbackStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepExecutionRollbackStatus] {
            return [
                .completed,
                .failed,
                .running,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStepExecutionRollbackStatus(rawValue: rawValue) ?? WorkflowStepExecutionRollbackStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum WorkflowStepExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepExecutionStatus] {
            return [
                .completed,
                .failed,
                .pending,
                .running,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStepExecutionStatus(rawValue: rawValue) ?? WorkflowStepExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.WorkflowStepMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case endTime
        case inputs
        case message
        case name
        case outputs
        case rollbackStatus
        case startTime
        case status
        case stepExecutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let inputs = self.inputs {
            try encodeContainer.encode(inputs, forKey: .inputs)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = self.outputs {
            try encodeContainer.encode(outputs, forKey: .outputs)
        }
        if let rollbackStatus = self.rollbackStatus {
            try encodeContainer.encode(rollbackStatus.rawValue, forKey: .rollbackStatus)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stepExecutionId = self.stepExecutionId {
            try encodeContainer.encode(stepExecutionId, forKey: .stepExecutionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepExecutionId)
        stepExecutionId = stepExecutionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowStepExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let rollbackStatusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus.self, forKey: .rollbackStatus)
        rollbackStatus = rollbackStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let inputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputs)
        inputs = inputsDecoded
        let outputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputs)
        outputs = outputsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Runtime details and status for the workflow step.
    public struct WorkflowStepMetadata: Swift.Equatable {
        /// The step action name.
        public var action: Swift.String?
        /// Description of the workflow step.
        public var description: Swift.String?
        /// The timestamp when the workflow step finished.
        public var endTime: Swift.String?
        /// Input parameters that Image Builder provides for the workflow step.
        public var inputs: Swift.String?
        /// Detailed output message that the workflow step provides at runtime.
        public var message: Swift.String?
        /// The name of the workflow step.
        public var name: Swift.String?
        /// The file names that the workflow step created as output for this runtime instance of the workflow.
        public var outputs: Swift.String?
        /// Reports on the rollback status of the step, if applicable.
        public var rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus?
        /// The timestamp when the workflow step started.
        public var startTime: Swift.String?
        /// Runtime status for the workflow step.
        public var status: ImagebuilderClientTypes.WorkflowStepExecutionStatus?
        /// A unique identifier for the workflow step, assigned at runtime.
        public var stepExecutionId: Swift.String?

        public init(
            action: Swift.String? = nil,
            description: Swift.String? = nil,
            endTime: Swift.String? = nil,
            inputs: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            outputs: Swift.String? = nil,
            rollbackStatus: ImagebuilderClientTypes.WorkflowStepExecutionRollbackStatus? = nil,
            startTime: Swift.String? = nil,
            status: ImagebuilderClientTypes.WorkflowStepExecutionStatus? = nil,
            stepExecutionId: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.endTime = endTime
            self.inputs = inputs
            self.message = message
            self.name = name
            self.outputs = outputs
            self.rollbackStatus = rollbackStatus
            self.startTime = startTime
            self.status = status
            self.stepExecutionId = stepExecutionId
        }
    }

}

extension ImagebuilderClientTypes {
    public enum WorkflowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case build
        case distribution
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .build,
                .distribution,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .distribution: return "DISTRIBUTION"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowType(rawValue: rawValue) ?? WorkflowType.sdkUnknown(rawValue)
        }
    }
}
