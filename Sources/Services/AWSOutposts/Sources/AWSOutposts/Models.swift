//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have permission to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OutpostsClientTypes {

    /// Information about an address.
    public struct Address: Swift.Sendable {
        /// The first line of the address.
        /// This member is required.
        public var addressLine1: Swift.String?
        /// The second line of the address.
        public var addressLine2: Swift.String?
        /// The third line of the address.
        public var addressLine3: Swift.String?
        /// The city for the address.
        /// This member is required.
        public var city: Swift.String?
        /// The name of the contact.
        public var contactName: Swift.String?
        /// The phone number of the contact.
        public var contactPhoneNumber: Swift.String?
        /// The ISO-3166 two-letter country code for the address.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The district or county for the address.
        public var districtOrCounty: Swift.String?
        /// The municipality for the address.
        public var municipality: Swift.String?
        /// The postal code for the address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state for the address.
        /// This member is required.
        public var stateOrRegion: Swift.String?

        public init(
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            contactName: Swift.String? = nil,
            contactPhoneNumber: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            municipality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        )
        {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.contactName = contactName
            self.contactPhoneNumber = contactPhoneNumber
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.municipality = municipality
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension OutpostsClientTypes {

    public enum AddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case operatingAddress
        case shippingAddress
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressType] {
            return [
                .operatingAddress,
                .shippingAddress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .operatingAddress: return "OPERATING_ADDRESS"
            case .shippingAddress: return "SHIPPING_ADDRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about the position of the asset in a rack.
    public struct AssetLocation: Swift.Sendable {
        /// The position of an asset in a rack measured in rack units.
        public var rackElevation: Swift.Float?

        public init(
            rackElevation: Swift.Float? = nil
        )
        {
            self.rackElevation = rackElevation
        }
    }
}

extension OutpostsClientTypes {

    public enum AssetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compute
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetType] {
            return [
                .compute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compute: return "COMPUTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// The capacity for each instance type.
    public struct AssetInstanceTypeCapacity: Swift.Sendable {
        /// The number of each instance type.
        /// This member is required.
        public var count: Swift.Int
        /// The type of instance.
        /// This member is required.
        public var instanceType: Swift.String?

        public init(
            count: Swift.Int = 0,
            instanceType: Swift.String? = nil
        )
        {
            self.count = count
            self.instanceType = instanceType
        }
    }
}

extension OutpostsClientTypes {

    public enum ComputeAssetState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case isolated
        case retiring
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeAssetState] {
            return [
                .active,
                .isolated,
                .retiring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .isolated: return "ISOLATED"
            case .retiring: return "RETIRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about compute hardware assets.
    public struct ComputeAttributes: Swift.Sendable {
        /// The host ID of the Dedicated Host on the asset.
        public var hostId: Swift.String?
        /// A list of the names of instance families that are currently associated with a given asset.
        public var instanceFamilies: [Swift.String]?
        /// The instance type capacities configured for this asset. This can be changed through a capacity task.
        public var instanceTypeCapacities: [OutpostsClientTypes.AssetInstanceTypeCapacity]?
        /// The maximum number of vCPUs possible for the specified asset.
        public var maxVcpus: Swift.Int?
        /// The state.
        ///
        /// * ACTIVE - The asset is available and can provide capacity for new compute resources.
        ///
        /// * ISOLATED - The asset is undergoing maintenance and can't provide capacity for new compute resources. Existing compute resources on the asset are not affected.
        ///
        /// * RETIRING - The underlying hardware for the asset is degraded. Capacity for new compute resources is reduced. Amazon Web Services sends notifications for resources that must be stopped before the asset can be replaced.
        public var state: OutpostsClientTypes.ComputeAssetState?

        public init(
            hostId: Swift.String? = nil,
            instanceFamilies: [Swift.String]? = nil,
            instanceTypeCapacities: [OutpostsClientTypes.AssetInstanceTypeCapacity]? = nil,
            maxVcpus: Swift.Int? = nil,
            state: OutpostsClientTypes.ComputeAssetState? = nil
        )
        {
            self.hostId = hostId
            self.instanceFamilies = instanceFamilies
            self.instanceTypeCapacities = instanceTypeCapacities
            self.maxVcpus = maxVcpus
            self.state = state
        }
    }
}

extension OutpostsClientTypes {

    /// Information about hardware assets.
    public struct AssetInfo: Swift.Sendable {
        /// The ID of the asset.
        public var assetId: Swift.String?
        /// The position of an asset in a rack.
        public var assetLocation: OutpostsClientTypes.AssetLocation?
        /// The type of the asset.
        public var assetType: OutpostsClientTypes.AssetType?
        /// Information about compute hardware assets.
        public var computeAttributes: OutpostsClientTypes.ComputeAttributes?
        /// The rack ID of the asset.
        public var rackId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetLocation: OutpostsClientTypes.AssetLocation? = nil,
            assetType: OutpostsClientTypes.AssetType? = nil,
            computeAttributes: OutpostsClientTypes.ComputeAttributes? = nil,
            rackId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetLocation = assetLocation
            self.assetType = assetType
            self.computeAttributes = computeAttributes
            self.rackId = rackId
        }
    }
}

extension OutpostsClientTypes {

    public enum AWSServiceName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case ec2
        case elasticache
        case elb
        case rds
        case route53
        case sdkUnknown(Swift.String)

        public static var allCases: [AWSServiceName] {
            return [
                .aws,
                .ec2,
                .elasticache,
                .elb,
                .rds,
                .route53
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .ec2: return "EC2"
            case .elasticache: return "ELASTICACHE"
            case .elb: return "ELB"
            case .rds: return "RDS"
            case .route53: return "ROUTE53"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// An Amazon EC2 instance.
    public struct AssetInstance: Swift.Sendable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the asset.
        public var assetId: Swift.String?
        /// The Amazon Web Services service name of the instance.
        public var awsServiceName: OutpostsClientTypes.AWSServiceName?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// The type of instance.
        public var instanceType: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            assetId: Swift.String? = nil,
            awsServiceName: OutpostsClientTypes.AWSServiceName? = nil,
            instanceId: Swift.String? = nil,
            instanceType: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.assetId = assetId
            self.awsServiceName = awsServiceName
            self.instanceId = instanceId
            self.instanceType = instanceType
        }
    }
}

extension OutpostsClientTypes {

    public enum AssetState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case isolated
        case retiring
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetState] {
            return [
                .active,
                .isolated,
                .retiring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .isolated: return "ISOLATED"
            case .retiring: return "RETIRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// A running Amazon EC2 instance that can be stopped to free up capacity needed to run the capacity task.
    public struct BlockingInstance: Swift.Sendable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The Amazon Web Services service name that owns the specified blocking instance.
        public var awsServiceName: OutpostsClientTypes.AWSServiceName?
        /// The ID of the blocking instance.
        public var instanceId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsServiceName: OutpostsClientTypes.AWSServiceName? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsServiceName = awsServiceName
            self.instanceId = instanceId
        }
    }
}

extension OutpostsClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case order
        case outpost
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .order,
                .outpost
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .outpost: return "OUTPOST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Updating or deleting this resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource causing the conflict.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource causing the conflict.
        public internal(set) var resourceType: OutpostsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: OutpostsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An internal error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified request is not valid.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelCapacityTaskInput: Swift.Sendable {
    /// ID of the capacity task that you want to cancel.
    /// This member is required.
    public var capacityTaskId: Swift.String?
    /// ID or ARN of the Outpost associated with the capacity task that you want to cancel.
    /// This member is required.
    public var outpostIdentifier: Swift.String?

    public init(
        capacityTaskId: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil
    )
    {
        self.capacityTaskId = capacityTaskId
        self.outpostIdentifier = outpostIdentifier
    }
}

public struct CancelCapacityTaskOutput: Swift.Sendable {

    public init() { }
}

public struct CancelOrderInput: Swift.Sendable {
    /// The ID of the order.
    /// This member is required.
    public var orderId: Swift.String?

    public init(
        orderId: Swift.String? = nil
    )
    {
        self.orderId = orderId
    }
}

public struct CancelOrderOutput: Swift.Sendable {

    public init() { }
}

extension OutpostsClientTypes {

    public enum CapacityTaskFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blockingInstancesNotEvacuated
        case internalServerError
        case resourceNotFound
        case unexpectedAssetState
        case unsupportedCapacityConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityTaskFailureType] {
            return [
                .blockingInstancesNotEvacuated,
                .internalServerError,
                .resourceNotFound,
                .unexpectedAssetState,
                .unsupportedCapacityConfiguration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blockingInstancesNotEvacuated: return "BLOCKING_INSTANCES_NOT_EVACUATED"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .unexpectedAssetState: return "UNEXPECTED_ASSET_STATE"
            case .unsupportedCapacityConfiguration: return "UNSUPPORTED_CAPACITY_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// The capacity tasks that failed.
    public struct CapacityTaskFailure: Swift.Sendable {
        /// The reason that the specified capacity task failed.
        /// This member is required.
        public var reason: Swift.String?
        /// The type of failure.
        public var type: OutpostsClientTypes.CapacityTaskFailureType?

        public init(
            reason: Swift.String? = nil,
            type: OutpostsClientTypes.CapacityTaskFailureType? = nil
        )
        {
            self.reason = reason
            self.type = type
        }
    }
}

extension OutpostsClientTypes {

    public enum CapacityTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancellationInProgress
        case cancelled
        case completed
        case failed
        case inProgress
        case requested
        case waitingForEvacuation
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityTaskStatus] {
            return [
                .cancellationInProgress,
                .cancelled,
                .completed,
                .failed,
                .inProgress,
                .requested,
                .waitingForEvacuation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancellationInProgress: return "CANCELLATION_IN_PROGRESS"
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .requested: return "REQUESTED"
            case .waitingForEvacuation: return "WAITING_FOR_EVACUATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// The summary of the capacity task.
    public struct CapacityTaskSummary: Swift.Sendable {
        /// The ID of the specified capacity task.
        public var capacityTaskId: Swift.String?
        /// The status of the capacity task.
        public var capacityTaskStatus: OutpostsClientTypes.CapacityTaskStatus?
        /// The date that the specified capacity task successfully ran.
        public var completionDate: Foundation.Date?
        /// The date that the specified capacity task was created.
        public var creationDate: Foundation.Date?
        /// The date that the specified capacity was last modified.
        public var lastModifiedDate: Foundation.Date?
        /// The ID of the Amazon Web Services Outposts order of the host associated with the capacity task.
        public var orderId: Swift.String?
        /// The ID of the Outpost associated with the specified capacity task.
        public var outpostId: Swift.String?

        public init(
            capacityTaskId: Swift.String? = nil,
            capacityTaskStatus: OutpostsClientTypes.CapacityTaskStatus? = nil,
            completionDate: Foundation.Date? = nil,
            creationDate: Foundation.Date? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            orderId: Swift.String? = nil,
            outpostId: Swift.String? = nil
        )
        {
            self.capacityTaskId = capacityTaskId
            self.capacityTaskStatus = capacityTaskStatus
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.orderId = orderId
            self.outpostId = outpostId
        }
    }
}

extension OutpostsClientTypes {

    /// Information about EC2 capacity.
    public struct EC2Capacity: Swift.Sendable {
        /// The family of the EC2 capacity.
        public var family: Swift.String?
        /// The maximum size of the EC2 capacity.
        public var maxSize: Swift.String?
        /// The quantity of the EC2 capacity.
        public var quantity: Swift.String?

        public init(
            family: Swift.String? = nil,
            maxSize: Swift.String? = nil,
            quantity: Swift.String? = nil
        )
        {
            self.family = family
            self.maxSize = maxSize
            self.quantity = quantity
        }
    }
}

extension OutpostsClientTypes {

    public enum CatalogItemStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case discontinued
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogItemStatus] {
            return [
                .available,
                .discontinued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .discontinued: return "DISCONTINUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum SupportedStorageEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ebs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedStorageEnum] {
            return [
                .ebs,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about a catalog item.
    public struct CatalogItem: Swift.Sendable {
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// Information about the EC2 capacity of an item.
        public var ec2Capacities: [OutpostsClientTypes.EC2Capacity]?
        /// The status of a catalog item.
        public var itemStatus: OutpostsClientTypes.CatalogItemStatus?
        /// Information about the power draw of an item.
        public var powerKva: Swift.Float?
        /// The supported storage options for the catalog item.
        public var supportedStorage: [OutpostsClientTypes.SupportedStorageEnum]?
        /// The uplink speed this catalog item requires for the connection to the Region.
        public var supportedUplinkGbps: [Swift.Int]?
        /// The weight of the item in pounds.
        public var weightLbs: Swift.Int?

        public init(
            catalogItemId: Swift.String? = nil,
            ec2Capacities: [OutpostsClientTypes.EC2Capacity]? = nil,
            itemStatus: OutpostsClientTypes.CatalogItemStatus? = nil,
            powerKva: Swift.Float? = nil,
            supportedStorage: [OutpostsClientTypes.SupportedStorageEnum]? = nil,
            supportedUplinkGbps: [Swift.Int]? = nil,
            weightLbs: Swift.Int? = nil
        )
        {
            self.catalogItemId = catalogItemId
            self.ec2Capacities = ec2Capacities
            self.itemStatus = itemStatus
            self.powerKva = powerKva
            self.supportedStorage = supportedStorage
            self.supportedUplinkGbps = supportedUplinkGbps
            self.weightLbs = weightLbs
        }
    }
}

extension OutpostsClientTypes {

    public enum CatalogItemClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rack
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogItemClass] {
            return [
                .rack,
                .server
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rack: return "RACK"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about a connection.
    public struct ConnectionDetails: Swift.Sendable {
        /// The allowed IP addresses.
        public var allowedIps: [Swift.String]?
        /// The public key of the client.
        public var clientPublicKey: Swift.String?
        /// The client tunnel address.
        public var clientTunnelAddress: Swift.String?
        /// The endpoint for the server.
        public var serverEndpoint: Swift.String?
        /// The public key of the server.
        public var serverPublicKey: Swift.String?
        /// The server tunnel address.
        public var serverTunnelAddress: Swift.String?

        public init(
            allowedIps: [Swift.String]? = nil,
            clientPublicKey: Swift.String? = nil,
            clientTunnelAddress: Swift.String? = nil,
            serverEndpoint: Swift.String? = nil,
            serverPublicKey: Swift.String? = nil,
            serverTunnelAddress: Swift.String? = nil
        )
        {
            self.allowedIps = allowedIps
            self.clientPublicKey = clientPublicKey
            self.clientTunnelAddress = clientTunnelAddress
            self.serverEndpoint = serverEndpoint
            self.serverPublicKey = serverPublicKey
            self.serverTunnelAddress = serverTunnelAddress
        }
    }
}

/// You have exceeded a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OutpostsClientTypes {

    /// Information about a line item request.
    public struct LineItemRequest: Swift.Sendable {
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// The quantity of a line item request.
        public var quantity: Swift.Int?

        public init(
            catalogItemId: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.catalogItemId = catalogItemId
            self.quantity = quantity
        }
    }
}

extension OutpostsClientTypes {

    public enum PaymentOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum PaymentTerm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneYear
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentTerm] {
            return [
                .oneYear,
                .threeYears
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateOrderInput: Swift.Sendable {
    /// The line items that make up the order.
    /// This member is required.
    public var lineItems: [OutpostsClientTypes.LineItemRequest]?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostIdentifier: Swift.String?
    /// The payment option.
    /// This member is required.
    public var paymentOption: OutpostsClientTypes.PaymentOption?
    /// The payment terms.
    public var paymentTerm: OutpostsClientTypes.PaymentTerm?

    public init(
        lineItems: [OutpostsClientTypes.LineItemRequest]? = nil,
        outpostIdentifier: Swift.String? = nil,
        paymentOption: OutpostsClientTypes.PaymentOption? = nil,
        paymentTerm: OutpostsClientTypes.PaymentTerm? = nil
    )
    {
        self.lineItems = lineItems
        self.outpostIdentifier = outpostIdentifier
        self.paymentOption = paymentOption
        self.paymentTerm = paymentTerm
    }
}

extension OutpostsClientTypes {

    /// Information about a line item asset.
    public struct LineItemAssetInformation: Swift.Sendable {
        /// The ID of the asset.
        public var assetId: Swift.String?
        /// The MAC addresses of the asset.
        public var macAddressList: [Swift.String]?

        public init(
            assetId: Swift.String? = nil,
            macAddressList: [Swift.String]? = nil
        )
        {
            self.assetId = assetId
            self.macAddressList = macAddressList
        }
    }
}

extension OutpostsClientTypes {

    public enum ShipmentCarrier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dbs
        case dhl
        case expeditors
        case fedex
        case ups
        case sdkUnknown(Swift.String)

        public static var allCases: [ShipmentCarrier] {
            return [
                .dbs,
                .dhl,
                .expeditors,
                .fedex,
                .ups
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dbs: return "DBS"
            case .dhl: return "DHL"
            case .expeditors: return "EXPEDITORS"
            case .fedex: return "FEDEX"
            case .ups: return "UPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about a line item shipment.
    public struct ShipmentInformation: Swift.Sendable {
        /// The carrier of the shipment.
        public var shipmentCarrier: OutpostsClientTypes.ShipmentCarrier?
        /// The tracking number of the shipment.
        public var shipmentTrackingNumber: Swift.String?

        public init(
            shipmentCarrier: OutpostsClientTypes.ShipmentCarrier? = nil,
            shipmentTrackingNumber: Swift.String? = nil
        )
        {
            self.shipmentCarrier = shipmentCarrier
            self.shipmentTrackingNumber = shipmentTrackingNumber
        }
    }
}

extension OutpostsClientTypes {

    public enum LineItemStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case building
        case cancelled
        case delivered
        case error
        case installed
        case installing
        case preparing
        case replaced
        case shipped
        case sdkUnknown(Swift.String)

        public static var allCases: [LineItemStatus] {
            return [
                .building,
                .cancelled,
                .delivered,
                .error,
                .installed,
                .installing,
                .preparing,
                .replaced,
                .shipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .installed: return "INSTALLED"
            case .installing: return "INSTALLING"
            case .preparing: return "PREPARING"
            case .replaced: return "REPLACED"
            case .shipped: return "SHIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about a line item.
    public struct LineItem: Swift.Sendable {
        /// Information about assets.
        public var assetInformationList: [OutpostsClientTypes.LineItemAssetInformation]?
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// The ID of the line item.
        public var lineItemId: Swift.String?
        /// The ID of the previous line item.
        public var previousLineItemId: Swift.String?
        /// The ID of the previous order.
        public var previousOrderId: Swift.String?
        /// The quantity of the line item.
        public var quantity: Swift.Int?
        /// Information about a line item shipment.
        public var shipmentInformation: OutpostsClientTypes.ShipmentInformation?
        /// The status of the line item.
        public var status: OutpostsClientTypes.LineItemStatus?

        public init(
            assetInformationList: [OutpostsClientTypes.LineItemAssetInformation]? = nil,
            catalogItemId: Swift.String? = nil,
            lineItemId: Swift.String? = nil,
            previousLineItemId: Swift.String? = nil,
            previousOrderId: Swift.String? = nil,
            quantity: Swift.Int? = nil,
            shipmentInformation: OutpostsClientTypes.ShipmentInformation? = nil,
            status: OutpostsClientTypes.LineItemStatus? = nil
        )
        {
            self.assetInformationList = assetInformationList
            self.catalogItemId = catalogItemId
            self.lineItemId = lineItemId
            self.previousLineItemId = previousLineItemId
            self.previousOrderId = previousOrderId
            self.quantity = quantity
            self.shipmentInformation = shipmentInformation
            self.status = status
        }
    }
}

extension OutpostsClientTypes {

    public enum OrderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case outpost
        case replacement
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderType] {
            return [
                .outpost,
                .replacement
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .outpost: return "OUTPOST"
            case .replacement: return "REPLACEMENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum OrderStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case delivered
        case error
        case fulfilled
        case installing
        case inProgress
        case pending
        case preparing
        case processing
        case received
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderStatus] {
            return [
                .cancelled,
                .completed,
                .delivered,
                .error,
                .fulfilled,
                .installing,
                .inProgress,
                .pending,
                .preparing,
                .processing,
                .received
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .fulfilled: return "FULFILLED"
            case .installing: return "INSTALLING"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .preparing: return "PREPARING"
            case .processing: return "PROCESSING"
            case .received: return "RECEIVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about an order.
    public struct Order: Swift.Sendable {
        /// The line items for the order
        public var lineItems: [OutpostsClientTypes.LineItem]?
        /// The fulfillment date of the order.
        public var orderFulfilledDate: Foundation.Date?
        /// The ID of the order.
        public var orderId: Swift.String?
        /// The submission date for the order.
        public var orderSubmissionDate: Foundation.Date?
        /// The type of order.
        public var orderType: OutpostsClientTypes.OrderType?
        /// The ID of the Outpost in the order.
        public var outpostId: Swift.String?
        /// The payment option for the order.
        public var paymentOption: OutpostsClientTypes.PaymentOption?
        /// The payment term.
        public var paymentTerm: OutpostsClientTypes.PaymentTerm?
        /// The status of the order.
        ///
        /// * PREPARING - Order is received and being prepared.
        ///
        /// * IN_PROGRESS - Order is either being built or shipped. To get more details, see the line item status.
        ///
        /// * DELIVERED - Order was delivered to the Outpost site.
        ///
        /// * COMPLETED - Order is complete.
        ///
        /// * CANCELLED - Order is cancelled.
        ///
        /// * ERROR - Customer should contact support.
        ///
        ///
        /// The following status are deprecated: RECEIVED, PENDING, PROCESSING, INSTALLING, and FULFILLED.
        public var status: OutpostsClientTypes.OrderStatus?

        public init(
            lineItems: [OutpostsClientTypes.LineItem]? = nil,
            orderFulfilledDate: Foundation.Date? = nil,
            orderId: Swift.String? = nil,
            orderSubmissionDate: Foundation.Date? = nil,
            orderType: OutpostsClientTypes.OrderType? = nil,
            outpostId: Swift.String? = nil,
            paymentOption: OutpostsClientTypes.PaymentOption? = nil,
            paymentTerm: OutpostsClientTypes.PaymentTerm? = nil,
            status: OutpostsClientTypes.OrderStatus? = nil
        )
        {
            self.lineItems = lineItems
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.orderType = orderType
            self.outpostId = outpostId
            self.paymentOption = paymentOption
            self.paymentTerm = paymentTerm
            self.status = status
        }
    }
}

public struct CreateOrderOutput: Swift.Sendable {
    /// Information about this order.
    public var order: OutpostsClientTypes.Order?

    public init(
        order: OutpostsClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

extension OutpostsClientTypes {

    public enum SupportedHardwareType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rack
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedHardwareType] {
            return [
                .rack,
                .server
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rack: return "RACK"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateOutpostInput: Swift.Sendable {
    /// The Availability Zone.
    public var availabilityZone: Swift.String?
    /// The ID of the Availability Zone.
    public var availabilityZoneId: Swift.String?
    /// The description of the Outpost.
    public var description: Swift.String?
    /// The name of the Outpost.
    /// This member is required.
    public var name: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The type of hardware for this Outpost.
    public var supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?
    /// The tags to apply to the Outpost.
    public var tags: [Swift.String: Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        siteId: Swift.String? = nil,
        supportedHardwareType: OutpostsClientTypes.SupportedHardwareType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.description = description
        self.name = name
        self.siteId = siteId
        self.supportedHardwareType = supportedHardwareType
        self.tags = tags
    }
}

extension OutpostsClientTypes {

    /// Information about an Outpost.
    public struct Outpost: Swift.Sendable {
        /// The Availability Zone.
        public var availabilityZone: Swift.String?
        /// The ID of the Availability Zone.
        public var availabilityZoneId: Swift.String?
        /// The description of the Outpost.
        public var description: Swift.String?
        /// The life cycle status.
        public var lifeCycleStatus: Swift.String?
        /// The name of the Outpost.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Outpost.
        public var outpostArn: Swift.String?
        /// The ID of the Outpost.
        public var outpostId: Swift.String?
        /// The Amazon Web Services account ID of the Outpost owner.
        public var ownerId: Swift.String?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The hardware type.
        public var supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?
        /// The Outpost tags.
        public var tags: [Swift.String: Swift.String]?

        public init(
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            description: Swift.String? = nil,
            lifeCycleStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            outpostId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            supportedHardwareType: OutpostsClientTypes.SupportedHardwareType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.description = description
            self.lifeCycleStatus = lifeCycleStatus
            self.name = name
            self.outpostArn = outpostArn
            self.outpostId = outpostId
            self.ownerId = ownerId
            self.siteArn = siteArn
            self.siteId = siteId
            self.supportedHardwareType = supportedHardwareType
            self.tags = tags
        }
    }
}

public struct CreateOutpostOutput: Swift.Sendable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init(
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

extension OutpostsClientTypes {

    public enum FiberOpticCableType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiMode
        case singleMode
        case sdkUnknown(Swift.String)

        public static var allCases: [FiberOpticCableType] {
            return [
                .multiMode,
                .singleMode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiMode: return "MULTI_MODE"
            case .singleMode: return "SINGLE_MODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum MaximumSupportedWeightLbs: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case max1400Lbs
        case max1600Lbs
        case max1800Lbs
        case max2000Lbs
        case noLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [MaximumSupportedWeightLbs] {
            return [
                .max1400Lbs,
                .max1600Lbs,
                .max1800Lbs,
                .max2000Lbs,
                .noLimit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .max1400Lbs: return "MAX_1400_LBS"
            case .max1600Lbs: return "MAX_1600_LBS"
            case .max1800Lbs: return "MAX_1800_LBS"
            case .max2000Lbs: return "MAX_2000_LBS"
            case .noLimit: return "NO_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum OpticalStandard: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case optic1000baseLx
        case optic1000baseSx
        case optic100gbaseCwdm4
        case optic100gbaseLr4
        case optic100gbaseSr4
        case optic100gPsm4Msa
        case optic10gbaseIr
        case optic10gbaseLr
        case optic10gbaseSr
        case optic40gbaseEsr
        case optic40gbaseIr4Lr4l
        case optic40gbaseLr4
        case optic40gbaseSr
        case sdkUnknown(Swift.String)

        public static var allCases: [OpticalStandard] {
            return [
                .optic1000baseLx,
                .optic1000baseSx,
                .optic100gbaseCwdm4,
                .optic100gbaseLr4,
                .optic100gbaseSr4,
                .optic100gPsm4Msa,
                .optic10gbaseIr,
                .optic10gbaseLr,
                .optic10gbaseSr,
                .optic40gbaseEsr,
                .optic40gbaseIr4Lr4l,
                .optic40gbaseLr4,
                .optic40gbaseSr
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optic1000baseLx: return "OPTIC_1000BASE_LX"
            case .optic1000baseSx: return "OPTIC_1000BASE_SX"
            case .optic100gbaseCwdm4: return "OPTIC_100GBASE_CWDM4"
            case .optic100gbaseLr4: return "OPTIC_100GBASE_LR4"
            case .optic100gbaseSr4: return "OPTIC_100GBASE_SR4"
            case .optic100gPsm4Msa: return "OPTIC_100G_PSM4_MSA"
            case .optic10gbaseIr: return "OPTIC_10GBASE_IR"
            case .optic10gbaseLr: return "OPTIC_10GBASE_LR"
            case .optic10gbaseSr: return "OPTIC_10GBASE_SR"
            case .optic40gbaseEsr: return "OPTIC_40GBASE_ESR"
            case .optic40gbaseIr4Lr4l: return "OPTIC_40GBASE_IR4_LR4L"
            case .optic40gbaseLr4: return "OPTIC_40GBASE_LR4"
            case .optic40gbaseSr: return "OPTIC_40GBASE_SR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum PowerConnector: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ah530p7w
        case ah532p6w
        case iec309
        case l630p
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerConnector] {
            return [
                .ah530p7w,
                .ah532p6w,
                .iec309,
                .l630p
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ah530p7w: return "AH530P7W"
            case .ah532p6w: return "AH532P6W"
            case .iec309: return "IEC309"
            case .l630p: return "L6_30P"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum PowerDrawKva: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case power10Kva
        case power15Kva
        case power30Kva
        case power5Kva
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerDrawKva] {
            return [
                .power10Kva,
                .power15Kva,
                .power30Kva,
                .power5Kva
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .power10Kva: return "POWER_10_KVA"
            case .power15Kva: return "POWER_15_KVA"
            case .power30Kva: return "POWER_30_KVA"
            case .power5Kva: return "POWER_5_KVA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum PowerFeedDrop: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aboveRack
        case belowRack
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerFeedDrop] {
            return [
                .aboveRack,
                .belowRack
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aboveRack: return "ABOVE_RACK"
            case .belowRack: return "BELOW_RACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum PowerPhase: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case singlePhase
        case threePhase
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerPhase] {
            return [
                .singlePhase,
                .threePhase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singlePhase: return "SINGLE_PHASE"
            case .threePhase: return "THREE_PHASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum UplinkCount: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case uplinkCount1
        case uplinkCount12
        case uplinkCount16
        case uplinkCount2
        case uplinkCount3
        case uplinkCount4
        case uplinkCount5
        case uplinkCount6
        case uplinkCount7
        case uplinkCount8
        case sdkUnknown(Swift.String)

        public static var allCases: [UplinkCount] {
            return [
                .uplinkCount1,
                .uplinkCount12,
                .uplinkCount16,
                .uplinkCount2,
                .uplinkCount3,
                .uplinkCount4,
                .uplinkCount5,
                .uplinkCount6,
                .uplinkCount7,
                .uplinkCount8
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .uplinkCount1: return "UPLINK_COUNT_1"
            case .uplinkCount12: return "UPLINK_COUNT_12"
            case .uplinkCount16: return "UPLINK_COUNT_16"
            case .uplinkCount2: return "UPLINK_COUNT_2"
            case .uplinkCount3: return "UPLINK_COUNT_3"
            case .uplinkCount4: return "UPLINK_COUNT_4"
            case .uplinkCount5: return "UPLINK_COUNT_5"
            case .uplinkCount6: return "UPLINK_COUNT_6"
            case .uplinkCount7: return "UPLINK_COUNT_7"
            case .uplinkCount8: return "UPLINK_COUNT_8"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    public enum UplinkGbps: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case uplink100g
        case uplink10g
        case uplink1g
        case uplink40g
        case sdkUnknown(Swift.String)

        public static var allCases: [UplinkGbps] {
            return [
                .uplink100g,
                .uplink10g,
                .uplink1g,
                .uplink40g
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .uplink100g: return "UPLINK_100G"
            case .uplink10g: return "UPLINK_10G"
            case .uplink1g: return "UPLINK_1G"
            case .uplink40g: return "UPLINK_40G"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OutpostsClientTypes {

    /// Information about the physical and logistical details for racks at sites. For more information about hardware requirements for racks, see [Network readiness checklist](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#checklist) in the Amazon Web Services Outposts User Guide.
    public struct RackPhysicalProperties: Swift.Sendable {
        /// The type of fiber used to attach the Outpost to the network.
        public var fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType?
        /// The maximum rack weight that this site can support. NO_LIMIT is over 2000 lbs (907 kg).
        public var maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs?
        /// The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see [Network](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking) in the Amazon Web Services Outposts User Guide.
        public var opticalStandard: OutpostsClientTypes.OpticalStandard?
        /// The power connector for the hardware.
        public var powerConnector: OutpostsClientTypes.PowerConnector?
        /// The power draw available at the hardware placement position for the rack.
        public var powerDrawKva: OutpostsClientTypes.PowerDrawKva?
        /// The position of the power feed.
        public var powerFeedDrop: OutpostsClientTypes.PowerFeedDrop?
        /// The power option that you can provide for hardware.
        public var powerPhase: OutpostsClientTypes.PowerPhase?
        /// The number of uplinks each Outpost network device.
        public var uplinkCount: OutpostsClientTypes.UplinkCount?
        /// The uplink speed the rack supports for the connection to the Region.
        public var uplinkGbps: OutpostsClientTypes.UplinkGbps?

        public init(
            fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType? = nil,
            maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs? = nil,
            opticalStandard: OutpostsClientTypes.OpticalStandard? = nil,
            powerConnector: OutpostsClientTypes.PowerConnector? = nil,
            powerDrawKva: OutpostsClientTypes.PowerDrawKva? = nil,
            powerFeedDrop: OutpostsClientTypes.PowerFeedDrop? = nil,
            powerPhase: OutpostsClientTypes.PowerPhase? = nil,
            uplinkCount: OutpostsClientTypes.UplinkCount? = nil,
            uplinkGbps: OutpostsClientTypes.UplinkGbps? = nil
        )
        {
            self.fiberOpticCableType = fiberOpticCableType
            self.maximumSupportedWeightLbs = maximumSupportedWeightLbs
            self.opticalStandard = opticalStandard
            self.powerConnector = powerConnector
            self.powerDrawKva = powerDrawKva
            self.powerFeedDrop = powerFeedDrop
            self.powerPhase = powerPhase
            self.uplinkCount = uplinkCount
            self.uplinkGbps = uplinkGbps
        }
    }
}

public struct CreateSiteInput: Swift.Sendable {
    /// The description of the site.
    public var description: Swift.String?
    /// The name of the site.
    /// This member is required.
    public var name: Swift.String?
    /// Additional information that you provide about site access requirements, electrician scheduling, personal protective equipment, or regulation of equipment materials that could affect your installation process.
    public var notes: Swift.String?
    /// The location to install and power on the hardware. This address might be different from the shipping address.
    public var operatingAddress: OutpostsClientTypes.Address?
    /// Information about the physical and logistical details for the rack at this site. For more information about hardware requirements for racks, see [Network readiness checklist](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#checklist) in the Amazon Web Services Outposts User Guide.
    public var rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties?
    /// The location to ship the hardware. This address might be different from the operating address.
    public var shippingAddress: OutpostsClientTypes.Address?
    /// The tags to apply to a site.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        notes: Swift.String? = nil,
        operatingAddress: OutpostsClientTypes.Address? = nil,
        rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties? = nil,
        shippingAddress: OutpostsClientTypes.Address? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.notes = notes
        self.operatingAddress = operatingAddress
        self.rackPhysicalProperties = rackPhysicalProperties
        self.shippingAddress = shippingAddress
        self.tags = tags
    }
}

extension OutpostsClientTypes {

    /// Information about a site.
    public struct Site: Swift.Sendable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The description of the site.
        public var description: Swift.String?
        /// The name of the site.
        public var name: Swift.String?
        /// Notes about a site.
        public var notes: Swift.String?
        /// City where the hardware is installed and powered on.
        public var operatingAddressCity: Swift.String?
        /// The ISO-3166 two-letter country code where the hardware is installed and powered on.
        public var operatingAddressCountryCode: Swift.String?
        /// State or region where the hardware is installed and powered on.
        public var operatingAddressStateOrRegion: Swift.String?
        /// Information about the physical and logistical details for a rack at the site.
        public var rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The site tags.
        public var tags: [Swift.String: Swift.String]?

        public init(
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            notes: Swift.String? = nil,
            operatingAddressCity: Swift.String? = nil,
            operatingAddressCountryCode: Swift.String? = nil,
            operatingAddressStateOrRegion: Swift.String? = nil,
            rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.name = name
            self.notes = notes
            self.operatingAddressCity = operatingAddressCity
            self.operatingAddressCountryCode = operatingAddressCountryCode
            self.operatingAddressStateOrRegion = operatingAddressStateOrRegion
            self.rackPhysicalProperties = rackPhysicalProperties
            self.siteArn = siteArn
            self.siteId = siteId
            self.tags = tags
        }
    }
}

public struct CreateSiteOutput: Swift.Sendable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init(
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

public struct DeleteOutpostInput: Swift.Sendable {
    /// The ID or ARN of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init(
        outpostId: Swift.String? = nil
    )
    {
        self.outpostId = outpostId
    }
}

public struct DeleteOutpostOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSiteInput: Swift.Sendable {
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        siteId: Swift.String? = nil
    )
    {
        self.siteId = siteId
    }
}

public struct DeleteSiteOutput: Swift.Sendable {

    public init() { }
}

public struct GetCapacityTaskInput: Swift.Sendable {
    /// ID of the capacity task.
    /// This member is required.
    public var capacityTaskId: Swift.String?
    /// ID or ARN of the Outpost associated with the specified capacity task.
    /// This member is required.
    public var outpostIdentifier: Swift.String?

    public init(
        capacityTaskId: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil
    )
    {
        self.capacityTaskId = capacityTaskId
        self.outpostIdentifier = outpostIdentifier
    }
}

extension OutpostsClientTypes {

    /// User-specified instances that must not be stopped. These instances will not appear in the list of instances that Amazon Web Services recommends to stop in order to free up capacity.
    public struct InstancesToExclude: Swift.Sendable {
        /// IDs of the accounts that own each instance that must not be stopped.
        public var accountIds: [Swift.String]?
        /// List of user-specified instances that must not be stopped.
        public var instances: [Swift.String]?
        /// Names of the services that own each instance that must not be stopped in order to free up the capacity needed to run the capacity task.
        public var services: [OutpostsClientTypes.AWSServiceName]?

        public init(
            accountIds: [Swift.String]? = nil,
            instances: [Swift.String]? = nil,
            services: [OutpostsClientTypes.AWSServiceName]? = nil
        )
        {
            self.accountIds = accountIds
            self.instances = instances
            self.services = services
        }
    }
}

extension OutpostsClientTypes {

    /// The instance type that you specify determines the combination of CPU, memory, storage, and networking capacity.
    public struct InstanceTypeCapacity: Swift.Sendable {
        /// The number of instances for the specified instance type.
        /// This member is required.
        public var count: Swift.Int
        /// The instance type of the hosts.
        /// This member is required.
        public var instanceType: Swift.String?

        public init(
            count: Swift.Int = 0,
            instanceType: Swift.String? = nil
        )
        {
            self.count = count
            self.instanceType = instanceType
        }
    }
}

extension OutpostsClientTypes {

    public enum TaskActionOnBlockingInstances: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failTask
        case waitForEvacuation
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskActionOnBlockingInstances] {
            return [
                .failTask,
                .waitForEvacuation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failTask: return "FAIL_TASK"
            case .waitForEvacuation: return "WAIT_FOR_EVACUATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCapacityTaskOutput: Swift.Sendable {
    /// ID of the capacity task.
    public var capacityTaskId: Swift.String?
    /// Status of the capacity task. A capacity task can have one of the following statuses:
    ///
    /// * REQUESTED - The capacity task was created and is awaiting the next step by Amazon Web Services Outposts.
    ///
    /// * IN_PROGRESS - The capacity task is running and cannot be cancelled.
    ///
    /// * WAITING_FOR_EVACUATION - The capacity task requires capacity to run. You must stop the recommended EC2 running instances to free up capacity for the task to run.
    public var capacityTaskStatus: OutpostsClientTypes.CapacityTaskStatus?
    /// The date the capacity task ran successfully.
    public var completionDate: Foundation.Date?
    /// The date the capacity task was created.
    public var creationDate: Foundation.Date?
    /// Performs a dry run to determine if you are above or below instance capacity.
    public var dryRun: Swift.Bool
    /// Reason why the capacity task failed.
    public var failed: OutpostsClientTypes.CapacityTaskFailure?
    /// Instances that the user specified they cannot stop in order to free up the capacity needed to run the capacity task.
    public var instancesToExclude: OutpostsClientTypes.InstancesToExclude?
    /// The date the capacity task was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// ID of the Amazon Web Services Outposts order associated with the specified capacity task.
    public var orderId: Swift.String?
    /// ID of the Outpost associated with the specified capacity task.
    public var outpostId: Swift.String?
    /// List of instance pools requested in the capacity task.
    public var requestedInstancePools: [OutpostsClientTypes.InstanceTypeCapacity]?
    /// User-specified option in case an instance is blocking the capacity task from running. Shows one of the following options:
    ///
    /// * WAIT_FOR_EVACUATION - Checks every 10 minutes over 48 hours to determine if instances have stopped and capacity is available to complete the task.
    ///
    /// * FAIL_TASK - The capacity task fails.
    public var taskActionOnBlockingInstances: OutpostsClientTypes.TaskActionOnBlockingInstances?

    public init(
        capacityTaskId: Swift.String? = nil,
        capacityTaskStatus: OutpostsClientTypes.CapacityTaskStatus? = nil,
        completionDate: Foundation.Date? = nil,
        creationDate: Foundation.Date? = nil,
        dryRun: Swift.Bool = false,
        failed: OutpostsClientTypes.CapacityTaskFailure? = nil,
        instancesToExclude: OutpostsClientTypes.InstancesToExclude? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        orderId: Swift.String? = nil,
        outpostId: Swift.String? = nil,
        requestedInstancePools: [OutpostsClientTypes.InstanceTypeCapacity]? = nil,
        taskActionOnBlockingInstances: OutpostsClientTypes.TaskActionOnBlockingInstances? = nil
    )
    {
        self.capacityTaskId = capacityTaskId
        self.capacityTaskStatus = capacityTaskStatus
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.dryRun = dryRun
        self.failed = failed
        self.instancesToExclude = instancesToExclude
        self.lastModifiedDate = lastModifiedDate
        self.orderId = orderId
        self.outpostId = outpostId
        self.requestedInstancePools = requestedInstancePools
        self.taskActionOnBlockingInstances = taskActionOnBlockingInstances
    }
}

public struct GetCatalogItemInput: Swift.Sendable {
    /// The ID of the catalog item.
    /// This member is required.
    public var catalogItemId: Swift.String?

    public init(
        catalogItemId: Swift.String? = nil
    )
    {
        self.catalogItemId = catalogItemId
    }
}

public struct GetCatalogItemOutput: Swift.Sendable {
    /// Information about this catalog item.
    public var catalogItem: OutpostsClientTypes.CatalogItem?

    public init(
        catalogItem: OutpostsClientTypes.CatalogItem? = nil
    )
    {
        self.catalogItem = catalogItem
    }
}

public struct GetConnectionInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

public struct GetConnectionOutput: Swift.Sendable {
    /// Information about the connection.
    public var connectionDetails: OutpostsClientTypes.ConnectionDetails?
    /// The ID of the connection.
    public var connectionId: Swift.String?

    public init(
        connectionDetails: OutpostsClientTypes.ConnectionDetails? = nil,
        connectionId: Swift.String? = nil
    )
    {
        self.connectionDetails = connectionDetails
        self.connectionId = connectionId
    }
}

public struct GetOrderInput: Swift.Sendable {
    /// The ID of the order.
    /// This member is required.
    public var orderId: Swift.String?

    public init(
        orderId: Swift.String? = nil
    )
    {
        self.orderId = orderId
    }
}

public struct GetOrderOutput: Swift.Sendable {
    /// Information about an order.
    public var order: OutpostsClientTypes.Order?

    public init(
        order: OutpostsClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

public struct GetOutpostInput: Swift.Sendable {
    /// The ID or ARN of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init(
        outpostId: Swift.String? = nil
    )
    {
        self.outpostId = outpostId
    }
}

public struct GetOutpostOutput: Swift.Sendable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init(
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

public struct GetOutpostInstanceTypesInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID or ARN of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

extension OutpostsClientTypes {

    /// Information about an instance type.
    public struct InstanceTypeItem: Swift.Sendable {
        /// The instance type.
        public var instanceType: Swift.String?
        /// The number of default VCPUs in an instance type.
        public var vcpUs: Swift.Int?

        public init(
            instanceType: Swift.String? = nil,
            vcpUs: Swift.Int? = nil
        )
        {
            self.instanceType = instanceType
            self.vcpUs = vcpUs
        }
    }
}

public struct GetOutpostInstanceTypesOutput: Swift.Sendable {
    /// Information about the instance types.
    public var instanceTypes: [OutpostsClientTypes.InstanceTypeItem]?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost.
    public var outpostArn: Swift.String?
    /// The ID of the Outpost.
    public var outpostId: Swift.String?

    public init(
        instanceTypes: [OutpostsClientTypes.InstanceTypeItem]? = nil,
        nextToken: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
        self.outpostArn = outpostArn
        self.outpostId = outpostId
    }
}

public struct GetOutpostSupportedInstanceTypesInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID for the Amazon Web Services Outposts order.
    public var orderId: Swift.String?
    /// The ID or ARN of the Outpost.
    /// This member is required.
    public var outpostIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderId: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderId = orderId
        self.outpostIdentifier = outpostIdentifier
    }
}

public struct GetOutpostSupportedInstanceTypesOutput: Swift.Sendable {
    /// Information about the instance types.
    public var instanceTypes: [OutpostsClientTypes.InstanceTypeItem]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        instanceTypes: [OutpostsClientTypes.InstanceTypeItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
    }
}

public struct GetSiteInput: Swift.Sendable {
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        siteId: Swift.String? = nil
    )
    {
        self.siteId = siteId
    }
}

public struct GetSiteOutput: Swift.Sendable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init(
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

public struct GetSiteAddressInput: Swift.Sendable {
    /// The type of the address you request.
    /// This member is required.
    public var addressType: OutpostsClientTypes.AddressType?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        addressType: OutpostsClientTypes.AddressType? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.addressType = addressType
        self.siteId = siteId
    }
}

public struct GetSiteAddressOutput: Swift.Sendable {
    /// Information about the address.
    public var address: OutpostsClientTypes.Address?
    /// The type of the address you receive.
    public var addressType: OutpostsClientTypes.AddressType?
    /// The ID of the site.
    public var siteId: Swift.String?

    public init(
        address: OutpostsClientTypes.Address? = nil,
        addressType: OutpostsClientTypes.AddressType? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.address = address
        self.addressType = addressType
        self.siteId = siteId
    }
}

public struct ListAssetInstancesInput: Swift.Sendable {
    /// Filters the results by account ID.
    public var accountIdFilter: [Swift.String]?
    /// Filters the results by asset ID.
    public var assetIdFilter: [Swift.String]?
    /// Filters the results by Amazon Web Services service.
    public var awsServiceFilter: [OutpostsClientTypes.AWSServiceName]?
    /// Filters the results by instance ID.
    public var instanceTypeFilter: [Swift.String]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID of the Outpost.
    /// This member is required.
    public var outpostIdentifier: Swift.String?

    public init(
        accountIdFilter: [Swift.String]? = nil,
        assetIdFilter: [Swift.String]? = nil,
        awsServiceFilter: [OutpostsClientTypes.AWSServiceName]? = nil,
        instanceTypeFilter: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil
    )
    {
        self.accountIdFilter = accountIdFilter
        self.assetIdFilter = assetIdFilter
        self.awsServiceFilter = awsServiceFilter
        self.instanceTypeFilter = instanceTypeFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostIdentifier = outpostIdentifier
    }
}

public struct ListAssetInstancesOutput: Swift.Sendable {
    /// List of instances owned by all accounts on the Outpost. Does not include Amazon EBS or Amazon S3 instances.
    public var assetInstances: [OutpostsClientTypes.AssetInstance]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        assetInstances: [OutpostsClientTypes.AssetInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetInstances = assetInstances
        self.nextToken = nextToken
    }
}

public struct ListAssetsInput: Swift.Sendable {
    /// Filters the results by the host ID of a Dedicated Host.
    public var hostIdFilter: [Swift.String]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostIdentifier: Swift.String?
    /// Filters the results by state.
    public var statusFilter: [OutpostsClientTypes.AssetState]?

    public init(
        hostIdFilter: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil,
        statusFilter: [OutpostsClientTypes.AssetState]? = nil
    )
    {
        self.hostIdFilter = hostIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostIdentifier = outpostIdentifier
        self.statusFilter = statusFilter
    }
}

public struct ListAssetsOutput: Swift.Sendable {
    /// Information about the hardware assets.
    public var assets: [OutpostsClientTypes.AssetInfo]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        assets: [OutpostsClientTypes.AssetInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assets = assets
        self.nextToken = nextToken
    }
}

public struct ListBlockingInstancesForCapacityTaskInput: Swift.Sendable {
    /// The ID of the capacity task.
    /// This member is required.
    public var capacityTaskId: Swift.String?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID or ARN of the Outpost associated with the specified capacity task.
    /// This member is required.
    public var outpostIdentifier: Swift.String?

    public init(
        capacityTaskId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil
    )
    {
        self.capacityTaskId = capacityTaskId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostIdentifier = outpostIdentifier
    }
}

public struct ListBlockingInstancesForCapacityTaskOutput: Swift.Sendable {
    /// A list of all running Amazon EC2 instances on the Outpost. Stopping one or more of these instances can free up the capacity needed to run the capacity task.
    public var blockingInstances: [OutpostsClientTypes.BlockingInstance]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        blockingInstances: [OutpostsClientTypes.BlockingInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.blockingInstances = blockingInstances
        self.nextToken = nextToken
    }
}

public struct ListCapacityTasksInput: Swift.Sendable {
    /// A list of statuses. For example, REQUESTED or WAITING_FOR_EVACUATION.
    public var capacityTaskStatusFilter: [OutpostsClientTypes.CapacityTaskStatus]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Filters the results by an Outpost ID or an Outpost ARN.
    public var outpostIdentifierFilter: Swift.String?

    public init(
        capacityTaskStatusFilter: [OutpostsClientTypes.CapacityTaskStatus]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostIdentifierFilter: Swift.String? = nil
    )
    {
        self.capacityTaskStatusFilter = capacityTaskStatusFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostIdentifierFilter = outpostIdentifierFilter
    }
}

public struct ListCapacityTasksOutput: Swift.Sendable {
    /// Lists all the capacity tasks.
    public var capacityTasks: [OutpostsClientTypes.CapacityTaskSummary]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        capacityTasks: [OutpostsClientTypes.CapacityTaskSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.capacityTasks = capacityTasks
        self.nextToken = nextToken
    }
}

public struct ListCatalogItemsInput: Swift.Sendable {
    /// Filters the results by EC2 family (for example, M5).
    public var ec2FamilyFilter: [Swift.String]?
    /// Filters the results by item class.
    public var itemClassFilter: [OutpostsClientTypes.CatalogItemClass]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Filters the results by storage option.
    public var supportedStorageFilter: [OutpostsClientTypes.SupportedStorageEnum]?

    public init(
        ec2FamilyFilter: [Swift.String]? = nil,
        itemClassFilter: [OutpostsClientTypes.CatalogItemClass]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        supportedStorageFilter: [OutpostsClientTypes.SupportedStorageEnum]? = nil
    )
    {
        self.ec2FamilyFilter = ec2FamilyFilter
        self.itemClassFilter = itemClassFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.supportedStorageFilter = supportedStorageFilter
    }
}

public struct ListCatalogItemsOutput: Swift.Sendable {
    /// Information about the catalog items.
    public var catalogItems: [OutpostsClientTypes.CatalogItem]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        catalogItems: [OutpostsClientTypes.CatalogItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogItems = catalogItems
        self.nextToken = nextToken
    }
}

public struct ListOrdersInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    public var outpostIdentifierFilter: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostIdentifierFilter: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostIdentifierFilter = outpostIdentifierFilter
    }
}

extension OutpostsClientTypes {

    /// A summary of line items in your order.
    public struct OrderSummary: Swift.Sendable {
        /// The status of all line items in the order.
        public var lineItemCountsByStatus: [Swift.String: Swift.Int]?
        /// The fulfilment date for the order.
        public var orderFulfilledDate: Foundation.Date?
        /// The ID of the order.
        public var orderId: Swift.String?
        /// The submission date for the order.
        public var orderSubmissionDate: Foundation.Date?
        /// The type of order.
        public var orderType: OutpostsClientTypes.OrderType?
        /// The ID of the Outpost.
        public var outpostId: Swift.String?
        /// The status of the order.
        ///
        /// * PREPARING - Order is received and is being prepared.
        ///
        /// * IN_PROGRESS - Order is either being built, shipped, or installed. For more information, see the LineItem status.
        ///
        /// * COMPLETED - Order is complete.
        ///
        /// * CANCELLED - Order is cancelled.
        ///
        /// * ERROR - Customer should contact support.
        ///
        ///
        /// The following statuses are deprecated: RECEIVED, PENDING, PROCESSING, INSTALLING, and FULFILLED.
        public var status: OutpostsClientTypes.OrderStatus?

        public init(
            lineItemCountsByStatus: [Swift.String: Swift.Int]? = nil,
            orderFulfilledDate: Foundation.Date? = nil,
            orderId: Swift.String? = nil,
            orderSubmissionDate: Foundation.Date? = nil,
            orderType: OutpostsClientTypes.OrderType? = nil,
            outpostId: Swift.String? = nil,
            status: OutpostsClientTypes.OrderStatus? = nil
        )
        {
            self.lineItemCountsByStatus = lineItemCountsByStatus
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.orderType = orderType
            self.outpostId = outpostId
            self.status = status
        }
    }
}

public struct ListOrdersOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the orders.
    public var orders: [OutpostsClientTypes.OrderSummary]?

    public init(
        nextToken: Swift.String? = nil,
        orders: [OutpostsClientTypes.OrderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.orders = orders
    }
}

public struct ListOutpostsInput: Swift.Sendable {
    /// Filters the results by Availability Zone (for example, us-east-1a).
    public var availabilityZoneFilter: [Swift.String]?
    /// Filters the results by AZ ID (for example, use1-az1).
    public var availabilityZoneIdFilter: [Swift.String]?
    /// Filters the results by the lifecycle status.
    public var lifeCycleStatusFilter: [Swift.String]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        availabilityZoneFilter: [Swift.String]? = nil,
        availabilityZoneIdFilter: [Swift.String]? = nil,
        lifeCycleStatusFilter: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availabilityZoneFilter = availabilityZoneFilter
        self.availabilityZoneIdFilter = availabilityZoneIdFilter
        self.lifeCycleStatusFilter = lifeCycleStatusFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListOutpostsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the Outposts.
    public var outposts: [OutpostsClientTypes.Outpost]?

    public init(
        nextToken: Swift.String? = nil,
        outposts: [OutpostsClientTypes.Outpost]? = nil
    )
    {
        self.nextToken = nextToken
        self.outposts = outposts
    }
}

public struct ListSitesInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Filters the results by city.
    public var operatingAddressCityFilter: [Swift.String]?
    /// Filters the results by country code.
    public var operatingAddressCountryCodeFilter: [Swift.String]?
    /// Filters the results by state or region.
    public var operatingAddressStateOrRegionFilter: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operatingAddressCityFilter: [Swift.String]? = nil,
        operatingAddressCountryCodeFilter: [Swift.String]? = nil,
        operatingAddressStateOrRegionFilter: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingAddressCityFilter = operatingAddressCityFilter
        self.operatingAddressCountryCodeFilter = operatingAddressCountryCodeFilter
        self.operatingAddressStateOrRegionFilter = operatingAddressStateOrRegionFilter
    }
}

public struct ListSitesOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the sites.
    public var sites: [OutpostsClientTypes.Site]?

    public init(
        nextToken: Swift.String? = nil,
        sites: [OutpostsClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The resource tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartCapacityTaskInput: Swift.Sendable {
    /// You can request a dry run to determine if the instance type and instance size changes is above or below available instance capacity. Requesting a dry run does not make any changes to your plan.
    public var dryRun: Swift.Bool?
    /// The instance pools specified in the capacity task.
    /// This member is required.
    public var instancePools: [OutpostsClientTypes.InstanceTypeCapacity]?
    /// List of user-specified running instances that must not be stopped in order to free up the capacity needed to run the capacity task.
    public var instancesToExclude: OutpostsClientTypes.InstancesToExclude?
    /// The ID of the Amazon Web Services Outposts order associated with the specified capacity task.
    public var orderId: Swift.String?
    /// The ID or ARN of the Outposts associated with the specified capacity task.
    /// This member is required.
    public var outpostIdentifier: Swift.String?
    /// Specify one of the following options in case an instance is blocking the capacity task from running.
    ///
    /// * WAIT_FOR_EVACUATION - Checks every 10 minutes over 48 hours to determine if instances have stopped and capacity is available to complete the task.
    ///
    /// * FAIL_TASK - The capacity task fails.
    public var taskActionOnBlockingInstances: OutpostsClientTypes.TaskActionOnBlockingInstances?

    public init(
        dryRun: Swift.Bool? = false,
        instancePools: [OutpostsClientTypes.InstanceTypeCapacity]? = nil,
        instancesToExclude: OutpostsClientTypes.InstancesToExclude? = nil,
        orderId: Swift.String? = nil,
        outpostIdentifier: Swift.String? = nil,
        taskActionOnBlockingInstances: OutpostsClientTypes.TaskActionOnBlockingInstances? = nil
    )
    {
        self.dryRun = dryRun
        self.instancePools = instancePools
        self.instancesToExclude = instancesToExclude
        self.orderId = orderId
        self.outpostIdentifier = outpostIdentifier
        self.taskActionOnBlockingInstances = taskActionOnBlockingInstances
    }
}

public struct StartCapacityTaskOutput: Swift.Sendable {
    /// ID of the capacity task that you want to start.
    public var capacityTaskId: Swift.String?
    /// Status of the specified capacity task.
    public var capacityTaskStatus: OutpostsClientTypes.CapacityTaskStatus?
    /// Date that the specified capacity task ran successfully.
    public var completionDate: Foundation.Date?
    /// Date that the specified capacity task was created.
    public var creationDate: Foundation.Date?
    /// Results of the dry run showing if the specified capacity task is above or below the available instance capacity.
    public var dryRun: Swift.Bool
    /// Reason that the specified capacity task failed.
    public var failed: OutpostsClientTypes.CapacityTaskFailure?
    /// User-specified instances that must not be stopped in order to free up the capacity needed to run the capacity task.
    public var instancesToExclude: OutpostsClientTypes.InstancesToExclude?
    /// Date that the specified capacity task was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// ID of the Amazon Web Services Outposts order of the host associated with the capacity task.
    public var orderId: Swift.String?
    /// ID of the Outpost associated with the capacity task.
    public var outpostId: Swift.String?
    /// List of the instance pools requested in the specified capacity task.
    public var requestedInstancePools: [OutpostsClientTypes.InstanceTypeCapacity]?
    /// User-specified option in case an instance is blocking the capacity task from running.
    ///
    /// * WAIT_FOR_EVACUATION - Checks every 10 minutes over 48 hours to determine if instances have stopped and capacity is available to complete the task.
    ///
    /// * FAIL_TASK - The capacity task fails.
    public var taskActionOnBlockingInstances: OutpostsClientTypes.TaskActionOnBlockingInstances?

    public init(
        capacityTaskId: Swift.String? = nil,
        capacityTaskStatus: OutpostsClientTypes.CapacityTaskStatus? = nil,
        completionDate: Foundation.Date? = nil,
        creationDate: Foundation.Date? = nil,
        dryRun: Swift.Bool = false,
        failed: OutpostsClientTypes.CapacityTaskFailure? = nil,
        instancesToExclude: OutpostsClientTypes.InstancesToExclude? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        orderId: Swift.String? = nil,
        outpostId: Swift.String? = nil,
        requestedInstancePools: [OutpostsClientTypes.InstanceTypeCapacity]? = nil,
        taskActionOnBlockingInstances: OutpostsClientTypes.TaskActionOnBlockingInstances? = nil
    )
    {
        self.capacityTaskId = capacityTaskId
        self.capacityTaskStatus = capacityTaskStatus
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.dryRun = dryRun
        self.failed = failed
        self.instancesToExclude = instancesToExclude
        self.lastModifiedDate = lastModifiedDate
        self.orderId = orderId
        self.outpostId = outpostId
        self.requestedInstancePools = requestedInstancePools
        self.taskActionOnBlockingInstances = taskActionOnBlockingInstances
    }
}

public struct StartConnectionInput: Swift.Sendable {
    /// The ID of the Outpost server.
    /// This member is required.
    public var assetId: Swift.String?
    /// The public key of the client.
    /// This member is required.
    public var clientPublicKey: Swift.String?
    /// The serial number of the dongle.
    public var deviceSerialNumber: Swift.String?
    /// The device index of the network interface on the Outpost server.
    /// This member is required.
    public var networkInterfaceDeviceIndex: Swift.Int?

    public init(
        assetId: Swift.String? = nil,
        clientPublicKey: Swift.String? = nil,
        deviceSerialNumber: Swift.String? = nil,
        networkInterfaceDeviceIndex: Swift.Int? = 0
    )
    {
        self.assetId = assetId
        self.clientPublicKey = clientPublicKey
        self.deviceSerialNumber = deviceSerialNumber
        self.networkInterfaceDeviceIndex = networkInterfaceDeviceIndex
    }
}

public struct StartConnectionOutput: Swift.Sendable {
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The underlay IP address.
    public var underlayIpAddress: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        underlayIpAddress: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.underlayIpAddress = underlayIpAddress
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateOutpostInput: Swift.Sendable {
    /// The description of the Outpost.
    public var description: Swift.String?
    /// The name of the Outpost.
    public var name: Swift.String?
    /// The ID or ARN of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?
    /// The type of hardware for this Outpost.
    public var supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        outpostId: Swift.String? = nil,
        supportedHardwareType: OutpostsClientTypes.SupportedHardwareType? = nil
    )
    {
        self.description = description
        self.name = name
        self.outpostId = outpostId
        self.supportedHardwareType = supportedHardwareType
    }
}

public struct UpdateOutpostOutput: Swift.Sendable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init(
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

public struct UpdateSiteInput: Swift.Sendable {
    /// The description of the site.
    public var description: Swift.String?
    /// The name of the site.
    public var name: Swift.String?
    /// Notes about a site.
    public var notes: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        notes: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.notes = notes
        self.siteId = siteId
    }
}

public struct UpdateSiteOutput: Swift.Sendable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init(
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

public struct UpdateSiteAddressInput: Swift.Sendable {
    /// The address for the site.
    /// This member is required.
    public var address: OutpostsClientTypes.Address?
    /// The type of the address.
    /// This member is required.
    public var addressType: OutpostsClientTypes.AddressType?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        address: OutpostsClientTypes.Address? = nil,
        addressType: OutpostsClientTypes.AddressType? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.address = address
        self.addressType = addressType
        self.siteId = siteId
    }
}

public struct UpdateSiteAddressOutput: Swift.Sendable {
    /// Information about an address.
    public var address: OutpostsClientTypes.Address?
    /// The type of the address.
    public var addressType: OutpostsClientTypes.AddressType?

    public init(
        address: OutpostsClientTypes.Address? = nil,
        addressType: OutpostsClientTypes.AddressType? = nil
    )
    {
        self.address = address
        self.addressType = addressType
    }
}

public struct UpdateSiteRackPhysicalPropertiesInput: Swift.Sendable {
    /// The type of fiber that you will use to attach the Outpost to your network.
    public var fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType?
    /// The maximum rack weight that this site can support. NO_LIMIT is over 2000lbs.
    public var maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs?
    /// The type of optical standard that you will use to attach the Outpost to your network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see [Network](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking) in the Amazon Web Services Outposts User Guide.
    ///
    /// * OPTIC_10GBASE_SR: 10GBASE-SR
    ///
    /// * OPTIC_10GBASE_IR: 10GBASE-IR
    ///
    /// * OPTIC_10GBASE_LR: 10GBASE-LR
    ///
    /// * OPTIC_40GBASE_SR: 40GBASE-SR
    ///
    /// * OPTIC_40GBASE_ESR: 40GBASE-ESR
    ///
    /// * OPTIC_40GBASE_IR4_LR4L: 40GBASE-IR (LR4L)
    ///
    /// * OPTIC_40GBASE_LR4: 40GBASE-LR4
    ///
    /// * OPTIC_100GBASE_SR4: 100GBASE-SR4
    ///
    /// * OPTIC_100GBASE_CWDM4: 100GBASE-CWDM4
    ///
    /// * OPTIC_100GBASE_LR4: 100GBASE-LR4
    ///
    /// * OPTIC_100G_PSM4_MSA: 100G PSM4 MSA
    ///
    /// * OPTIC_1000BASE_LX: 1000Base-LX
    ///
    /// * OPTIC_1000BASE_SX : 1000Base-SX
    public var opticalStandard: OutpostsClientTypes.OpticalStandard?
    /// The power connector that Amazon Web Services should plan to provide for connections to the hardware. Note the correlation between PowerPhase and PowerConnector.
    ///
    /// * Single-phase AC feed
    ///
    /// * L6-30P – (common in US); 30A; single phase
    ///
    /// * IEC309 (blue) – P+N+E, 6hr; 32 A; single phase
    ///
    ///
    ///
    ///
    /// * Three-phase AC feed
    ///
    /// * AH530P7W (red) – 3P+N+E, 7hr; 30A; three phase
    ///
    /// * AH532P6W (red) – 3P+N+E, 6hr; 32A; three phase
    public var powerConnector: OutpostsClientTypes.PowerConnector?
    /// The power draw, in kVA, available at the hardware placement position for the rack.
    public var powerDrawKva: OutpostsClientTypes.PowerDrawKva?
    /// Indicates whether the power feed comes above or below the rack.
    public var powerFeedDrop: OutpostsClientTypes.PowerFeedDrop?
    /// The power option that you can provide for hardware.
    ///
    /// * Single-phase AC feed: 200 V to 277 V, 50 Hz or 60 Hz
    ///
    /// * Three-phase AC feed: 346 V to 480 V, 50 Hz or 60 Hz
    public var powerPhase: OutpostsClientTypes.PowerPhase?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// Racks come with two Outpost network devices. Depending on the supported uplink speed at the site, the Outpost network devices provide a variable number of uplinks. Specify the number of uplinks for each Outpost network device that you intend to use to connect the rack to your network. Note the correlation between UplinkGbps and UplinkCount.
    ///
    /// * 1Gbps - Uplinks available: 1, 2, 4, 6, 8
    ///
    /// * 10Gbps - Uplinks available: 1, 2, 4, 8, 12, 16
    ///
    /// * 40 and 100 Gbps- Uplinks available: 1, 2, 4
    public var uplinkCount: OutpostsClientTypes.UplinkCount?
    /// The uplink speed the rack should support for the connection to the Region.
    public var uplinkGbps: OutpostsClientTypes.UplinkGbps?

    public init(
        fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType? = nil,
        maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs? = nil,
        opticalStandard: OutpostsClientTypes.OpticalStandard? = nil,
        powerConnector: OutpostsClientTypes.PowerConnector? = nil,
        powerDrawKva: OutpostsClientTypes.PowerDrawKva? = nil,
        powerFeedDrop: OutpostsClientTypes.PowerFeedDrop? = nil,
        powerPhase: OutpostsClientTypes.PowerPhase? = nil,
        siteId: Swift.String? = nil,
        uplinkCount: OutpostsClientTypes.UplinkCount? = nil,
        uplinkGbps: OutpostsClientTypes.UplinkGbps? = nil
    )
    {
        self.fiberOpticCableType = fiberOpticCableType
        self.maximumSupportedWeightLbs = maximumSupportedWeightLbs
        self.opticalStandard = opticalStandard
        self.powerConnector = powerConnector
        self.powerDrawKva = powerDrawKva
        self.powerFeedDrop = powerFeedDrop
        self.powerPhase = powerPhase
        self.siteId = siteId
        self.uplinkCount = uplinkCount
        self.uplinkGbps = uplinkGbps
    }
}

public struct UpdateSiteRackPhysicalPropertiesOutput: Swift.Sendable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init(
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

extension CancelCapacityTaskInput {

    static func urlPathProvider(_ value: CancelCapacityTaskInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        guard let capacityTaskId = value.capacityTaskId else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/capacity/\(capacityTaskId.urlPercentEncoding())"
    }
}

extension CancelOrderInput {

    static func urlPathProvider(_ value: CancelOrderInput) -> Swift.String? {
        guard let orderId = value.orderId else {
            return nil
        }
        return "/orders/\(orderId.urlPercentEncoding())/cancel"
    }
}

extension CreateOrderInput {

    static func urlPathProvider(_ value: CreateOrderInput) -> Swift.String? {
        return "/orders"
    }
}

extension CreateOutpostInput {

    static func urlPathProvider(_ value: CreateOutpostInput) -> Swift.String? {
        return "/outposts"
    }
}

extension CreateSiteInput {

    static func urlPathProvider(_ value: CreateSiteInput) -> Swift.String? {
        return "/sites"
    }
}

extension DeleteOutpostInput {

    static func urlPathProvider(_ value: DeleteOutpostInput) -> Swift.String? {
        guard let outpostId = value.outpostId else {
            return nil
        }
        return "/outposts/\(outpostId.urlPercentEncoding())"
    }
}

extension DeleteSiteInput {

    static func urlPathProvider(_ value: DeleteSiteInput) -> Swift.String? {
        guard let siteId = value.siteId else {
            return nil
        }
        return "/sites/\(siteId.urlPercentEncoding())"
    }
}

extension GetCapacityTaskInput {

    static func urlPathProvider(_ value: GetCapacityTaskInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        guard let capacityTaskId = value.capacityTaskId else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/capacity/\(capacityTaskId.urlPercentEncoding())"
    }
}

extension GetCatalogItemInput {

    static func urlPathProvider(_ value: GetCatalogItemInput) -> Swift.String? {
        guard let catalogItemId = value.catalogItemId else {
            return nil
        }
        return "/catalog/item/\(catalogItemId.urlPercentEncoding())"
    }
}

extension GetConnectionInput {

    static func urlPathProvider(_ value: GetConnectionInput) -> Swift.String? {
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/connections/\(connectionId.urlPercentEncoding())"
    }
}

extension GetOrderInput {

    static func urlPathProvider(_ value: GetOrderInput) -> Swift.String? {
        guard let orderId = value.orderId else {
            return nil
        }
        return "/orders/\(orderId.urlPercentEncoding())"
    }
}

extension GetOutpostInput {

    static func urlPathProvider(_ value: GetOutpostInput) -> Swift.String? {
        guard let outpostId = value.outpostId else {
            return nil
        }
        return "/outposts/\(outpostId.urlPercentEncoding())"
    }
}

extension GetOutpostInstanceTypesInput {

    static func urlPathProvider(_ value: GetOutpostInstanceTypesInput) -> Swift.String? {
        guard let outpostId = value.outpostId else {
            return nil
        }
        return "/outposts/\(outpostId.urlPercentEncoding())/instanceTypes"
    }
}

extension GetOutpostInstanceTypesInput {

    static func queryItemProvider(_ value: GetOutpostInstanceTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetOutpostSupportedInstanceTypesInput {

    static func urlPathProvider(_ value: GetOutpostSupportedInstanceTypesInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/supportedInstanceTypes"
    }
}

extension GetOutpostSupportedInstanceTypesInput {

    static func queryItemProvider(_ value: GetOutpostSupportedInstanceTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let orderId = value.orderId {
            let orderIdQueryItem = Smithy.URIQueryItem(name: "OrderId".urlPercentEncoding(), value: Swift.String(orderId).urlPercentEncoding())
            items.append(orderIdQueryItem)
        }
        return items
    }
}

extension GetSiteInput {

    static func urlPathProvider(_ value: GetSiteInput) -> Swift.String? {
        guard let siteId = value.siteId else {
            return nil
        }
        return "/sites/\(siteId.urlPercentEncoding())"
    }
}

extension GetSiteAddressInput {

    static func urlPathProvider(_ value: GetSiteAddressInput) -> Swift.String? {
        guard let siteId = value.siteId else {
            return nil
        }
        return "/sites/\(siteId.urlPercentEncoding())/address"
    }
}

extension GetSiteAddressInput {

    static func queryItemProvider(_ value: GetSiteAddressInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let addressType = value.addressType else {
            let message = "Creating a URL Query Item failed. addressType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let addressTypeQueryItem = Smithy.URIQueryItem(name: "AddressType".urlPercentEncoding(), value: Swift.String(addressType.rawValue).urlPercentEncoding())
        items.append(addressTypeQueryItem)
        return items
    }
}

extension ListAssetInstancesInput {

    static func urlPathProvider(_ value: ListAssetInstancesInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/assetInstances"
    }
}

extension ListAssetInstancesInput {

    static func queryItemProvider(_ value: ListAssetInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let instanceTypeFilter = value.instanceTypeFilter {
            instanceTypeFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "InstanceTypeFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let awsServiceFilter = value.awsServiceFilter {
            awsServiceFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "AwsServiceFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let accountIdFilter = value.accountIdFilter {
            accountIdFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "AccountIdFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assetIdFilter = value.assetIdFilter {
            assetIdFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "AssetIdFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListAssetsInput {

    static func urlPathProvider(_ value: ListAssetsInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/assets"
    }
}

extension ListAssetsInput {

    static func queryItemProvider(_ value: ListAssetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let hostIdFilter = value.hostIdFilter {
            hostIdFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "HostIdFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let statusFilter = value.statusFilter {
            statusFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "StatusFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListBlockingInstancesForCapacityTaskInput {

    static func urlPathProvider(_ value: ListBlockingInstancesForCapacityTaskInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        guard let capacityTaskId = value.capacityTaskId else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/capacity/\(capacityTaskId.urlPercentEncoding())/blockingInstances"
    }
}

extension ListBlockingInstancesForCapacityTaskInput {

    static func queryItemProvider(_ value: ListBlockingInstancesForCapacityTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCapacityTasksInput {

    static func urlPathProvider(_ value: ListCapacityTasksInput) -> Swift.String? {
        return "/capacity/tasks"
    }
}

extension ListCapacityTasksInput {

    static func queryItemProvider(_ value: ListCapacityTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let capacityTaskStatusFilter = value.capacityTaskStatusFilter {
            capacityTaskStatusFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "CapacityTaskStatusFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let outpostIdentifierFilter = value.outpostIdentifierFilter {
            let outpostIdentifierFilterQueryItem = Smithy.URIQueryItem(name: "OutpostIdentifierFilter".urlPercentEncoding(), value: Swift.String(outpostIdentifierFilter).urlPercentEncoding())
            items.append(outpostIdentifierFilterQueryItem)
        }
        return items
    }
}

extension ListCatalogItemsInput {

    static func urlPathProvider(_ value: ListCatalogItemsInput) -> Swift.String? {
        return "/catalog/items"
    }
}

extension ListCatalogItemsInput {

    static func queryItemProvider(_ value: ListCatalogItemsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let supportedStorageFilter = value.supportedStorageFilter {
            supportedStorageFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "SupportedStorageFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let itemClassFilter = value.itemClassFilter {
            itemClassFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "ItemClassFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let ec2FamilyFilter = value.ec2FamilyFilter {
            ec2FamilyFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "EC2FamilyFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOrdersInput {

    static func urlPathProvider(_ value: ListOrdersInput) -> Swift.String? {
        return "/list-orders"
    }
}

extension ListOrdersInput {

    static func queryItemProvider(_ value: ListOrdersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let outpostIdentifierFilter = value.outpostIdentifierFilter {
            let outpostIdentifierFilterQueryItem = Smithy.URIQueryItem(name: "OutpostIdentifierFilter".urlPercentEncoding(), value: Swift.String(outpostIdentifierFilter).urlPercentEncoding())
            items.append(outpostIdentifierFilterQueryItem)
        }
        return items
    }
}

extension ListOutpostsInput {

    static func urlPathProvider(_ value: ListOutpostsInput) -> Swift.String? {
        return "/outposts"
    }
}

extension ListOutpostsInput {

    static func queryItemProvider(_ value: ListOutpostsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let availabilityZoneIdFilter = value.availabilityZoneIdFilter {
            availabilityZoneIdFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "AvailabilityZoneIdFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let lifeCycleStatusFilter = value.lifeCycleStatusFilter {
            lifeCycleStatusFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "LifeCycleStatusFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let availabilityZoneFilter = value.availabilityZoneFilter {
            availabilityZoneFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "AvailabilityZoneFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListSitesInput {

    static func urlPathProvider(_ value: ListSitesInput) -> Swift.String? {
        return "/sites"
    }
}

extension ListSitesInput {

    static func queryItemProvider(_ value: ListSitesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let operatingAddressCountryCodeFilter = value.operatingAddressCountryCodeFilter {
            operatingAddressCountryCodeFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "OperatingAddressCountryCodeFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let operatingAddressStateOrRegionFilter = value.operatingAddressStateOrRegionFilter {
            operatingAddressStateOrRegionFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "OperatingAddressStateOrRegionFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let operatingAddressCityFilter = value.operatingAddressCityFilter {
            operatingAddressCityFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "OperatingAddressCityFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartCapacityTaskInput {

    static func urlPathProvider(_ value: StartCapacityTaskInput) -> Swift.String? {
        guard let outpostIdentifier = value.outpostIdentifier else {
            return nil
        }
        return "/outposts/\(outpostIdentifier.urlPercentEncoding())/capacity"
    }
}

extension StartConnectionInput {

    static func urlPathProvider(_ value: StartConnectionInput) -> Swift.String? {
        return "/connections"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateOutpostInput {

    static func urlPathProvider(_ value: UpdateOutpostInput) -> Swift.String? {
        guard let outpostId = value.outpostId else {
            return nil
        }
        return "/outposts/\(outpostId.urlPercentEncoding())"
    }
}

extension UpdateSiteInput {

    static func urlPathProvider(_ value: UpdateSiteInput) -> Swift.String? {
        guard let siteId = value.siteId else {
            return nil
        }
        return "/sites/\(siteId.urlPercentEncoding())"
    }
}

extension UpdateSiteAddressInput {

    static func urlPathProvider(_ value: UpdateSiteAddressInput) -> Swift.String? {
        guard let siteId = value.siteId else {
            return nil
        }
        return "/sites/\(siteId.urlPercentEncoding())/address"
    }
}

extension UpdateSiteRackPhysicalPropertiesInput {

    static func urlPathProvider(_ value: UpdateSiteRackPhysicalPropertiesInput) -> Swift.String? {
        guard let siteId = value.siteId else {
            return nil
        }
        return "/sites/\(siteId.urlPercentEncoding())/rackPhysicalProperties"
    }
}

extension CreateOrderInput {

    static func write(value: CreateOrderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineItems"].writeList(value.lineItems, memberWritingClosure: OutpostsClientTypes.LineItemRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutpostIdentifier"].write(value.outpostIdentifier)
        try writer["PaymentOption"].write(value.paymentOption)
        try writer["PaymentTerm"].write(value.paymentTerm)
    }
}

extension CreateOutpostInput {

    static func write(value: CreateOutpostInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["AvailabilityZoneId"].write(value.availabilityZoneId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["SiteId"].write(value.siteId)
        try writer["SupportedHardwareType"].write(value.supportedHardwareType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSiteInput {

    static func write(value: CreateSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Notes"].write(value.notes)
        try writer["OperatingAddress"].write(value.operatingAddress, with: OutpostsClientTypes.Address.write(value:to:))
        try writer["RackPhysicalProperties"].write(value.rackPhysicalProperties, with: OutpostsClientTypes.RackPhysicalProperties.write(value:to:))
        try writer["ShippingAddress"].write(value.shippingAddress, with: OutpostsClientTypes.Address.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartCapacityTaskInput {

    static func write(value: StartCapacityTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DryRun"].write(value.dryRun)
        try writer["InstancePools"].writeList(value.instancePools, memberWritingClosure: OutpostsClientTypes.InstanceTypeCapacity.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstancesToExclude"].write(value.instancesToExclude, with: OutpostsClientTypes.InstancesToExclude.write(value:to:))
        try writer["OrderId"].write(value.orderId)
        try writer["TaskActionOnBlockingInstances"].write(value.taskActionOnBlockingInstances)
    }
}

extension StartConnectionInput {

    static func write(value: StartConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssetId"].write(value.assetId)
        try writer["ClientPublicKey"].write(value.clientPublicKey)
        try writer["DeviceSerialNumber"].write(value.deviceSerialNumber)
        try writer["NetworkInterfaceDeviceIndex"].write(value.networkInterfaceDeviceIndex)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateOutpostInput {

    static func write(value: UpdateOutpostInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["SupportedHardwareType"].write(value.supportedHardwareType)
    }
}

extension UpdateSiteInput {

    static func write(value: UpdateSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Notes"].write(value.notes)
    }
}

extension UpdateSiteAddressInput {

    static func write(value: UpdateSiteAddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address, with: OutpostsClientTypes.Address.write(value:to:))
        try writer["AddressType"].write(value.addressType)
    }
}

extension UpdateSiteRackPhysicalPropertiesInput {

    static func write(value: UpdateSiteRackPhysicalPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FiberOpticCableType"].write(value.fiberOpticCableType)
        try writer["MaximumSupportedWeightLbs"].write(value.maximumSupportedWeightLbs)
        try writer["OpticalStandard"].write(value.opticalStandard)
        try writer["PowerConnector"].write(value.powerConnector)
        try writer["PowerDrawKva"].write(value.powerDrawKva)
        try writer["PowerFeedDrop"].write(value.powerFeedDrop)
        try writer["PowerPhase"].write(value.powerPhase)
        try writer["UplinkCount"].write(value.uplinkCount)
        try writer["UplinkGbps"].write(value.uplinkGbps)
    }
}

extension CancelCapacityTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelCapacityTaskOutput {
        return CancelCapacityTaskOutput()
    }
}

extension CancelOrderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelOrderOutput {
        return CancelOrderOutput()
    }
}

extension CreateOrderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOrderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOrderOutput()
        value.order = try reader["Order"].readIfPresent(with: OutpostsClientTypes.Order.read(from:))
        return value
    }
}

extension CreateOutpostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOutpostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOutpostOutput()
        value.outpost = try reader["Outpost"].readIfPresent(with: OutpostsClientTypes.Outpost.read(from:))
        return value
    }
}

extension CreateSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSiteOutput()
        value.site = try reader["Site"].readIfPresent(with: OutpostsClientTypes.Site.read(from:))
        return value
    }
}

extension DeleteOutpostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOutpostOutput {
        return DeleteOutpostOutput()
    }
}

extension DeleteSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSiteOutput {
        return DeleteSiteOutput()
    }
}

extension GetCapacityTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCapacityTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCapacityTaskOutput()
        value.capacityTaskId = try reader["CapacityTaskId"].readIfPresent()
        value.capacityTaskStatus = try reader["CapacityTaskStatus"].readIfPresent()
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dryRun = try reader["DryRun"].readIfPresent() ?? false
        value.failed = try reader["Failed"].readIfPresent(with: OutpostsClientTypes.CapacityTaskFailure.read(from:))
        value.instancesToExclude = try reader["InstancesToExclude"].readIfPresent(with: OutpostsClientTypes.InstancesToExclude.read(from:))
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.orderId = try reader["OrderId"].readIfPresent()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        value.requestedInstancePools = try reader["RequestedInstancePools"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.InstanceTypeCapacity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskActionOnBlockingInstances = try reader["TaskActionOnBlockingInstances"].readIfPresent()
        return value
    }
}

extension GetCatalogItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCatalogItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCatalogItemOutput()
        value.catalogItem = try reader["CatalogItem"].readIfPresent(with: OutpostsClientTypes.CatalogItem.read(from:))
        return value
    }
}

extension GetConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionOutput()
        value.connectionDetails = try reader["ConnectionDetails"].readIfPresent(with: OutpostsClientTypes.ConnectionDetails.read(from:))
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        return value
    }
}

extension GetOrderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrderOutput()
        value.order = try reader["Order"].readIfPresent(with: OutpostsClientTypes.Order.read(from:))
        return value
    }
}

extension GetOutpostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOutpostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOutpostOutput()
        value.outpost = try reader["Outpost"].readIfPresent(with: OutpostsClientTypes.Outpost.read(from:))
        return value
    }
}

extension GetOutpostInstanceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOutpostInstanceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOutpostInstanceTypesOutput()
        value.instanceTypes = try reader["InstanceTypes"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.InstanceTypeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.outpostArn = try reader["OutpostArn"].readIfPresent()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        return value
    }
}

extension GetOutpostSupportedInstanceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOutpostSupportedInstanceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOutpostSupportedInstanceTypesOutput()
        value.instanceTypes = try reader["InstanceTypes"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.InstanceTypeItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSiteOutput()
        value.site = try reader["Site"].readIfPresent(with: OutpostsClientTypes.Site.read(from:))
        return value
    }
}

extension GetSiteAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSiteAddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSiteAddressOutput()
        value.address = try reader["Address"].readIfPresent(with: OutpostsClientTypes.Address.read(from:))
        value.addressType = try reader["AddressType"].readIfPresent()
        value.siteId = try reader["SiteId"].readIfPresent()
        return value
    }
}

extension ListAssetInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetInstancesOutput()
        value.assetInstances = try reader["AssetInstances"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.AssetInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetsOutput()
        value.assets = try reader["Assets"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.AssetInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBlockingInstancesForCapacityTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBlockingInstancesForCapacityTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBlockingInstancesForCapacityTaskOutput()
        value.blockingInstances = try reader["BlockingInstances"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.BlockingInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCapacityTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCapacityTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCapacityTasksOutput()
        value.capacityTasks = try reader["CapacityTasks"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.CapacityTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCatalogItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCatalogItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCatalogItemsOutput()
        value.catalogItems = try reader["CatalogItems"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.CatalogItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOrdersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrdersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrdersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.orders = try reader["Orders"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.OrderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOutpostsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOutpostsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOutpostsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.outposts = try reader["Outposts"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.Outpost.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSitesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSitesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSitesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sites = try reader["Sites"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.Site.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartCapacityTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCapacityTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCapacityTaskOutput()
        value.capacityTaskId = try reader["CapacityTaskId"].readIfPresent()
        value.capacityTaskStatus = try reader["CapacityTaskStatus"].readIfPresent()
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dryRun = try reader["DryRun"].readIfPresent() ?? false
        value.failed = try reader["Failed"].readIfPresent(with: OutpostsClientTypes.CapacityTaskFailure.read(from:))
        value.instancesToExclude = try reader["InstancesToExclude"].readIfPresent(with: OutpostsClientTypes.InstancesToExclude.read(from:))
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.orderId = try reader["OrderId"].readIfPresent()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        value.requestedInstancePools = try reader["RequestedInstancePools"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.InstanceTypeCapacity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskActionOnBlockingInstances = try reader["TaskActionOnBlockingInstances"].readIfPresent()
        return value
    }
}

extension StartConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartConnectionOutput()
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.underlayIpAddress = try reader["UnderlayIpAddress"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateOutpostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOutpostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOutpostOutput()
        value.outpost = try reader["Outpost"].readIfPresent(with: OutpostsClientTypes.Outpost.read(from:))
        return value
    }
}

extension UpdateSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSiteOutput()
        value.site = try reader["Site"].readIfPresent(with: OutpostsClientTypes.Site.read(from:))
        return value
    }
}

extension UpdateSiteAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSiteAddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSiteAddressOutput()
        value.address = try reader["Address"].readIfPresent(with: OutpostsClientTypes.Address.read(from:))
        value.addressType = try reader["AddressType"].readIfPresent()
        return value
    }
}

extension UpdateSiteRackPhysicalPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSiteRackPhysicalPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSiteRackPhysicalPropertiesOutput()
        value.site = try reader["Site"].readIfPresent(with: OutpostsClientTypes.Site.read(from:))
        return value
    }
}

enum CancelCapacityTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelOrderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOrderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOutpostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOutpostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCapacityTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCatalogItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOutpostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOutpostInstanceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOutpostSupportedInstanceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSiteAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBlockingInstancesForCapacityTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCapacityTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCatalogItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrdersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOutpostsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSitesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCapacityTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOutpostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSiteAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSiteRackPhysicalPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OutpostsClientTypes.Order {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.Order {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.Order()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        value.orderId = try reader["OrderId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.lineItems = try reader["LineItems"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.LineItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.paymentOption = try reader["PaymentOption"].readIfPresent()
        value.orderSubmissionDate = try reader["OrderSubmissionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.orderFulfilledDate = try reader["OrderFulfilledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.paymentTerm = try reader["PaymentTerm"].readIfPresent()
        value.orderType = try reader["OrderType"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.LineItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.LineItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.LineItem()
        value.catalogItemId = try reader["CatalogItemId"].readIfPresent()
        value.lineItemId = try reader["LineItemId"].readIfPresent()
        value.quantity = try reader["Quantity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.shipmentInformation = try reader["ShipmentInformation"].readIfPresent(with: OutpostsClientTypes.ShipmentInformation.read(from:))
        value.assetInformationList = try reader["AssetInformationList"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.LineItemAssetInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.previousLineItemId = try reader["PreviousLineItemId"].readIfPresent()
        value.previousOrderId = try reader["PreviousOrderId"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.LineItemAssetInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.LineItemAssetInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.LineItemAssetInformation()
        value.assetId = try reader["AssetId"].readIfPresent()
        value.macAddressList = try reader["MacAddressList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OutpostsClientTypes.ShipmentInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.ShipmentInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.ShipmentInformation()
        value.shipmentTrackingNumber = try reader["ShipmentTrackingNumber"].readIfPresent()
        value.shipmentCarrier = try reader["ShipmentCarrier"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.Outpost {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.Outpost {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.Outpost()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.outpostArn = try reader["OutpostArn"].readIfPresent()
        value.siteId = try reader["SiteId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lifeCycleStatus = try reader["LifeCycleStatus"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["AvailabilityZoneId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.siteArn = try reader["SiteArn"].readIfPresent()
        value.supportedHardwareType = try reader["SupportedHardwareType"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.Site {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.Site {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.Site()
        value.siteId = try reader["SiteId"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.siteArn = try reader["SiteArn"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        value.operatingAddressCountryCode = try reader["OperatingAddressCountryCode"].readIfPresent()
        value.operatingAddressStateOrRegion = try reader["OperatingAddressStateOrRegion"].readIfPresent()
        value.operatingAddressCity = try reader["OperatingAddressCity"].readIfPresent()
        value.rackPhysicalProperties = try reader["RackPhysicalProperties"].readIfPresent(with: OutpostsClientTypes.RackPhysicalProperties.read(from:))
        return value
    }
}

extension OutpostsClientTypes.RackPhysicalProperties {

    static func write(value: OutpostsClientTypes.RackPhysicalProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FiberOpticCableType"].write(value.fiberOpticCableType)
        try writer["MaximumSupportedWeightLbs"].write(value.maximumSupportedWeightLbs)
        try writer["OpticalStandard"].write(value.opticalStandard)
        try writer["PowerConnector"].write(value.powerConnector)
        try writer["PowerDrawKva"].write(value.powerDrawKva)
        try writer["PowerFeedDrop"].write(value.powerFeedDrop)
        try writer["PowerPhase"].write(value.powerPhase)
        try writer["UplinkCount"].write(value.uplinkCount)
        try writer["UplinkGbps"].write(value.uplinkGbps)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.RackPhysicalProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.RackPhysicalProperties()
        value.powerDrawKva = try reader["PowerDrawKva"].readIfPresent()
        value.powerPhase = try reader["PowerPhase"].readIfPresent()
        value.powerConnector = try reader["PowerConnector"].readIfPresent()
        value.powerFeedDrop = try reader["PowerFeedDrop"].readIfPresent()
        value.uplinkGbps = try reader["UplinkGbps"].readIfPresent()
        value.uplinkCount = try reader["UplinkCount"].readIfPresent()
        value.fiberOpticCableType = try reader["FiberOpticCableType"].readIfPresent()
        value.opticalStandard = try reader["OpticalStandard"].readIfPresent()
        value.maximumSupportedWeightLbs = try reader["MaximumSupportedWeightLbs"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.InstanceTypeCapacity {

    static func write(value: OutpostsClientTypes.InstanceTypeCapacity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Count"].write(value.count)
        try writer["InstanceType"].write(value.instanceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.InstanceTypeCapacity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.InstanceTypeCapacity()
        value.instanceType = try reader["InstanceType"].readIfPresent() ?? ""
        value.count = try reader["Count"].readIfPresent() ?? 0
        return value
    }
}

extension OutpostsClientTypes.InstancesToExclude {

    static func write(value: OutpostsClientTypes.InstancesToExclude?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Instances"].writeList(value.instances, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Services"].writeList(value.services, memberWritingClosure: SmithyReadWrite.WritingClosureBox<OutpostsClientTypes.AWSServiceName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.InstancesToExclude {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.InstancesToExclude()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountIds = try reader["AccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<OutpostsClientTypes.AWSServiceName>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OutpostsClientTypes.CapacityTaskFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.CapacityTaskFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.CapacityTaskFailure()
        value.reason = try reader["Reason"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.CatalogItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.CatalogItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.CatalogItem()
        value.catalogItemId = try reader["CatalogItemId"].readIfPresent()
        value.itemStatus = try reader["ItemStatus"].readIfPresent()
        value.ec2Capacities = try reader["EC2Capacities"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.EC2Capacity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.powerKva = try reader["PowerKva"].readIfPresent()
        value.weightLbs = try reader["WeightLbs"].readIfPresent()
        value.supportedUplinkGbps = try reader["SupportedUplinkGbps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedStorage = try reader["SupportedStorage"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<OutpostsClientTypes.SupportedStorageEnum>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OutpostsClientTypes.EC2Capacity {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.EC2Capacity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.EC2Capacity()
        value.family = try reader["Family"].readIfPresent()
        value.maxSize = try reader["MaxSize"].readIfPresent()
        value.quantity = try reader["Quantity"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.ConnectionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.ConnectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.ConnectionDetails()
        value.clientPublicKey = try reader["ClientPublicKey"].readIfPresent()
        value.serverPublicKey = try reader["ServerPublicKey"].readIfPresent()
        value.serverEndpoint = try reader["ServerEndpoint"].readIfPresent()
        value.clientTunnelAddress = try reader["ClientTunnelAddress"].readIfPresent()
        value.serverTunnelAddress = try reader["ServerTunnelAddress"].readIfPresent()
        value.allowedIps = try reader["AllowedIps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OutpostsClientTypes.InstanceTypeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.InstanceTypeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.InstanceTypeItem()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.vcpUs = try reader["VCPUs"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.Address {

    static func write(value: OutpostsClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressLine1"].write(value.addressLine1)
        try writer["AddressLine2"].write(value.addressLine2)
        try writer["AddressLine3"].write(value.addressLine3)
        try writer["City"].write(value.city)
        try writer["ContactName"].write(value.contactName)
        try writer["ContactPhoneNumber"].write(value.contactPhoneNumber)
        try writer["CountryCode"].write(value.countryCode)
        try writer["DistrictOrCounty"].write(value.districtOrCounty)
        try writer["Municipality"].write(value.municipality)
        try writer["PostalCode"].write(value.postalCode)
        try writer["StateOrRegion"].write(value.stateOrRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.Address()
        value.contactName = try reader["ContactName"].readIfPresent()
        value.contactPhoneNumber = try reader["ContactPhoneNumber"].readIfPresent()
        value.addressLine1 = try reader["AddressLine1"].readIfPresent() ?? ""
        value.addressLine2 = try reader["AddressLine2"].readIfPresent()
        value.addressLine3 = try reader["AddressLine3"].readIfPresent()
        value.city = try reader["City"].readIfPresent() ?? ""
        value.stateOrRegion = try reader["StateOrRegion"].readIfPresent() ?? ""
        value.districtOrCounty = try reader["DistrictOrCounty"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent() ?? ""
        value.countryCode = try reader["CountryCode"].readIfPresent() ?? ""
        value.municipality = try reader["Municipality"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.AssetInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.AssetInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.AssetInstance()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.assetId = try reader["AssetId"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.awsServiceName = try reader["AwsServiceName"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.AssetInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.AssetInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.AssetInfo()
        value.assetId = try reader["AssetId"].readIfPresent()
        value.rackId = try reader["RackId"].readIfPresent()
        value.assetType = try reader["AssetType"].readIfPresent()
        value.computeAttributes = try reader["ComputeAttributes"].readIfPresent(with: OutpostsClientTypes.ComputeAttributes.read(from:))
        value.assetLocation = try reader["AssetLocation"].readIfPresent(with: OutpostsClientTypes.AssetLocation.read(from:))
        return value
    }
}

extension OutpostsClientTypes.AssetLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.AssetLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.AssetLocation()
        value.rackElevation = try reader["RackElevation"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.ComputeAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.ComputeAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.ComputeAttributes()
        value.hostId = try reader["HostId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.instanceFamilies = try reader["InstanceFamilies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceTypeCapacities = try reader["InstanceTypeCapacities"].readListIfPresent(memberReadingClosure: OutpostsClientTypes.AssetInstanceTypeCapacity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxVcpus = try reader["MaxVcpus"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.AssetInstanceTypeCapacity {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.AssetInstanceTypeCapacity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.AssetInstanceTypeCapacity()
        value.instanceType = try reader["InstanceType"].readIfPresent() ?? ""
        value.count = try reader["Count"].readIfPresent() ?? 0
        return value
    }
}

extension OutpostsClientTypes.BlockingInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.BlockingInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.BlockingInstance()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.awsServiceName = try reader["AwsServiceName"].readIfPresent()
        return value
    }
}

extension OutpostsClientTypes.CapacityTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.CapacityTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.CapacityTaskSummary()
        value.capacityTaskId = try reader["CapacityTaskId"].readIfPresent()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        value.orderId = try reader["OrderId"].readIfPresent()
        value.capacityTaskStatus = try reader["CapacityTaskStatus"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionDate = try reader["CompletionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension OutpostsClientTypes.OrderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OutpostsClientTypes.OrderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OutpostsClientTypes.OrderSummary()
        value.outpostId = try reader["OutpostId"].readIfPresent()
        value.orderId = try reader["OrderId"].readIfPresent()
        value.orderType = try reader["OrderType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.lineItemCountsByStatus = try reader["LineItemCountsByStatus"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.orderSubmissionDate = try reader["OrderSubmissionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.orderFulfilledDate = try reader["OrderFulfilledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension OutpostsClientTypes.LineItemRequest {

    static func write(value: OutpostsClientTypes.LineItemRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogItemId"].write(value.catalogItemId)
        try writer["Quantity"].write(value.quantity)
    }
}

public enum OutpostsClientTypes {}
