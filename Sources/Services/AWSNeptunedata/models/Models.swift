// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised in case of an authentication or authorization failure.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes {
    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case initializeReset
        case performReset
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .initializeReset,
                .performReset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .initializeReset: return "initiateDatabaseReset"
            case .performReset: return "performDatabaseReset"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request is submitted that cannot be processed.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the bad request.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension BulkLoadIdNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BulkLoadIdNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a specified bulk-load job ID cannot be found.
public struct BulkLoadIdNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The bulk-load job ID that could not be found.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BulkLoadIdNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct BulkLoadIdNotFoundExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension BulkLoadIdNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CancelGremlinQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let queryId = queryId else {
            return nil
        }
        return "/gremlin/status/\(queryId.urlPercentEncoding())"
    }
}

public struct CancelGremlinQueryInput: Swift.Equatable {
    /// The unique identifier that identifies the query to be canceled.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct CancelGremlinQueryInputBody: Swift.Equatable {
}

extension CancelGremlinQueryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelGremlinQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelGremlinQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelGremlinQueryOutput: Swift.Equatable {
    /// The status of the cancelation
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct CancelGremlinQueryOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension CancelGremlinQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelGremlinQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelLoaderJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loadId = loadId else {
            return nil
        }
        return "/loader/\(loadId.urlPercentEncoding())"
    }
}

public struct CancelLoaderJobInput: Swift.Equatable {
    /// The ID of the load job to be deleted.
    /// This member is required.
    public var loadId: Swift.String?

    public init(
        loadId: Swift.String? = nil
    )
    {
        self.loadId = loadId
    }
}

struct CancelLoaderJobInputBody: Swift.Equatable {
}

extension CancelLoaderJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelLoaderJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelLoaderJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelLoaderJobOutput: Swift.Equatable {
    /// The cancellation status.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct CancelLoaderJobOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension CancelLoaderJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelLoaderJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BulkLoadIdNotFoundException": return try await BulkLoadIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LoadUrlAccessDeniedException": return try await LoadUrlAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelMLDataProcessingJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            if let clean = clean {
                let cleanQueryItem = ClientRuntime.URLQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
                items.append(cleanQueryItem)
            }
            return items
        }
    }
}

extension CancelMLDataProcessingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/dataprocessing/\(id.urlPercentEncoding())"
    }
}

public struct CancelMLDataProcessingJobInput: Swift.Equatable {
    /// If set to TRUE, this flag specifies that all Neptune ML S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique identifier of the data-processing job.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct CancelMLDataProcessingJobInputBody: Swift.Equatable {
}

extension CancelMLDataProcessingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelMLDataProcessingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelMLDataProcessingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelMLDataProcessingJobOutput: Swift.Equatable {
    /// The status of the cancellation request.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct CancelMLDataProcessingJobOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension CancelMLDataProcessingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelMLDataProcessingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelMLModelTrainingJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            if let clean = clean {
                let cleanQueryItem = ClientRuntime.URLQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
                items.append(cleanQueryItem)
            }
            return items
        }
    }
}

extension CancelMLModelTrainingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/modeltraining/\(id.urlPercentEncoding())"
    }
}

public struct CancelMLModelTrainingJobInput: Swift.Equatable {
    /// If set to TRUE, this flag specifies that all Amazon S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique identifier of the model-training job to be canceled.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct CancelMLModelTrainingJobInputBody: Swift.Equatable {
}

extension CancelMLModelTrainingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelMLModelTrainingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelMLModelTrainingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelMLModelTrainingJobOutput: Swift.Equatable {
    /// The status of the cancellation.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct CancelMLModelTrainingJobOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension CancelMLModelTrainingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelMLModelTrainingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelMLModelTransformJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            if let clean = clean {
                let cleanQueryItem = ClientRuntime.URLQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
                items.append(cleanQueryItem)
            }
            return items
        }
    }
}

extension CancelMLModelTransformJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/modeltransform/\(id.urlPercentEncoding())"
    }
}

public struct CancelMLModelTransformJobInput: Swift.Equatable {
    /// If this flag is set to TRUE, all Neptune ML S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique ID of the model transform job to be canceled.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct CancelMLModelTransformJobInputBody: Swift.Equatable {
}

extension CancelMLModelTransformJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelMLModelTransformJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelMLModelTransformJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelMLModelTransformJobOutput: Swift.Equatable {
    /// the status of the cancelation.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct CancelMLModelTransformJobOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension CancelMLModelTransformJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelMLModelTransformJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelOpenCypherQueryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let silent = silent {
                let silentQueryItem = ClientRuntime.URLQueryItem(name: "silent".urlPercentEncoding(), value: Swift.String(silent).urlPercentEncoding())
                items.append(silentQueryItem)
            }
            return items
        }
    }
}

extension CancelOpenCypherQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let queryId = queryId else {
            return nil
        }
        return "/opencypher/status/\(queryId.urlPercentEncoding())"
    }
}

public struct CancelOpenCypherQueryInput: Swift.Equatable {
    /// The unique ID of the openCypher query to cancel.
    /// This member is required.
    public var queryId: Swift.String?
    /// If set to TRUE, causes the cancelation of the openCypher query to happen silently.
    public var silent: Swift.Bool?

    public init(
        queryId: Swift.String? = nil,
        silent: Swift.Bool? = nil
    )
    {
        self.queryId = queryId
        self.silent = silent
    }
}

struct CancelOpenCypherQueryInputBody: Swift.Equatable {
}

extension CancelOpenCypherQueryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelOpenCypherQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelOpenCypherQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct CancelOpenCypherQueryOutput: Swift.Equatable {
    /// The cancelation payload for the openCypher query.
    public var payload: Swift.Bool?
    /// The cancellation status of the openCypher query.
    public var status: Swift.String?

    public init(
        payload: Swift.Bool? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct CancelOpenCypherQueryOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: Swift.Bool?
}

extension CancelOpenCypherQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum CancelOpenCypherQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNumericDataException": return try await InvalidNumericDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelledByUserException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelledByUserExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a user cancelled a request.
public struct CancelledByUserException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CancelledByUserException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct CancelledByUserExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension CancelledByUserExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ClientTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClientTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request timed out in the client.
public struct ClientTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ClientTimeoutExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ClientTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request attempts to modify data that is concurrently being modified by another process.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ConstraintViolationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConstraintViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a value in a request field did not satisfy required constraints.
public struct ConstraintViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConstraintViolationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ConstraintViolationExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ConstraintViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CreateMLEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case instanceCount
        case instanceType
        case mlModelTrainingJobId
        case mlModelTransformJobId
        case modelName
        case neptuneIamRoleArn
        case update
        case volumeEncryptionKMSKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let mlModelTrainingJobId = self.mlModelTrainingJobId {
            try encodeContainer.encode(mlModelTrainingJobId, forKey: .mlModelTrainingJobId)
        }
        if let mlModelTransformJobId = self.mlModelTransformJobId {
            try encodeContainer.encode(mlModelTransformJobId, forKey: .mlModelTransformJobId)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let neptuneIamRoleArn = self.neptuneIamRoleArn {
            try encodeContainer.encode(neptuneIamRoleArn, forKey: .neptuneIamRoleArn)
        }
        if let update = self.update {
            try encodeContainer.encode(update, forKey: .update)
        }
        if let volumeEncryptionKMSKey = self.volumeEncryptionKMSKey {
            try encodeContainer.encode(volumeEncryptionKMSKey, forKey: .volumeEncryptionKMSKey)
        }
    }
}

extension CreateMLEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/endpoints"
    }
}

public struct CreateMLEndpointInput: Swift.Equatable {
    /// A unique identifier for the new inference endpoint. The default is an autogenerated timestamped name.
    public var id: Swift.String?
    /// The minimum number of Amazon EC2 instances to deploy to an endpoint for prediction. The default is 1
    public var instanceCount: Swift.Int?
    /// The type of Neptune ML instance to use for online servicing. The default is ml.m5.xlarge. Choosing the ML instance for an inference endpoint depends on the task type, the graph size, and your budget.
    public var instanceType: Swift.String?
    /// The job Id of the completed model-training job that has created the model that the inference endpoint will point to. You must supply either the mlModelTrainingJobId or the mlModelTransformJobId.
    public var mlModelTrainingJobId: Swift.String?
    /// The job Id of the completed model-transform job. You must supply either the mlModelTrainingJobId or the mlModelTransformJobId.
    public var mlModelTransformJobId: Swift.String?
    /// Model type for training. By default the Neptune ML model is automatically based on the modelType used in data processing, but you can specify a different model type here. The default is rgcn for heterogeneous graphs and kge for knowledge graphs. The only valid value for heterogeneous graphs is rgcn. Valid values for knowledge graphs are: kge, transe, distmult, and rotate.
    public var modelName: Swift.String?
    /// The ARN of an IAM role providing Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will be thrown.
    public var neptuneIamRoleArn: Swift.String?
    /// If set to true, update indicates that this is an update request. The default is false. You must supply either the mlModelTrainingJobId or the mlModelTransformJobId.
    public var update: Swift.Bool?
    /// The Amazon Key Management Service (Amazon KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        id: Swift.String? = nil,
        instanceCount: Swift.Int? = nil,
        instanceType: Swift.String? = nil,
        mlModelTrainingJobId: Swift.String? = nil,
        mlModelTransformJobId: Swift.String? = nil,
        modelName: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        update: Swift.Bool? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.id = id
        self.instanceCount = instanceCount
        self.instanceType = instanceType
        self.mlModelTrainingJobId = mlModelTrainingJobId
        self.mlModelTransformJobId = mlModelTransformJobId
        self.modelName = modelName
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.update = update
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

struct CreateMLEndpointInputBody: Swift.Equatable {
    let id: Swift.String?
    let mlModelTrainingJobId: Swift.String?
    let mlModelTransformJobId: Swift.String?
    let update: Swift.Bool?
    let neptuneIamRoleArn: Swift.String?
    let modelName: Swift.String?
    let instanceType: Swift.String?
    let instanceCount: Swift.Int?
    let volumeEncryptionKMSKey: Swift.String?
}

extension CreateMLEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case instanceCount
        case instanceType
        case mlModelTrainingJobId
        case mlModelTransformJobId
        case modelName
        case neptuneIamRoleArn
        case update
        case volumeEncryptionKMSKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let mlModelTrainingJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mlModelTrainingJobId)
        mlModelTrainingJobId = mlModelTrainingJobIdDecoded
        let mlModelTransformJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mlModelTransformJobId)
        mlModelTransformJobId = mlModelTransformJobIdDecoded
        let updateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .update)
        update = updateDecoded
        let neptuneIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neptuneIamRoleArn)
        neptuneIamRoleArn = neptuneIamRoleArnDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let volumeEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKMSKey)
        volumeEncryptionKMSKey = volumeEncryptionKMSKeyDecoded
    }
}

extension CreateMLEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMLEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimeInMillis = output.creationTimeInMillis
            self.id = output.id
        } else {
            self.arn = nil
            self.creationTimeInMillis = nil
            self.id = nil
        }
    }
}

public struct CreateMLEndpointOutput: Swift.Equatable {
    /// The ARN for the new inference endpoint.
    public var arn: Swift.String?
    /// The endpoint creation time, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new inference endpoint.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

struct CreateMLEndpointOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let creationTimeInMillis: Swift.Int?
}

extension CreateMLEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTimeInMillis
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTimeInMillis)
        creationTimeInMillis = creationTimeInMillisDecoded
    }
}

enum CreateMLEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptunedataClientTypes.CustomModelTrainingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3DirectoryPath
        case trainingEntryPointScript
        case transformEntryPointScript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceS3DirectoryPath = self.sourceS3DirectoryPath {
            try encodeContainer.encode(sourceS3DirectoryPath, forKey: .sourceS3DirectoryPath)
        }
        if let trainingEntryPointScript = self.trainingEntryPointScript {
            try encodeContainer.encode(trainingEntryPointScript, forKey: .trainingEntryPointScript)
        }
        if let transformEntryPointScript = self.transformEntryPointScript {
            try encodeContainer.encode(transformEntryPointScript, forKey: .transformEntryPointScript)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3DirectoryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceS3DirectoryPath)
        sourceS3DirectoryPath = sourceS3DirectoryPathDecoded
        let trainingEntryPointScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingEntryPointScript)
        trainingEntryPointScript = trainingEntryPointScriptDecoded
        let transformEntryPointScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformEntryPointScript)
        transformEntryPointScript = transformEntryPointScriptDecoded
    }
}

extension NeptunedataClientTypes {
    /// Contains custom model training parameters. See [Custom models in Neptune ML](https://docs.aws.amazon.com/neptune/latest/userguide/machine-learning-custom-models.html).
    public struct CustomModelTrainingParameters: Swift.Equatable {
        /// The path to the Amazon S3 location where the Python module implementing your model is located. This must point to a valid existing Amazon S3 location that contains, at a minimum, a training script, a transform script, and a model-hpo-configuration.json file.
        /// This member is required.
        public var sourceS3DirectoryPath: Swift.String?
        /// The name of the entry point in your module of a script that performs model training and takes hyperparameters as command-line arguments, including fixed hyperparameters. The default is training.py.
        public var trainingEntryPointScript: Swift.String?
        /// The name of the entry point in your module of a script that should be run after the best model from the hyperparameter search has been identified, to compute the model artifacts necessary for model deployment. It should be able to run with no command-line arguments.The default is transform.py.
        public var transformEntryPointScript: Swift.String?

        public init(
            sourceS3DirectoryPath: Swift.String? = nil,
            trainingEntryPointScript: Swift.String? = nil,
            transformEntryPointScript: Swift.String? = nil
        )
        {
            self.sourceS3DirectoryPath = sourceS3DirectoryPath
            self.trainingEntryPointScript = trainingEntryPointScript
            self.transformEntryPointScript = transformEntryPointScript
        }
    }

}

extension NeptunedataClientTypes.CustomModelTransformParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3DirectoryPath
        case transformEntryPointScript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceS3DirectoryPath = self.sourceS3DirectoryPath {
            try encodeContainer.encode(sourceS3DirectoryPath, forKey: .sourceS3DirectoryPath)
        }
        if let transformEntryPointScript = self.transformEntryPointScript {
            try encodeContainer.encode(transformEntryPointScript, forKey: .transformEntryPointScript)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3DirectoryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceS3DirectoryPath)
        sourceS3DirectoryPath = sourceS3DirectoryPathDecoded
        let transformEntryPointScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformEntryPointScript)
        transformEntryPointScript = transformEntryPointScriptDecoded
    }
}

extension NeptunedataClientTypes {
    /// Contains custom model transform parameters. See [Use a trained model to generate new model artifacts](https://docs.aws.amazon.com/neptune/latest/userguide/machine-learning-model-transform.html).
    public struct CustomModelTransformParameters: Swift.Equatable {
        /// The path to the Amazon S3 location where the Python module implementing your model is located. This must point to a valid existing Amazon S3 location that contains, at a minimum, a training script, a transform script, and a model-hpo-configuration.json file.
        /// This member is required.
        public var sourceS3DirectoryPath: Swift.String?
        /// The name of the entry point in your module of a script that should be run after the best model from the hyperparameter search has been identified, to compute the model artifacts necessary for model deployment. It should be able to run with no command-line arguments. The default is transform.py.
        public var transformEntryPointScript: Swift.String?

        public init(
            sourceS3DirectoryPath: Swift.String? = nil,
            transformEntryPointScript: Swift.String? = nil
        )
        {
            self.sourceS3DirectoryPath = sourceS3DirectoryPath
            self.transformEntryPointScript = transformEntryPointScript
        }
    }

}

extension DeleteMLEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            if let clean = clean {
                let cleanQueryItem = ClientRuntime.URLQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
                items.append(cleanQueryItem)
            }
            return items
        }
    }
}

extension DeleteMLEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DeleteMLEndpointInput: Swift.Equatable {
    /// If this flag is set to TRUE, all Neptune ML S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique identifier of the inference endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role providing Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will be thrown.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct DeleteMLEndpointInputBody: Swift.Equatable {
}

extension DeleteMLEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMLEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMLEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteMLEndpointOutput: Swift.Equatable {
    /// The status of the cancellation.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteMLEndpointOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteMLEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteMLEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePropertygraphStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/propertygraph/statistics"
    }
}

public struct DeletePropertygraphStatisticsInput: Swift.Equatable {

    public init() { }
}

struct DeletePropertygraphStatisticsInputBody: Swift.Equatable {
}

extension DeletePropertygraphStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePropertygraphStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePropertygraphStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct DeletePropertygraphStatisticsOutput: Swift.Equatable {
    /// The deletion payload.
    public var payload: NeptunedataClientTypes.DeleteStatisticsValueMap?
    /// The cancel status.
    public var status: Swift.String?
    /// The HTTP response code: 200 if the delete was successful, or 204 if there were no statistics to delete.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.DeleteStatisticsValueMap? = nil,
        status: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.status = status
        self.statusCode = statusCode
    }
}

struct DeletePropertygraphStatisticsOutputBody: Swift.Equatable {
    let statusCode: Swift.Int?
    let status: Swift.String?
    let payload: NeptunedataClientTypes.DeleteStatisticsValueMap?
}

extension DeletePropertygraphStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.DeleteStatisticsValueMap.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum DeletePropertygraphStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSparqlStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sparql/statistics"
    }
}

public struct DeleteSparqlStatisticsInput: Swift.Equatable {

    public init() { }
}

struct DeleteSparqlStatisticsInputBody: Swift.Equatable {
}

extension DeleteSparqlStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSparqlStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSparqlStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct DeleteSparqlStatisticsOutput: Swift.Equatable {
    /// The deletion payload.
    public var payload: NeptunedataClientTypes.DeleteStatisticsValueMap?
    /// The cancel status.
    public var status: Swift.String?
    /// The HTTP response code: 200 if the delete was successful, or 204 if there were no statistics to delete.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.DeleteStatisticsValueMap? = nil,
        status: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.status = status
        self.statusCode = statusCode
    }
}

struct DeleteSparqlStatisticsOutputBody: Swift.Equatable {
    let statusCode: Swift.Int?
    let status: Swift.String?
    let payload: NeptunedataClientTypes.DeleteStatisticsValueMap?
}

extension DeleteSparqlStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.DeleteStatisticsValueMap.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum DeleteSparqlStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptunedataClientTypes.DeleteStatisticsValueMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case statisticsId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let statisticsId = self.statisticsId {
            try encodeContainer.encode(statisticsId, forKey: .statisticsId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let statisticsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statisticsId)
        statisticsId = statisticsIdDecoded
    }
}

extension NeptunedataClientTypes {
    /// The payload for DeleteStatistics.
    public struct DeleteStatisticsValueMap: Swift.Equatable {
        /// The current status of the statistics.
        public var active: Swift.Bool?
        /// The ID of the statistics generation run that is currently occurring.
        public var statisticsId: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            statisticsId: Swift.String? = nil
        )
        {
            self.active = active
            self.statisticsId = statisticsId
        }
    }

}

extension NeptunedataClientTypes.EdgeStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case edgeProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let edgeProperties = edgeProperties {
            var edgePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeProperties)
            for string0 in edgeProperties {
                try edgePropertiesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let edgePropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeProperties)
        var edgePropertiesDecoded0:[Swift.String]? = nil
        if let edgePropertiesContainer = edgePropertiesContainer {
            edgePropertiesDecoded0 = [Swift.String]()
            for string0 in edgePropertiesContainer {
                if let string0 = string0 {
                    edgePropertiesDecoded0?.append(string0)
                }
            }
        }
        edgeProperties = edgePropertiesDecoded0
    }
}

extension NeptunedataClientTypes {
    /// An edge structure.
    public struct EdgeStructure: Swift.Equatable {
        /// The number of edges that have this specific structure.
        public var count: Swift.Int?
        /// A list of edge properties present in this specific structure.
        public var edgeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            edgeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.edgeProperties = edgeProperties
        }
    }

}

extension NeptunedataClientTypes {
    public enum Encoding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case sdkUnknown(Swift.String)

        public static var allCases: [Encoding] {
            return [
                .gzip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Encoding(rawValue: rawValue) ?? Encoding.sdkUnknown(rawValue)
        }
    }
}

extension ExecuteFastResetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

extension ExecuteFastResetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/system"
    }
}

public struct ExecuteFastResetInput: Swift.Equatable {
    /// The fast reset action. One of the following values:
    ///
    /// * initiateDatabaseReset – This action generates a unique token needed to actually perform the fast reset.
    ///
    /// * performDatabaseReset – This action uses the token generated by the initiateDatabaseReset action to actually perform the fast reset.
    /// This member is required.
    public var action: NeptunedataClientTypes.Action?
    /// The fast-reset token to initiate the reset.
    public var token: Swift.String?

    public init(
        action: NeptunedataClientTypes.Action? = nil,
        token: Swift.String? = nil
    )
    {
        self.action = action
        self.token = token
    }
}

struct ExecuteFastResetInputBody: Swift.Equatable {
    let action: NeptunedataClientTypes.Action?
    let token: Swift.String?
}

extension ExecuteFastResetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case token
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension ExecuteFastResetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteFastResetOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct ExecuteFastResetOutput: Swift.Equatable {
    /// The payload is only returned by the initiateDatabaseReset action, and contains the unique token to use with the performDatabaseReset action to make the reset occur.
    public var payload: NeptunedataClientTypes.FastResetToken?
    /// The status is only returned for the performDatabaseReset action, and indicates whether or not the fast reset rquest is accepted.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.FastResetToken? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct ExecuteFastResetOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: NeptunedataClientTypes.FastResetToken?
}

extension ExecuteFastResetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.FastResetToken.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum ExecuteFastResetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MethodNotAllowedException": return try await MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerShutdownException": return try await ServerShutdownException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteGremlinExplainQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gremlinQuery = "gremlin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gremlinQuery = self.gremlinQuery {
            try encodeContainer.encode(gremlinQuery, forKey: .gremlinQuery)
        }
    }
}

extension ExecuteGremlinExplainQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/gremlin/explain"
    }
}

public struct ExecuteGremlinExplainQueryInput: Swift.Equatable {
    /// The Gremlin explain query string.
    /// This member is required.
    public var gremlinQuery: Swift.String?

    public init(
        gremlinQuery: Swift.String? = nil
    )
    {
        self.gremlinQuery = gremlinQuery
    }
}

struct ExecuteGremlinExplainQueryInputBody: Swift.Equatable {
    let gremlinQuery: Swift.String?
}

extension ExecuteGremlinExplainQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gremlinQuery = "gremlin"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gremlinQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gremlinQuery)
        gremlinQuery = gremlinQueryDecoded
    }
}

extension ExecuteGremlinExplainQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.output = data
        case .stream(let stream):
            self.output = try stream.readToEnd()
        case .noStream:
            self.output = nil
        }
    }
}

public struct ExecuteGremlinExplainQueryOutput: Swift.Equatable {
    /// A text blob containing the Gremlin explain result, as described in [Tuning Gremlin queries](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-traversal-tuning.html).
    public var output: ClientRuntime.Data?

    public init(
        output: ClientRuntime.Data? = nil
    )
    {
        self.output = output
    }
}

struct ExecuteGremlinExplainQueryOutputBody: Swift.Equatable {
    let output: ClientRuntime.Data?
}

extension ExecuteGremlinExplainQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .output)
        output = outputDecoded
    }
}

enum ExecuteGremlinExplainQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CancelledByUserException": return try await CancelledByUserException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedQueryException": return try await MalformedQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitExceededException": return try await QueryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitException": return try await QueryLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryTooLargeException": return try await QueryTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteGremlinProfileQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chop = "profile.chop"
        case gremlinQuery = "gremlin"
        case indexOps = "profile.indexOps"
        case results = "profile.results"
        case serializer = "profile.serializer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chop = self.chop {
            try encodeContainer.encode(chop, forKey: .chop)
        }
        if let gremlinQuery = self.gremlinQuery {
            try encodeContainer.encode(gremlinQuery, forKey: .gremlinQuery)
        }
        if let indexOps = self.indexOps {
            try encodeContainer.encode(indexOps, forKey: .indexOps)
        }
        if let results = self.results {
            try encodeContainer.encode(results, forKey: .results)
        }
        if let serializer = self.serializer {
            try encodeContainer.encode(serializer, forKey: .serializer)
        }
    }
}

extension ExecuteGremlinProfileQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/gremlin/profile"
    }
}

public struct ExecuteGremlinProfileQueryInput: Swift.Equatable {
    /// If non-zero, causes the results string to be truncated at that number of characters. If set to zero, the string contains all the results.
    public var chop: Swift.Int?
    /// The Gremlin query string to profile.
    /// This member is required.
    public var gremlinQuery: Swift.String?
    /// If this flag is set to TRUE, the results include a detailed report of all index operations that took place during query execution and serialization.
    public var indexOps: Swift.Bool?
    /// If this flag is set to TRUE, the query results are gathered and displayed as part of the profile report. If FALSE, only the result count is displayed.
    public var results: Swift.Bool?
    /// If non-null, the gathered results are returned in a serialized response message in the format specified by this parameter. See [Gremlin profile API in Neptune](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-profile-api.html) for more information.
    public var serializer: Swift.String?

    public init(
        chop: Swift.Int? = nil,
        gremlinQuery: Swift.String? = nil,
        indexOps: Swift.Bool? = nil,
        results: Swift.Bool? = nil,
        serializer: Swift.String? = nil
    )
    {
        self.chop = chop
        self.gremlinQuery = gremlinQuery
        self.indexOps = indexOps
        self.results = results
        self.serializer = serializer
    }
}

struct ExecuteGremlinProfileQueryInputBody: Swift.Equatable {
    let gremlinQuery: Swift.String?
    let results: Swift.Bool?
    let chop: Swift.Int?
    let serializer: Swift.String?
    let indexOps: Swift.Bool?
}

extension ExecuteGremlinProfileQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chop = "profile.chop"
        case gremlinQuery = "gremlin"
        case indexOps = "profile.indexOps"
        case results = "profile.results"
        case serializer = "profile.serializer"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gremlinQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gremlinQuery)
        gremlinQuery = gremlinQueryDecoded
        let resultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .results)
        results = resultsDecoded
        let chopDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .chop)
        chop = chopDecoded
        let serializerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serializer)
        serializer = serializerDecoded
        let indexOpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .indexOps)
        indexOps = indexOpsDecoded
    }
}

extension ExecuteGremlinProfileQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.output = data
        case .stream(let stream):
            self.output = try stream.readToEnd()
        case .noStream:
            self.output = nil
        }
    }
}

public struct ExecuteGremlinProfileQueryOutput: Swift.Equatable {
    /// A text blob containing the Gremlin Profile result. See [Gremlin profile API in Neptune](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-profile-api.html) for details.
    public var output: ClientRuntime.Data?

    public init(
        output: ClientRuntime.Data? = nil
    )
    {
        self.output = output
    }
}

struct ExecuteGremlinProfileQueryOutputBody: Swift.Equatable {
    let output: ClientRuntime.Data?
}

extension ExecuteGremlinProfileQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .output)
        output = outputDecoded
    }
}

enum ExecuteGremlinProfileQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CancelledByUserException": return try await CancelledByUserException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedQueryException": return try await MalformedQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitExceededException": return try await QueryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitException": return try await QueryLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryTooLargeException": return try await QueryTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteGremlinQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gremlinQuery = "gremlin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gremlinQuery = self.gremlinQuery {
            try encodeContainer.encode(gremlinQuery, forKey: .gremlinQuery)
        }
    }
}

extension ExecuteGremlinQueryInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let serializer = serializer {
            items.add(Header(name: "accept", value: Swift.String(serializer)))
        }
        return items
    }
}

extension ExecuteGremlinQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/gremlin"
    }
}

public struct ExecuteGremlinQueryInput: Swift.Equatable {
    /// Using this API, you can run Gremlin queries in string format much as you can using the HTTP endpoint. The interface is compatible with whatever Gremlin version your DB cluster is using (see the [Tinkerpop client section](https://docs.aws.amazon.com/neptune/latest/userguide/access-graph-gremlin-client.html#best-practices-gremlin-java-latest) to determine which Gremlin releases your engine version supports).
    /// This member is required.
    public var gremlinQuery: Swift.String?
    /// If non-null, the query results are returned in a serialized response message in the format specified by this parameter. See the [GraphSON](https://tinkerpop.apache.org/docs/current/reference/#_graphson) section in the TinkerPop documentation for a list of the formats that are currently supported.
    public var serializer: Swift.String?

    public init(
        gremlinQuery: Swift.String? = nil,
        serializer: Swift.String? = nil
    )
    {
        self.gremlinQuery = gremlinQuery
        self.serializer = serializer
    }
}

struct ExecuteGremlinQueryInputBody: Swift.Equatable {
    let gremlinQuery: Swift.String?
}

extension ExecuteGremlinQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gremlinQuery = "gremlin"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gremlinQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gremlinQuery)
        gremlinQuery = gremlinQueryDecoded
    }
}

extension ExecuteGremlinQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteGremlinQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.meta = output.meta
            self.requestId = output.requestId
            self.result = output.result
            self.status = output.status
        } else {
            self.meta = nil
            self.requestId = nil
            self.result = nil
            self.status = nil
        }
    }
}

public struct ExecuteGremlinQueryOutput: Swift.Equatable {
    /// Metadata about the Gremlin query.
    public var meta: ClientRuntime.Document?
    /// The unique identifier of the Gremlin query.
    public var requestId: Swift.String?
    /// The Gremlin query output from the server.
    public var result: ClientRuntime.Document?
    /// The status of the Gremlin query.
    public var status: NeptunedataClientTypes.GremlinQueryStatusAttributes?

    public init(
        meta: ClientRuntime.Document? = nil,
        requestId: Swift.String? = nil,
        result: ClientRuntime.Document? = nil,
        status: NeptunedataClientTypes.GremlinQueryStatusAttributes? = nil
    )
    {
        self.meta = meta
        self.requestId = requestId
        self.result = result
        self.status = status
    }
}

struct ExecuteGremlinQueryOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: NeptunedataClientTypes.GremlinQueryStatusAttributes?
    let result: ClientRuntime.Document?
    let meta: ClientRuntime.Document?
}

extension ExecuteGremlinQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meta
        case requestId
        case result
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.GremlinQueryStatusAttributes.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .result)
        result = resultDecoded
        let metaDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .meta)
        meta = metaDecoded
    }
}

enum ExecuteGremlinQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CancelledByUserException": return try await CancelledByUserException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedQueryException": return try await MalformedQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitExceededException": return try await QueryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitException": return try await QueryLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryTooLargeException": return try await QueryTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteOpenCypherExplainQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainMode = "explain"
        case openCypherQuery = "query"
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainMode = self.explainMode {
            try encodeContainer.encode(explainMode.rawValue, forKey: .explainMode)
        }
        if let openCypherQuery = self.openCypherQuery {
            try encodeContainer.encode(openCypherQuery, forKey: .openCypherQuery)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }
}

extension ExecuteOpenCypherExplainQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/opencypher/explain"
    }
}

public struct ExecuteOpenCypherExplainQueryInput: Swift.Equatable {
    /// The openCypher explain mode. Can be one of: static, dynamic, or details.
    /// This member is required.
    public var explainMode: NeptunedataClientTypes.OpenCypherExplainMode?
    /// The openCypher query string.
    /// This member is required.
    public var openCypherQuery: Swift.String?
    /// The openCypher query parameters.
    public var parameters: Swift.String?

    public init(
        explainMode: NeptunedataClientTypes.OpenCypherExplainMode? = nil,
        openCypherQuery: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.explainMode = explainMode
        self.openCypherQuery = openCypherQuery
        self.parameters = parameters
    }
}

struct ExecuteOpenCypherExplainQueryInputBody: Swift.Equatable {
    let openCypherQuery: Swift.String?
    let parameters: Swift.String?
    let explainMode: NeptunedataClientTypes.OpenCypherExplainMode?
}

extension ExecuteOpenCypherExplainQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainMode = "explain"
        case openCypherQuery = "query"
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openCypherQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openCypherQuery)
        openCypherQuery = openCypherQueryDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let explainModeDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.OpenCypherExplainMode.self, forKey: .explainMode)
        explainMode = explainModeDecoded
    }
}

extension ExecuteOpenCypherExplainQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.results = data
        case .stream(let stream):
            self.results = try stream.readToEnd()
        case .noStream:
            self.results = nil
        }
    }
}

public struct ExecuteOpenCypherExplainQueryOutput: Swift.Equatable {
    /// A text blob containing the openCypher explain results.
    /// This member is required.
    public var results: ClientRuntime.Data?

    public init(
        results: ClientRuntime.Data? = nil
    )
    {
        self.results = results
    }
}

struct ExecuteOpenCypherExplainQueryOutputBody: Swift.Equatable {
    let results: ClientRuntime.Data?
}

extension ExecuteOpenCypherExplainQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .results)
        results = resultsDecoded
    }
}

enum ExecuteOpenCypherExplainQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CancelledByUserException": return try await CancelledByUserException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNumericDataException": return try await InvalidNumericDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedQueryException": return try await MalformedQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitExceededException": return try await QueryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitException": return try await QueryLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryTooLargeException": return try await QueryTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteOpenCypherQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openCypherQuery = "query"
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let openCypherQuery = self.openCypherQuery {
            try encodeContainer.encode(openCypherQuery, forKey: .openCypherQuery)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }
}

extension ExecuteOpenCypherQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/opencypher"
    }
}

public struct ExecuteOpenCypherQueryInput: Swift.Equatable {
    /// The openCypher query string to be executed.
    /// This member is required.
    public var openCypherQuery: Swift.String?
    /// The openCypher query parameters for query execution. See [Examples of openCypher parameterized queries](https://docs.aws.amazon.com/neptune/latest/userguide/opencypher-parameterized-queries.html) for more information.
    public var parameters: Swift.String?

    public init(
        openCypherQuery: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.openCypherQuery = openCypherQuery
        self.parameters = parameters
    }
}

struct ExecuteOpenCypherQueryInputBody: Swift.Equatable {
    let openCypherQuery: Swift.String?
    let parameters: Swift.String?
}

extension ExecuteOpenCypherQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openCypherQuery = "query"
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openCypherQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openCypherQuery)
        openCypherQuery = openCypherQueryDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension ExecuteOpenCypherQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteOpenCypherQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
        } else {
            self.results = nil
        }
    }
}

public struct ExecuteOpenCypherQueryOutput: Swift.Equatable {
    /// The openCypherquery results.
    /// This member is required.
    public var results: ClientRuntime.Document?

    public init(
        results: ClientRuntime.Document? = nil
    )
    {
        self.results = results
    }
}

struct ExecuteOpenCypherQueryOutputBody: Swift.Equatable {
    let results: ClientRuntime.Document?
}

extension ExecuteOpenCypherQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .results)
        results = resultsDecoded
    }
}

enum ExecuteOpenCypherQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CancelledByUserException": return try await CancelledByUserException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNumericDataException": return try await InvalidNumericDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedQueryException": return try await MalformedQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitExceededException": return try await QueryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryLimitException": return try await QueryLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryTooLargeException": return try await QueryTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExpiredStreamException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredStreamExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request attempts to access an stream that has expired.
public struct ExpiredStreamException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredStreamException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ExpiredStreamExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ExpiredStreamExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension FailureByQueryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FailureByQueryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request fails.
public struct FailureByQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FailureByQueryException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct FailureByQueryExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension FailureByQueryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.FastResetToken: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension NeptunedataClientTypes {
    /// A structure containing the fast reset token used to initiate a fast reset.
    public struct FastResetToken: Swift.Equatable {
        /// A UUID generated by the database in the initiateDatabaseReset action, and then consumed by the performDatabaseReset to reset the database.
        public var token: Swift.String?

        public init(
            token: Swift.String? = nil
        )
        {
            self.token = token
        }
    }

}

extension NeptunedataClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case nquads
        case ntriples
        case opencypher
        case rdfxml
        case turtle
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .nquads,
                .ntriples,
                .opencypher,
                .rdfxml,
                .turtle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .nquads: return "nquads"
            case .ntriples: return "ntriples"
            case .opencypher: return "opencypher"
            case .rdfxml: return "rdfxml"
            case .turtle: return "turtle"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetEngineStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/status"
    }
}

public struct GetEngineStatusInput: Swift.Equatable {

    public init() { }
}

struct GetEngineStatusInputBody: Swift.Equatable {
}

extension GetEngineStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEngineStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEngineStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.dbEngineVersion = output.dbEngineVersion
            self.dfeQueryEngine = output.dfeQueryEngine
            self.features = output.features
            self.gremlin = output.gremlin
            self.labMode = output.labMode
            self.opencypher = output.opencypher
            self.role = output.role
            self.rollingBackTrxCount = output.rollingBackTrxCount
            self.rollingBackTrxEarliestStartTime = output.rollingBackTrxEarliestStartTime
            self.settings = output.settings
            self.sparql = output.sparql
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.dbEngineVersion = nil
            self.dfeQueryEngine = nil
            self.features = nil
            self.gremlin = nil
            self.labMode = nil
            self.opencypher = nil
            self.role = nil
            self.rollingBackTrxCount = nil
            self.rollingBackTrxEarliestStartTime = nil
            self.settings = nil
            self.sparql = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct GetEngineStatusOutput: Swift.Equatable {
    /// Set to the Neptune engine version running on your DB cluster. If this engine version has been manually patched since it was released, the version number is prefixed by Patch-.
    public var dbEngineVersion: Swift.String?
    /// Set to enabled if the DFE engine is fully enabled, or to viaQueryHint (the default) if the DFE engine is only used with queries that have the useDFE query hint set to true.
    public var dfeQueryEngine: Swift.String?
    /// Contains status information about the features enabled on your DB cluster.
    public var features: [Swift.String:ClientRuntime.Document]?
    /// Contains information about the Gremlin query language available on your cluster. Specifically, it contains a version field that specifies the current TinkerPop version being used by the engine.
    public var gremlin: NeptunedataClientTypes.QueryLanguageVersion?
    /// Contains Lab Mode settings being used by the engine.
    public var labMode: [Swift.String:Swift.String]?
    /// Contains information about the openCypher query language available on your cluster. Specifically, it contains a version field that specifies the current operCypher version being used by the engine.
    public var opencypher: NeptunedataClientTypes.QueryLanguageVersion?
    /// Set to reader if the instance is a read-replica, or to writer if the instance is the primary instance.
    public var role: Swift.String?
    /// If there are transactions being rolled back, this field is set to the number of such transactions. If there are none, the field doesn't appear at all.
    public var rollingBackTrxCount: Swift.Int?
    /// Set to the start time of the earliest transaction being rolled back. If no transactions are being rolled back, the field doesn't appear at all.
    public var rollingBackTrxEarliestStartTime: Swift.String?
    /// Contains information about the current settings on your DB cluster. For example, contains the current cluster query timeout setting (clusterQueryTimeoutInMs).
    public var settings: [Swift.String:Swift.String]?
    /// Contains information about the SPARQL query language available on your cluster. Specifically, it contains a version field that specifies the current SPARQL version being used by the engine.
    public var sparql: NeptunedataClientTypes.QueryLanguageVersion?
    /// Set to the UTC time at which the current server process started.
    public var startTime: Swift.String?
    /// Set to healthy if the instance is not experiencing problems. If the instance is recovering from a crash or from being rebooted and there are active transactions running from the latest server shutdown, status is set to recovery.
    public var status: Swift.String?

    public init(
        dbEngineVersion: Swift.String? = nil,
        dfeQueryEngine: Swift.String? = nil,
        features: [Swift.String:ClientRuntime.Document]? = nil,
        gremlin: NeptunedataClientTypes.QueryLanguageVersion? = nil,
        labMode: [Swift.String:Swift.String]? = nil,
        opencypher: NeptunedataClientTypes.QueryLanguageVersion? = nil,
        role: Swift.String? = nil,
        rollingBackTrxCount: Swift.Int? = nil,
        rollingBackTrxEarliestStartTime: Swift.String? = nil,
        settings: [Swift.String:Swift.String]? = nil,
        sparql: NeptunedataClientTypes.QueryLanguageVersion? = nil,
        startTime: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.dbEngineVersion = dbEngineVersion
        self.dfeQueryEngine = dfeQueryEngine
        self.features = features
        self.gremlin = gremlin
        self.labMode = labMode
        self.opencypher = opencypher
        self.role = role
        self.rollingBackTrxCount = rollingBackTrxCount
        self.rollingBackTrxEarliestStartTime = rollingBackTrxEarliestStartTime
        self.settings = settings
        self.sparql = sparql
        self.startTime = startTime
        self.status = status
    }
}

struct GetEngineStatusOutputBody: Swift.Equatable {
    let status: Swift.String?
    let startTime: Swift.String?
    let dbEngineVersion: Swift.String?
    let role: Swift.String?
    let dfeQueryEngine: Swift.String?
    let gremlin: NeptunedataClientTypes.QueryLanguageVersion?
    let sparql: NeptunedataClientTypes.QueryLanguageVersion?
    let opencypher: NeptunedataClientTypes.QueryLanguageVersion?
    let labMode: [Swift.String:Swift.String]?
    let rollingBackTrxCount: Swift.Int?
    let rollingBackTrxEarliestStartTime: Swift.String?
    let features: [Swift.String:ClientRuntime.Document]?
    let settings: [Swift.String:Swift.String]?
}

extension GetEngineStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbEngineVersion
        case dfeQueryEngine
        case features
        case gremlin
        case labMode
        case opencypher
        case role
        case rollingBackTrxCount
        case rollingBackTrxEarliestStartTime
        case settings
        case sparql
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let dbEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbEngineVersion)
        dbEngineVersion = dbEngineVersionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let dfeQueryEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dfeQueryEngine)
        dfeQueryEngine = dfeQueryEngineDecoded
        let gremlinDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.QueryLanguageVersion.self, forKey: .gremlin)
        gremlin = gremlinDecoded
        let sparqlDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.QueryLanguageVersion.self, forKey: .sparql)
        sparql = sparqlDecoded
        let opencypherDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.QueryLanguageVersion.self, forKey: .opencypher)
        opencypher = opencypherDecoded
        let labModeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .labMode)
        var labModeDecoded0: [Swift.String:Swift.String]? = nil
        if let labModeContainer = labModeContainer {
            labModeDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in labModeContainer {
                if let string0 = string0 {
                    labModeDecoded0?[key0] = string0
                }
            }
        }
        labMode = labModeDecoded0
        let rollingBackTrxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rollingBackTrxCount)
        rollingBackTrxCount = rollingBackTrxCountDecoded
        let rollingBackTrxEarliestStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rollingBackTrxEarliestStartTime)
        rollingBackTrxEarliestStartTime = rollingBackTrxEarliestStartTimeDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String: ClientRuntime.Document?].self, forKey: .features)
        var featuresDecoded0: [Swift.String:ClientRuntime.Document]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String:ClientRuntime.Document]()
            for (key0, document0) in featuresContainer {
                if let document0 = document0 {
                    featuresDecoded0?[key0] = document0
                }
            }
        }
        features = featuresDecoded0
        let settingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .settings)
        var settingsDecoded0: [Swift.String:Swift.String]? = nil
        if let settingsContainer = settingsContainer {
            settingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in settingsContainer {
                if let string0 = string0 {
                    settingsDecoded0?[key0] = string0
                }
            }
        }
        settings = settingsDecoded0
    }
}

enum GetEngineStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGremlinQueryStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let queryId = queryId else {
            return nil
        }
        return "/gremlin/status/\(queryId.urlPercentEncoding())"
    }
}

public struct GetGremlinQueryStatusInput: Swift.Equatable {
    /// The unique identifier that identifies the Gremlin query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct GetGremlinQueryStatusInputBody: Swift.Equatable {
}

extension GetGremlinQueryStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGremlinQueryStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGremlinQueryStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryEvalStats = output.queryEvalStats
            self.queryId = output.queryId
            self.queryString = output.queryString
        } else {
            self.queryEvalStats = nil
            self.queryId = nil
            self.queryString = nil
        }
    }
}

public struct GetGremlinQueryStatusOutput: Swift.Equatable {
    /// The evaluation status of the Gremlin query.
    public var queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
    /// The ID of the query for which status is being returned.
    public var queryId: Swift.String?
    /// The Gremlin query string.
    public var queryString: Swift.String?

    public init(
        queryEvalStats: NeptunedataClientTypes.QueryEvalStats? = nil,
        queryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.queryEvalStats = queryEvalStats
        self.queryId = queryId
        self.queryString = queryString
    }
}

struct GetGremlinQueryStatusOutputBody: Swift.Equatable {
    let queryId: Swift.String?
    let queryString: Swift.String?
    let queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
}

extension GetGremlinQueryStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryEvalStats
        case queryId
        case queryString
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryEvalStatsDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.QueryEvalStats.self, forKey: .queryEvalStats)
        queryEvalStats = queryEvalStatsDecoded
    }
}

enum GetGremlinQueryStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLoaderJobStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let errorsPerPage = errorsPerPage {
                let errorsPerPageQueryItem = ClientRuntime.URLQueryItem(name: "errorsPerPage".urlPercentEncoding(), value: Swift.String(errorsPerPage).urlPercentEncoding())
                items.append(errorsPerPageQueryItem)
            }
            if let details = details {
                let detailsQueryItem = ClientRuntime.URLQueryItem(name: "details".urlPercentEncoding(), value: Swift.String(details).urlPercentEncoding())
                items.append(detailsQueryItem)
            }
            if let page = page {
                let pageQueryItem = ClientRuntime.URLQueryItem(name: "page".urlPercentEncoding(), value: Swift.String(page).urlPercentEncoding())
                items.append(pageQueryItem)
            }
            if let errors = errors {
                let errorsQueryItem = ClientRuntime.URLQueryItem(name: "errors".urlPercentEncoding(), value: Swift.String(errors).urlPercentEncoding())
                items.append(errorsQueryItem)
            }
            return items
        }
    }
}

extension GetLoaderJobStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loadId = loadId else {
            return nil
        }
        return "/loader/\(loadId.urlPercentEncoding())"
    }
}

public struct GetLoaderJobStatusInput: Swift.Equatable {
    /// Flag indicating whether or not to include details beyond the overall status (TRUE or FALSE; the default is FALSE).
    public var details: Swift.Bool?
    /// Flag indicating whether or not to include a list of errors encountered (TRUE or FALSE; the default is FALSE). The list of errors is paged. The page and errorsPerPage parameters allow you to page through all the errors.
    public var errors: Swift.Bool?
    /// The number of errors returned in each page (a positive integer; the default is 10). Only valid when the errors parameter set to TRUE.
    public var errorsPerPage: Swift.Int?
    /// The load ID of the load job to get the status of.
    /// This member is required.
    public var loadId: Swift.String?
    /// The error page number (a positive integer; the default is 1). Only valid when the errors parameter is set to TRUE.
    public var page: Swift.Int?

    public init(
        details: Swift.Bool? = nil,
        errors: Swift.Bool? = nil,
        errorsPerPage: Swift.Int? = nil,
        loadId: Swift.String? = nil,
        page: Swift.Int? = nil
    )
    {
        self.details = details
        self.errors = errors
        self.errorsPerPage = errorsPerPage
        self.loadId = loadId
        self.page = page
    }
}

struct GetLoaderJobStatusInputBody: Swift.Equatable {
}

extension GetLoaderJobStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLoaderJobStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoaderJobStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct GetLoaderJobStatusOutput: Swift.Equatable {
    /// Status information about the load job, in a layout that could look like this:
    /// This member is required.
    public var payload: ClientRuntime.Document?
    /// The HTTP response code for the request.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: ClientRuntime.Document? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct GetLoaderJobStatusOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: ClientRuntime.Document?
}

extension GetLoaderJobStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetLoaderJobStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BulkLoadIdNotFoundException": return try await BulkLoadIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LoadUrlAccessDeniedException": return try await LoadUrlAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMLDataProcessingJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension GetMLDataProcessingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/dataprocessing/\(id.urlPercentEncoding())"
    }
}

public struct GetMLDataProcessingJobInput: Swift.Equatable {
    /// The unique identifier of the data-processing job to be retrieved.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct GetMLDataProcessingJobInputBody: Swift.Equatable {
}

extension GetMLDataProcessingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMLDataProcessingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMLDataProcessingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.processingJob = output.processingJob
            self.status = output.status
        } else {
            self.id = nil
            self.processingJob = nil
            self.status = nil
        }
    }
}

public struct GetMLDataProcessingJobOutput: Swift.Equatable {
    /// The unique identifier of this data-processing job.
    public var id: Swift.String?
    /// Definition of the data processing job.
    public var processingJob: NeptunedataClientTypes.MlResourceDefinition?
    /// Status of the data processing job.
    public var status: Swift.String?

    public init(
        id: Swift.String? = nil,
        processingJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        status: Swift.String? = nil
    )
    {
        self.id = id
        self.processingJob = processingJob
        self.status = status
    }
}

struct GetMLDataProcessingJobOutputBody: Swift.Equatable {
    let status: Swift.String?
    let id: Swift.String?
    let processingJob: NeptunedataClientTypes.MlResourceDefinition?
}

extension GetMLDataProcessingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case processingJob
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let processingJobDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .processingJob)
        processingJob = processingJobDecoded
    }
}

enum GetMLDataProcessingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMLEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension GetMLEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/endpoints/\(id.urlPercentEncoding())"
    }
}

public struct GetMLEndpointInput: Swift.Equatable {
    /// The unique identifier of the inference endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct GetMLEndpointInputBody: Swift.Equatable {
}

extension GetMLEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMLEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMLEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
            self.endpointConfig = output.endpointConfig
            self.id = output.id
            self.status = output.status
        } else {
            self.endpoint = nil
            self.endpointConfig = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct GetMLEndpointOutput: Swift.Equatable {
    /// The endpoint definition.
    public var endpoint: NeptunedataClientTypes.MlResourceDefinition?
    /// The endpoint configuration
    public var endpointConfig: NeptunedataClientTypes.MlConfigDefinition?
    /// The unique identifier of the inference endpoint.
    public var id: Swift.String?
    /// The status of the inference endpoint.
    public var status: Swift.String?

    public init(
        endpoint: NeptunedataClientTypes.MlResourceDefinition? = nil,
        endpointConfig: NeptunedataClientTypes.MlConfigDefinition? = nil,
        id: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.endpoint = endpoint
        self.endpointConfig = endpointConfig
        self.id = id
        self.status = status
    }
}

struct GetMLEndpointOutputBody: Swift.Equatable {
    let status: Swift.String?
    let id: Swift.String?
    let endpoint: NeptunedataClientTypes.MlResourceDefinition?
    let endpointConfig: NeptunedataClientTypes.MlConfigDefinition?
}

extension GetMLEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case endpointConfig
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let endpointConfigDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlConfigDefinition.self, forKey: .endpointConfig)
        endpointConfig = endpointConfigDecoded
    }
}

enum GetMLEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMLModelTrainingJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension GetMLModelTrainingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/modeltraining/\(id.urlPercentEncoding())"
    }
}

public struct GetMLModelTrainingJobInput: Swift.Equatable {
    /// The unique identifier of the model-training job to retrieve.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct GetMLModelTrainingJobInputBody: Swift.Equatable {
}

extension GetMLModelTrainingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMLModelTrainingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMLModelTrainingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.hpoJob = output.hpoJob
            self.id = output.id
            self.mlModels = output.mlModels
            self.modelTransformJob = output.modelTransformJob
            self.processingJob = output.processingJob
            self.status = output.status
        } else {
            self.hpoJob = nil
            self.id = nil
            self.mlModels = nil
            self.modelTransformJob = nil
            self.processingJob = nil
            self.status = nil
        }
    }
}

public struct GetMLModelTrainingJobOutput: Swift.Equatable {
    /// The HPO job.
    public var hpoJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The unique identifier of this model-training job.
    public var id: Swift.String?
    /// A list of the configurations of the ML models being used.
    public var mlModels: [NeptunedataClientTypes.MlConfigDefinition]?
    /// The model transform job.
    public var modelTransformJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The data processing job.
    public var processingJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The status of the model training job.
    public var status: Swift.String?

    public init(
        hpoJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        id: Swift.String? = nil,
        mlModels: [NeptunedataClientTypes.MlConfigDefinition]? = nil,
        modelTransformJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        processingJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        status: Swift.String? = nil
    )
    {
        self.hpoJob = hpoJob
        self.id = id
        self.mlModels = mlModels
        self.modelTransformJob = modelTransformJob
        self.processingJob = processingJob
        self.status = status
    }
}

struct GetMLModelTrainingJobOutputBody: Swift.Equatable {
    let status: Swift.String?
    let id: Swift.String?
    let processingJob: NeptunedataClientTypes.MlResourceDefinition?
    let hpoJob: NeptunedataClientTypes.MlResourceDefinition?
    let modelTransformJob: NeptunedataClientTypes.MlResourceDefinition?
    let mlModels: [NeptunedataClientTypes.MlConfigDefinition]?
}

extension GetMLModelTrainingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hpoJob
        case id
        case mlModels
        case modelTransformJob
        case processingJob
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let processingJobDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .processingJob)
        processingJob = processingJobDecoded
        let hpoJobDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .hpoJob)
        hpoJob = hpoJobDecoded
        let modelTransformJobDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .modelTransformJob)
        modelTransformJob = modelTransformJobDecoded
        let mlModelsContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.MlConfigDefinition?].self, forKey: .mlModels)
        var mlModelsDecoded0:[NeptunedataClientTypes.MlConfigDefinition]? = nil
        if let mlModelsContainer = mlModelsContainer {
            mlModelsDecoded0 = [NeptunedataClientTypes.MlConfigDefinition]()
            for structure0 in mlModelsContainer {
                if let structure0 = structure0 {
                    mlModelsDecoded0?.append(structure0)
                }
            }
        }
        mlModels = mlModelsDecoded0
    }
}

enum GetMLModelTrainingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMLModelTransformJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension GetMLModelTransformJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/ml/modeltransform/\(id.urlPercentEncoding())"
    }
}

public struct GetMLModelTransformJobInput: Swift.Equatable {
    /// The unique identifier of the model-transform job to be reetrieved.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct GetMLModelTransformJobInputBody: Swift.Equatable {
}

extension GetMLModelTransformJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMLModelTransformJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMLModelTransformJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseProcessingJob = output.baseProcessingJob
            self.id = output.id
            self.models = output.models
            self.remoteModelTransformJob = output.remoteModelTransformJob
            self.status = output.status
        } else {
            self.baseProcessingJob = nil
            self.id = nil
            self.models = nil
            self.remoteModelTransformJob = nil
            self.status = nil
        }
    }
}

public struct GetMLModelTransformJobOutput: Swift.Equatable {
    /// The base data processing job.
    public var baseProcessingJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The unique identifier of the model-transform job to be retrieved.
    public var id: Swift.String?
    /// A list of the configuration information for the models being used.
    public var models: [NeptunedataClientTypes.MlConfigDefinition]?
    /// The remote model transform job.
    public var remoteModelTransformJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The status of the model-transform job.
    public var status: Swift.String?

    public init(
        baseProcessingJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        id: Swift.String? = nil,
        models: [NeptunedataClientTypes.MlConfigDefinition]? = nil,
        remoteModelTransformJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        status: Swift.String? = nil
    )
    {
        self.baseProcessingJob = baseProcessingJob
        self.id = id
        self.models = models
        self.remoteModelTransformJob = remoteModelTransformJob
        self.status = status
    }
}

struct GetMLModelTransformJobOutputBody: Swift.Equatable {
    let status: Swift.String?
    let id: Swift.String?
    let baseProcessingJob: NeptunedataClientTypes.MlResourceDefinition?
    let remoteModelTransformJob: NeptunedataClientTypes.MlResourceDefinition?
    let models: [NeptunedataClientTypes.MlConfigDefinition]?
}

extension GetMLModelTransformJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseProcessingJob
        case id
        case models
        case remoteModelTransformJob
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let baseProcessingJobDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .baseProcessingJob)
        baseProcessingJob = baseProcessingJobDecoded
        let remoteModelTransformJobDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.MlResourceDefinition.self, forKey: .remoteModelTransformJob)
        remoteModelTransformJob = remoteModelTransformJobDecoded
        let modelsContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.MlConfigDefinition?].self, forKey: .models)
        var modelsDecoded0:[NeptunedataClientTypes.MlConfigDefinition]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [NeptunedataClientTypes.MlConfigDefinition]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
    }
}

enum GetMLModelTransformJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOpenCypherQueryStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let queryId = queryId else {
            return nil
        }
        return "/opencypher/status/\(queryId.urlPercentEncoding())"
    }
}

public struct GetOpenCypherQueryStatusInput: Swift.Equatable {
    /// The unique ID of the openCypher query for which to retrieve the query status.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct GetOpenCypherQueryStatusInputBody: Swift.Equatable {
}

extension GetOpenCypherQueryStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOpenCypherQueryStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOpenCypherQueryStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryEvalStats = output.queryEvalStats
            self.queryId = output.queryId
            self.queryString = output.queryString
        } else {
            self.queryEvalStats = nil
            self.queryId = nil
            self.queryString = nil
        }
    }
}

public struct GetOpenCypherQueryStatusOutput: Swift.Equatable {
    /// The openCypher query evaluation status.
    public var queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
    /// The unique ID of the query for which status is being returned.
    public var queryId: Swift.String?
    /// The openCypher query string.
    public var queryString: Swift.String?

    public init(
        queryEvalStats: NeptunedataClientTypes.QueryEvalStats? = nil,
        queryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.queryEvalStats = queryEvalStats
        self.queryId = queryId
        self.queryString = queryString
    }
}

struct GetOpenCypherQueryStatusOutputBody: Swift.Equatable {
    let queryId: Swift.String?
    let queryString: Swift.String?
    let queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
}

extension GetOpenCypherQueryStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryEvalStats
        case queryId
        case queryString
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryEvalStatsDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.QueryEvalStats.self, forKey: .queryEvalStats)
        queryEvalStats = queryEvalStatsDecoded
    }
}

enum GetOpenCypherQueryStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNumericDataException": return try await InvalidNumericDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPropertygraphStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/propertygraph/statistics"
    }
}

public struct GetPropertygraphStatisticsInput: Swift.Equatable {

    public init() { }
}

struct GetPropertygraphStatisticsInputBody: Swift.Equatable {
}

extension GetPropertygraphStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPropertygraphStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPropertygraphStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct GetPropertygraphStatisticsOutput: Swift.Equatable {
    /// Statistics for property-graph data.
    /// This member is required.
    public var payload: NeptunedataClientTypes.Statistics?
    /// The HTTP return code of the request. If the request succeeded, the code is 200. See [Common error codes for DFE statistics request](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-dfe-statistics.html#neptune-dfe-statistics-errors) for a list of common errors.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.Statistics? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct GetPropertygraphStatisticsOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: NeptunedataClientTypes.Statistics?
}

extension GetPropertygraphStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.Statistics.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetPropertygraphStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPropertygraphStreamInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let encoding = encoding {
            items.add(Header(name: "Accept-Encoding", value: Swift.String(encoding.rawValue)))
        }
        return items
    }
}

extension GetPropertygraphStreamInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let commitNum = commitNum {
                let commitNumQueryItem = ClientRuntime.URLQueryItem(name: "commitNum".urlPercentEncoding(), value: Swift.String(commitNum).urlPercentEncoding())
                items.append(commitNumQueryItem)
            }
            if let opNum = opNum {
                let opNumQueryItem = ClientRuntime.URLQueryItem(name: "opNum".urlPercentEncoding(), value: Swift.String(opNum).urlPercentEncoding())
                items.append(opNumQueryItem)
            }
            if let iteratorType = iteratorType {
                let iteratorTypeQueryItem = ClientRuntime.URLQueryItem(name: "iteratorType".urlPercentEncoding(), value: Swift.String(iteratorType.rawValue).urlPercentEncoding())
                items.append(iteratorTypeQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension GetPropertygraphStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/propertygraph/stream"
    }
}

public struct GetPropertygraphStreamInput: Swift.Equatable {
    /// The commit number of the starting record to read from the change-log stream. This parameter is required when iteratorType isAT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER, and ignored when iteratorType is TRIM_HORIZON or LATEST.
    public var commitNum: Swift.Int?
    /// If set to TRUE, Neptune compresses the response using gzip encoding.
    public var encoding: NeptunedataClientTypes.Encoding?
    /// Can be one of:
    ///
    /// * AT_SEQUENCE_NUMBER – Indicates that reading should start from the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * AFTER_SEQUENCE_NUMBER – Indicates that reading should start right after the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * TRIM_HORIZON – Indicates that reading should start at the last untrimmed record in the system, which is the oldest unexpired (not yet deleted) record in the change-log stream.
    ///
    /// * LATEST – Indicates that reading should start at the most recent record in the system, which is the latest unexpired (not yet deleted) record in the change-log stream.
    public var iteratorType: NeptunedataClientTypes.IteratorType?
    /// Specifies the maximum number of records to return. There is also a size limit of 10 MB on the response that can't be modified and that takes precedence over the number of records specified in the limit parameter. The response does include a threshold-breaching record if the 10 MB limit was reached. The range for limit is 1 to 100,000, with a default of 10.
    public var limit: Swift.Int?
    /// The operation sequence number within the specified commit to start reading from in the change-log stream data. The default is 1.
    public var opNum: Swift.Int?

    public init(
        commitNum: Swift.Int? = nil,
        encoding: NeptunedataClientTypes.Encoding? = nil,
        iteratorType: NeptunedataClientTypes.IteratorType? = nil,
        limit: Swift.Int? = nil,
        opNum: Swift.Int? = nil
    )
    {
        self.commitNum = commitNum
        self.encoding = encoding
        self.iteratorType = iteratorType
        self.limit = limit
        self.opNum = opNum
    }
}

struct GetPropertygraphStreamInputBody: Swift.Equatable {
}

extension GetPropertygraphStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPropertygraphStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPropertygraphStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.lastEventId = output.lastEventId
            self.lastTrxTimestampInMillis = output.lastTrxTimestampInMillis
            self.records = output.records
            self.totalRecords = output.totalRecords
        } else {
            self.format = nil
            self.lastEventId = nil
            self.lastTrxTimestampInMillis = nil
            self.records = nil
            self.totalRecords = nil
        }
    }
}

public struct GetPropertygraphStreamOutput: Swift.Equatable {
    /// Serialization format for the change records being returned. Currently, the only supported value is PG_JSON.
    /// This member is required.
    public var format: Swift.String?
    /// Sequence identifier of the last change in the stream response. An event ID is composed of two fields: a commitNum, which identifies a transaction that changed the graph, and an opNum, which identifies a specific operation within that transaction:
    /// This member is required.
    public var lastEventId: [Swift.String:Swift.String]?
    /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
    /// This member is required.
    public var lastTrxTimestampInMillis: Swift.Int?
    /// An array of serialized change-log stream records included in the response.
    /// This member is required.
    public var records: [NeptunedataClientTypes.PropertygraphRecord]?
    /// The total number of records in the response.
    /// This member is required.
    public var totalRecords: Swift.Int?

    public init(
        format: Swift.String? = nil,
        lastEventId: [Swift.String:Swift.String]? = nil,
        lastTrxTimestampInMillis: Swift.Int? = nil,
        records: [NeptunedataClientTypes.PropertygraphRecord]? = nil,
        totalRecords: Swift.Int? = nil
    )
    {
        self.format = format
        self.lastEventId = lastEventId
        self.lastTrxTimestampInMillis = lastTrxTimestampInMillis
        self.records = records
        self.totalRecords = totalRecords
    }
}

struct GetPropertygraphStreamOutputBody: Swift.Equatable {
    let lastEventId: [Swift.String:Swift.String]?
    let lastTrxTimestampInMillis: Swift.Int?
    let format: Swift.String?
    let records: [NeptunedataClientTypes.PropertygraphRecord]?
    let totalRecords: Swift.Int?
}

extension GetPropertygraphStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case lastEventId
        case lastTrxTimestampInMillis = "lastTrxTimestamp"
        case records
        case totalRecords
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastEventIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .lastEventId)
        var lastEventIdDecoded0: [Swift.String:Swift.String]? = nil
        if let lastEventIdContainer = lastEventIdContainer {
            lastEventIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in lastEventIdContainer {
                if let string0 = string0 {
                    lastEventIdDecoded0?[key0] = string0
                }
            }
        }
        lastEventId = lastEventIdDecoded0
        let lastTrxTimestampInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastTrxTimestampInMillis)
        lastTrxTimestampInMillis = lastTrxTimestampInMillisDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let recordsContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.PropertygraphRecord?].self, forKey: .records)
        var recordsDecoded0:[NeptunedataClientTypes.PropertygraphRecord]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [NeptunedataClientTypes.PropertygraphRecord]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let totalRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecords)
        totalRecords = totalRecordsDecoded
    }
}

enum GetPropertygraphStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredStreamException": return try await ExpiredStreamException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StreamRecordsNotFoundException": return try await StreamRecordsNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPropertygraphSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let mode = mode {
                let modeQueryItem = ClientRuntime.URLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
                items.append(modeQueryItem)
            }
            return items
        }
    }
}

extension GetPropertygraphSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/propertygraph/statistics/summary"
    }
}

public struct GetPropertygraphSummaryInput: Swift.Equatable {
    /// Mode can take one of two values: BASIC (the default), and DETAILED.
    public var mode: NeptunedataClientTypes.GraphSummaryType?

    public init(
        mode: NeptunedataClientTypes.GraphSummaryType? = nil
    )
    {
        self.mode = mode
    }
}

struct GetPropertygraphSummaryInputBody: Swift.Equatable {
}

extension GetPropertygraphSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPropertygraphSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPropertygraphSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
        } else {
            self.payload = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct GetPropertygraphSummaryOutput: Swift.Equatable {
    /// Payload containing the property graph summary response.
    public var payload: NeptunedataClientTypes.PropertygraphSummaryValueMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.PropertygraphSummaryValueMap? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.statusCode = statusCode
    }
}

struct GetPropertygraphSummaryOutputBody: Swift.Equatable {
    let statusCode: Swift.Int?
    let payload: NeptunedataClientTypes.PropertygraphSummaryValueMap?
}

extension GetPropertygraphSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.PropertygraphSummaryValueMap.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetPropertygraphSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRDFGraphSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let mode = mode {
                let modeQueryItem = ClientRuntime.URLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
                items.append(modeQueryItem)
            }
            return items
        }
    }
}

extension GetRDFGraphSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rdf/statistics/summary"
    }
}

public struct GetRDFGraphSummaryInput: Swift.Equatable {
    /// Mode can take one of two values: BASIC (the default), and DETAILED.
    public var mode: NeptunedataClientTypes.GraphSummaryType?

    public init(
        mode: NeptunedataClientTypes.GraphSummaryType? = nil
    )
    {
        self.mode = mode
    }
}

struct GetRDFGraphSummaryInputBody: Swift.Equatable {
}

extension GetRDFGraphSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRDFGraphSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRDFGraphSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
        } else {
            self.payload = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct GetRDFGraphSummaryOutput: Swift.Equatable {
    /// Payload for an RDF graph summary response
    public var payload: NeptunedataClientTypes.RDFGraphSummaryValueMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.RDFGraphSummaryValueMap? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.statusCode = statusCode
    }
}

struct GetRDFGraphSummaryOutputBody: Swift.Equatable {
    let statusCode: Swift.Int?
    let payload: NeptunedataClientTypes.RDFGraphSummaryValueMap?
}

extension GetRDFGraphSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.RDFGraphSummaryValueMap.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetRDFGraphSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSparqlStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sparql/statistics"
    }
}

public struct GetSparqlStatisticsInput: Swift.Equatable {

    public init() { }
}

struct GetSparqlStatisticsInputBody: Swift.Equatable {
}

extension GetSparqlStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSparqlStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSparqlStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct GetSparqlStatisticsOutput: Swift.Equatable {
    /// Statistics for RDF data.
    /// This member is required.
    public var payload: NeptunedataClientTypes.Statistics?
    /// The HTTP return code of the request. If the request succeeded, the code is 200. See [Common error codes for DFE statistics request](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-dfe-statistics.html#neptune-dfe-statistics-errors) for a list of common errors. When invoking this operation in a Neptune cluster that has IAM authentication enabled, the IAM user or role making the request must have a policy attached that allows the [neptune-db:GetStatisticsStatus](https://docs.aws.amazon.com/neptune/latest/userguide/iam-dp-actions.html#getstatisticsstatus) IAM action in that cluster.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.Statistics? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct GetSparqlStatisticsOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: NeptunedataClientTypes.Statistics?
}

extension GetSparqlStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.Statistics.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum GetSparqlStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSparqlStreamInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let encoding = encoding {
            items.add(Header(name: "Accept-Encoding", value: Swift.String(encoding.rawValue)))
        }
        return items
    }
}

extension GetSparqlStreamInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let commitNum = commitNum {
                let commitNumQueryItem = ClientRuntime.URLQueryItem(name: "commitNum".urlPercentEncoding(), value: Swift.String(commitNum).urlPercentEncoding())
                items.append(commitNumQueryItem)
            }
            if let opNum = opNum {
                let opNumQueryItem = ClientRuntime.URLQueryItem(name: "opNum".urlPercentEncoding(), value: Swift.String(opNum).urlPercentEncoding())
                items.append(opNumQueryItem)
            }
            if let iteratorType = iteratorType {
                let iteratorTypeQueryItem = ClientRuntime.URLQueryItem(name: "iteratorType".urlPercentEncoding(), value: Swift.String(iteratorType.rawValue).urlPercentEncoding())
                items.append(iteratorTypeQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension GetSparqlStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sparql/stream"
    }
}

public struct GetSparqlStreamInput: Swift.Equatable {
    /// The commit number of the starting record to read from the change-log stream. This parameter is required when iteratorType isAT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER, and ignored when iteratorType is TRIM_HORIZON or LATEST.
    public var commitNum: Swift.Int?
    /// If set to TRUE, Neptune compresses the response using gzip encoding.
    public var encoding: NeptunedataClientTypes.Encoding?
    /// Can be one of:
    ///
    /// * AT_SEQUENCE_NUMBER – Indicates that reading should start from the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * AFTER_SEQUENCE_NUMBER – Indicates that reading should start right after the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * TRIM_HORIZON – Indicates that reading should start at the last untrimmed record in the system, which is the oldest unexpired (not yet deleted) record in the change-log stream.
    ///
    /// * LATEST – Indicates that reading should start at the most recent record in the system, which is the latest unexpired (not yet deleted) record in the change-log stream.
    public var iteratorType: NeptunedataClientTypes.IteratorType?
    /// Specifies the maximum number of records to return. There is also a size limit of 10 MB on the response that can't be modified and that takes precedence over the number of records specified in the limit parameter. The response does include a threshold-breaching record if the 10 MB limit was reached. The range for limit is 1 to 100,000, with a default of 10.
    public var limit: Swift.Int?
    /// The operation sequence number within the specified commit to start reading from in the change-log stream data. The default is 1.
    public var opNum: Swift.Int?

    public init(
        commitNum: Swift.Int? = nil,
        encoding: NeptunedataClientTypes.Encoding? = nil,
        iteratorType: NeptunedataClientTypes.IteratorType? = nil,
        limit: Swift.Int? = nil,
        opNum: Swift.Int? = nil
    )
    {
        self.commitNum = commitNum
        self.encoding = encoding
        self.iteratorType = iteratorType
        self.limit = limit
        self.opNum = opNum
    }
}

struct GetSparqlStreamInputBody: Swift.Equatable {
}

extension GetSparqlStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSparqlStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSparqlStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.lastEventId = output.lastEventId
            self.lastTrxTimestampInMillis = output.lastTrxTimestampInMillis
            self.records = output.records
            self.totalRecords = output.totalRecords
        } else {
            self.format = nil
            self.lastEventId = nil
            self.lastTrxTimestampInMillis = nil
            self.records = nil
            self.totalRecords = nil
        }
    }
}

public struct GetSparqlStreamOutput: Swift.Equatable {
    /// Serialization format for the change records being returned. Currently, the only supported value is NQUADS.
    /// This member is required.
    public var format: Swift.String?
    /// Sequence identifier of the last change in the stream response. An event ID is composed of two fields: a commitNum, which identifies a transaction that changed the graph, and an opNum, which identifies a specific operation within that transaction:
    /// This member is required.
    public var lastEventId: [Swift.String:Swift.String]?
    /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
    /// This member is required.
    public var lastTrxTimestampInMillis: Swift.Int?
    /// An array of serialized change-log stream records included in the response.
    /// This member is required.
    public var records: [NeptunedataClientTypes.SparqlRecord]?
    /// The total number of records in the response.
    /// This member is required.
    public var totalRecords: Swift.Int?

    public init(
        format: Swift.String? = nil,
        lastEventId: [Swift.String:Swift.String]? = nil,
        lastTrxTimestampInMillis: Swift.Int? = nil,
        records: [NeptunedataClientTypes.SparqlRecord]? = nil,
        totalRecords: Swift.Int? = nil
    )
    {
        self.format = format
        self.lastEventId = lastEventId
        self.lastTrxTimestampInMillis = lastTrxTimestampInMillis
        self.records = records
        self.totalRecords = totalRecords
    }
}

struct GetSparqlStreamOutputBody: Swift.Equatable {
    let lastEventId: [Swift.String:Swift.String]?
    let lastTrxTimestampInMillis: Swift.Int?
    let format: Swift.String?
    let records: [NeptunedataClientTypes.SparqlRecord]?
    let totalRecords: Swift.Int?
}

extension GetSparqlStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case lastEventId
        case lastTrxTimestampInMillis = "lastTrxTimestamp"
        case records
        case totalRecords
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastEventIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .lastEventId)
        var lastEventIdDecoded0: [Swift.String:Swift.String]? = nil
        if let lastEventIdContainer = lastEventIdContainer {
            lastEventIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in lastEventIdContainer {
                if let string0 = string0 {
                    lastEventIdDecoded0?[key0] = string0
                }
            }
        }
        lastEventId = lastEventIdDecoded0
        let lastTrxTimestampInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastTrxTimestampInMillis)
        lastTrxTimestampInMillis = lastTrxTimestampInMillisDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let recordsContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.SparqlRecord?].self, forKey: .records)
        var recordsDecoded0:[NeptunedataClientTypes.SparqlRecord]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [NeptunedataClientTypes.SparqlRecord]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let totalRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecords)
        totalRecords = totalRecordsDecoded
    }
}

enum GetSparqlStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredStreamException": return try await ExpiredStreamException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MemoryLimitExceededException": return try await MemoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StreamRecordsNotFoundException": return try await StreamRecordsNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptunedataClientTypes {
    public enum GraphSummaryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case detailed
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphSummaryType] {
            return [
                .basic,
                .detailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "basic"
            case .detailed: return "detailed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GraphSummaryType(rawValue: rawValue) ?? GraphSummaryType.sdkUnknown(rawValue)
        }
    }
}

extension NeptunedataClientTypes.GremlinQueryStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryEvalStats
        case queryId
        case queryString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryEvalStats = self.queryEvalStats {
            try encodeContainer.encode(queryEvalStats, forKey: .queryEvalStats)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryEvalStatsDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.QueryEvalStats.self, forKey: .queryEvalStats)
        queryEvalStats = queryEvalStatsDecoded
    }
}

extension NeptunedataClientTypes {
    /// Captures the status of a Gremlin query (see the [Gremlin query status API](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-api-status.html) page).
    public struct GremlinQueryStatus: Swift.Equatable {
        /// The query statistics of the Gremlin query.
        public var queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
        /// The ID of the Gremlin query.
        public var queryId: Swift.String?
        /// The query string of the Gremlin query.
        public var queryString: Swift.String?

        public init(
            queryEvalStats: NeptunedataClientTypes.QueryEvalStats? = nil,
            queryId: Swift.String? = nil,
            queryString: Swift.String? = nil
        )
        {
            self.queryEvalStats = queryEvalStats
            self.queryId = queryId
            self.queryString = queryString
        }
    }

}

extension NeptunedataClientTypes.GremlinQueryStatusAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code)
        code = codeDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension NeptunedataClientTypes {
    /// Contains status components of a Gremlin query.
    public struct GremlinQueryStatusAttributes: Swift.Equatable {
        /// Attributes of the Gremlin query status.
        public var attributes: ClientRuntime.Document?
        /// The HTTP response code returned fro the Gremlin query request..
        public var code: Swift.Int?
        /// The status message.
        public var message: Swift.String?

        public init(
            attributes: ClientRuntime.Document? = nil,
            code: Swift.Int? = nil,
            message: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.code = code
            self.message = message
        }
    }

}

extension IllegalArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when an argument in a request is not supported.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct IllegalArgumentExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension IllegalArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the processing of the request failed unexpectedly.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when an argument in a request has an invalid value.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidNumericDataException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNumericDataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when invalid numerical data is encountered when servicing a request.
public struct InvalidNumericDataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNumericDataException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct InvalidNumericDataExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension InvalidNumericDataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a parameter value is not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that includes an invalid parameter.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes {
    public enum IteratorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterSequenceNumber
        case atSequenceNumber
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [IteratorType] {
            return [
                .afterSequenceNumber,
                .atSequenceNumber,
                .latest,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
            case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IteratorType(rawValue: rawValue) ?? IteratorType.sdkUnknown(rawValue)
        }
    }
}

extension ListGremlinQueriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeWaiting = includeWaiting {
                let includeWaitingQueryItem = ClientRuntime.URLQueryItem(name: "includeWaiting".urlPercentEncoding(), value: Swift.String(includeWaiting).urlPercentEncoding())
                items.append(includeWaitingQueryItem)
            }
            return items
        }
    }
}

extension ListGremlinQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/gremlin/status"
    }
}

public struct ListGremlinQueriesInput: Swift.Equatable {
    /// If set to TRUE, the list returned includes waiting queries. The default is FALSE;
    public var includeWaiting: Swift.Bool?

    public init(
        includeWaiting: Swift.Bool? = nil
    )
    {
        self.includeWaiting = includeWaiting
    }
}

struct ListGremlinQueriesInputBody: Swift.Equatable {
}

extension ListGremlinQueriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGremlinQueriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGremlinQueriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceptedQueryCount = output.acceptedQueryCount
            self.queries = output.queries
            self.runningQueryCount = output.runningQueryCount
        } else {
            self.acceptedQueryCount = nil
            self.queries = nil
            self.runningQueryCount = nil
        }
    }
}

public struct ListGremlinQueriesOutput: Swift.Equatable {
    /// The number of queries that have been accepted but not yet completed, including queries in the queue.
    public var acceptedQueryCount: Swift.Int?
    /// A list of the current queries.
    public var queries: [NeptunedataClientTypes.GremlinQueryStatus]?
    /// The number of Gremlin queries currently running.
    public var runningQueryCount: Swift.Int?

    public init(
        acceptedQueryCount: Swift.Int? = nil,
        queries: [NeptunedataClientTypes.GremlinQueryStatus]? = nil,
        runningQueryCount: Swift.Int? = nil
    )
    {
        self.acceptedQueryCount = acceptedQueryCount
        self.queries = queries
        self.runningQueryCount = runningQueryCount
    }
}

struct ListGremlinQueriesOutputBody: Swift.Equatable {
    let acceptedQueryCount: Swift.Int?
    let runningQueryCount: Swift.Int?
    let queries: [NeptunedataClientTypes.GremlinQueryStatus]?
}

extension ListGremlinQueriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedQueryCount
        case queries
        case runningQueryCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedQueryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptedQueryCount)
        acceptedQueryCount = acceptedQueryCountDecoded
        let runningQueryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningQueryCount)
        runningQueryCount = runningQueryCountDecoded
        let queriesContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.GremlinQueryStatus?].self, forKey: .queries)
        var queriesDecoded0:[NeptunedataClientTypes.GremlinQueryStatus]? = nil
        if let queriesContainer = queriesContainer {
            queriesDecoded0 = [NeptunedataClientTypes.GremlinQueryStatus]()
            for structure0 in queriesContainer {
                if let structure0 = structure0 {
                    queriesDecoded0?.append(structure0)
                }
            }
        }
        queries = queriesDecoded0
    }
}

enum ListGremlinQueriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLoaderJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeQueuedLoads = includeQueuedLoads {
                let includeQueuedLoadsQueryItem = ClientRuntime.URLQueryItem(name: "includeQueuedLoads".urlPercentEncoding(), value: Swift.String(includeQueuedLoads).urlPercentEncoding())
                items.append(includeQueuedLoadsQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListLoaderJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/loader"
    }
}

public struct ListLoaderJobsInput: Swift.Equatable {
    /// An optional parameter that can be used to exclude the load IDs of queued load requests when requesting a list of load IDs by setting the parameter to FALSE. The default value is TRUE.
    public var includeQueuedLoads: Swift.Bool?
    /// The number of load IDs to list. Must be a positive integer greater than zero and not more than 100 (which is the default).
    public var limit: Swift.Int?

    public init(
        includeQueuedLoads: Swift.Bool? = nil,
        limit: Swift.Int? = nil
    )
    {
        self.includeQueuedLoads = includeQueuedLoads
        self.limit = limit
    }
}

struct ListLoaderJobsInputBody: Swift.Equatable {
}

extension ListLoaderJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLoaderJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLoaderJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct ListLoaderJobsOutput: Swift.Equatable {
    /// The requested list of job IDs.
    /// This member is required.
    public var payload: NeptunedataClientTypes.LoaderIdResult?
    /// Returns the status of the job list request.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.LoaderIdResult? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct ListLoaderJobsOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: NeptunedataClientTypes.LoaderIdResult?
}

extension ListLoaderJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.LoaderIdResult.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum ListLoaderJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BulkLoadIdNotFoundException": return try await BulkLoadIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LoadUrlAccessDeniedException": return try await LoadUrlAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMLDataProcessingJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension ListMLDataProcessingJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/dataprocessing"
    }
}

public struct ListMLDataProcessingJobsInput: Swift.Equatable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10).
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct ListMLDataProcessingJobsInputBody: Swift.Equatable {
}

extension ListMLDataProcessingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMLDataProcessingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMLDataProcessingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
        } else {
            self.ids = nil
        }
    }
}

public struct ListMLDataProcessingJobsOutput: Swift.Equatable {
    /// A page listing data processing job IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct ListMLDataProcessingJobsOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension ListMLDataProcessingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

enum ListMLDataProcessingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMLEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension ListMLEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/endpoints"
    }
}

public struct ListMLEndpointsInput: Swift.Equatable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10.
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct ListMLEndpointsInputBody: Swift.Equatable {
}

extension ListMLEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMLEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMLEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
        } else {
            self.ids = nil
        }
    }
}

public struct ListMLEndpointsOutput: Swift.Equatable {
    /// A page from the list of inference endpoint IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct ListMLEndpointsOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension ListMLEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

enum ListMLEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMLModelTrainingJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension ListMLModelTrainingJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/modeltraining"
    }
}

public struct ListMLModelTrainingJobsInput: Swift.Equatable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10).
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct ListMLModelTrainingJobsInputBody: Swift.Equatable {
}

extension ListMLModelTrainingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMLModelTrainingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMLModelTrainingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
        } else {
            self.ids = nil
        }
    }
}

public struct ListMLModelTrainingJobsOutput: Swift.Equatable {
    /// A page of the list of model training job IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct ListMLModelTrainingJobsOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension ListMLModelTrainingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

enum ListMLModelTrainingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMLModelTransformJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let neptuneIamRoleArn = neptuneIamRoleArn {
                let neptuneIamRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
                items.append(neptuneIamRoleArnQueryItem)
            }
            return items
        }
    }
}

extension ListMLModelTransformJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/modeltransform"
    }
}

public struct ListMLModelTransformJobsInput: Swift.Equatable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10).
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

struct ListMLModelTransformJobsInputBody: Swift.Equatable {
}

extension ListMLModelTransformJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMLModelTransformJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMLModelTransformJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
        } else {
            self.ids = nil
        }
    }
}

public struct ListMLModelTransformJobsOutput: Swift.Equatable {
    /// A page from the list of model transform IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct ListMLModelTransformJobsOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension ListMLModelTransformJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

enum ListMLModelTransformJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOpenCypherQueriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeWaiting = includeWaiting {
                let includeWaitingQueryItem = ClientRuntime.URLQueryItem(name: "includeWaiting".urlPercentEncoding(), value: Swift.String(includeWaiting).urlPercentEncoding())
                items.append(includeWaitingQueryItem)
            }
            return items
        }
    }
}

extension ListOpenCypherQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/opencypher/status"
    }
}

public struct ListOpenCypherQueriesInput: Swift.Equatable {
    /// When set to TRUE and other parameters are not present, causes status information to be returned for waiting queries as well as for running queries.
    public var includeWaiting: Swift.Bool?

    public init(
        includeWaiting: Swift.Bool? = nil
    )
    {
        self.includeWaiting = includeWaiting
    }
}

struct ListOpenCypherQueriesInputBody: Swift.Equatable {
}

extension ListOpenCypherQueriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOpenCypherQueriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOpenCypherQueriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceptedQueryCount = output.acceptedQueryCount
            self.queries = output.queries
            self.runningQueryCount = output.runningQueryCount
        } else {
            self.acceptedQueryCount = nil
            self.queries = nil
            self.runningQueryCount = nil
        }
    }
}

public struct ListOpenCypherQueriesOutput: Swift.Equatable {
    /// The number of queries that have been accepted but not yet completed, including queries in the queue.
    public var acceptedQueryCount: Swift.Int?
    /// A list of current openCypher queries.
    public var queries: [NeptunedataClientTypes.GremlinQueryStatus]?
    /// The number of currently running openCypher queries.
    public var runningQueryCount: Swift.Int?

    public init(
        acceptedQueryCount: Swift.Int? = nil,
        queries: [NeptunedataClientTypes.GremlinQueryStatus]? = nil,
        runningQueryCount: Swift.Int? = nil
    )
    {
        self.acceptedQueryCount = acceptedQueryCount
        self.queries = queries
        self.runningQueryCount = runningQueryCount
    }
}

struct ListOpenCypherQueriesOutputBody: Swift.Equatable {
    let acceptedQueryCount: Swift.Int?
    let runningQueryCount: Swift.Int?
    let queries: [NeptunedataClientTypes.GremlinQueryStatus]?
}

extension ListOpenCypherQueriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedQueryCount
        case queries
        case runningQueryCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedQueryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptedQueryCount)
        acceptedQueryCount = acceptedQueryCountDecoded
        let runningQueryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningQueryCount)
        runningQueryCount = runningQueryCountDecoded
        let queriesContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.GremlinQueryStatus?].self, forKey: .queries)
        var queriesDecoded0:[NeptunedataClientTypes.GremlinQueryStatus]? = nil
        if let queriesContainer = queriesContainer {
            queriesDecoded0 = [NeptunedataClientTypes.GremlinQueryStatus]()
            for structure0 in queriesContainer {
                if let structure0 = structure0 {
                    queriesDecoded0?.append(structure0)
                }
            }
        }
        queries = queriesDecoded0
    }
}

enum ListOpenCypherQueriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailureByQueryException": return try await FailureByQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNumericDataException": return try await InvalidNumericDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParsingException": return try await ParsingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimeLimitExceededException": return try await TimeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LoadUrlAccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LoadUrlAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when access is denied to a specified load URL.
public struct LoadUrlAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoadUrlAccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct LoadUrlAccessDeniedExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension LoadUrlAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.LoaderIdResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loadIds = loadIds {
            var loadIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadIds)
            for string0 in loadIds {
                try loadIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loadIds)
        var loadIdsDecoded0:[Swift.String]? = nil
        if let loadIdsContainer = loadIdsContainer {
            loadIdsDecoded0 = [Swift.String]()
            for string0 in loadIdsContainer {
                if let string0 = string0 {
                    loadIdsDecoded0?.append(string0)
                }
            }
        }
        loadIds = loadIdsDecoded0
    }
}

extension NeptunedataClientTypes {
    /// Contains a list of load IDs.
    public struct LoaderIdResult: Swift.Equatable {
        /// A list of load IDs.
        public var loadIds: [Swift.String]?

        public init(
            loadIds: [Swift.String]? = nil
        )
        {
            self.loadIds = loadIds
        }
    }

}

extension MLResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MLResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a specified machine-learning resource could not be found.
public struct MLResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MLResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct MLResourceNotFoundExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension MLResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension MalformedQueryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MalformedQueryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a query is submitted that is syntactically incorrect or does not pass additional validation.
public struct MalformedQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the malformed query request.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedQueryException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct MalformedQueryExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension MalformedQueryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ManagePropertygraphStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }
}

extension ManagePropertygraphStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/propertygraph/statistics"
    }
}

public struct ManagePropertygraphStatisticsInput: Swift.Equatable {
    /// The statistics generation mode. One of: DISABLE_AUTOCOMPUTE, ENABLE_AUTOCOMPUTE, or REFRESH, the last of which manually triggers DFE statistics generation.
    public var mode: NeptunedataClientTypes.StatisticsAutoGenerationMode?

    public init(
        mode: NeptunedataClientTypes.StatisticsAutoGenerationMode? = nil
    )
    {
        self.mode = mode
    }
}

struct ManagePropertygraphStatisticsInputBody: Swift.Equatable {
    let mode: NeptunedataClientTypes.StatisticsAutoGenerationMode?
}

extension ManagePropertygraphStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.StatisticsAutoGenerationMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension ManagePropertygraphStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ManagePropertygraphStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct ManagePropertygraphStatisticsOutput: Swift.Equatable {
    /// This is only returned for refresh mode.
    public var payload: NeptunedataClientTypes.RefreshStatisticsIdMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.RefreshStatisticsIdMap? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct ManagePropertygraphStatisticsOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: NeptunedataClientTypes.RefreshStatisticsIdMap?
}

extension ManagePropertygraphStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.RefreshStatisticsIdMap.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum ManagePropertygraphStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ManageSparqlStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }
}

extension ManageSparqlStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sparql/statistics"
    }
}

public struct ManageSparqlStatisticsInput: Swift.Equatable {
    /// The statistics generation mode. One of: DISABLE_AUTOCOMPUTE, ENABLE_AUTOCOMPUTE, or REFRESH, the last of which manually triggers DFE statistics generation.
    public var mode: NeptunedataClientTypes.StatisticsAutoGenerationMode?

    public init(
        mode: NeptunedataClientTypes.StatisticsAutoGenerationMode? = nil
    )
    {
        self.mode = mode
    }
}

struct ManageSparqlStatisticsInputBody: Swift.Equatable {
    let mode: NeptunedataClientTypes.StatisticsAutoGenerationMode?
}

extension ManageSparqlStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.StatisticsAutoGenerationMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension ManageSparqlStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ManageSparqlStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct ManageSparqlStatisticsOutput: Swift.Equatable {
    /// This is only returned for refresh mode.
    public var payload: NeptunedataClientTypes.RefreshStatisticsIdMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.RefreshStatisticsIdMap? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct ManageSparqlStatisticsOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: NeptunedataClientTypes.RefreshStatisticsIdMap?
}

extension ManageSparqlStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.RefreshStatisticsIdMap.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum ManageSparqlStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReadOnlyViolationException": return try await ReadOnlyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotAvailableException": return try await StatisticsNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MemoryLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MemoryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request fails because of insufficient memory resources. The request can be retried.
public struct MemoryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that failed.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MemoryLimitExceededException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct MemoryLimitExceededExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension MemoryLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension MethodNotAllowedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MethodNotAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the HTTP method used by a request is not supported by the endpoint being used.
public struct MethodNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MethodNotAllowedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct MethodNotAllowedExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension MethodNotAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension MissingParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MissingParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a required parameter is missing.
public struct MissingParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in which the parameter is missing.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct MissingParameterExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension MissingParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.MlConfigDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension NeptunedataClientTypes {
    /// Contains a Neptune ML configuration.
    public struct MlConfigDefinition: Swift.Equatable {
        /// The ARN for the configuration.
        public var arn: Swift.String?
        /// The configuration name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension NeptunedataClientTypes.MlResourceDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case cloudwatchLogUrl
        case failureReason
        case name
        case outputLocation
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let cloudwatchLogUrl = self.cloudwatchLogUrl {
            try encodeContainer.encode(cloudwatchLogUrl, forKey: .cloudwatchLogUrl)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let cloudwatchLogUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudwatchLogUrl)
        cloudwatchLogUrl = cloudwatchLogUrlDecoded
    }
}

extension NeptunedataClientTypes {
    /// Defines a Neptune ML resource.
    public struct MlResourceDefinition: Swift.Equatable {
        /// The resource ARN.
        public var arn: Swift.String?
        /// The CloudWatch log URL for the resource.
        public var cloudwatchLogUrl: Swift.String?
        /// The failure reason, in case of a failure.
        public var failureReason: Swift.String?
        /// The resource name.
        public var name: Swift.String?
        /// The output location.
        public var outputLocation: Swift.String?
        /// The resource status.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            cloudwatchLogUrl: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.cloudwatchLogUrl = cloudwatchLogUrl
            self.failureReason = failureReason
            self.name = name
            self.outputLocation = outputLocation
            self.status = status
        }
    }

}

extension NeptunedataClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case new
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .auto,
                .new,
                .resume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .new: return "NEW"
            case .resume: return "RESUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension NeptunedataClientTypes.NodeStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case distinctOutgoingEdgeLabels
        case nodeProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels {
            var distinctOutgoingEdgeLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distinctOutgoingEdgeLabels)
            for string0 in distinctOutgoingEdgeLabels {
                try distinctOutgoingEdgeLabelsContainer.encode(string0)
            }
        }
        if let nodeProperties = nodeProperties {
            var nodePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeProperties)
            for string0 in nodeProperties {
                try nodePropertiesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let nodePropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeProperties)
        var nodePropertiesDecoded0:[Swift.String]? = nil
        if let nodePropertiesContainer = nodePropertiesContainer {
            nodePropertiesDecoded0 = [Swift.String]()
            for string0 in nodePropertiesContainer {
                if let string0 = string0 {
                    nodePropertiesDecoded0?.append(string0)
                }
            }
        }
        nodeProperties = nodePropertiesDecoded0
        let distinctOutgoingEdgeLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .distinctOutgoingEdgeLabels)
        var distinctOutgoingEdgeLabelsDecoded0:[Swift.String]? = nil
        if let distinctOutgoingEdgeLabelsContainer = distinctOutgoingEdgeLabelsContainer {
            distinctOutgoingEdgeLabelsDecoded0 = [Swift.String]()
            for string0 in distinctOutgoingEdgeLabelsContainer {
                if let string0 = string0 {
                    distinctOutgoingEdgeLabelsDecoded0?.append(string0)
                }
            }
        }
        distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabelsDecoded0
    }
}

extension NeptunedataClientTypes {
    /// A node structure.
    public struct NodeStructure: Swift.Equatable {
        /// Number of nodes that have this specific structure.
        public var count: Swift.Int?
        /// A list of distinct outgoing edge labels present in this specific structure.
        public var distinctOutgoingEdgeLabels: [Swift.String]?
        /// A list of the node properties present in this specific structure.
        public var nodeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            distinctOutgoingEdgeLabels: [Swift.String]? = nil,
            nodeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels
            self.nodeProperties = nodeProperties
        }
    }

}

extension NeptunedataClientTypes {
    public enum OpenCypherExplainMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case details
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenCypherExplainMode] {
            return [
                .details,
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .details: return "details"
            case .dynamic: return "dynamic"
            case .static: return "static"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpenCypherExplainMode(rawValue: rawValue) ?? OpenCypherExplainMode.sdkUnknown(rawValue)
        }
    }
}

extension NeptunedataClientTypes {
    public enum Parallelism: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case oversubscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [Parallelism] {
            return [
                .high,
                .low,
                .medium,
                .oversubscribe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .oversubscribe: return "OVERSUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Parallelism(rawValue: rawValue) ?? Parallelism.sdkUnknown(rawValue)
        }
    }
}

extension ParsingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParsingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a parsing issue is encountered.
public struct ParsingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParsingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ParsingExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ParsingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension PreconditionsFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreconditionsFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a precondition for processing a request is not satisfied.
public struct PreconditionsFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionsFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct PreconditionsFailedExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension PreconditionsFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.PropertygraphData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from
        case id
        case key
        case to
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let to = self.to {
            try encodeContainer.encode(to, forKey: .to)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .to)
        to = toDecoded
    }
}

extension NeptunedataClientTypes {
    /// A Gremlin or openCypher change record.
    public struct PropertygraphData: Swift.Equatable {
        /// If this is an edge (type = e), the ID of the corresponding from vertex or source node.
        public var from: Swift.String?
        /// The ID of the Gremlin or openCypher element.
        /// This member is required.
        public var id: Swift.String?
        /// The property name. For element labels, this is label.
        /// This member is required.
        public var key: Swift.String?
        /// If this is an edge (type = e), the ID of the corresponding to vertex or target node.
        public var to: Swift.String?
        /// The type of this Gremlin or openCypher element. Must be one of:
        ///
        /// * v1 - Vertex label for Gremlin, or node label for openCypher.
        ///
        /// * vp - Vertex properties for Gremlin, or node properties for openCypher.
        ///
        /// * e - Edge and edge label for Gremlin, or relationship and relationship type for openCypher.
        ///
        /// * ep - Edge properties for Gremlin, or relationship properties for openCypher.
        /// This member is required.
        public var type: Swift.String?
        /// This is a JSON object that contains a value field for the value itself, and a datatype field for the JSON data type of that value:
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            from: Swift.String? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            to: Swift.String? = nil,
            type: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.from = from
            self.id = id
            self.key = key
            self.to = to
            self.type = type
            self.value = value
        }
    }

}

extension NeptunedataClientTypes.PropertygraphRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitTimestampInMillis = "commitTimestamp"
        case data
        case eventId
        case isLastOp
        case op
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitTimestampInMillis = self.commitTimestampInMillis {
            try encodeContainer.encode(commitTimestampInMillis, forKey: .commitTimestampInMillis)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let eventId = eventId {
            var eventIdContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventId)
            for (dictKey0, stringValuedMap0) in eventId {
                try eventIdContainer.encode(stringValuedMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isLastOp = self.isLastOp {
            try encodeContainer.encode(isLastOp, forKey: .isLastOp)
        }
        if let op = self.op {
            try encodeContainer.encode(op, forKey: .op)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitTimestampInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .commitTimestampInMillis)
        commitTimestampInMillis = commitTimestampInMillisDecoded
        let eventIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventId)
        var eventIdDecoded0: [Swift.String:Swift.String]? = nil
        if let eventIdContainer = eventIdContainer {
            eventIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in eventIdContainer {
                if let string0 = string0 {
                    eventIdDecoded0?[key0] = string0
                }
            }
        }
        eventId = eventIdDecoded0
        let dataDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.PropertygraphData.self, forKey: .data)
        data = dataDecoded
        let opDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .op)
        op = opDecoded
        let isLastOpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLastOp)
        isLastOp = isLastOpDecoded
    }
}

extension NeptunedataClientTypes {
    /// Structure of a property graph record.
    public struct PropertygraphRecord: Swift.Equatable {
        /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
        /// This member is required.
        public var commitTimestampInMillis: Swift.Int?
        /// The serialized Gremlin or openCypher change record.
        /// This member is required.
        public var data: NeptunedataClientTypes.PropertygraphData?
        /// The sequence identifier of the stream change record.
        /// This member is required.
        public var eventId: [Swift.String:Swift.String]?
        /// Only present if this operation is the last one in its transaction. If present, it is set to true. It is useful for ensuring that an entire transaction is consumed.
        public var isLastOp: Swift.Bool?
        /// The operation that created the change.
        /// This member is required.
        public var op: Swift.String?

        public init(
            commitTimestampInMillis: Swift.Int? = nil,
            data: NeptunedataClientTypes.PropertygraphData? = nil,
            eventId: [Swift.String:Swift.String]? = nil,
            isLastOp: Swift.Bool? = nil,
            op: Swift.String? = nil
        )
        {
            self.commitTimestampInMillis = commitTimestampInMillis
            self.data = data
            self.eventId = eventId
            self.isLastOp = isLastOp
            self.op = op
        }
    }

}

extension NeptunedataClientTypes.PropertygraphSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeLabels
        case edgeProperties
        case edgeStructures
        case nodeLabels
        case nodeProperties
        case nodeStructures
        case numEdgeLabels
        case numEdgeProperties
        case numEdges
        case numNodeLabels
        case numNodeProperties
        case numNodes
        case totalEdgePropertyValues
        case totalNodePropertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeLabels = edgeLabels {
            var edgeLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeLabels)
            for string0 in edgeLabels {
                try edgeLabelsContainer.encode(string0)
            }
        }
        if let edgeProperties = edgeProperties {
            var edgePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeProperties)
            for longvaluedmap0 in edgeProperties {
                var longvaluedmap0Container = edgePropertiesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, longValuedMap1) in longvaluedmap0 {
                    try longvaluedmap0Container.encode(longValuedMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let edgeStructures = edgeStructures {
            var edgeStructuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeStructures)
            for edgestructure0 in edgeStructures {
                try edgeStructuresContainer.encode(edgestructure0)
            }
        }
        if let nodeLabels = nodeLabels {
            var nodeLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeLabels)
            for string0 in nodeLabels {
                try nodeLabelsContainer.encode(string0)
            }
        }
        if let nodeProperties = nodeProperties {
            var nodePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeProperties)
            for longvaluedmap0 in nodeProperties {
                var longvaluedmap0Container = nodePropertiesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, longValuedMap1) in longvaluedmap0 {
                    try longvaluedmap0Container.encode(longValuedMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let nodeStructures = nodeStructures {
            var nodeStructuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeStructures)
            for nodestructure0 in nodeStructures {
                try nodeStructuresContainer.encode(nodestructure0)
            }
        }
        if let numEdgeLabels = self.numEdgeLabels {
            try encodeContainer.encode(numEdgeLabels, forKey: .numEdgeLabels)
        }
        if let numEdgeProperties = self.numEdgeProperties {
            try encodeContainer.encode(numEdgeProperties, forKey: .numEdgeProperties)
        }
        if let numEdges = self.numEdges {
            try encodeContainer.encode(numEdges, forKey: .numEdges)
        }
        if let numNodeLabels = self.numNodeLabels {
            try encodeContainer.encode(numNodeLabels, forKey: .numNodeLabels)
        }
        if let numNodeProperties = self.numNodeProperties {
            try encodeContainer.encode(numNodeProperties, forKey: .numNodeProperties)
        }
        if let numNodes = self.numNodes {
            try encodeContainer.encode(numNodes, forKey: .numNodes)
        }
        if let totalEdgePropertyValues = self.totalEdgePropertyValues {
            try encodeContainer.encode(totalEdgePropertyValues, forKey: .totalEdgePropertyValues)
        }
        if let totalNodePropertyValues = self.totalNodePropertyValues {
            try encodeContainer.encode(totalNodePropertyValues, forKey: .totalNodePropertyValues)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodes)
        numNodes = numNodesDecoded
        let numEdgesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numEdges)
        numEdges = numEdgesDecoded
        let numNodeLabelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodeLabels)
        numNodeLabels = numNodeLabelsDecoded
        let numEdgeLabelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numEdgeLabels)
        numEdgeLabels = numEdgeLabelsDecoded
        let nodeLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeLabels)
        var nodeLabelsDecoded0:[Swift.String]? = nil
        if let nodeLabelsContainer = nodeLabelsContainer {
            nodeLabelsDecoded0 = [Swift.String]()
            for string0 in nodeLabelsContainer {
                if let string0 = string0 {
                    nodeLabelsDecoded0?.append(string0)
                }
            }
        }
        nodeLabels = nodeLabelsDecoded0
        let edgeLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeLabels)
        var edgeLabelsDecoded0:[Swift.String]? = nil
        if let edgeLabelsContainer = edgeLabelsContainer {
            edgeLabelsDecoded0 = [Swift.String]()
            for string0 in edgeLabelsContainer {
                if let string0 = string0 {
                    edgeLabelsDecoded0?.append(string0)
                }
            }
        }
        edgeLabels = edgeLabelsDecoded0
        let numNodePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodeProperties)
        numNodeProperties = numNodePropertiesDecoded
        let numEdgePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numEdgeProperties)
        numEdgeProperties = numEdgePropertiesDecoded
        let nodePropertiesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.Int?]?].self, forKey: .nodeProperties)
        var nodePropertiesDecoded0:[[Swift.String:Swift.Int]]? = nil
        if let nodePropertiesContainer = nodePropertiesContainer {
            nodePropertiesDecoded0 = [[Swift.String:Swift.Int]]()
            for map0 in nodePropertiesContainer {
                var nodePropertiesContainerDecoded0: [Swift.String: Swift.Int]? = nil
                if let map0 = map0 {
                    nodePropertiesContainerDecoded0 = [Swift.String: Swift.Int]()
                    for (key1, long1) in map0 {
                        if let long1 = long1 {
                            nodePropertiesContainerDecoded0?[key1] = long1
                        }
                    }
                }
                if let nodePropertiesContainerDecoded0 = nodePropertiesContainerDecoded0 {
                    nodePropertiesDecoded0?.append(nodePropertiesContainerDecoded0)
                }
            }
        }
        nodeProperties = nodePropertiesDecoded0
        let edgePropertiesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.Int?]?].self, forKey: .edgeProperties)
        var edgePropertiesDecoded0:[[Swift.String:Swift.Int]]? = nil
        if let edgePropertiesContainer = edgePropertiesContainer {
            edgePropertiesDecoded0 = [[Swift.String:Swift.Int]]()
            for map0 in edgePropertiesContainer {
                var edgePropertiesContainerDecoded0: [Swift.String: Swift.Int]? = nil
                if let map0 = map0 {
                    edgePropertiesContainerDecoded0 = [Swift.String: Swift.Int]()
                    for (key1, long1) in map0 {
                        if let long1 = long1 {
                            edgePropertiesContainerDecoded0?[key1] = long1
                        }
                    }
                }
                if let edgePropertiesContainerDecoded0 = edgePropertiesContainerDecoded0 {
                    edgePropertiesDecoded0?.append(edgePropertiesContainerDecoded0)
                }
            }
        }
        edgeProperties = edgePropertiesDecoded0
        let totalNodePropertyValuesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodePropertyValues)
        totalNodePropertyValues = totalNodePropertyValuesDecoded
        let totalEdgePropertyValuesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalEdgePropertyValues)
        totalEdgePropertyValues = totalEdgePropertyValuesDecoded
        let nodeStructuresContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.NodeStructure?].self, forKey: .nodeStructures)
        var nodeStructuresDecoded0:[NeptunedataClientTypes.NodeStructure]? = nil
        if let nodeStructuresContainer = nodeStructuresContainer {
            nodeStructuresDecoded0 = [NeptunedataClientTypes.NodeStructure]()
            for structure0 in nodeStructuresContainer {
                if let structure0 = structure0 {
                    nodeStructuresDecoded0?.append(structure0)
                }
            }
        }
        nodeStructures = nodeStructuresDecoded0
        let edgeStructuresContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.EdgeStructure?].self, forKey: .edgeStructures)
        var edgeStructuresDecoded0:[NeptunedataClientTypes.EdgeStructure]? = nil
        if let edgeStructuresContainer = edgeStructuresContainer {
            edgeStructuresDecoded0 = [NeptunedataClientTypes.EdgeStructure]()
            for structure0 in edgeStructuresContainer {
                if let structure0 = structure0 {
                    edgeStructuresDecoded0?.append(structure0)
                }
            }
        }
        edgeStructures = edgeStructuresDecoded0
    }
}

extension NeptunedataClientTypes {
    /// The graph summary API returns a read-only list of node and edge labels and property keys, along with counts of nodes, edges, and properties. See [Graph summary response for a property graph (PG)](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-graph-summary.html#neptune-graph-summary-pg-response).
    public struct PropertygraphSummary: Swift.Equatable {
        /// A list of the distinct edge labels in the graph.
        public var edgeLabels: [Swift.String]?
        /// A list of the distinct edge properties in the graph, along with the count of edges where each property is used.
        public var edgeProperties: [[Swift.String:Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of edge structures.
        public var edgeStructures: [NeptunedataClientTypes.EdgeStructure]?
        /// A list of the distinct node labels in the graph.
        public var nodeLabels: [Swift.String]?
        /// The number of distinct node properties in the graph.
        public var nodeProperties: [[Swift.String:Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of node structures.
        public var nodeStructures: [NeptunedataClientTypes.NodeStructure]?
        /// The number of distinct edge labels in the graph.
        public var numEdgeLabels: Swift.Int?
        /// The number of distinct edge properties in the graph.
        public var numEdgeProperties: Swift.Int?
        /// The number of edges in the graph.
        public var numEdges: Swift.Int?
        /// The number of distinct node labels in the graph.
        public var numNodeLabels: Swift.Int?
        /// A list of the distinct node properties in the graph, along with the count of nodes where each property is used.
        public var numNodeProperties: Swift.Int?
        /// The number of nodes in the graph.
        public var numNodes: Swift.Int?
        /// The total number of usages of all edge properties.
        public var totalEdgePropertyValues: Swift.Int?
        /// The total number of usages of all node properties.
        public var totalNodePropertyValues: Swift.Int?

        public init(
            edgeLabels: [Swift.String]? = nil,
            edgeProperties: [[Swift.String:Swift.Int]]? = nil,
            edgeStructures: [NeptunedataClientTypes.EdgeStructure]? = nil,
            nodeLabels: [Swift.String]? = nil,
            nodeProperties: [[Swift.String:Swift.Int]]? = nil,
            nodeStructures: [NeptunedataClientTypes.NodeStructure]? = nil,
            numEdgeLabels: Swift.Int? = nil,
            numEdgeProperties: Swift.Int? = nil,
            numEdges: Swift.Int? = nil,
            numNodeLabels: Swift.Int? = nil,
            numNodeProperties: Swift.Int? = nil,
            numNodes: Swift.Int? = nil,
            totalEdgePropertyValues: Swift.Int? = nil,
            totalNodePropertyValues: Swift.Int? = nil
        )
        {
            self.edgeLabels = edgeLabels
            self.edgeProperties = edgeProperties
            self.edgeStructures = edgeStructures
            self.nodeLabels = nodeLabels
            self.nodeProperties = nodeProperties
            self.nodeStructures = nodeStructures
            self.numEdgeLabels = numEdgeLabels
            self.numEdgeProperties = numEdgeProperties
            self.numEdges = numEdges
            self.numNodeLabels = numNodeLabels
            self.numNodeProperties = numNodeProperties
            self.numNodes = numNodes
            self.totalEdgePropertyValues = totalEdgePropertyValues
            self.totalNodePropertyValues = totalNodePropertyValues
        }
    }

}

extension NeptunedataClientTypes.PropertygraphSummaryValueMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphSummary
        case lastStatisticsComputationTime
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphSummary = self.graphSummary {
            try encodeContainer.encode(graphSummary, forKey: .graphSummary)
        }
        if let lastStatisticsComputationTime = self.lastStatisticsComputationTime {
            try encodeContainer.encodeTimestamp(lastStatisticsComputationTime, format: .dateTime, forKey: .lastStatisticsComputationTime)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastStatisticsComputationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastStatisticsComputationTime)
        lastStatisticsComputationTime = lastStatisticsComputationTimeDecoded
        let graphSummaryDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.PropertygraphSummary.self, forKey: .graphSummary)
        graphSummary = graphSummaryDecoded
    }
}

extension NeptunedataClientTypes {
    /// Payload for the property graph summary response.
    public struct PropertygraphSummaryValueMap: Swift.Equatable {
        /// The graph summary.
        public var graphSummary: NeptunedataClientTypes.PropertygraphSummary?
        /// The timestamp, in ISO 8601 format, of the time at which Neptune last computed statistics.
        public var lastStatisticsComputationTime: ClientRuntime.Date?
        /// The version of this graph summary response.
        public var version: Swift.String?

        public init(
            graphSummary: NeptunedataClientTypes.PropertygraphSummary? = nil,
            lastStatisticsComputationTime: ClientRuntime.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.graphSummary = graphSummary
            self.lastStatisticsComputationTime = lastStatisticsComputationTime
            self.version = version
        }
    }

}

extension NeptunedataClientTypes.QueryEvalStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelled
        case elapsed
        case subqueries
        case waited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancelled = self.cancelled {
            try encodeContainer.encode(cancelled, forKey: .cancelled)
        }
        if let elapsed = self.elapsed {
            try encodeContainer.encode(elapsed, forKey: .elapsed)
        }
        if let subqueries = self.subqueries {
            try encodeContainer.encode(subqueries, forKey: .subqueries)
        }
        if let waited = self.waited {
            try encodeContainer.encode(waited, forKey: .waited)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .waited)
        waited = waitedDecoded
        let elapsedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsed)
        elapsed = elapsedDecoded
        let cancelledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cancelled)
        cancelled = cancelledDecoded
        let subqueriesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .subqueries)
        subqueries = subqueriesDecoded
    }
}

extension NeptunedataClientTypes {
    /// Structure to capture query statistics such as how many queries are running, accepted or waiting and their details.
    public struct QueryEvalStats: Swift.Equatable {
        /// Set to TRUE if the query was cancelled, or FALSE otherwise.
        public var cancelled: Swift.Bool?
        /// The number of milliseconds the query has been running so far.
        public var elapsed: Swift.Int?
        /// The number of subqueries in this query.
        public var subqueries: ClientRuntime.Document?
        /// Indicates how long the query waited, in milliseconds.
        public var waited: Swift.Int?

        public init(
            cancelled: Swift.Bool? = nil,
            elapsed: Swift.Int? = nil,
            subqueries: ClientRuntime.Document? = nil,
            waited: Swift.Int? = nil
        )
        {
            self.cancelled = cancelled
            self.elapsed = elapsed
            self.subqueries = subqueries
            self.waited = waited
        }
    }

}

extension NeptunedataClientTypes.QueryLanguageVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension NeptunedataClientTypes {
    /// Structure for expressing the query language version.
    public struct QueryLanguageVersion: Swift.Equatable {
        /// The version of the query language.
        /// This member is required.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }

}

extension QueryLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the number of active queries exceeds what the server can process. The query in question can be retried when the system is less busy.
public struct QueryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request which exceeded the limit.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryLimitExceededException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct QueryLimitExceededExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension QueryLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension QueryLimitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the size of a query exceeds the system limit.
public struct QueryLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that exceeded the limit.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct QueryLimitExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension QueryLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension QueryTooLargeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the body of a query is too large.
public struct QueryTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that is too large.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryTooLargeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct QueryTooLargeExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension QueryTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.RDFGraphSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classes
        case numClasses
        case numDistinctPredicates
        case numDistinctSubjects
        case numQuads
        case predicates
        case subjectStructures
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classes = classes {
            var classesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .classes)
            for string0 in classes {
                try classesContainer.encode(string0)
            }
        }
        if let numClasses = self.numClasses {
            try encodeContainer.encode(numClasses, forKey: .numClasses)
        }
        if let numDistinctPredicates = self.numDistinctPredicates {
            try encodeContainer.encode(numDistinctPredicates, forKey: .numDistinctPredicates)
        }
        if let numDistinctSubjects = self.numDistinctSubjects {
            try encodeContainer.encode(numDistinctSubjects, forKey: .numDistinctSubjects)
        }
        if let numQuads = self.numQuads {
            try encodeContainer.encode(numQuads, forKey: .numQuads)
        }
        if let predicates = predicates {
            var predicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicates)
            for longvaluedmap0 in predicates {
                var longvaluedmap0Container = predicatesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, longValuedMap1) in longvaluedmap0 {
                    try longvaluedmap0Container.encode(longValuedMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let subjectStructures = subjectStructures {
            var subjectStructuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectStructures)
            for subjectstructure0 in subjectStructures {
                try subjectStructuresContainer.encode(subjectstructure0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numDistinctSubjectsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numDistinctSubjects)
        numDistinctSubjects = numDistinctSubjectsDecoded
        let numDistinctPredicatesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numDistinctPredicates)
        numDistinctPredicates = numDistinctPredicatesDecoded
        let numQuadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numQuads)
        numQuads = numQuadsDecoded
        let numClassesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numClasses)
        numClasses = numClassesDecoded
        let classesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .classes)
        var classesDecoded0:[Swift.String]? = nil
        if let classesContainer = classesContainer {
            classesDecoded0 = [Swift.String]()
            for string0 in classesContainer {
                if let string0 = string0 {
                    classesDecoded0?.append(string0)
                }
            }
        }
        classes = classesDecoded0
        let predicatesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.Int?]?].self, forKey: .predicates)
        var predicatesDecoded0:[[Swift.String:Swift.Int]]? = nil
        if let predicatesContainer = predicatesContainer {
            predicatesDecoded0 = [[Swift.String:Swift.Int]]()
            for map0 in predicatesContainer {
                var predicatesContainerDecoded0: [Swift.String: Swift.Int]? = nil
                if let map0 = map0 {
                    predicatesContainerDecoded0 = [Swift.String: Swift.Int]()
                    for (key1, long1) in map0 {
                        if let long1 = long1 {
                            predicatesContainerDecoded0?[key1] = long1
                        }
                    }
                }
                if let predicatesContainerDecoded0 = predicatesContainerDecoded0 {
                    predicatesDecoded0?.append(predicatesContainerDecoded0)
                }
            }
        }
        predicates = predicatesDecoded0
        let subjectStructuresContainer = try containerValues.decodeIfPresent([NeptunedataClientTypes.SubjectStructure?].self, forKey: .subjectStructures)
        var subjectStructuresDecoded0:[NeptunedataClientTypes.SubjectStructure]? = nil
        if let subjectStructuresContainer = subjectStructuresContainer {
            subjectStructuresDecoded0 = [NeptunedataClientTypes.SubjectStructure]()
            for structure0 in subjectStructuresContainer {
                if let structure0 = structure0 {
                    subjectStructuresDecoded0?.append(structure0)
                }
            }
        }
        subjectStructures = subjectStructuresDecoded0
    }
}

extension NeptunedataClientTypes {
    /// The RDF graph summary API returns a read-only list of classes and predicate keys, along with counts of quads, subjects, and predicates.
    public struct RDFGraphSummary: Swift.Equatable {
        /// A list of the classes in the graph.
        public var classes: [Swift.String]?
        /// The number of classes in the graph.
        public var numClasses: Swift.Int?
        /// The number of distinct predicates in the graph.
        public var numDistinctPredicates: Swift.Int?
        /// The number of distinct subjects in the graph.
        public var numDistinctSubjects: Swift.Int?
        /// The number of quads in the graph.
        public var numQuads: Swift.Int?
        /// "A list of predicates in the graph, along with the predicate counts.
        public var predicates: [[Swift.String:Swift.Int]]?
        /// This field is only present when the request mode is DETAILED. It contains a list of subject structures.
        public var subjectStructures: [NeptunedataClientTypes.SubjectStructure]?

        public init(
            classes: [Swift.String]? = nil,
            numClasses: Swift.Int? = nil,
            numDistinctPredicates: Swift.Int? = nil,
            numDistinctSubjects: Swift.Int? = nil,
            numQuads: Swift.Int? = nil,
            predicates: [[Swift.String:Swift.Int]]? = nil,
            subjectStructures: [NeptunedataClientTypes.SubjectStructure]? = nil
        )
        {
            self.classes = classes
            self.numClasses = numClasses
            self.numDistinctPredicates = numDistinctPredicates
            self.numDistinctSubjects = numDistinctSubjects
            self.numQuads = numQuads
            self.predicates = predicates
            self.subjectStructures = subjectStructures
        }
    }

}

extension NeptunedataClientTypes.RDFGraphSummaryValueMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphSummary
        case lastStatisticsComputationTime
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphSummary = self.graphSummary {
            try encodeContainer.encode(graphSummary, forKey: .graphSummary)
        }
        if let lastStatisticsComputationTime = self.lastStatisticsComputationTime {
            try encodeContainer.encodeTimestamp(lastStatisticsComputationTime, format: .dateTime, forKey: .lastStatisticsComputationTime)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastStatisticsComputationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastStatisticsComputationTime)
        lastStatisticsComputationTime = lastStatisticsComputationTimeDecoded
        let graphSummaryDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.RDFGraphSummary.self, forKey: .graphSummary)
        graphSummary = graphSummaryDecoded
    }
}

extension NeptunedataClientTypes {
    /// Payload for an RDF graph summary response.
    public struct RDFGraphSummaryValueMap: Swift.Equatable {
        /// The graph summary of an RDF graph. See [Graph summary response for an RDF graph](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-graph-summary.html#neptune-graph-summary-rdf-response).
        public var graphSummary: NeptunedataClientTypes.RDFGraphSummary?
        /// The timestamp, in ISO 8601 format, of the time at which Neptune last computed statistics.
        public var lastStatisticsComputationTime: ClientRuntime.Date?
        /// The version of this graph summary response.
        public var version: Swift.String?

        public init(
            graphSummary: NeptunedataClientTypes.RDFGraphSummary? = nil,
            lastStatisticsComputationTime: ClientRuntime.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.graphSummary = graphSummary
            self.lastStatisticsComputationTime = lastStatisticsComputationTime
            self.version = version
        }
    }

}

extension ReadOnlyViolationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReadOnlyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request attempts to write to a read-only resource.
public struct ReadOnlyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in which the parameter is missing.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReadOnlyViolationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ReadOnlyViolationExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ReadOnlyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.RefreshStatisticsIdMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statisticsId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statisticsId = self.statisticsId {
            try encodeContainer.encode(statisticsId, forKey: .statisticsId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statisticsId)
        statisticsId = statisticsIdDecoded
    }
}

extension NeptunedataClientTypes {
    /// Statistics for REFRESH mode.
    public struct RefreshStatisticsIdMap: Swift.Equatable {
        /// The ID of the statistics generation run that is currently occurring.
        public var statisticsId: Swift.String?

        public init(
            statisticsId: Swift.String? = nil
        )
        {
            self.statisticsId = statisticsId
        }
    }

}

extension NeptunedataClientTypes {
    public enum S3BucketRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afSouth1
        case apEast1
        case apNortheast1
        case apNortheast2
        case apSoutheast1
        case apSoutheast2
        case apSouth1
        case caCentral1
        case cnNorthwest1
        case cnNorth1
        case euCentral1
        case euNorth1
        case euWest1
        case euWest2
        case euWest3
        case meSouth1
        case saEast1
        case usEast1
        case usEast2
        case usGovEast1
        case usGovWest1
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [S3BucketRegion] {
            return [
                .afSouth1,
                .apEast1,
                .apNortheast1,
                .apNortheast2,
                .apSoutheast1,
                .apSoutheast2,
                .apSouth1,
                .caCentral1,
                .cnNorthwest1,
                .cnNorth1,
                .euCentral1,
                .euNorth1,
                .euWest1,
                .euWest2,
                .euWest3,
                .meSouth1,
                .saEast1,
                .usEast1,
                .usEast2,
                .usGovEast1,
                .usGovWest1,
                .usWest1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .apSouth1: return "ap-south-1"
            case .caCentral1: return "ca-central-1"
            case .cnNorthwest1: return "cn-northwest-1"
            case .cnNorth1: return "cn-north-1"
            case .euCentral1: return "eu-central-1"
            case .euNorth1: return "eu-north-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .euWest3: return "eu-west-3"
            case .meSouth1: return "me-south-1"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usGovEast1: return "us-gov-east-1"
            case .usGovWest1: return "us-gov-west-1"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3BucketRegion(rawValue: rawValue) ?? S3BucketRegion.sdkUnknown(rawValue)
        }
    }
}

extension S3Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: S3ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when there is a problem accessing Amazon S3.
public struct S3Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct S3ExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension S3ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ServerShutdownException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServerShutdownExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the server shuts down while processing a request.
public struct ServerShutdownException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerShutdownException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ServerShutdownExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ServerShutdownExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.SparqlData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stmt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stmt = self.stmt {
            try encodeContainer.encode(stmt, forKey: .stmt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stmtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stmt)
        stmt = stmtDecoded
    }
}

extension NeptunedataClientTypes {
    /// Neptune logs are converted to SPARQL quads in the graph using the Resource Description Framework (RDF) [N-QUADS](https://www.w3.org/TR/n-quads/) language defined in the W3C RDF 1.1 N-Quads specification
    public struct SparqlData: Swift.Equatable {
        /// Holds an [N-QUADS](https://www.w3.org/TR/n-quads/) statement expressing the changed quad.
        /// This member is required.
        public var stmt: Swift.String?

        public init(
            stmt: Swift.String? = nil
        )
        {
            self.stmt = stmt
        }
    }

}

extension NeptunedataClientTypes.SparqlRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitTimestampInMillis = "commitTimestamp"
        case data
        case eventId
        case isLastOp
        case op
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitTimestampInMillis = self.commitTimestampInMillis {
            try encodeContainer.encode(commitTimestampInMillis, forKey: .commitTimestampInMillis)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let eventId = eventId {
            var eventIdContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventId)
            for (dictKey0, stringValuedMap0) in eventId {
                try eventIdContainer.encode(stringValuedMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isLastOp = self.isLastOp {
            try encodeContainer.encode(isLastOp, forKey: .isLastOp)
        }
        if let op = self.op {
            try encodeContainer.encode(op, forKey: .op)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitTimestampInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .commitTimestampInMillis)
        commitTimestampInMillis = commitTimestampInMillisDecoded
        let eventIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventId)
        var eventIdDecoded0: [Swift.String:Swift.String]? = nil
        if let eventIdContainer = eventIdContainer {
            eventIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in eventIdContainer {
                if let string0 = string0 {
                    eventIdDecoded0?[key0] = string0
                }
            }
        }
        eventId = eventIdDecoded0
        let dataDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.SparqlData.self, forKey: .data)
        data = dataDecoded
        let opDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .op)
        op = opDecoded
        let isLastOpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLastOp)
        isLastOp = isLastOpDecoded
    }
}

extension NeptunedataClientTypes {
    /// A serialized SPARQL stream record capturing a change-log entry for the RDF graph.
    public struct SparqlRecord: Swift.Equatable {
        /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
        /// This member is required.
        public var commitTimestampInMillis: Swift.Int?
        /// The serialized SPARQL change record. The serialization formats of each record are described in more detail in [Serialization Formats in Neptune Streams](https://docs.aws.amazon.com/neptune/latest/userguide/streams-change-formats.html).
        /// This member is required.
        public var data: NeptunedataClientTypes.SparqlData?
        /// The sequence identifier of the stream change record.
        /// This member is required.
        public var eventId: [Swift.String:Swift.String]?
        /// Only present if this operation is the last one in its transaction. If present, it is set to true. It is useful for ensuring that an entire transaction is consumed.
        public var isLastOp: Swift.Bool?
        /// The operation that created the change.
        /// This member is required.
        public var op: Swift.String?

        public init(
            commitTimestampInMillis: Swift.Int? = nil,
            data: NeptunedataClientTypes.SparqlData? = nil,
            eventId: [Swift.String:Swift.String]? = nil,
            isLastOp: Swift.Bool? = nil,
            op: Swift.String? = nil
        )
        {
            self.commitTimestampInMillis = commitTimestampInMillis
            self.data = data
            self.eventId = eventId
            self.isLastOp = isLastOp
            self.op = op
        }
    }

}

extension StartLoaderJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case failOnError
        case format
        case iamRoleArn
        case mode
        case parallelism
        case parserConfiguration
        case queueRequest
        case s3BucketRegion = "region"
        case source
        case updateSingleCardinalityProperties
        case userProvidedEdgeIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencies = dependencies {
            var dependenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependencies)
            for string0 in dependencies {
                try dependenciesContainer.encode(string0)
            }
        }
        if let failOnError = self.failOnError {
            try encodeContainer.encode(failOnError, forKey: .failOnError)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let parallelism = self.parallelism {
            try encodeContainer.encode(parallelism.rawValue, forKey: .parallelism)
        }
        if let parserConfiguration = parserConfiguration {
            var parserConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parserConfiguration)
            for (dictKey0, stringValuedMap0) in parserConfiguration {
                try parserConfigurationContainer.encode(stringValuedMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queueRequest = self.queueRequest {
            try encodeContainer.encode(queueRequest, forKey: .queueRequest)
        }
        if let s3BucketRegion = self.s3BucketRegion {
            try encodeContainer.encode(s3BucketRegion.rawValue, forKey: .s3BucketRegion)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let updateSingleCardinalityProperties = self.updateSingleCardinalityProperties {
            try encodeContainer.encode(updateSingleCardinalityProperties, forKey: .updateSingleCardinalityProperties)
        }
        if let userProvidedEdgeIds = self.userProvidedEdgeIds {
            try encodeContainer.encode(userProvidedEdgeIds, forKey: .userProvidedEdgeIds)
        }
    }
}

extension StartLoaderJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/loader"
    }
}

public struct StartLoaderJobInput: Swift.Equatable {
    /// This is an optional parameter that can make a queued load request contingent on the successful completion of one or more previous jobs in the queue. Neptune can queue up as many as 64 load requests at a time, if their queueRequest parameters are set to "TRUE". The dependencies parameter lets you make execution of such a queued request dependent on the successful completion of one or more specified previous requests in the queue. For example, if load Job-A and Job-B are independent of each other, but load Job-C needs Job-A and Job-B to be finished before it begins, proceed as follows:
    ///
    /// * Submit load-job-A and load-job-B one after another in any order, and save their load-ids.
    ///
    /// * Submit load-job-C with the load-ids of the two jobs in its dependencies field:
    ///
    ///
    /// Because of the dependencies parameter, the bulk loader will not start Job-C until Job-A and Job-B have completed successfully. If either one of them fails, Job-C will not be executed, and its status will be set to LOAD_FAILED_BECAUSE_DEPENDENCY_NOT_SATISFIED. You can set up multiple levels of dependency in this way, so that the failure of one job will cause all requests that are directly or indirectly dependent on it to be cancelled.
    public var dependencies: [Swift.String]?
    /// failOnError – A flag to toggle a complete stop on an error. Allowed values: "TRUE", "FALSE". Default value: "TRUE". When this parameter is set to "FALSE", the loader tries to load all the data in the location specified, skipping any entries with errors. When this parameter is set to "TRUE", the loader stops as soon as it encounters an error. Data loaded up to that point persists.
    public var failOnError: Swift.Bool?
    /// The format of the data. For more information about data formats for the Neptune Loader command, see [Load Data Formats](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format.html). Allowed values
    ///
    /// * csv for the [Gremlin CSV data format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html).
    ///
    /// * opencypher for the [openCypher CSV data format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    ///
    /// * ntriples for the [N-Triples RDF data format](https://www.w3.org/TR/n-triples/).
    ///
    /// * nquads for the [N-Quads RDF data format](https://www.w3.org/TR/n-quads/).
    ///
    /// * rdfxml for the [RDF\XML RDF data format](https://www.w3.org/TR/rdf-syntax-grammar/).
    ///
    /// * turtle for the [Turtle RDF data format](https://www.w3.org/TR/turtle/).
    /// This member is required.
    public var format: NeptunedataClientTypes.Format?
    /// The Amazon Resource Name (ARN) for an IAM role to be assumed by the Neptune DB instance for access to the S3 bucket. The IAM role ARN provided here should be attached to the DB cluster (see [Adding the IAM Role to an Amazon Neptune Cluster](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-IAM-add-role-cluster.html).
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The load job mode. Allowed values: RESUME, NEW, AUTO. Default value: AUTO.
    ///
    /// * RESUME – In RESUME mode, the loader looks for a previous load from this source, and if it finds one, resumes that load job. If no previous load job is found, the loader stops. The loader avoids reloading files that were successfully loaded in a previous job. It only tries to process failed files. If you dropped previously loaded data from your Neptune cluster, that data is not reloaded in this mode. If a previous load job loaded all files from the same source successfully, nothing is reloaded, and the loader returns success.
    ///
    /// * NEW – In NEW mode, the creates a new load request regardless of any previous loads. You can use this mode to reload all the data from a source after dropping previously loaded data from your Neptune cluster, or to load new data available at the same source.
    ///
    /// * AUTO – In AUTO mode, the loader looks for a previous load job from the same source, and if it finds one, resumes that job, just as in RESUME mode. If the loader doesn't find a previous load job from the same source, it loads all data from the source, just as in NEW mode.
    public var mode: NeptunedataClientTypes.Mode?
    /// The optional parallelism parameter can be set to reduce the number of threads used by the bulk load process. Allowed values:
    ///
    /// * LOW – The number of threads used is the number of available vCPUs divided by 8.
    ///
    /// * MEDIUM – The number of threads used is the number of available vCPUs divided by 2.
    ///
    /// * HIGH – The number of threads used is the same as the number of available vCPUs.
    ///
    /// * OVERSUBSCRIBE – The number of threads used is the number of available vCPUs multiplied by 2. If this value is used, the bulk loader takes up all available resources. This does not mean, however, that the OVERSUBSCRIBE setting results in 100% CPU utilization. Because the load operation is I/O bound, the highest CPU utilization to expect is in the 60% to 70% range.
    ///
    ///
    /// Default value: HIGH The parallelism setting can sometimes result in a deadlock between threads when loading openCypher data. When this happens, Neptune returns the LOAD_DATA_DEADLOCK error. You can generally fix the issue by setting parallelism to a lower setting and retrying the load command.
    public var parallelism: NeptunedataClientTypes.Parallelism?
    /// parserConfiguration – An optional object with additional parser configuration values. Each of the child parameters is also optional:
    ///
    /// * namedGraphUri – The default graph for all RDF formats when no graph is specified (for non-quads formats and NQUAD entries with no graph). The default is https://aws.amazon.com/neptune/vocab/v01/DefaultNamedGraph.
    ///
    /// * baseUri – The base URI for RDF/XML and Turtle formats. The default is https://aws.amazon.com/neptune/default.
    ///
    /// * allowEmptyStrings – Gremlin users need to be able to pass empty string values("") as node and edge properties when loading CSV data. If allowEmptyStrings is set to false (the default), such empty strings are treated as nulls and are not loaded. If allowEmptyStrings is set to true, the loader treats empty strings as valid property values and loads them accordingly.
    public var parserConfiguration: [Swift.String:Swift.String]?
    /// This is an optional flag parameter that indicates whether the load request can be queued up or not. You don't have to wait for one load job to complete before issuing the next one, because Neptune can queue up as many as 64 jobs at a time, provided that their queueRequest parameters are all set to "TRUE". The queue order of the jobs will be first-in-first-out (FIFO). If the queueRequest parameter is omitted or set to "FALSE", the load request will fail if another load job is already running. Allowed values: "TRUE", "FALSE". Default value: "FALSE".
    public var queueRequest: Swift.Bool?
    /// The Amazon region of the S3 bucket. This must match the Amazon Region of the DB cluster.
    /// This member is required.
    public var s3BucketRegion: NeptunedataClientTypes.S3BucketRegion?
    /// The source parameter accepts an S3 URI that identifies a single file, multiple files, a folder, or multiple folders. Neptune loads every data file in any folder that is specified. The URI can be in any of the following formats.
    ///
    /// * s3://(bucket_name)/(object-key-name)
    ///
    /// * https://s3.amazonaws.com/(bucket_name)/(object-key-name)
    ///
    /// * https://s3.us-east-1.amazonaws.com/(bucket_name)/(object-key-name)
    ///
    ///
    /// The object-key-name element of the URI is equivalent to the [prefix](https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestParameters) parameter in an S3 [ListObjects](https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html) API call. It identifies all the objects in the specified S3 bucket whose names begin with that prefix. That can be a single file or folder, or multiple files and/or folders. The specified folder or folders can contain multiple vertex files and multiple edge files.
    /// This member is required.
    public var source: Swift.String?
    /// updateSingleCardinalityProperties is an optional parameter that controls how the bulk loader treats a new value for single-cardinality vertex or edge properties. This is not supported for loading openCypher data. Allowed values: "TRUE", "FALSE". Default value: "FALSE". By default, or when updateSingleCardinalityProperties is explicitly set to "FALSE", the loader treats a new value as an error, because it violates single cardinality. When updateSingleCardinalityProperties is set to "TRUE", on the other hand, the bulk loader replaces the existing value with the new one. If multiple edge or single-cardinality vertex property values are provided in the source file(s) being loaded, the final value at the end of the bulk load could be any one of those new values. The loader only guarantees that the existing value has been replaced by one of the new ones.
    public var updateSingleCardinalityProperties: Swift.Bool?
    /// This parameter is required only when loading openCypher data that contains relationship IDs. It must be included and set to True when openCypher relationship IDs are explicitly provided in the load data (recommended). When userProvidedEdgeIds is absent or set to True, an :ID column must be present in every relationship file in the load. When userProvidedEdgeIds is present and set to False, relationship files in the load must not contain an :ID column. Instead, the Neptune loader automatically generates an ID for each relationship. It's useful to provide relationship IDs explicitly so that the loader can resume loading after error in the CSV data have been fixed, without having to reload any relationships that have already been loaded. If relationship IDs have not been explicitly assigned, the loader cannot resume a failed load if any relationship file has had to be corrected, and must instead reload all the relationships.
    public var userProvidedEdgeIds: Swift.Bool?

    public init(
        dependencies: [Swift.String]? = nil,
        failOnError: Swift.Bool? = nil,
        format: NeptunedataClientTypes.Format? = nil,
        iamRoleArn: Swift.String? = nil,
        mode: NeptunedataClientTypes.Mode? = nil,
        parallelism: NeptunedataClientTypes.Parallelism? = nil,
        parserConfiguration: [Swift.String:Swift.String]? = nil,
        queueRequest: Swift.Bool? = nil,
        s3BucketRegion: NeptunedataClientTypes.S3BucketRegion? = nil,
        source: Swift.String? = nil,
        updateSingleCardinalityProperties: Swift.Bool? = nil,
        userProvidedEdgeIds: Swift.Bool? = nil
    )
    {
        self.dependencies = dependencies
        self.failOnError = failOnError
        self.format = format
        self.iamRoleArn = iamRoleArn
        self.mode = mode
        self.parallelism = parallelism
        self.parserConfiguration = parserConfiguration
        self.queueRequest = queueRequest
        self.s3BucketRegion = s3BucketRegion
        self.source = source
        self.updateSingleCardinalityProperties = updateSingleCardinalityProperties
        self.userProvidedEdgeIds = userProvidedEdgeIds
    }
}

struct StartLoaderJobInputBody: Swift.Equatable {
    let source: Swift.String?
    let format: NeptunedataClientTypes.Format?
    let s3BucketRegion: NeptunedataClientTypes.S3BucketRegion?
    let iamRoleArn: Swift.String?
    let mode: NeptunedataClientTypes.Mode?
    let failOnError: Swift.Bool?
    let parallelism: NeptunedataClientTypes.Parallelism?
    let parserConfiguration: [Swift.String:Swift.String]?
    let updateSingleCardinalityProperties: Swift.Bool?
    let queueRequest: Swift.Bool?
    let dependencies: [Swift.String]?
    let userProvidedEdgeIds: Swift.Bool?
}

extension StartLoaderJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case failOnError
        case format
        case iamRoleArn
        case mode
        case parallelism
        case parserConfiguration
        case queueRequest
        case s3BucketRegion = "region"
        case source
        case updateSingleCardinalityProperties
        case userProvidedEdgeIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let s3BucketRegionDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.S3BucketRegion.self, forKey: .s3BucketRegion)
        s3BucketRegion = s3BucketRegionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let failOnErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failOnError)
        failOnError = failOnErrorDecoded
        let parallelismDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.Parallelism.self, forKey: .parallelism)
        parallelism = parallelismDecoded
        let parserConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parserConfiguration)
        var parserConfigurationDecoded0: [Swift.String:Swift.String]? = nil
        if let parserConfigurationContainer = parserConfigurationContainer {
            parserConfigurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in parserConfigurationContainer {
                if let string0 = string0 {
                    parserConfigurationDecoded0?[key0] = string0
                }
            }
        }
        parserConfiguration = parserConfigurationDecoded0
        let updateSingleCardinalityPropertiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateSingleCardinalityProperties)
        updateSingleCardinalityProperties = updateSingleCardinalityPropertiesDecoded
        let queueRequestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .queueRequest)
        queueRequest = queueRequestDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dependencies)
        var dependenciesDecoded0:[Swift.String]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [Swift.String]()
            for string0 in dependenciesContainer {
                if let string0 = string0 {
                    dependenciesDecoded0?.append(string0)
                }
            }
        }
        dependencies = dependenciesDecoded0
        let userProvidedEdgeIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userProvidedEdgeIds)
        userProvidedEdgeIds = userProvidedEdgeIdsDecoded
    }
}

extension StartLoaderJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartLoaderJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.payload = output.payload
            self.status = output.status
        } else {
            self.payload = nil
            self.status = nil
        }
    }
}

public struct StartLoaderJobOutput: Swift.Equatable {
    /// Contains a loadId name-value pair that provides an identifier for the load operation.
    /// This member is required.
    public var payload: [Swift.String:Swift.String]?
    /// The HTTP return code indicating the status of the load job.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: [Swift.String:Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

struct StartLoaderJobOutputBody: Swift.Equatable {
    let status: Swift.String?
    let payload: [Swift.String:Swift.String]?
}

extension StartLoaderJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let payloadContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .payload)
        var payloadDecoded0: [Swift.String:Swift.String]? = nil
        if let payloadContainer = payloadContainer {
            payloadDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in payloadContainer {
                if let string0 = string0 {
                    payloadDecoded0?[key0] = string0
                }
            }
        }
        payload = payloadDecoded0
    }
}

enum StartLoaderJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BulkLoadIdNotFoundException": return try await BulkLoadIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LoadUrlAccessDeniedException": return try await LoadUrlAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3Exception": return try await S3Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMLDataProcessingJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configFileName
        case id
        case inputDataS3Location
        case modelType
        case neptuneIamRoleArn
        case previousDataProcessingJobId
        case processedDataS3Location
        case processingInstanceType
        case processingInstanceVolumeSizeInGB
        case processingTimeOutInSeconds
        case s3OutputEncryptionKMSKey
        case sagemakerIamRoleArn
        case securityGroupIds
        case subnets
        case volumeEncryptionKMSKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configFileName = self.configFileName {
            try encodeContainer.encode(configFileName, forKey: .configFileName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputDataS3Location = self.inputDataS3Location {
            try encodeContainer.encode(inputDataS3Location, forKey: .inputDataS3Location)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType, forKey: .modelType)
        }
        if let neptuneIamRoleArn = self.neptuneIamRoleArn {
            try encodeContainer.encode(neptuneIamRoleArn, forKey: .neptuneIamRoleArn)
        }
        if let previousDataProcessingJobId = self.previousDataProcessingJobId {
            try encodeContainer.encode(previousDataProcessingJobId, forKey: .previousDataProcessingJobId)
        }
        if let processedDataS3Location = self.processedDataS3Location {
            try encodeContainer.encode(processedDataS3Location, forKey: .processedDataS3Location)
        }
        if let processingInstanceType = self.processingInstanceType {
            try encodeContainer.encode(processingInstanceType, forKey: .processingInstanceType)
        }
        if let processingInstanceVolumeSizeInGB = self.processingInstanceVolumeSizeInGB {
            try encodeContainer.encode(processingInstanceVolumeSizeInGB, forKey: .processingInstanceVolumeSizeInGB)
        }
        if let processingTimeOutInSeconds = self.processingTimeOutInSeconds {
            try encodeContainer.encode(processingTimeOutInSeconds, forKey: .processingTimeOutInSeconds)
        }
        if let s3OutputEncryptionKMSKey = self.s3OutputEncryptionKMSKey {
            try encodeContainer.encode(s3OutputEncryptionKMSKey, forKey: .s3OutputEncryptionKMSKey)
        }
        if let sagemakerIamRoleArn = self.sagemakerIamRoleArn {
            try encodeContainer.encode(sagemakerIamRoleArn, forKey: .sagemakerIamRoleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for string0 in subnets {
                try subnetsContainer.encode(string0)
            }
        }
        if let volumeEncryptionKMSKey = self.volumeEncryptionKMSKey {
            try encodeContainer.encode(volumeEncryptionKMSKey, forKey: .volumeEncryptionKMSKey)
        }
    }
}

extension StartMLDataProcessingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/dataprocessing"
    }
}

public struct StartMLDataProcessingJobInput: Swift.Equatable {
    /// A data specification file that describes how to load the exported graph data for training. The file is automatically generated by the Neptune export toolkit. The default is training-data-configuration.json.
    public var configFileName: Swift.String?
    /// A unique identifier for the new job. The default is an autogenerated UUID.
    public var id: Swift.String?
    /// The URI of the Amazon S3 location where you want SageMaker to download the data needed to run the data processing job.
    /// This member is required.
    public var inputDataS3Location: Swift.String?
    /// One of the two model types that Neptune ML currently supports: heterogeneous graph models (heterogeneous), and knowledge graph (kge). The default is none. If not specified, Neptune ML chooses the model type automatically based on the data.
    public var modelType: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that SageMaker can assume to perform tasks on your behalf. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?
    /// The job ID of a completed data processing job run on an earlier version of the data.
    public var previousDataProcessingJobId: Swift.String?
    /// The URI of the Amazon S3 location where you want SageMaker to save the results of a data processing job.
    /// This member is required.
    public var processedDataS3Location: Swift.String?
    /// The type of ML instance used during data processing. Its memory should be large enough to hold the processed dataset. The default is the smallest ml.r5 type whose memory is ten times larger than the size of the exported graph data on disk.
    public var processingInstanceType: Swift.String?
    /// The disk volume size of the processing instance. Both input data and processed data are stored on disk, so the volume size must be large enough to hold both data sets. The default is 0. If not specified or 0, Neptune ML chooses the volume size automatically based on the data size.
    public var processingInstanceVolumeSizeInGB: Swift.Int?
    /// Timeout in seconds for the data processing job. The default is 86,400 (1 day).
    public var processingTimeOutInSeconds: Swift.Int?
    /// The Amazon Key Management Service (Amazon KMS) key that SageMaker uses to encrypt the output of the processing job. The default is none.
    public var s3OutputEncryptionKMSKey: Swift.String?
    /// The ARN of an IAM role for SageMaker execution. This must be listed in your DB cluster parameter group or an error will occur.
    public var sagemakerIamRoleArn: Swift.String?
    /// The VPC security group IDs. The default is None.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the subnets in the Neptune VPC. The default is None.
    public var subnets: [Swift.String]?
    /// The Amazon Key Management Service (Amazon KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        configFileName: Swift.String? = nil,
        id: Swift.String? = nil,
        inputDataS3Location: Swift.String? = nil,
        modelType: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        previousDataProcessingJobId: Swift.String? = nil,
        processedDataS3Location: Swift.String? = nil,
        processingInstanceType: Swift.String? = nil,
        processingInstanceVolumeSizeInGB: Swift.Int? = nil,
        processingTimeOutInSeconds: Swift.Int? = nil,
        s3OutputEncryptionKMSKey: Swift.String? = nil,
        sagemakerIamRoleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.configFileName = configFileName
        self.id = id
        self.inputDataS3Location = inputDataS3Location
        self.modelType = modelType
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.previousDataProcessingJobId = previousDataProcessingJobId
        self.processedDataS3Location = processedDataS3Location
        self.processingInstanceType = processingInstanceType
        self.processingInstanceVolumeSizeInGB = processingInstanceVolumeSizeInGB
        self.processingTimeOutInSeconds = processingTimeOutInSeconds
        self.s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKey
        self.sagemakerIamRoleArn = sagemakerIamRoleArn
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

struct StartMLDataProcessingJobInputBody: Swift.Equatable {
    let id: Swift.String?
    let previousDataProcessingJobId: Swift.String?
    let inputDataS3Location: Swift.String?
    let processedDataS3Location: Swift.String?
    let sagemakerIamRoleArn: Swift.String?
    let neptuneIamRoleArn: Swift.String?
    let processingInstanceType: Swift.String?
    let processingInstanceVolumeSizeInGB: Swift.Int?
    let processingTimeOutInSeconds: Swift.Int?
    let modelType: Swift.String?
    let configFileName: Swift.String?
    let subnets: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let volumeEncryptionKMSKey: Swift.String?
    let s3OutputEncryptionKMSKey: Swift.String?
}

extension StartMLDataProcessingJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configFileName
        case id
        case inputDataS3Location
        case modelType
        case neptuneIamRoleArn
        case previousDataProcessingJobId
        case processedDataS3Location
        case processingInstanceType
        case processingInstanceVolumeSizeInGB
        case processingTimeOutInSeconds
        case s3OutputEncryptionKMSKey
        case sagemakerIamRoleArn
        case securityGroupIds
        case subnets
        case volumeEncryptionKMSKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let previousDataProcessingJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousDataProcessingJobId)
        previousDataProcessingJobId = previousDataProcessingJobIdDecoded
        let inputDataS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDataS3Location)
        inputDataS3Location = inputDataS3LocationDecoded
        let processedDataS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .processedDataS3Location)
        processedDataS3Location = processedDataS3LocationDecoded
        let sagemakerIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sagemakerIamRoleArn)
        sagemakerIamRoleArn = sagemakerIamRoleArnDecoded
        let neptuneIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neptuneIamRoleArn)
        neptuneIamRoleArn = neptuneIamRoleArnDecoded
        let processingInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .processingInstanceType)
        processingInstanceType = processingInstanceTypeDecoded
        let processingInstanceVolumeSizeInGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processingInstanceVolumeSizeInGB)
        processingInstanceVolumeSizeInGB = processingInstanceVolumeSizeInGBDecoded
        let processingTimeOutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processingTimeOutInSeconds)
        processingTimeOutInSeconds = processingTimeOutInSecondsDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let configFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configFileName)
        configFileName = configFileNameDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let volumeEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKMSKey)
        volumeEncryptionKMSKey = volumeEncryptionKMSKeyDecoded
        let s3OutputEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputEncryptionKMSKey)
        s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKeyDecoded
    }
}

extension StartMLDataProcessingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMLDataProcessingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimeInMillis = output.creationTimeInMillis
            self.id = output.id
        } else {
            self.arn = nil
            self.creationTimeInMillis = nil
            self.id = nil
        }
    }
}

public struct StartMLDataProcessingJobOutput: Swift.Equatable {
    /// The ARN of the data processing job.
    public var arn: Swift.String?
    /// The time it took to create the new processing job, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new data processing job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

struct StartMLDataProcessingJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let creationTimeInMillis: Swift.Int?
}

extension StartMLDataProcessingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTimeInMillis
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTimeInMillis)
        creationTimeInMillis = creationTimeInMillisDecoded
    }
}

enum StartMLDataProcessingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMLModelTrainingJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseProcessingInstanceType
        case customModelTrainingParameters
        case dataProcessingJobId
        case enableManagedSpotTraining
        case id
        case maxHPONumberOfTrainingJobs
        case maxHPOParallelTrainingJobs
        case neptuneIamRoleArn
        case previousModelTrainingJobId
        case s3OutputEncryptionKMSKey
        case sagemakerIamRoleArn
        case securityGroupIds
        case subnets
        case trainModelS3Location
        case trainingInstanceType
        case trainingInstanceVolumeSizeInGB
        case trainingTimeOutInSeconds
        case volumeEncryptionKMSKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseProcessingInstanceType = self.baseProcessingInstanceType {
            try encodeContainer.encode(baseProcessingInstanceType, forKey: .baseProcessingInstanceType)
        }
        if let customModelTrainingParameters = self.customModelTrainingParameters {
            try encodeContainer.encode(customModelTrainingParameters, forKey: .customModelTrainingParameters)
        }
        if let dataProcessingJobId = self.dataProcessingJobId {
            try encodeContainer.encode(dataProcessingJobId, forKey: .dataProcessingJobId)
        }
        if let enableManagedSpotTraining = self.enableManagedSpotTraining {
            try encodeContainer.encode(enableManagedSpotTraining, forKey: .enableManagedSpotTraining)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxHPONumberOfTrainingJobs = self.maxHPONumberOfTrainingJobs {
            try encodeContainer.encode(maxHPONumberOfTrainingJobs, forKey: .maxHPONumberOfTrainingJobs)
        }
        if let maxHPOParallelTrainingJobs = self.maxHPOParallelTrainingJobs {
            try encodeContainer.encode(maxHPOParallelTrainingJobs, forKey: .maxHPOParallelTrainingJobs)
        }
        if let neptuneIamRoleArn = self.neptuneIamRoleArn {
            try encodeContainer.encode(neptuneIamRoleArn, forKey: .neptuneIamRoleArn)
        }
        if let previousModelTrainingJobId = self.previousModelTrainingJobId {
            try encodeContainer.encode(previousModelTrainingJobId, forKey: .previousModelTrainingJobId)
        }
        if let s3OutputEncryptionKMSKey = self.s3OutputEncryptionKMSKey {
            try encodeContainer.encode(s3OutputEncryptionKMSKey, forKey: .s3OutputEncryptionKMSKey)
        }
        if let sagemakerIamRoleArn = self.sagemakerIamRoleArn {
            try encodeContainer.encode(sagemakerIamRoleArn, forKey: .sagemakerIamRoleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for string0 in subnets {
                try subnetsContainer.encode(string0)
            }
        }
        if let trainModelS3Location = self.trainModelS3Location {
            try encodeContainer.encode(trainModelS3Location, forKey: .trainModelS3Location)
        }
        if let trainingInstanceType = self.trainingInstanceType {
            try encodeContainer.encode(trainingInstanceType, forKey: .trainingInstanceType)
        }
        if let trainingInstanceVolumeSizeInGB = self.trainingInstanceVolumeSizeInGB {
            try encodeContainer.encode(trainingInstanceVolumeSizeInGB, forKey: .trainingInstanceVolumeSizeInGB)
        }
        if let trainingTimeOutInSeconds = self.trainingTimeOutInSeconds {
            try encodeContainer.encode(trainingTimeOutInSeconds, forKey: .trainingTimeOutInSeconds)
        }
        if let volumeEncryptionKMSKey = self.volumeEncryptionKMSKey {
            try encodeContainer.encode(volumeEncryptionKMSKey, forKey: .volumeEncryptionKMSKey)
        }
    }
}

extension StartMLModelTrainingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/modeltraining"
    }
}

public struct StartMLModelTrainingJobInput: Swift.Equatable {
    /// The type of ML instance used in preparing and managing training of ML models. This is a CPU instance chosen based on memory requirements for processing the training data and model.
    public var baseProcessingInstanceType: Swift.String?
    /// The configuration for custom model training. This is a JSON object.
    public var customModelTrainingParameters: NeptunedataClientTypes.CustomModelTrainingParameters?
    /// The job ID of the completed data-processing job that has created the data that the training will work with.
    /// This member is required.
    public var dataProcessingJobId: Swift.String?
    /// Optimizes the cost of training machine-learning models by using Amazon Elastic Compute Cloud spot instances. The default is False.
    public var enableManagedSpotTraining: Swift.Bool?
    /// A unique identifier for the new job. The default is An autogenerated UUID.
    public var id: Swift.String?
    /// Maximum total number of training jobs to start for the hyperparameter tuning job. The default is 2. Neptune ML automatically tunes the hyperparameters of the machine learning model. To obtain a model that performs well, use at least 10 jobs (in other words, set maxHPONumberOfTrainingJobs to 10). In general, the more tuning runs, the better the results.
    public var maxHPONumberOfTrainingJobs: Swift.Int?
    /// Maximum number of parallel training jobs to start for the hyperparameter tuning job. The default is 2. The number of parallel jobs you can run is limited by the available resources on your training instance.
    public var maxHPOParallelTrainingJobs: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?
    /// The job ID of a completed model-training job that you want to update incrementally based on updated data.
    public var previousModelTrainingJobId: Swift.String?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt the output of the processing job. The default is none.
    public var s3OutputEncryptionKMSKey: Swift.String?
    /// The ARN of an IAM role for SageMaker execution.This must be listed in your DB cluster parameter group or an error will occur.
    public var sagemakerIamRoleArn: Swift.String?
    /// The VPC security group IDs. The default is None.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the subnets in the Neptune VPC. The default is None.
    public var subnets: [Swift.String]?
    /// The location in Amazon S3 where the model artifacts are to be stored.
    /// This member is required.
    public var trainModelS3Location: Swift.String?
    /// The type of ML instance used for model training. All Neptune ML models support CPU, GPU, and multiGPU training. The default is ml.p3.2xlarge. Choosing the right instance type for training depends on the task type, graph size, and your budget.
    public var trainingInstanceType: Swift.String?
    /// The disk volume size of the training instance. Both input data and the output model are stored on disk, so the volume size must be large enough to hold both data sets. The default is 0. If not specified or 0, Neptune ML selects a disk volume size based on the recommendation generated in the data processing step.
    public var trainingInstanceVolumeSizeInGB: Swift.Int?
    /// Timeout in seconds for the training job. The default is 86,400 (1 day).
    public var trainingTimeOutInSeconds: Swift.Int?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        baseProcessingInstanceType: Swift.String? = nil,
        customModelTrainingParameters: NeptunedataClientTypes.CustomModelTrainingParameters? = nil,
        dataProcessingJobId: Swift.String? = nil,
        enableManagedSpotTraining: Swift.Bool? = nil,
        id: Swift.String? = nil,
        maxHPONumberOfTrainingJobs: Swift.Int? = nil,
        maxHPOParallelTrainingJobs: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        previousModelTrainingJobId: Swift.String? = nil,
        s3OutputEncryptionKMSKey: Swift.String? = nil,
        sagemakerIamRoleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        trainModelS3Location: Swift.String? = nil,
        trainingInstanceType: Swift.String? = nil,
        trainingInstanceVolumeSizeInGB: Swift.Int? = nil,
        trainingTimeOutInSeconds: Swift.Int? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.baseProcessingInstanceType = baseProcessingInstanceType
        self.customModelTrainingParameters = customModelTrainingParameters
        self.dataProcessingJobId = dataProcessingJobId
        self.enableManagedSpotTraining = enableManagedSpotTraining
        self.id = id
        self.maxHPONumberOfTrainingJobs = maxHPONumberOfTrainingJobs
        self.maxHPOParallelTrainingJobs = maxHPOParallelTrainingJobs
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.previousModelTrainingJobId = previousModelTrainingJobId
        self.s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKey
        self.sagemakerIamRoleArn = sagemakerIamRoleArn
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.trainModelS3Location = trainModelS3Location
        self.trainingInstanceType = trainingInstanceType
        self.trainingInstanceVolumeSizeInGB = trainingInstanceVolumeSizeInGB
        self.trainingTimeOutInSeconds = trainingTimeOutInSeconds
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

struct StartMLModelTrainingJobInputBody: Swift.Equatable {
    let id: Swift.String?
    let previousModelTrainingJobId: Swift.String?
    let dataProcessingJobId: Swift.String?
    let trainModelS3Location: Swift.String?
    let sagemakerIamRoleArn: Swift.String?
    let neptuneIamRoleArn: Swift.String?
    let baseProcessingInstanceType: Swift.String?
    let trainingInstanceType: Swift.String?
    let trainingInstanceVolumeSizeInGB: Swift.Int?
    let trainingTimeOutInSeconds: Swift.Int?
    let maxHPONumberOfTrainingJobs: Swift.Int?
    let maxHPOParallelTrainingJobs: Swift.Int?
    let subnets: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let volumeEncryptionKMSKey: Swift.String?
    let s3OutputEncryptionKMSKey: Swift.String?
    let enableManagedSpotTraining: Swift.Bool?
    let customModelTrainingParameters: NeptunedataClientTypes.CustomModelTrainingParameters?
}

extension StartMLModelTrainingJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseProcessingInstanceType
        case customModelTrainingParameters
        case dataProcessingJobId
        case enableManagedSpotTraining
        case id
        case maxHPONumberOfTrainingJobs
        case maxHPOParallelTrainingJobs
        case neptuneIamRoleArn
        case previousModelTrainingJobId
        case s3OutputEncryptionKMSKey
        case sagemakerIamRoleArn
        case securityGroupIds
        case subnets
        case trainModelS3Location
        case trainingInstanceType
        case trainingInstanceVolumeSizeInGB
        case trainingTimeOutInSeconds
        case volumeEncryptionKMSKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let previousModelTrainingJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousModelTrainingJobId)
        previousModelTrainingJobId = previousModelTrainingJobIdDecoded
        let dataProcessingJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProcessingJobId)
        dataProcessingJobId = dataProcessingJobIdDecoded
        let trainModelS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainModelS3Location)
        trainModelS3Location = trainModelS3LocationDecoded
        let sagemakerIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sagemakerIamRoleArn)
        sagemakerIamRoleArn = sagemakerIamRoleArnDecoded
        let neptuneIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neptuneIamRoleArn)
        neptuneIamRoleArn = neptuneIamRoleArnDecoded
        let baseProcessingInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseProcessingInstanceType)
        baseProcessingInstanceType = baseProcessingInstanceTypeDecoded
        let trainingInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingInstanceType)
        trainingInstanceType = trainingInstanceTypeDecoded
        let trainingInstanceVolumeSizeInGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .trainingInstanceVolumeSizeInGB)
        trainingInstanceVolumeSizeInGB = trainingInstanceVolumeSizeInGBDecoded
        let trainingTimeOutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .trainingTimeOutInSeconds)
        trainingTimeOutInSeconds = trainingTimeOutInSecondsDecoded
        let maxHPONumberOfTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxHPONumberOfTrainingJobs)
        maxHPONumberOfTrainingJobs = maxHPONumberOfTrainingJobsDecoded
        let maxHPOParallelTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxHPOParallelTrainingJobs)
        maxHPOParallelTrainingJobs = maxHPOParallelTrainingJobsDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let volumeEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKMSKey)
        volumeEncryptionKMSKey = volumeEncryptionKMSKeyDecoded
        let s3OutputEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputEncryptionKMSKey)
        s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKeyDecoded
        let enableManagedSpotTrainingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableManagedSpotTraining)
        enableManagedSpotTraining = enableManagedSpotTrainingDecoded
        let customModelTrainingParametersDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.CustomModelTrainingParameters.self, forKey: .customModelTrainingParameters)
        customModelTrainingParameters = customModelTrainingParametersDecoded
    }
}

extension StartMLModelTrainingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMLModelTrainingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimeInMillis = output.creationTimeInMillis
            self.id = output.id
        } else {
            self.arn = nil
            self.creationTimeInMillis = nil
            self.id = nil
        }
    }
}

public struct StartMLModelTrainingJobOutput: Swift.Equatable {
    /// The ARN of the new model training job.
    public var arn: Swift.String?
    /// The model training job creation time, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new model training job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

struct StartMLModelTrainingJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let creationTimeInMillis: Swift.Int?
}

extension StartMLModelTrainingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTimeInMillis
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTimeInMillis)
        creationTimeInMillis = creationTimeInMillisDecoded
    }
}

enum StartMLModelTrainingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMLModelTransformJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseProcessingInstanceType
        case baseProcessingInstanceVolumeSizeInGB
        case customModelTransformParameters
        case dataProcessingJobId
        case id
        case mlModelTrainingJobId
        case modelTransformOutputS3Location
        case neptuneIamRoleArn
        case s3OutputEncryptionKMSKey
        case sagemakerIamRoleArn
        case securityGroupIds
        case subnets
        case trainingJobName
        case volumeEncryptionKMSKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseProcessingInstanceType = self.baseProcessingInstanceType {
            try encodeContainer.encode(baseProcessingInstanceType, forKey: .baseProcessingInstanceType)
        }
        if let baseProcessingInstanceVolumeSizeInGB = self.baseProcessingInstanceVolumeSizeInGB {
            try encodeContainer.encode(baseProcessingInstanceVolumeSizeInGB, forKey: .baseProcessingInstanceVolumeSizeInGB)
        }
        if let customModelTransformParameters = self.customModelTransformParameters {
            try encodeContainer.encode(customModelTransformParameters, forKey: .customModelTransformParameters)
        }
        if let dataProcessingJobId = self.dataProcessingJobId {
            try encodeContainer.encode(dataProcessingJobId, forKey: .dataProcessingJobId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let mlModelTrainingJobId = self.mlModelTrainingJobId {
            try encodeContainer.encode(mlModelTrainingJobId, forKey: .mlModelTrainingJobId)
        }
        if let modelTransformOutputS3Location = self.modelTransformOutputS3Location {
            try encodeContainer.encode(modelTransformOutputS3Location, forKey: .modelTransformOutputS3Location)
        }
        if let neptuneIamRoleArn = self.neptuneIamRoleArn {
            try encodeContainer.encode(neptuneIamRoleArn, forKey: .neptuneIamRoleArn)
        }
        if let s3OutputEncryptionKMSKey = self.s3OutputEncryptionKMSKey {
            try encodeContainer.encode(s3OutputEncryptionKMSKey, forKey: .s3OutputEncryptionKMSKey)
        }
        if let sagemakerIamRoleArn = self.sagemakerIamRoleArn {
            try encodeContainer.encode(sagemakerIamRoleArn, forKey: .sagemakerIamRoleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for string0 in subnets {
                try subnetsContainer.encode(string0)
            }
        }
        if let trainingJobName = self.trainingJobName {
            try encodeContainer.encode(trainingJobName, forKey: .trainingJobName)
        }
        if let volumeEncryptionKMSKey = self.volumeEncryptionKMSKey {
            try encodeContainer.encode(volumeEncryptionKMSKey, forKey: .volumeEncryptionKMSKey)
        }
    }
}

extension StartMLModelTransformJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ml/modeltransform"
    }
}

public struct StartMLModelTransformJobInput: Swift.Equatable {
    /// The type of ML instance used in preparing and managing training of ML models. This is an ML compute instance chosen based on memory requirements for processing the training data and model.
    public var baseProcessingInstanceType: Swift.String?
    /// The disk volume size of the training instance in gigabytes. The default is 0. Both input data and the output model are stored on disk, so the volume size must be large enough to hold both data sets. If not specified or 0, Neptune ML selects a disk volume size based on the recommendation generated in the data processing step.
    public var baseProcessingInstanceVolumeSizeInGB: Swift.Int?
    /// Configuration information for a model transform using a custom model. The customModelTransformParameters object contains the following fields, which must have values compatible with the saved model parameters from the training job:
    public var customModelTransformParameters: NeptunedataClientTypes.CustomModelTransformParameters?
    /// The job ID of a completed data-processing job. You must include either dataProcessingJobId and a mlModelTrainingJobId, or a trainingJobName.
    public var dataProcessingJobId: Swift.String?
    /// A unique identifier for the new job. The default is an autogenerated UUID.
    public var id: Swift.String?
    /// The job ID of a completed model-training job. You must include either dataProcessingJobId and a mlModelTrainingJobId, or a trainingJobName.
    public var mlModelTrainingJobId: Swift.String?
    /// The location in Amazon S3 where the model artifacts are to be stored.
    /// This member is required.
    public var modelTransformOutputS3Location: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt the output of the processing job. The default is none.
    public var s3OutputEncryptionKMSKey: Swift.String?
    /// The ARN of an IAM role for SageMaker execution. This must be listed in your DB cluster parameter group or an error will occur.
    public var sagemakerIamRoleArn: Swift.String?
    /// The VPC security group IDs. The default is None.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the subnets in the Neptune VPC. The default is None.
    public var subnets: [Swift.String]?
    /// The name of a completed SageMaker training job. You must include either dataProcessingJobId and a mlModelTrainingJobId, or a trainingJobName.
    public var trainingJobName: Swift.String?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        baseProcessingInstanceType: Swift.String? = nil,
        baseProcessingInstanceVolumeSizeInGB: Swift.Int? = nil,
        customModelTransformParameters: NeptunedataClientTypes.CustomModelTransformParameters? = nil,
        dataProcessingJobId: Swift.String? = nil,
        id: Swift.String? = nil,
        mlModelTrainingJobId: Swift.String? = nil,
        modelTransformOutputS3Location: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        s3OutputEncryptionKMSKey: Swift.String? = nil,
        sagemakerIamRoleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        trainingJobName: Swift.String? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.baseProcessingInstanceType = baseProcessingInstanceType
        self.baseProcessingInstanceVolumeSizeInGB = baseProcessingInstanceVolumeSizeInGB
        self.customModelTransformParameters = customModelTransformParameters
        self.dataProcessingJobId = dataProcessingJobId
        self.id = id
        self.mlModelTrainingJobId = mlModelTrainingJobId
        self.modelTransformOutputS3Location = modelTransformOutputS3Location
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKey
        self.sagemakerIamRoleArn = sagemakerIamRoleArn
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.trainingJobName = trainingJobName
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

struct StartMLModelTransformJobInputBody: Swift.Equatable {
    let id: Swift.String?
    let dataProcessingJobId: Swift.String?
    let mlModelTrainingJobId: Swift.String?
    let trainingJobName: Swift.String?
    let modelTransformOutputS3Location: Swift.String?
    let sagemakerIamRoleArn: Swift.String?
    let neptuneIamRoleArn: Swift.String?
    let customModelTransformParameters: NeptunedataClientTypes.CustomModelTransformParameters?
    let baseProcessingInstanceType: Swift.String?
    let baseProcessingInstanceVolumeSizeInGB: Swift.Int?
    let subnets: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let volumeEncryptionKMSKey: Swift.String?
    let s3OutputEncryptionKMSKey: Swift.String?
}

extension StartMLModelTransformJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseProcessingInstanceType
        case baseProcessingInstanceVolumeSizeInGB
        case customModelTransformParameters
        case dataProcessingJobId
        case id
        case mlModelTrainingJobId
        case modelTransformOutputS3Location
        case neptuneIamRoleArn
        case s3OutputEncryptionKMSKey
        case sagemakerIamRoleArn
        case securityGroupIds
        case subnets
        case trainingJobName
        case volumeEncryptionKMSKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataProcessingJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProcessingJobId)
        dataProcessingJobId = dataProcessingJobIdDecoded
        let mlModelTrainingJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mlModelTrainingJobId)
        mlModelTrainingJobId = mlModelTrainingJobIdDecoded
        let trainingJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingJobName)
        trainingJobName = trainingJobNameDecoded
        let modelTransformOutputS3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelTransformOutputS3Location)
        modelTransformOutputS3Location = modelTransformOutputS3LocationDecoded
        let sagemakerIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sagemakerIamRoleArn)
        sagemakerIamRoleArn = sagemakerIamRoleArnDecoded
        let neptuneIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neptuneIamRoleArn)
        neptuneIamRoleArn = neptuneIamRoleArnDecoded
        let customModelTransformParametersDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.CustomModelTransformParameters.self, forKey: .customModelTransformParameters)
        customModelTransformParameters = customModelTransformParametersDecoded
        let baseProcessingInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseProcessingInstanceType)
        baseProcessingInstanceType = baseProcessingInstanceTypeDecoded
        let baseProcessingInstanceVolumeSizeInGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseProcessingInstanceVolumeSizeInGB)
        baseProcessingInstanceVolumeSizeInGB = baseProcessingInstanceVolumeSizeInGBDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let volumeEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKMSKey)
        volumeEncryptionKMSKey = volumeEncryptionKMSKeyDecoded
        let s3OutputEncryptionKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputEncryptionKMSKey)
        s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKeyDecoded
    }
}

extension StartMLModelTransformJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMLModelTransformJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimeInMillis = output.creationTimeInMillis
            self.id = output.id
        } else {
            self.arn = nil
            self.creationTimeInMillis = nil
            self.id = nil
        }
    }
}

public struct StartMLModelTransformJobOutput: Swift.Equatable {
    /// The ARN of the model transform job.
    public var arn: Swift.String?
    /// The creation time of the model transform job, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new model transform job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

struct StartMLModelTransformJobOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let creationTimeInMillis: Swift.Int?
}

extension StartMLModelTransformJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTimeInMillis
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTimeInMillis)
        creationTimeInMillis = creationTimeInMillisDecoded
    }
}

enum StartMLModelTransformJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientTimeoutException": return try await ClientTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConstraintViolationException": return try await ConstraintViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingParameterException": return try await MissingParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MLResourceNotFoundException": return try await MLResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionsFailedException": return try await PreconditionsFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptunedataClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case autoCompute
        case date
        case note
        case signatureInfo
        case statisticsId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let autoCompute = self.autoCompute {
            try encodeContainer.encode(autoCompute, forKey: .autoCompute)
        }
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .dateTime, forKey: .date)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let signatureInfo = self.signatureInfo {
            try encodeContainer.encode(signatureInfo, forKey: .signatureInfo)
        }
        if let statisticsId = self.statisticsId {
            try encodeContainer.encode(statisticsId, forKey: .statisticsId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoComputeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCompute)
        autoCompute = autoComputeDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let statisticsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statisticsId)
        statisticsId = statisticsIdDecoded
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .date)
        date = dateDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
        let signatureInfoDecoded = try containerValues.decodeIfPresent(NeptunedataClientTypes.StatisticsSummary.self, forKey: .signatureInfo)
        signatureInfo = signatureInfoDecoded
    }
}

extension NeptunedataClientTypes {
    /// Contains statistics information. The DFE engine uses information about the data in your Neptune graph to make effective trade-offs when planning query execution. This information takes the form of statistics that include so-called characteristic sets and predicate statistics that can guide query planning. See [Managing statistics for the Neptune DFE to use](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-dfe-statistics.html).
    public struct Statistics: Swift.Equatable {
        /// Indicates whether or not DFE statistics generation is enabled at all.
        public var active: Swift.Bool?
        /// Indicates whether or not automatic statistics generation is enabled.
        public var autoCompute: Swift.Bool?
        /// The UTC time at which DFE statistics have most recently been generated.
        public var date: ClientRuntime.Date?
        /// A note about problems in the case where statistics are invalid.
        public var note: Swift.String?
        /// A StatisticsSummary structure that contains:
        ///
        /// * signatureCount - The total number of signatures across all characteristic sets.
        ///
        /// * instanceCount - The total number of characteristic-set instances.
        ///
        /// * predicateCount - The total number of unique predicates.
        public var signatureInfo: NeptunedataClientTypes.StatisticsSummary?
        /// Reports the ID of the current statistics generation run. A value of -1 indicates that no statistics have been generated.
        public var statisticsId: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            autoCompute: Swift.Bool? = nil,
            date: ClientRuntime.Date? = nil,
            note: Swift.String? = nil,
            signatureInfo: NeptunedataClientTypes.StatisticsSummary? = nil,
            statisticsId: Swift.String? = nil
        )
        {
            self.active = active
            self.autoCompute = autoCompute
            self.date = date
            self.note = note
            self.signatureInfo = signatureInfo
            self.statisticsId = statisticsId
        }
    }

}

extension NeptunedataClientTypes {
    public enum StatisticsAutoGenerationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableAutocompute
        case enableAutocompute
        case refresh
        case sdkUnknown(Swift.String)

        public static var allCases: [StatisticsAutoGenerationMode] {
            return [
                .disableAutocompute,
                .enableAutocompute,
                .refresh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableAutocompute: return "disableAutoCompute"
            case .enableAutocompute: return "enableAutoCompute"
            case .refresh: return "refresh"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatisticsAutoGenerationMode(rawValue: rawValue) ?? StatisticsAutoGenerationMode.sdkUnknown(rawValue)
        }
    }
}

extension StatisticsNotAvailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StatisticsNotAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when statistics needed to satisfy a request are not available.
public struct StatisticsNotAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StatisticsNotAvailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct StatisticsNotAvailableExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension StatisticsNotAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.StatisticsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCount
        case predicateCount
        case signatureCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let predicateCount = self.predicateCount {
            try encodeContainer.encode(predicateCount, forKey: .predicateCount)
        }
        if let signatureCount = self.signatureCount {
            try encodeContainer.encode(signatureCount, forKey: .signatureCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signatureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .signatureCount)
        signatureCount = signatureCountDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let predicateCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predicateCount)
        predicateCount = predicateCountDecoded
    }
}

extension NeptunedataClientTypes {
    /// Information about the characteristic sets generated in the statistics.
    public struct StatisticsSummary: Swift.Equatable {
        /// The total number of characteristic-set instances.
        public var instanceCount: Swift.Int?
        /// The total number of unique predicates.
        public var predicateCount: Swift.Int?
        /// The total number of signatures across all characteristic sets.
        public var signatureCount: Swift.Int?

        public init(
            instanceCount: Swift.Int? = nil,
            predicateCount: Swift.Int? = nil,
            signatureCount: Swift.Int? = nil
        )
        {
            self.instanceCount = instanceCount
            self.predicateCount = predicateCount
            self.signatureCount = signatureCount
        }
    }

}

extension StreamRecordsNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StreamRecordsNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when stream records requested by a query cannot be found.
public struct StreamRecordsNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamRecordsNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct StreamRecordsNotFoundExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension StreamRecordsNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension NeptunedataClientTypes.SubjectStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case predicates
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let predicates = predicates {
            var predicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicates)
            for string0 in predicates {
                try predicatesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let predicatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .predicates)
        var predicatesDecoded0:[Swift.String]? = nil
        if let predicatesContainer = predicatesContainer {
            predicatesDecoded0 = [Swift.String]()
            for string0 in predicatesContainer {
                if let string0 = string0 {
                    predicatesDecoded0?.append(string0)
                }
            }
        }
        predicates = predicatesDecoded0
    }
}

extension NeptunedataClientTypes {
    /// A subject structure.
    public struct SubjectStructure: Swift.Equatable {
        /// Number of occurrences of this specific structure.
        public var count: Swift.Int?
        /// A list of predicates present in this specific structure.
        public var predicates: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            predicates: [Swift.String]? = nil
        )
        {
            self.count = count
            self.predicates = predicates
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the rate of requests exceeds the maximum throughput. Requests can be retried after encountering this exception.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that could not be processed for this reason.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TimeLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TimeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the an operation exceeds the time limit allowed for it.
public struct TimeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that could not be processed for this reason.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TimeLimitExceededException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct TimeLimitExceededExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension TimeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the number of requests being processed exceeds the limit.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that could not be processed for this reason.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UnsupportedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.detailedMessage = output.detailedMessage
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.detailedMessage = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a request attempts to initiate an operation that is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let detailedMessage: Swift.String?
    let requestId: Swift.String?
    let code: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case detailedMessage
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedMessage)
        detailedMessage = detailedMessageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}
