//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers


public struct DeletePropertygraphStatisticsInput: Swift.Sendable {

    public init() { }
}

public struct DeleteSparqlStatisticsInput: Swift.Sendable {

    public init() { }
}

public struct GetEngineStatusInput: Swift.Sendable {

    public init() { }
}

public struct GetPropertygraphStatisticsInput: Swift.Sendable {

    public init() { }
}

public struct GetSparqlStatisticsInput: Swift.Sendable {

    public init() { }
}

/// Raised in case of an authentication or authorization failure.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

extension NeptunedataClientTypes {

    public enum Action: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case initializeReset
        case performReset
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .initializeReset,
                .performReset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .initializeReset: return "initiateDatabaseReset"
            case .performReset: return "performDatabaseReset"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Raised when a request is submitted that cannot be processed.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the bad request.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a request timed out in the client.
public struct ClientTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a request attempts to modify data that is concurrently being modified by another process.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a value in a request field did not satisfy required constraints.
public struct ConstraintViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConstraintViolationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a request fails.
public struct FailureByQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FailureByQueryException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when an argument in a request is not supported.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when an argument in a request has an invalid value.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a parameter value is not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that includes an invalid parameter.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a required parameter is missing.
public struct MissingParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in which the parameter is missing.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a parsing issue is encountered.
public struct ParsingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParsingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a precondition for processing a request is not satisfied.
public struct PreconditionsFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionsFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the an operation exceeds the time limit allowed for it.
public struct TimeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that could not be processed for this reason.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TimeLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the number of requests being processed exceeds the limit.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that could not be processed for this reason.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a request attempts to initiate an operation that is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

public struct CancelGremlinQueryInput: Swift.Sendable {
    /// The unique identifier that identifies the query to be canceled.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

public struct CancelGremlinQueryOutput: Swift.Sendable {
    /// The status of the cancelation
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

/// Raised when a specified bulk-load job ID cannot be found.
public struct BulkLoadIdNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The bulk-load job ID that could not be found.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BulkLoadIdNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the processing of the request failed unexpectedly.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when access is denied to a specified load URL.
public struct LoadUrlAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoadUrlAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

public struct CancelLoaderJobInput: Swift.Sendable {
    /// The ID of the load job to be deleted.
    /// This member is required.
    public var loadId: Swift.String?

    public init(
        loadId: Swift.String? = nil
    )
    {
        self.loadId = loadId
    }
}

public struct CancelLoaderJobOutput: Swift.Sendable {
    /// The cancellation status.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

/// Raised when a specified machine-learning resource could not be found.
public struct MLResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MLResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

public struct CancelMLDataProcessingJobInput: Swift.Sendable {
    /// If set to TRUE, this flag specifies that all Neptune ML S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique identifier of the data-processing job.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct CancelMLDataProcessingJobOutput: Swift.Sendable {
    /// The status of the cancellation request.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

public struct CancelMLModelTrainingJobInput: Swift.Sendable {
    /// If set to TRUE, this flag specifies that all Amazon S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique identifier of the model-training job to be canceled.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct CancelMLModelTrainingJobOutput: Swift.Sendable {
    /// The status of the cancellation.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

public struct CancelMLModelTransformJobInput: Swift.Sendable {
    /// If this flag is set to TRUE, all Neptune ML S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique ID of the model transform job to be canceled.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct CancelMLModelTransformJobOutput: Swift.Sendable {
    /// the status of the cancelation.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

/// Raised when invalid numerical data is encountered when servicing a request.
public struct InvalidNumericDataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNumericDataException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

public struct CancelOpenCypherQueryInput: Swift.Sendable {
    /// The unique ID of the openCypher query to cancel.
    /// This member is required.
    public var queryId: Swift.String?
    /// If set to TRUE, causes the cancelation of the openCypher query to happen silently.
    public var silent: Swift.Bool?

    public init(
        queryId: Swift.String? = nil,
        silent: Swift.Bool? = nil
    )
    {
        self.queryId = queryId
        self.silent = silent
    }
}

public struct CancelOpenCypherQueryOutput: Swift.Sendable {
    /// The cancelation payload for the openCypher query.
    public var payload: Swift.Bool?
    /// The cancellation status of the openCypher query.
    public var status: Swift.String?

    public init(
        payload: Swift.Bool? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

public struct CreateMLEndpointInput: Swift.Sendable {
    /// A unique identifier for the new inference endpoint. The default is an autogenerated timestamped name.
    public var id: Swift.String?
    /// The minimum number of Amazon EC2 instances to deploy to an endpoint for prediction. The default is 1
    public var instanceCount: Swift.Int?
    /// The type of Neptune ML instance to use for online servicing. The default is ml.m5.xlarge. Choosing the ML instance for an inference endpoint depends on the task type, the graph size, and your budget.
    public var instanceType: Swift.String?
    /// The job Id of the completed model-training job that has created the model that the inference endpoint will point to. You must supply either the mlModelTrainingJobId or the mlModelTransformJobId.
    public var mlModelTrainingJobId: Swift.String?
    /// The job Id of the completed model-transform job. You must supply either the mlModelTrainingJobId or the mlModelTransformJobId.
    public var mlModelTransformJobId: Swift.String?
    /// Model type for training. By default the Neptune ML model is automatically based on the modelType used in data processing, but you can specify a different model type here. The default is rgcn for heterogeneous graphs and kge for knowledge graphs. The only valid value for heterogeneous graphs is rgcn. Valid values for knowledge graphs are: kge, transe, distmult, and rotate.
    public var modelName: Swift.String?
    /// The ARN of an IAM role providing Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will be thrown.
    public var neptuneIamRoleArn: Swift.String?
    /// If set to true, update indicates that this is an update request. The default is false. You must supply either the mlModelTrainingJobId or the mlModelTransformJobId.
    public var update: Swift.Bool?
    /// The Amazon Key Management Service (Amazon KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        id: Swift.String? = nil,
        instanceCount: Swift.Int? = nil,
        instanceType: Swift.String? = nil,
        mlModelTrainingJobId: Swift.String? = nil,
        mlModelTransformJobId: Swift.String? = nil,
        modelName: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        update: Swift.Bool? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.id = id
        self.instanceCount = instanceCount
        self.instanceType = instanceType
        self.mlModelTrainingJobId = mlModelTrainingJobId
        self.mlModelTransformJobId = mlModelTransformJobId
        self.modelName = modelName
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.update = update
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

public struct CreateMLEndpointOutput: Swift.Sendable {
    /// The ARN for the new inference endpoint.
    public var arn: Swift.String?
    /// The endpoint creation time, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new inference endpoint.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

public struct DeleteMLEndpointInput: Swift.Sendable {
    /// If this flag is set to TRUE, all Neptune ML S3 artifacts should be deleted when the job is stopped. The default is FALSE.
    public var clean: Swift.Bool?
    /// The unique identifier of the inference endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role providing Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will be thrown.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        clean: Swift.Bool? = nil,
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.clean = clean
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct DeleteMLEndpointOutput: Swift.Sendable {
    /// The status of the cancellation.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

/// Raised when a request attempts to write to a read-only resource.
public struct ReadOnlyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in which the parameter is missing.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReadOnlyViolationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when statistics needed to satisfy a request are not available.
public struct StatisticsNotAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StatisticsNotAvailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

extension NeptunedataClientTypes {

    /// The payload for DeleteStatistics.
    public struct DeleteStatisticsValueMap: Swift.Sendable {
        /// The current status of the statistics.
        public var active: Swift.Bool?
        /// The ID of the statistics generation run that is currently occurring.
        public var statisticsId: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            statisticsId: Swift.String? = nil
        )
        {
            self.active = active
            self.statisticsId = statisticsId
        }
    }
}

public struct DeletePropertygraphStatisticsOutput: Swift.Sendable {
    /// The deletion payload.
    public var payload: NeptunedataClientTypes.DeleteStatisticsValueMap?
    /// The cancel status.
    public var status: Swift.String?
    /// The HTTP response code: 200 if the delete was successful, or 204 if there were no statistics to delete.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.DeleteStatisticsValueMap? = nil,
        status: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.status = status
        self.statusCode = statusCode
    }
}

public struct DeleteSparqlStatisticsOutput: Swift.Sendable {
    /// The deletion payload.
    public var payload: NeptunedataClientTypes.DeleteStatisticsValueMap?
    /// The cancel status.
    public var status: Swift.String?
    /// The HTTP response code: 200 if the delete was successful, or 204 if there were no statistics to delete.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.DeleteStatisticsValueMap? = nil,
        status: Swift.String? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.status = status
        self.statusCode = statusCode
    }
}

/// Raised when the HTTP method used by a request is not supported by the endpoint being used.
public struct MethodNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MethodNotAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the server shuts down while processing a request.
public struct ServerShutdownException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerShutdownException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

public struct ExecuteFastResetInput: Swift.Sendable {
    /// The fast reset action. One of the following values:
    ///
    /// * initiateDatabaseReset – This action generates a unique token needed to actually perform the fast reset.
    ///
    /// * performDatabaseReset – This action uses the token generated by the initiateDatabaseReset action to actually perform the fast reset.
    /// This member is required.
    public var action: NeptunedataClientTypes.Action?
    /// The fast-reset token to initiate the reset.
    public var token: Swift.String?

    public init(
        action: NeptunedataClientTypes.Action? = nil,
        token: Swift.String? = nil
    )
    {
        self.action = action
        self.token = token
    }
}

extension NeptunedataClientTypes {

    /// A structure containing the fast reset token used to initiate a fast reset.
    public struct FastResetToken: Swift.Sendable {
        /// A UUID generated by the database in the initiateDatabaseReset action, and then consumed by the performDatabaseReset to reset the database.
        public var token: Swift.String?

        public init(
            token: Swift.String? = nil
        )
        {
            self.token = token
        }
    }
}

public struct ExecuteFastResetOutput: Swift.Sendable {
    /// The payload is only returned by the initiateDatabaseReset action, and contains the unique token to use with the performDatabaseReset action to make the reset occur.
    public var payload: NeptunedataClientTypes.FastResetToken?
    /// The status is only returned for the performDatabaseReset action, and indicates whether or not the fast reset rquest is accepted.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.FastResetToken? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

/// Raised when a user cancelled a request.
public struct CancelledByUserException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CancelledByUserException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a query is submitted that is syntactically incorrect or does not pass additional validation.
public struct MalformedQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the malformed query request.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedQueryException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when a request fails because of insufficient memory resources. The request can be retried.
public struct MemoryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that failed.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MemoryLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the number of active queries exceeds what the server can process. The query in question can be retried when the system is less busy.
public struct QueryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request which exceeded the limit.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the size of a query exceeds the system limit.
public struct QueryLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that exceeded the limit.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryLimitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the body of a query is too large.
public struct QueryTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that is too large.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

public struct ExecuteGremlinExplainQueryInput: Swift.Sendable {
    /// The Gremlin explain query string.
    /// This member is required.
    public var gremlinQuery: Swift.String?

    public init(
        gremlinQuery: Swift.String? = nil
    )
    {
        self.gremlinQuery = gremlinQuery
    }
}

public struct ExecuteGremlinExplainQueryOutput: Swift.Sendable {
    /// A text blob containing the Gremlin explain result, as described in [Tuning Gremlin queries](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-traversal-tuning.html).
    public var output: Foundation.Data?

    public init(
        output: Foundation.Data? = nil
    )
    {
        self.output = output
    }
}

public struct ExecuteGremlinProfileQueryInput: Swift.Sendable {
    /// If non-zero, causes the results string to be truncated at that number of characters. If set to zero, the string contains all the results.
    public var chop: Swift.Int?
    /// The Gremlin query string to profile.
    /// This member is required.
    public var gremlinQuery: Swift.String?
    /// If this flag is set to TRUE, the results include a detailed report of all index operations that took place during query execution and serialization.
    public var indexOps: Swift.Bool?
    /// If this flag is set to TRUE, the query results are gathered and displayed as part of the profile report. If FALSE, only the result count is displayed.
    public var results: Swift.Bool?
    /// If non-null, the gathered results are returned in a serialized response message in the format specified by this parameter. See [Gremlin profile API in Neptune](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-profile-api.html) for more information.
    public var serializer: Swift.String?

    public init(
        chop: Swift.Int? = nil,
        gremlinQuery: Swift.String? = nil,
        indexOps: Swift.Bool? = nil,
        results: Swift.Bool? = nil,
        serializer: Swift.String? = nil
    )
    {
        self.chop = chop
        self.gremlinQuery = gremlinQuery
        self.indexOps = indexOps
        self.results = results
        self.serializer = serializer
    }
}

public struct ExecuteGremlinProfileQueryOutput: Swift.Sendable {
    /// A text blob containing the Gremlin Profile result. See [Gremlin profile API in Neptune](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-profile-api.html) for details.
    public var output: Foundation.Data?

    public init(
        output: Foundation.Data? = nil
    )
    {
        self.output = output
    }
}

public struct ExecuteGremlinQueryInput: Swift.Sendable {
    /// Using this API, you can run Gremlin queries in string format much as you can using the HTTP endpoint. The interface is compatible with whatever Gremlin version your DB cluster is using (see the [Tinkerpop client section](https://docs.aws.amazon.com/neptune/latest/userguide/access-graph-gremlin-client.html#best-practices-gremlin-java-latest) to determine which Gremlin releases your engine version supports).
    /// This member is required.
    public var gremlinQuery: Swift.String?
    /// If non-null, the query results are returned in a serialized response message in the format specified by this parameter. See the [GraphSON](https://tinkerpop.apache.org/docs/current/reference/#_graphson) section in the TinkerPop documentation for a list of the formats that are currently supported.
    public var serializer: Swift.String?

    public init(
        gremlinQuery: Swift.String? = nil,
        serializer: Swift.String? = nil
    )
    {
        self.gremlinQuery = gremlinQuery
        self.serializer = serializer
    }
}

extension NeptunedataClientTypes {

    /// Contains status components of a Gremlin query.
    public struct GremlinQueryStatusAttributes: Swift.Sendable {
        /// Attributes of the Gremlin query status.
        public var attributes: Smithy.Document?
        /// The HTTP response code returned fro the Gremlin query request..
        public var code: Swift.Int?
        /// The status message.
        public var message: Swift.String?

        public init(
            attributes: Smithy.Document? = nil,
            code: Swift.Int? = nil,
            message: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.code = code
            self.message = message
        }
    }
}

public struct ExecuteGremlinQueryOutput: Swift.Sendable {
    /// Metadata about the Gremlin query.
    public var meta: Smithy.Document?
    /// The unique identifier of the Gremlin query.
    public var requestId: Swift.String?
    /// The Gremlin query output from the server.
    public var result: Smithy.Document?
    /// The status of the Gremlin query.
    public var status: NeptunedataClientTypes.GremlinQueryStatusAttributes?

    public init(
        meta: Smithy.Document? = nil,
        requestId: Swift.String? = nil,
        result: Smithy.Document? = nil,
        status: NeptunedataClientTypes.GremlinQueryStatusAttributes? = nil
    )
    {
        self.meta = meta
        self.requestId = requestId
        self.result = result
        self.status = status
    }
}

extension NeptunedataClientTypes {

    public enum OpenCypherExplainMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case details
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenCypherExplainMode] {
            return [
                .details,
                .dynamic,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .details: return "details"
            case .dynamic: return "dynamic"
            case .static: return "static"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ExecuteOpenCypherExplainQueryInput: Swift.Sendable {
    /// The openCypher explain mode. Can be one of: static, dynamic, or details.
    /// This member is required.
    public var explainMode: NeptunedataClientTypes.OpenCypherExplainMode?
    /// The openCypher query string.
    /// This member is required.
    public var openCypherQuery: Swift.String?
    /// The openCypher query parameters.
    public var parameters: Swift.String?

    public init(
        explainMode: NeptunedataClientTypes.OpenCypherExplainMode? = nil,
        openCypherQuery: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.explainMode = explainMode
        self.openCypherQuery = openCypherQuery
        self.parameters = parameters
    }
}

public struct ExecuteOpenCypherExplainQueryOutput: Swift.Sendable {
    /// A text blob containing the openCypher explain results.
    /// This member is required.
    public var results: Foundation.Data?

    public init(
        results: Foundation.Data? = nil
    )
    {
        self.results = results
    }
}

public struct ExecuteOpenCypherQueryInput: Swift.Sendable {
    /// The openCypher query string to be executed.
    /// This member is required.
    public var openCypherQuery: Swift.String?
    /// The openCypher query parameters for query execution. See [Examples of openCypher parameterized queries](https://docs.aws.amazon.com/neptune/latest/userguide/opencypher-parameterized-queries.html) for more information.
    public var parameters: Swift.String?

    public init(
        openCypherQuery: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.openCypherQuery = openCypherQuery
        self.parameters = parameters
    }
}

public struct ExecuteOpenCypherQueryOutput: Swift.Sendable {
    /// The openCypherquery results.
    /// This member is required.
    public var results: Smithy.Document?

    public init(
        results: Smithy.Document? = nil
    )
    {
        self.results = results
    }
}

extension NeptunedataClientTypes {

    /// Structure for expressing the query language version.
    public struct QueryLanguageVersion: Swift.Sendable {
        /// The version of the query language.
        /// This member is required.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }
}

public struct GetEngineStatusOutput: Swift.Sendable {
    /// Set to the Neptune engine version running on your DB cluster. If this engine version has been manually patched since it was released, the version number is prefixed by Patch-.
    public var dbEngineVersion: Swift.String?
    /// Set to enabled if the DFE engine is fully enabled, or to viaQueryHint (the default) if the DFE engine is only used with queries that have the useDFE query hint set to true.
    public var dfeQueryEngine: Swift.String?
    /// Contains status information about the features enabled on your DB cluster.
    public var features: [Swift.String: Smithy.Document]?
    /// Contains information about the Gremlin query language available on your cluster. Specifically, it contains a version field that specifies the current TinkerPop version being used by the engine.
    public var gremlin: NeptunedataClientTypes.QueryLanguageVersion?
    /// Contains Lab Mode settings being used by the engine.
    public var labMode: [Swift.String: Swift.String]?
    /// Contains information about the openCypher query language available on your cluster. Specifically, it contains a version field that specifies the current operCypher version being used by the engine.
    public var opencypher: NeptunedataClientTypes.QueryLanguageVersion?
    /// Set to reader if the instance is a read-replica, or to writer if the instance is the primary instance.
    public var role: Swift.String?
    /// If there are transactions being rolled back, this field is set to the number of such transactions. If there are none, the field doesn't appear at all.
    public var rollingBackTrxCount: Swift.Int?
    /// Set to the start time of the earliest transaction being rolled back. If no transactions are being rolled back, the field doesn't appear at all.
    public var rollingBackTrxEarliestStartTime: Swift.String?
    /// Contains information about the current settings on your DB cluster. For example, contains the current cluster query timeout setting (clusterQueryTimeoutInMs).
    public var settings: [Swift.String: Swift.String]?
    /// Contains information about the SPARQL query language available on your cluster. Specifically, it contains a version field that specifies the current SPARQL version being used by the engine.
    public var sparql: NeptunedataClientTypes.QueryLanguageVersion?
    /// Set to the UTC time at which the current server process started.
    public var startTime: Swift.String?
    /// Set to healthy if the instance is not experiencing problems. If the instance is recovering from a crash or from being rebooted and there are active transactions running from the latest server shutdown, status is set to recovery.
    public var status: Swift.String?

    public init(
        dbEngineVersion: Swift.String? = nil,
        dfeQueryEngine: Swift.String? = nil,
        features: [Swift.String: Smithy.Document]? = nil,
        gremlin: NeptunedataClientTypes.QueryLanguageVersion? = nil,
        labMode: [Swift.String: Swift.String]? = nil,
        opencypher: NeptunedataClientTypes.QueryLanguageVersion? = nil,
        role: Swift.String? = nil,
        rollingBackTrxCount: Swift.Int? = nil,
        rollingBackTrxEarliestStartTime: Swift.String? = nil,
        settings: [Swift.String: Swift.String]? = nil,
        sparql: NeptunedataClientTypes.QueryLanguageVersion? = nil,
        startTime: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.dbEngineVersion = dbEngineVersion
        self.dfeQueryEngine = dfeQueryEngine
        self.features = features
        self.gremlin = gremlin
        self.labMode = labMode
        self.opencypher = opencypher
        self.role = role
        self.rollingBackTrxCount = rollingBackTrxCount
        self.rollingBackTrxEarliestStartTime = rollingBackTrxEarliestStartTime
        self.settings = settings
        self.sparql = sparql
        self.startTime = startTime
        self.status = status
    }
}

public struct GetGremlinQueryStatusInput: Swift.Sendable {
    /// The unique identifier that identifies the Gremlin query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

extension NeptunedataClientTypes {

    /// Structure to capture query statistics such as how many queries are running, accepted or waiting and their details.
    public struct QueryEvalStats: Swift.Sendable {
        /// Set to TRUE if the query was cancelled, or FALSE otherwise.
        public var cancelled: Swift.Bool?
        /// The number of milliseconds the query has been running so far.
        public var elapsed: Swift.Int?
        /// The number of subqueries in this query.
        public var subqueries: Smithy.Document?
        /// Indicates how long the query waited, in milliseconds.
        public var waited: Swift.Int?

        public init(
            cancelled: Swift.Bool? = nil,
            elapsed: Swift.Int? = nil,
            subqueries: Smithy.Document? = nil,
            waited: Swift.Int? = nil
        )
        {
            self.cancelled = cancelled
            self.elapsed = elapsed
            self.subqueries = subqueries
            self.waited = waited
        }
    }
}

public struct GetGremlinQueryStatusOutput: Swift.Sendable {
    /// The evaluation status of the Gremlin query.
    public var queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
    /// The ID of the query for which status is being returned.
    public var queryId: Swift.String?
    /// The Gremlin query string.
    public var queryString: Swift.String?

    public init(
        queryEvalStats: NeptunedataClientTypes.QueryEvalStats? = nil,
        queryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.queryEvalStats = queryEvalStats
        self.queryId = queryId
        self.queryString = queryString
    }
}

public struct GetLoaderJobStatusInput: Swift.Sendable {
    /// Flag indicating whether or not to include details beyond the overall status (TRUE or FALSE; the default is FALSE).
    public var details: Swift.Bool?
    /// Flag indicating whether or not to include a list of errors encountered (TRUE or FALSE; the default is FALSE). The list of errors is paged. The page and errorsPerPage parameters allow you to page through all the errors.
    public var errors: Swift.Bool?
    /// The number of errors returned in each page (a positive integer; the default is 10). Only valid when the errors parameter set to TRUE.
    public var errorsPerPage: Swift.Int?
    /// The load ID of the load job to get the status of.
    /// This member is required.
    public var loadId: Swift.String?
    /// The error page number (a positive integer; the default is 1). Only valid when the errors parameter is set to TRUE.
    public var page: Swift.Int?

    public init(
        details: Swift.Bool? = nil,
        errors: Swift.Bool? = nil,
        errorsPerPage: Swift.Int? = nil,
        loadId: Swift.String? = nil,
        page: Swift.Int? = nil
    )
    {
        self.details = details
        self.errors = errors
        self.errorsPerPage = errorsPerPage
        self.loadId = loadId
        self.page = page
    }
}

public struct GetLoaderJobStatusOutput: Swift.Sendable {
    /// Status information about the load job, in a layout that could look like this:
    /// This member is required.
    public var payload: Smithy.Document?
    /// The HTTP response code for the request.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: Smithy.Document? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

public struct GetMLDataProcessingJobInput: Swift.Sendable {
    /// The unique identifier of the data-processing job to be retrieved.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

extension NeptunedataClientTypes {

    /// Defines a Neptune ML resource.
    public struct MlResourceDefinition: Swift.Sendable {
        /// The resource ARN.
        public var arn: Swift.String?
        /// The CloudWatch log URL for the resource.
        public var cloudwatchLogUrl: Swift.String?
        /// The failure reason, in case of a failure.
        public var failureReason: Swift.String?
        /// The resource name.
        public var name: Swift.String?
        /// The output location.
        public var outputLocation: Swift.String?
        /// The resource status.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            cloudwatchLogUrl: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.cloudwatchLogUrl = cloudwatchLogUrl
            self.failureReason = failureReason
            self.name = name
            self.outputLocation = outputLocation
            self.status = status
        }
    }
}

public struct GetMLDataProcessingJobOutput: Swift.Sendable {
    /// The unique identifier of this data-processing job.
    public var id: Swift.String?
    /// Definition of the data processing job.
    public var processingJob: NeptunedataClientTypes.MlResourceDefinition?
    /// Status of the data processing job.
    public var status: Swift.String?

    public init(
        id: Swift.String? = nil,
        processingJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        status: Swift.String? = nil
    )
    {
        self.id = id
        self.processingJob = processingJob
        self.status = status
    }
}

public struct GetMLEndpointInput: Swift.Sendable {
    /// The unique identifier of the inference endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

extension NeptunedataClientTypes {

    /// Contains a Neptune ML configuration.
    public struct MlConfigDefinition: Swift.Sendable {
        /// The ARN for the configuration.
        public var arn: Swift.String?
        /// The configuration name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }
}

public struct GetMLEndpointOutput: Swift.Sendable {
    /// The endpoint definition.
    public var endpoint: NeptunedataClientTypes.MlResourceDefinition?
    /// The endpoint configuration
    public var endpointConfig: NeptunedataClientTypes.MlConfigDefinition?
    /// The unique identifier of the inference endpoint.
    public var id: Swift.String?
    /// The status of the inference endpoint.
    public var status: Swift.String?

    public init(
        endpoint: NeptunedataClientTypes.MlResourceDefinition? = nil,
        endpointConfig: NeptunedataClientTypes.MlConfigDefinition? = nil,
        id: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.endpoint = endpoint
        self.endpointConfig = endpointConfig
        self.id = id
        self.status = status
    }
}

public struct GetMLModelTrainingJobInput: Swift.Sendable {
    /// The unique identifier of the model-training job to retrieve.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct GetMLModelTrainingJobOutput: Swift.Sendable {
    /// The HPO job.
    public var hpoJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The unique identifier of this model-training job.
    public var id: Swift.String?
    /// A list of the configurations of the ML models being used.
    public var mlModels: [NeptunedataClientTypes.MlConfigDefinition]?
    /// The model transform job.
    public var modelTransformJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The data processing job.
    public var processingJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The status of the model training job.
    public var status: Swift.String?

    public init(
        hpoJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        id: Swift.String? = nil,
        mlModels: [NeptunedataClientTypes.MlConfigDefinition]? = nil,
        modelTransformJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        processingJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        status: Swift.String? = nil
    )
    {
        self.hpoJob = hpoJob
        self.id = id
        self.mlModels = mlModels
        self.modelTransformJob = modelTransformJob
        self.processingJob = processingJob
        self.status = status
    }
}

public struct GetMLModelTransformJobInput: Swift.Sendable {
    /// The unique identifier of the model-transform job to be reetrieved.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.id = id
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct GetMLModelTransformJobOutput: Swift.Sendable {
    /// The base data processing job.
    public var baseProcessingJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The unique identifier of the model-transform job to be retrieved.
    public var id: Swift.String?
    /// A list of the configuration information for the models being used.
    public var models: [NeptunedataClientTypes.MlConfigDefinition]?
    /// The remote model transform job.
    public var remoteModelTransformJob: NeptunedataClientTypes.MlResourceDefinition?
    /// The status of the model-transform job.
    public var status: Swift.String?

    public init(
        baseProcessingJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        id: Swift.String? = nil,
        models: [NeptunedataClientTypes.MlConfigDefinition]? = nil,
        remoteModelTransformJob: NeptunedataClientTypes.MlResourceDefinition? = nil,
        status: Swift.String? = nil
    )
    {
        self.baseProcessingJob = baseProcessingJob
        self.id = id
        self.models = models
        self.remoteModelTransformJob = remoteModelTransformJob
        self.status = status
    }
}

public struct GetOpenCypherQueryStatusInput: Swift.Sendable {
    /// The unique ID of the openCypher query for which to retrieve the query status.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

public struct GetOpenCypherQueryStatusOutput: Swift.Sendable {
    /// The openCypher query evaluation status.
    public var queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
    /// The unique ID of the query for which status is being returned.
    public var queryId: Swift.String?
    /// The openCypher query string.
    public var queryString: Swift.String?

    public init(
        queryEvalStats: NeptunedataClientTypes.QueryEvalStats? = nil,
        queryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.queryEvalStats = queryEvalStats
        self.queryId = queryId
        self.queryString = queryString
    }
}

extension NeptunedataClientTypes {

    /// Information about the characteristic sets generated in the statistics.
    public struct StatisticsSummary: Swift.Sendable {
        /// The total number of characteristic-set instances.
        public var instanceCount: Swift.Int?
        /// The total number of unique predicates.
        public var predicateCount: Swift.Int?
        /// The total number of signatures across all characteristic sets.
        public var signatureCount: Swift.Int?

        public init(
            instanceCount: Swift.Int? = nil,
            predicateCount: Swift.Int? = nil,
            signatureCount: Swift.Int? = nil
        )
        {
            self.instanceCount = instanceCount
            self.predicateCount = predicateCount
            self.signatureCount = signatureCount
        }
    }
}

extension NeptunedataClientTypes {

    /// Contains statistics information. The DFE engine uses information about the data in your Neptune graph to make effective trade-offs when planning query execution. This information takes the form of statistics that include so-called characteristic sets and predicate statistics that can guide query planning. See [Managing statistics for the Neptune DFE to use](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-dfe-statistics.html).
    public struct Statistics: Swift.Sendable {
        /// Indicates whether or not DFE statistics generation is enabled at all.
        public var active: Swift.Bool?
        /// Indicates whether or not automatic statistics generation is enabled.
        public var autoCompute: Swift.Bool?
        /// The UTC time at which DFE statistics have most recently been generated.
        public var date: Foundation.Date?
        /// A note about problems in the case where statistics are invalid.
        public var note: Swift.String?
        /// A StatisticsSummary structure that contains:
        ///
        /// * signatureCount - The total number of signatures across all characteristic sets.
        ///
        /// * instanceCount - The total number of characteristic-set instances.
        ///
        /// * predicateCount - The total number of unique predicates.
        public var signatureInfo: NeptunedataClientTypes.StatisticsSummary?
        /// Reports the ID of the current statistics generation run. A value of -1 indicates that no statistics have been generated.
        public var statisticsId: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            autoCompute: Swift.Bool? = nil,
            date: Foundation.Date? = nil,
            note: Swift.String? = nil,
            signatureInfo: NeptunedataClientTypes.StatisticsSummary? = nil,
            statisticsId: Swift.String? = nil
        )
        {
            self.active = active
            self.autoCompute = autoCompute
            self.date = date
            self.note = note
            self.signatureInfo = signatureInfo
            self.statisticsId = statisticsId
        }
    }
}

public struct GetPropertygraphStatisticsOutput: Swift.Sendable {
    /// Statistics for property-graph data.
    /// This member is required.
    public var payload: NeptunedataClientTypes.Statistics?
    /// The HTTP return code of the request. If the request succeeded, the code is 200. See [Common error codes for DFE statistics request](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-dfe-statistics.html#neptune-dfe-statistics-errors) for a list of common errors.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.Statistics? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

/// Raised when a request attempts to access an stream that has expired.
public struct ExpiredStreamException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredStreamException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when stream records requested by a query cannot be found.
public struct StreamRecordsNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamRecordsNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

/// Raised when the rate of requests exceeds the maximum throughput. Requests can be retried after encountering this exception.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request that could not be processed for this reason.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

extension NeptunedataClientTypes {

    public enum Encoding: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case sdkUnknown(Swift.String)

        public static var allCases: [Encoding] {
            return [
                .gzip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptunedataClientTypes {

    public enum IteratorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterSequenceNumber
        case atSequenceNumber
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [IteratorType] {
            return [
                .afterSequenceNumber,
                .atSequenceNumber,
                .latest,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
            case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPropertygraphStreamInput: Swift.Sendable {
    /// The commit number of the starting record to read from the change-log stream. This parameter is required when iteratorType isAT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER, and ignored when iteratorType is TRIM_HORIZON or LATEST.
    public var commitNum: Swift.Int?
    /// If set to TRUE, Neptune compresses the response using gzip encoding.
    public var encoding: NeptunedataClientTypes.Encoding?
    /// Can be one of:
    ///
    /// * AT_SEQUENCE_NUMBER – Indicates that reading should start from the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * AFTER_SEQUENCE_NUMBER – Indicates that reading should start right after the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * TRIM_HORIZON – Indicates that reading should start at the last untrimmed record in the system, which is the oldest unexpired (not yet deleted) record in the change-log stream.
    ///
    /// * LATEST – Indicates that reading should start at the most recent record in the system, which is the latest unexpired (not yet deleted) record in the change-log stream.
    public var iteratorType: NeptunedataClientTypes.IteratorType?
    /// Specifies the maximum number of records to return. There is also a size limit of 10 MB on the response that can't be modified and that takes precedence over the number of records specified in the limit parameter. The response does include a threshold-breaching record if the 10 MB limit was reached. The range for limit is 1 to 100,000, with a default of 10.
    public var limit: Swift.Int?
    /// The operation sequence number within the specified commit to start reading from in the change-log stream data. The default is 1.
    public var opNum: Swift.Int?

    public init(
        commitNum: Swift.Int? = nil,
        encoding: NeptunedataClientTypes.Encoding? = nil,
        iteratorType: NeptunedataClientTypes.IteratorType? = nil,
        limit: Swift.Int? = nil,
        opNum: Swift.Int? = nil
    )
    {
        self.commitNum = commitNum
        self.encoding = encoding
        self.iteratorType = iteratorType
        self.limit = limit
        self.opNum = opNum
    }
}

extension NeptunedataClientTypes {

    /// A Gremlin or openCypher change record.
    public struct PropertygraphData: Swift.Sendable {
        /// If this is an edge (type = e), the ID of the corresponding from vertex or source node.
        public var from: Swift.String?
        /// The ID of the Gremlin or openCypher element.
        /// This member is required.
        public var id: Swift.String?
        /// The property name. For element labels, this is label.
        /// This member is required.
        public var key: Swift.String?
        /// If this is an edge (type = e), the ID of the corresponding to vertex or target node.
        public var to: Swift.String?
        /// The type of this Gremlin or openCypher element. Must be one of:
        ///
        /// * v1 - Vertex label for Gremlin, or node label for openCypher.
        ///
        /// * vp - Vertex properties for Gremlin, or node properties for openCypher.
        ///
        /// * e - Edge and edge label for Gremlin, or relationship and relationship type for openCypher.
        ///
        /// * ep - Edge properties for Gremlin, or relationship properties for openCypher.
        /// This member is required.
        public var type: Swift.String?
        /// This is a JSON object that contains a value field for the value itself, and a datatype field for the JSON data type of that value:
        /// This member is required.
        public var value: Smithy.Document?

        public init(
            from: Swift.String? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            to: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Smithy.Document? = nil
        )
        {
            self.from = from
            self.id = id
            self.key = key
            self.to = to
            self.type = type
            self.value = value
        }
    }
}

extension NeptunedataClientTypes {

    /// Structure of a property graph record.
    public struct PropertygraphRecord: Swift.Sendable {
        /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
        /// This member is required.
        public var commitTimestampInMillis: Swift.Int?
        /// The serialized Gremlin or openCypher change record.
        /// This member is required.
        public var data: NeptunedataClientTypes.PropertygraphData?
        /// The sequence identifier of the stream change record.
        /// This member is required.
        public var eventId: [Swift.String: Swift.String]?
        /// Only present if this operation is the last one in its transaction. If present, it is set to true. It is useful for ensuring that an entire transaction is consumed.
        public var isLastOp: Swift.Bool?
        /// The operation that created the change.
        /// This member is required.
        public var op: Swift.String?

        public init(
            commitTimestampInMillis: Swift.Int? = nil,
            data: NeptunedataClientTypes.PropertygraphData? = nil,
            eventId: [Swift.String: Swift.String]? = nil,
            isLastOp: Swift.Bool? = nil,
            op: Swift.String? = nil
        )
        {
            self.commitTimestampInMillis = commitTimestampInMillis
            self.data = data
            self.eventId = eventId
            self.isLastOp = isLastOp
            self.op = op
        }
    }
}

public struct GetPropertygraphStreamOutput: Swift.Sendable {
    /// Serialization format for the change records being returned. Currently, the only supported value is PG_JSON.
    /// This member is required.
    public var format: Swift.String?
    /// Sequence identifier of the last change in the stream response. An event ID is composed of two fields: a commitNum, which identifies a transaction that changed the graph, and an opNum, which identifies a specific operation within that transaction:
    /// This member is required.
    public var lastEventId: [Swift.String: Swift.String]?
    /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
    /// This member is required.
    public var lastTrxTimestampInMillis: Swift.Int?
    /// An array of serialized change-log stream records included in the response.
    /// This member is required.
    public var records: [NeptunedataClientTypes.PropertygraphRecord]?
    /// The total number of records in the response.
    /// This member is required.
    public var totalRecords: Swift.Int?

    public init(
        format: Swift.String? = nil,
        lastEventId: [Swift.String: Swift.String]? = nil,
        lastTrxTimestampInMillis: Swift.Int? = nil,
        records: [NeptunedataClientTypes.PropertygraphRecord]? = nil,
        totalRecords: Swift.Int? = nil
    )
    {
        self.format = format
        self.lastEventId = lastEventId
        self.lastTrxTimestampInMillis = lastTrxTimestampInMillis
        self.records = records
        self.totalRecords = totalRecords
    }
}

extension NeptunedataClientTypes {

    public enum GraphSummaryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case detailed
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphSummaryType] {
            return [
                .basic,
                .detailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "basic"
            case .detailed: return "detailed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPropertygraphSummaryInput: Swift.Sendable {
    /// Mode can take one of two values: BASIC (the default), and DETAILED.
    public var mode: NeptunedataClientTypes.GraphSummaryType?

    public init(
        mode: NeptunedataClientTypes.GraphSummaryType? = nil
    )
    {
        self.mode = mode
    }
}

extension NeptunedataClientTypes {

    /// An edge structure.
    public struct EdgeStructure: Swift.Sendable {
        /// The number of edges that have this specific structure.
        public var count: Swift.Int?
        /// A list of edge properties present in this specific structure.
        public var edgeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            edgeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.edgeProperties = edgeProperties
        }
    }
}

extension NeptunedataClientTypes {

    /// A node structure.
    public struct NodeStructure: Swift.Sendable {
        /// Number of nodes that have this specific structure.
        public var count: Swift.Int?
        /// A list of distinct outgoing edge labels present in this specific structure.
        public var distinctOutgoingEdgeLabels: [Swift.String]?
        /// A list of the node properties present in this specific structure.
        public var nodeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            distinctOutgoingEdgeLabels: [Swift.String]? = nil,
            nodeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels
            self.nodeProperties = nodeProperties
        }
    }
}

extension NeptunedataClientTypes {

    /// The graph summary API returns a read-only list of node and edge labels and property keys, along with counts of nodes, edges, and properties. See [Graph summary response for a property graph (PG)](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-graph-summary.html#neptune-graph-summary-pg-response).
    public struct PropertygraphSummary: Swift.Sendable {
        /// A list of the distinct edge labels in the graph.
        public var edgeLabels: [Swift.String]?
        /// A list of the distinct edge properties in the graph, along with the count of edges where each property is used.
        public var edgeProperties: [[Swift.String: Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of edge structures.
        public var edgeStructures: [NeptunedataClientTypes.EdgeStructure]?
        /// A list of the distinct node labels in the graph.
        public var nodeLabels: [Swift.String]?
        /// The number of distinct node properties in the graph.
        public var nodeProperties: [[Swift.String: Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of node structures.
        public var nodeStructures: [NeptunedataClientTypes.NodeStructure]?
        /// The number of distinct edge labels in the graph.
        public var numEdgeLabels: Swift.Int?
        /// The number of distinct edge properties in the graph.
        public var numEdgeProperties: Swift.Int?
        /// The number of edges in the graph.
        public var numEdges: Swift.Int?
        /// The number of distinct node labels in the graph.
        public var numNodeLabels: Swift.Int?
        /// A list of the distinct node properties in the graph, along with the count of nodes where each property is used.
        public var numNodeProperties: Swift.Int?
        /// The number of nodes in the graph.
        public var numNodes: Swift.Int?
        /// The total number of usages of all edge properties.
        public var totalEdgePropertyValues: Swift.Int?
        /// The total number of usages of all node properties.
        public var totalNodePropertyValues: Swift.Int?

        public init(
            edgeLabels: [Swift.String]? = nil,
            edgeProperties: [[Swift.String: Swift.Int]]? = nil,
            edgeStructures: [NeptunedataClientTypes.EdgeStructure]? = nil,
            nodeLabels: [Swift.String]? = nil,
            nodeProperties: [[Swift.String: Swift.Int]]? = nil,
            nodeStructures: [NeptunedataClientTypes.NodeStructure]? = nil,
            numEdgeLabels: Swift.Int? = nil,
            numEdgeProperties: Swift.Int? = nil,
            numEdges: Swift.Int? = nil,
            numNodeLabels: Swift.Int? = nil,
            numNodeProperties: Swift.Int? = nil,
            numNodes: Swift.Int? = nil,
            totalEdgePropertyValues: Swift.Int? = nil,
            totalNodePropertyValues: Swift.Int? = nil
        )
        {
            self.edgeLabels = edgeLabels
            self.edgeProperties = edgeProperties
            self.edgeStructures = edgeStructures
            self.nodeLabels = nodeLabels
            self.nodeProperties = nodeProperties
            self.nodeStructures = nodeStructures
            self.numEdgeLabels = numEdgeLabels
            self.numEdgeProperties = numEdgeProperties
            self.numEdges = numEdges
            self.numNodeLabels = numNodeLabels
            self.numNodeProperties = numNodeProperties
            self.numNodes = numNodes
            self.totalEdgePropertyValues = totalEdgePropertyValues
            self.totalNodePropertyValues = totalNodePropertyValues
        }
    }
}

extension NeptunedataClientTypes {

    /// Payload for the property graph summary response.
    public struct PropertygraphSummaryValueMap: Swift.Sendable {
        /// The graph summary.
        public var graphSummary: NeptunedataClientTypes.PropertygraphSummary?
        /// The timestamp, in ISO 8601 format, of the time at which Neptune last computed statistics.
        public var lastStatisticsComputationTime: Foundation.Date?
        /// The version of this graph summary response.
        public var version: Swift.String?

        public init(
            graphSummary: NeptunedataClientTypes.PropertygraphSummary? = nil,
            lastStatisticsComputationTime: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.graphSummary = graphSummary
            self.lastStatisticsComputationTime = lastStatisticsComputationTime
            self.version = version
        }
    }
}

public struct GetPropertygraphSummaryOutput: Swift.Sendable {
    /// Payload containing the property graph summary response.
    public var payload: NeptunedataClientTypes.PropertygraphSummaryValueMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.PropertygraphSummaryValueMap? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.statusCode = statusCode
    }
}

public struct GetRDFGraphSummaryInput: Swift.Sendable {
    /// Mode can take one of two values: BASIC (the default), and DETAILED.
    public var mode: NeptunedataClientTypes.GraphSummaryType?

    public init(
        mode: NeptunedataClientTypes.GraphSummaryType? = nil
    )
    {
        self.mode = mode
    }
}

extension NeptunedataClientTypes {

    /// A subject structure.
    public struct SubjectStructure: Swift.Sendable {
        /// Number of occurrences of this specific structure.
        public var count: Swift.Int?
        /// A list of predicates present in this specific structure.
        public var predicates: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            predicates: [Swift.String]? = nil
        )
        {
            self.count = count
            self.predicates = predicates
        }
    }
}

extension NeptunedataClientTypes {

    /// The RDF graph summary API returns a read-only list of classes and predicate keys, along with counts of quads, subjects, and predicates.
    public struct RDFGraphSummary: Swift.Sendable {
        /// A list of the classes in the graph.
        public var classes: [Swift.String]?
        /// The number of classes in the graph.
        public var numClasses: Swift.Int?
        /// The number of distinct predicates in the graph.
        public var numDistinctPredicates: Swift.Int?
        /// The number of distinct subjects in the graph.
        public var numDistinctSubjects: Swift.Int?
        /// The number of quads in the graph.
        public var numQuads: Swift.Int?
        /// "A list of predicates in the graph, along with the predicate counts.
        public var predicates: [[Swift.String: Swift.Int]]?
        /// This field is only present when the request mode is DETAILED. It contains a list of subject structures.
        public var subjectStructures: [NeptunedataClientTypes.SubjectStructure]?

        public init(
            classes: [Swift.String]? = nil,
            numClasses: Swift.Int? = nil,
            numDistinctPredicates: Swift.Int? = nil,
            numDistinctSubjects: Swift.Int? = nil,
            numQuads: Swift.Int? = nil,
            predicates: [[Swift.String: Swift.Int]]? = nil,
            subjectStructures: [NeptunedataClientTypes.SubjectStructure]? = nil
        )
        {
            self.classes = classes
            self.numClasses = numClasses
            self.numDistinctPredicates = numDistinctPredicates
            self.numDistinctSubjects = numDistinctSubjects
            self.numQuads = numQuads
            self.predicates = predicates
            self.subjectStructures = subjectStructures
        }
    }
}

extension NeptunedataClientTypes {

    /// Payload for an RDF graph summary response.
    public struct RDFGraphSummaryValueMap: Swift.Sendable {
        /// The graph summary of an RDF graph. See [Graph summary response for an RDF graph](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-graph-summary.html#neptune-graph-summary-rdf-response).
        public var graphSummary: NeptunedataClientTypes.RDFGraphSummary?
        /// The timestamp, in ISO 8601 format, of the time at which Neptune last computed statistics.
        public var lastStatisticsComputationTime: Foundation.Date?
        /// The version of this graph summary response.
        public var version: Swift.String?

        public init(
            graphSummary: NeptunedataClientTypes.RDFGraphSummary? = nil,
            lastStatisticsComputationTime: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.graphSummary = graphSummary
            self.lastStatisticsComputationTime = lastStatisticsComputationTime
            self.version = version
        }
    }
}

public struct GetRDFGraphSummaryOutput: Swift.Sendable {
    /// Payload for an RDF graph summary response
    public var payload: NeptunedataClientTypes.RDFGraphSummaryValueMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    public var statusCode: Swift.Int?

    public init(
        payload: NeptunedataClientTypes.RDFGraphSummaryValueMap? = nil,
        statusCode: Swift.Int? = nil
    )
    {
        self.payload = payload
        self.statusCode = statusCode
    }
}

public struct GetSparqlStatisticsOutput: Swift.Sendable {
    /// Statistics for RDF data.
    /// This member is required.
    public var payload: NeptunedataClientTypes.Statistics?
    /// The HTTP return code of the request. If the request succeeded, the code is 200. See [Common error codes for DFE statistics request](https://docs.aws.amazon.com/neptune/latest/userguide/neptune-dfe-statistics.html#neptune-dfe-statistics-errors) for a list of common errors. When invoking this operation in a Neptune cluster that has IAM authentication enabled, the IAM user or role making the request must have a policy attached that allows the [neptune-db:GetStatisticsStatus](https://docs.aws.amazon.com/neptune/latest/userguide/iam-dp-actions.html#getstatisticsstatus) IAM action in that cluster.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.Statistics? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

public struct GetSparqlStreamInput: Swift.Sendable {
    /// The commit number of the starting record to read from the change-log stream. This parameter is required when iteratorType isAT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER, and ignored when iteratorType is TRIM_HORIZON or LATEST.
    public var commitNum: Swift.Int?
    /// If set to TRUE, Neptune compresses the response using gzip encoding.
    public var encoding: NeptunedataClientTypes.Encoding?
    /// Can be one of:
    ///
    /// * AT_SEQUENCE_NUMBER – Indicates that reading should start from the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * AFTER_SEQUENCE_NUMBER – Indicates that reading should start right after the event sequence number specified jointly by the commitNum and opNum parameters.
    ///
    /// * TRIM_HORIZON – Indicates that reading should start at the last untrimmed record in the system, which is the oldest unexpired (not yet deleted) record in the change-log stream.
    ///
    /// * LATEST – Indicates that reading should start at the most recent record in the system, which is the latest unexpired (not yet deleted) record in the change-log stream.
    public var iteratorType: NeptunedataClientTypes.IteratorType?
    /// Specifies the maximum number of records to return. There is also a size limit of 10 MB on the response that can't be modified and that takes precedence over the number of records specified in the limit parameter. The response does include a threshold-breaching record if the 10 MB limit was reached. The range for limit is 1 to 100,000, with a default of 10.
    public var limit: Swift.Int?
    /// The operation sequence number within the specified commit to start reading from in the change-log stream data. The default is 1.
    public var opNum: Swift.Int?

    public init(
        commitNum: Swift.Int? = nil,
        encoding: NeptunedataClientTypes.Encoding? = nil,
        iteratorType: NeptunedataClientTypes.IteratorType? = nil,
        limit: Swift.Int? = nil,
        opNum: Swift.Int? = nil
    )
    {
        self.commitNum = commitNum
        self.encoding = encoding
        self.iteratorType = iteratorType
        self.limit = limit
        self.opNum = opNum
    }
}

extension NeptunedataClientTypes {

    /// Neptune logs are converted to SPARQL quads in the graph using the Resource Description Framework (RDF) [N-QUADS](https://www.w3.org/TR/n-quads/) language defined in the W3C RDF 1.1 N-Quads specification
    public struct SparqlData: Swift.Sendable {
        /// Holds an [N-QUADS](https://www.w3.org/TR/n-quads/) statement expressing the changed quad.
        /// This member is required.
        public var stmt: Swift.String?

        public init(
            stmt: Swift.String? = nil
        )
        {
            self.stmt = stmt
        }
    }
}

extension NeptunedataClientTypes {

    /// A serialized SPARQL stream record capturing a change-log entry for the RDF graph.
    public struct SparqlRecord: Swift.Sendable {
        /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
        /// This member is required.
        public var commitTimestampInMillis: Swift.Int?
        /// The serialized SPARQL change record. The serialization formats of each record are described in more detail in [Serialization Formats in Neptune Streams](https://docs.aws.amazon.com/neptune/latest/userguide/streams-change-formats.html).
        /// This member is required.
        public var data: NeptunedataClientTypes.SparqlData?
        /// The sequence identifier of the stream change record.
        /// This member is required.
        public var eventId: [Swift.String: Swift.String]?
        /// Only present if this operation is the last one in its transaction. If present, it is set to true. It is useful for ensuring that an entire transaction is consumed.
        public var isLastOp: Swift.Bool?
        /// The operation that created the change.
        /// This member is required.
        public var op: Swift.String?

        public init(
            commitTimestampInMillis: Swift.Int? = nil,
            data: NeptunedataClientTypes.SparqlData? = nil,
            eventId: [Swift.String: Swift.String]? = nil,
            isLastOp: Swift.Bool? = nil,
            op: Swift.String? = nil
        )
        {
            self.commitTimestampInMillis = commitTimestampInMillis
            self.data = data
            self.eventId = eventId
            self.isLastOp = isLastOp
            self.op = op
        }
    }
}

public struct GetSparqlStreamOutput: Swift.Sendable {
    /// Serialization format for the change records being returned. Currently, the only supported value is NQUADS.
    /// This member is required.
    public var format: Swift.String?
    /// Sequence identifier of the last change in the stream response. An event ID is composed of two fields: a commitNum, which identifies a transaction that changed the graph, and an opNum, which identifies a specific operation within that transaction:
    /// This member is required.
    public var lastEventId: [Swift.String: Swift.String]?
    /// The time at which the commit for the transaction was requested, in milliseconds from the Unix epoch.
    /// This member is required.
    public var lastTrxTimestampInMillis: Swift.Int?
    /// An array of serialized change-log stream records included in the response.
    /// This member is required.
    public var records: [NeptunedataClientTypes.SparqlRecord]?
    /// The total number of records in the response.
    /// This member is required.
    public var totalRecords: Swift.Int?

    public init(
        format: Swift.String? = nil,
        lastEventId: [Swift.String: Swift.String]? = nil,
        lastTrxTimestampInMillis: Swift.Int? = nil,
        records: [NeptunedataClientTypes.SparqlRecord]? = nil,
        totalRecords: Swift.Int? = nil
    )
    {
        self.format = format
        self.lastEventId = lastEventId
        self.lastTrxTimestampInMillis = lastTrxTimestampInMillis
        self.records = records
        self.totalRecords = totalRecords
    }
}

public struct ListGremlinQueriesInput: Swift.Sendable {
    /// If set to TRUE, the list returned includes waiting queries. The default is FALSE;
    public var includeWaiting: Swift.Bool?

    public init(
        includeWaiting: Swift.Bool? = nil
    )
    {
        self.includeWaiting = includeWaiting
    }
}

extension NeptunedataClientTypes {

    /// Captures the status of a Gremlin query (see the [Gremlin query status API](https://docs.aws.amazon.com/neptune/latest/userguide/gremlin-api-status.html) page).
    public struct GremlinQueryStatus: Swift.Sendable {
        /// The query statistics of the Gremlin query.
        public var queryEvalStats: NeptunedataClientTypes.QueryEvalStats?
        /// The ID of the Gremlin query.
        public var queryId: Swift.String?
        /// The query string of the Gremlin query.
        public var queryString: Swift.String?

        public init(
            queryEvalStats: NeptunedataClientTypes.QueryEvalStats? = nil,
            queryId: Swift.String? = nil,
            queryString: Swift.String? = nil
        )
        {
            self.queryEvalStats = queryEvalStats
            self.queryId = queryId
            self.queryString = queryString
        }
    }
}

public struct ListGremlinQueriesOutput: Swift.Sendable {
    /// The number of queries that have been accepted but not yet completed, including queries in the queue.
    public var acceptedQueryCount: Swift.Int?
    /// A list of the current queries.
    public var queries: [NeptunedataClientTypes.GremlinQueryStatus]?
    /// The number of Gremlin queries currently running.
    public var runningQueryCount: Swift.Int?

    public init(
        acceptedQueryCount: Swift.Int? = nil,
        queries: [NeptunedataClientTypes.GremlinQueryStatus]? = nil,
        runningQueryCount: Swift.Int? = nil
    )
    {
        self.acceptedQueryCount = acceptedQueryCount
        self.queries = queries
        self.runningQueryCount = runningQueryCount
    }
}

public struct ListLoaderJobsInput: Swift.Sendable {
    /// An optional parameter that can be used to exclude the load IDs of queued load requests when requesting a list of load IDs by setting the parameter to FALSE. The default value is TRUE.
    public var includeQueuedLoads: Swift.Bool?
    /// The number of load IDs to list. Must be a positive integer greater than zero and not more than 100 (which is the default).
    public var limit: Swift.Int?

    public init(
        includeQueuedLoads: Swift.Bool? = nil,
        limit: Swift.Int? = nil
    )
    {
        self.includeQueuedLoads = includeQueuedLoads
        self.limit = limit
    }
}

extension NeptunedataClientTypes {

    /// Contains a list of load IDs.
    public struct LoaderIdResult: Swift.Sendable {
        /// A list of load IDs.
        public var loadIds: [Swift.String]?

        public init(
            loadIds: [Swift.String]? = nil
        )
        {
            self.loadIds = loadIds
        }
    }
}

public struct ListLoaderJobsOutput: Swift.Sendable {
    /// The requested list of job IDs.
    /// This member is required.
    public var payload: NeptunedataClientTypes.LoaderIdResult?
    /// Returns the status of the job list request.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.LoaderIdResult? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

public struct ListMLDataProcessingJobsInput: Swift.Sendable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10).
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct ListMLDataProcessingJobsOutput: Swift.Sendable {
    /// A page listing data processing job IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

public struct ListMLEndpointsInput: Swift.Sendable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10.
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct ListMLEndpointsOutput: Swift.Sendable {
    /// A page from the list of inference endpoint IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

public struct ListMLModelTrainingJobsInput: Swift.Sendable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10).
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct ListMLModelTrainingJobsOutput: Swift.Sendable {
    /// A page of the list of model training job IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

public struct ListMLModelTransformJobsInput: Swift.Sendable {
    /// The maximum number of items to return (from 1 to 1024; the default is 10).
    public var maxItems: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.neptuneIamRoleArn = neptuneIamRoleArn
    }
}

public struct ListMLModelTransformJobsOutput: Swift.Sendable {
    /// A page from the list of model transform IDs.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

public struct ListOpenCypherQueriesInput: Swift.Sendable {
    /// When set to TRUE and other parameters are not present, causes status information to be returned for waiting queries as well as for running queries.
    public var includeWaiting: Swift.Bool?

    public init(
        includeWaiting: Swift.Bool? = nil
    )
    {
        self.includeWaiting = includeWaiting
    }
}

public struct ListOpenCypherQueriesOutput: Swift.Sendable {
    /// The number of queries that have been accepted but not yet completed, including queries in the queue.
    public var acceptedQueryCount: Swift.Int?
    /// A list of current openCypher queries.
    public var queries: [NeptunedataClientTypes.GremlinQueryStatus]?
    /// The number of currently running openCypher queries.
    public var runningQueryCount: Swift.Int?

    public init(
        acceptedQueryCount: Swift.Int? = nil,
        queries: [NeptunedataClientTypes.GremlinQueryStatus]? = nil,
        runningQueryCount: Swift.Int? = nil
    )
    {
        self.acceptedQueryCount = acceptedQueryCount
        self.queries = queries
        self.runningQueryCount = runningQueryCount
    }
}

extension NeptunedataClientTypes {

    public enum StatisticsAutoGenerationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disableAutocompute
        case enableAutocompute
        case refresh
        case sdkUnknown(Swift.String)

        public static var allCases: [StatisticsAutoGenerationMode] {
            return [
                .disableAutocompute,
                .enableAutocompute,
                .refresh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disableAutocompute: return "disableAutoCompute"
            case .enableAutocompute: return "enableAutoCompute"
            case .refresh: return "refresh"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ManagePropertygraphStatisticsInput: Swift.Sendable {
    /// The statistics generation mode. One of: DISABLE_AUTOCOMPUTE, ENABLE_AUTOCOMPUTE, or REFRESH, the last of which manually triggers DFE statistics generation.
    public var mode: NeptunedataClientTypes.StatisticsAutoGenerationMode?

    public init(
        mode: NeptunedataClientTypes.StatisticsAutoGenerationMode? = nil
    )
    {
        self.mode = mode
    }
}

extension NeptunedataClientTypes {

    /// Statistics for REFRESH mode.
    public struct RefreshStatisticsIdMap: Swift.Sendable {
        /// The ID of the statistics generation run that is currently occurring.
        public var statisticsId: Swift.String?

        public init(
            statisticsId: Swift.String? = nil
        )
        {
            self.statisticsId = statisticsId
        }
    }
}

public struct ManagePropertygraphStatisticsOutput: Swift.Sendable {
    /// This is only returned for refresh mode.
    public var payload: NeptunedataClientTypes.RefreshStatisticsIdMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.RefreshStatisticsIdMap? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

public struct ManageSparqlStatisticsInput: Swift.Sendable {
    /// The statistics generation mode. One of: DISABLE_AUTOCOMPUTE, ENABLE_AUTOCOMPUTE, or REFRESH, the last of which manually triggers DFE statistics generation.
    public var mode: NeptunedataClientTypes.StatisticsAutoGenerationMode?

    public init(
        mode: NeptunedataClientTypes.StatisticsAutoGenerationMode? = nil
    )
    {
        self.mode = mode
    }
}

public struct ManageSparqlStatisticsOutput: Swift.Sendable {
    /// This is only returned for refresh mode.
    public var payload: NeptunedataClientTypes.RefreshStatisticsIdMap?
    /// The HTTP return code of the request. If the request succeeded, the code is 200.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: NeptunedataClientTypes.RefreshStatisticsIdMap? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

/// Raised when there is a problem accessing Amazon S3.
public struct S3Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP status code returned with the exception.
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// A detailed message describing the problem.
        /// This member is required.
        public internal(set) var detailedMessage: Swift.String? = nil
        /// The ID of the request in question.
        /// This member is required.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        detailedMessage: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.detailedMessage = detailedMessage
        self.properties.requestId = requestId
    }
}

extension NeptunedataClientTypes {

    public enum Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case nquads
        case ntriples
        case opencypher
        case rdfxml
        case turtle
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .nquads,
                .ntriples,
                .opencypher,
                .rdfxml,
                .turtle
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .nquads: return "nquads"
            case .ntriples: return "ntriples"
            case .opencypher: return "opencypher"
            case .rdfxml: return "rdfxml"
            case .turtle: return "turtle"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptunedataClientTypes {

    public enum Mode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case new
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .auto,
                .new,
                .resume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .new: return "NEW"
            case .resume: return "RESUME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptunedataClientTypes {

    public enum Parallelism: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case oversubscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [Parallelism] {
            return [
                .high,
                .low,
                .medium,
                .oversubscribe
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .oversubscribe: return "OVERSUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptunedataClientTypes {

    public enum S3BucketRegion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afSouth1
        case apEast1
        case apNortheast1
        case apNortheast2
        case apSoutheast1
        case apSoutheast2
        case apSouth1
        case caCentral1
        case cnNorthwest1
        case cnNorth1
        case euCentral1
        case euNorth1
        case euWest1
        case euWest2
        case euWest3
        case meSouth1
        case saEast1
        case usEast1
        case usEast2
        case usGovEast1
        case usGovWest1
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [S3BucketRegion] {
            return [
                .afSouth1,
                .apEast1,
                .apNortheast1,
                .apNortheast2,
                .apSoutheast1,
                .apSoutheast2,
                .apSouth1,
                .caCentral1,
                .cnNorthwest1,
                .cnNorth1,
                .euCentral1,
                .euNorth1,
                .euWest1,
                .euWest2,
                .euWest3,
                .meSouth1,
                .saEast1,
                .usEast1,
                .usEast2,
                .usGovEast1,
                .usGovWest1,
                .usWest1,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .apSouth1: return "ap-south-1"
            case .caCentral1: return "ca-central-1"
            case .cnNorthwest1: return "cn-northwest-1"
            case .cnNorth1: return "cn-north-1"
            case .euCentral1: return "eu-central-1"
            case .euNorth1: return "eu-north-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .euWest3: return "eu-west-3"
            case .meSouth1: return "me-south-1"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usGovEast1: return "us-gov-east-1"
            case .usGovWest1: return "us-gov-west-1"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartLoaderJobInput: Swift.Sendable {
    /// This is an optional parameter that can make a queued load request contingent on the successful completion of one or more previous jobs in the queue. Neptune can queue up as many as 64 load requests at a time, if their queueRequest parameters are set to "TRUE". The dependencies parameter lets you make execution of such a queued request dependent on the successful completion of one or more specified previous requests in the queue. For example, if load Job-A and Job-B are independent of each other, but load Job-C needs Job-A and Job-B to be finished before it begins, proceed as follows:
    ///
    /// * Submit load-job-A and load-job-B one after another in any order, and save their load-ids.
    ///
    /// * Submit load-job-C with the load-ids of the two jobs in its dependencies field:
    ///
    ///
    /// Because of the dependencies parameter, the bulk loader will not start Job-C until Job-A and Job-B have completed successfully. If either one of them fails, Job-C will not be executed, and its status will be set to LOAD_FAILED_BECAUSE_DEPENDENCY_NOT_SATISFIED. You can set up multiple levels of dependency in this way, so that the failure of one job will cause all requests that are directly or indirectly dependent on it to be cancelled.
    public var dependencies: [Swift.String]?
    /// failOnError – A flag to toggle a complete stop on an error. Allowed values: "TRUE", "FALSE". Default value: "TRUE". When this parameter is set to "FALSE", the loader tries to load all the data in the location specified, skipping any entries with errors. When this parameter is set to "TRUE", the loader stops as soon as it encounters an error. Data loaded up to that point persists.
    public var failOnError: Swift.Bool?
    /// The format of the data. For more information about data formats for the Neptune Loader command, see [Load Data Formats](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format.html). Allowed values
    ///
    /// * csv for the [Gremlin CSV data format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html).
    ///
    /// * opencypher for the [openCypher CSV data format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    ///
    /// * ntriples for the [N-Triples RDF data format](https://www.w3.org/TR/n-triples/).
    ///
    /// * nquads for the [N-Quads RDF data format](https://www.w3.org/TR/n-quads/).
    ///
    /// * rdfxml for the [RDF\XML RDF data format](https://www.w3.org/TR/rdf-syntax-grammar/).
    ///
    /// * turtle for the [Turtle RDF data format](https://www.w3.org/TR/turtle/).
    /// This member is required.
    public var format: NeptunedataClientTypes.Format?
    /// The Amazon Resource Name (ARN) for an IAM role to be assumed by the Neptune DB instance for access to the S3 bucket. The IAM role ARN provided here should be attached to the DB cluster (see [Adding the IAM Role to an Amazon Neptune Cluster](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-IAM-add-role-cluster.html).
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The load job mode. Allowed values: RESUME, NEW, AUTO. Default value: AUTO.
    ///
    /// * RESUME – In RESUME mode, the loader looks for a previous load from this source, and if it finds one, resumes that load job. If no previous load job is found, the loader stops. The loader avoids reloading files that were successfully loaded in a previous job. It only tries to process failed files. If you dropped previously loaded data from your Neptune cluster, that data is not reloaded in this mode. If a previous load job loaded all files from the same source successfully, nothing is reloaded, and the loader returns success.
    ///
    /// * NEW – In NEW mode, the creates a new load request regardless of any previous loads. You can use this mode to reload all the data from a source after dropping previously loaded data from your Neptune cluster, or to load new data available at the same source.
    ///
    /// * AUTO – In AUTO mode, the loader looks for a previous load job from the same source, and if it finds one, resumes that job, just as in RESUME mode. If the loader doesn't find a previous load job from the same source, it loads all data from the source, just as in NEW mode.
    public var mode: NeptunedataClientTypes.Mode?
    /// The optional parallelism parameter can be set to reduce the number of threads used by the bulk load process. Allowed values:
    ///
    /// * LOW – The number of threads used is the number of available vCPUs divided by 8.
    ///
    /// * MEDIUM – The number of threads used is the number of available vCPUs divided by 2.
    ///
    /// * HIGH – The number of threads used is the same as the number of available vCPUs.
    ///
    /// * OVERSUBSCRIBE – The number of threads used is the number of available vCPUs multiplied by 2. If this value is used, the bulk loader takes up all available resources. This does not mean, however, that the OVERSUBSCRIBE setting results in 100% CPU utilization. Because the load operation is I/O bound, the highest CPU utilization to expect is in the 60% to 70% range.
    ///
    ///
    /// Default value: HIGH The parallelism setting can sometimes result in a deadlock between threads when loading openCypher data. When this happens, Neptune returns the LOAD_DATA_DEADLOCK error. You can generally fix the issue by setting parallelism to a lower setting and retrying the load command.
    public var parallelism: NeptunedataClientTypes.Parallelism?
    /// parserConfiguration – An optional object with additional parser configuration values. Each of the child parameters is also optional:
    ///
    /// * namedGraphUri – The default graph for all RDF formats when no graph is specified (for non-quads formats and NQUAD entries with no graph). The default is https://aws.amazon.com/neptune/vocab/v01/DefaultNamedGraph.
    ///
    /// * baseUri – The base URI for RDF/XML and Turtle formats. The default is https://aws.amazon.com/neptune/default.
    ///
    /// * allowEmptyStrings – Gremlin users need to be able to pass empty string values("") as node and edge properties when loading CSV data. If allowEmptyStrings is set to false (the default), such empty strings are treated as nulls and are not loaded. If allowEmptyStrings is set to true, the loader treats empty strings as valid property values and loads them accordingly.
    public var parserConfiguration: [Swift.String: Swift.String]?
    /// This is an optional flag parameter that indicates whether the load request can be queued up or not. You don't have to wait for one load job to complete before issuing the next one, because Neptune can queue up as many as 64 jobs at a time, provided that their queueRequest parameters are all set to "TRUE". The queue order of the jobs will be first-in-first-out (FIFO). If the queueRequest parameter is omitted or set to "FALSE", the load request will fail if another load job is already running. Allowed values: "TRUE", "FALSE". Default value: "FALSE".
    public var queueRequest: Swift.Bool?
    /// The Amazon region of the S3 bucket. This must match the Amazon Region of the DB cluster.
    /// This member is required.
    public var s3BucketRegion: NeptunedataClientTypes.S3BucketRegion?
    /// The source parameter accepts an S3 URI that identifies a single file, multiple files, a folder, or multiple folders. Neptune loads every data file in any folder that is specified. The URI can be in any of the following formats.
    ///
    /// * s3://(bucket_name)/(object-key-name)
    ///
    /// * https://s3.amazonaws.com/(bucket_name)/(object-key-name)
    ///
    /// * https://s3.us-east-1.amazonaws.com/(bucket_name)/(object-key-name)
    ///
    ///
    /// The object-key-name element of the URI is equivalent to the [prefix](https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestParameters) parameter in an S3 [ListObjects](https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html) API call. It identifies all the objects in the specified S3 bucket whose names begin with that prefix. That can be a single file or folder, or multiple files and/or folders. The specified folder or folders can contain multiple vertex files and multiple edge files.
    /// This member is required.
    public var source: Swift.String?
    /// updateSingleCardinalityProperties is an optional parameter that controls how the bulk loader treats a new value for single-cardinality vertex or edge properties. This is not supported for loading openCypher data. Allowed values: "TRUE", "FALSE". Default value: "FALSE". By default, or when updateSingleCardinalityProperties is explicitly set to "FALSE", the loader treats a new value as an error, because it violates single cardinality. When updateSingleCardinalityProperties is set to "TRUE", on the other hand, the bulk loader replaces the existing value with the new one. If multiple edge or single-cardinality vertex property values are provided in the source file(s) being loaded, the final value at the end of the bulk load could be any one of those new values. The loader only guarantees that the existing value has been replaced by one of the new ones.
    public var updateSingleCardinalityProperties: Swift.Bool?
    /// This parameter is required only when loading openCypher data that contains relationship IDs. It must be included and set to True when openCypher relationship IDs are explicitly provided in the load data (recommended). When userProvidedEdgeIds is absent or set to True, an :ID column must be present in every relationship file in the load. When userProvidedEdgeIds is present and set to False, relationship files in the load must not contain an :ID column. Instead, the Neptune loader automatically generates an ID for each relationship. It's useful to provide relationship IDs explicitly so that the loader can resume loading after error in the CSV data have been fixed, without having to reload any relationships that have already been loaded. If relationship IDs have not been explicitly assigned, the loader cannot resume a failed load if any relationship file has had to be corrected, and must instead reload all the relationships.
    public var userProvidedEdgeIds: Swift.Bool?

    public init(
        dependencies: [Swift.String]? = nil,
        failOnError: Swift.Bool? = nil,
        format: NeptunedataClientTypes.Format? = nil,
        iamRoleArn: Swift.String? = nil,
        mode: NeptunedataClientTypes.Mode? = nil,
        parallelism: NeptunedataClientTypes.Parallelism? = nil,
        parserConfiguration: [Swift.String: Swift.String]? = nil,
        queueRequest: Swift.Bool? = nil,
        s3BucketRegion: NeptunedataClientTypes.S3BucketRegion? = nil,
        source: Swift.String? = nil,
        updateSingleCardinalityProperties: Swift.Bool? = nil,
        userProvidedEdgeIds: Swift.Bool? = nil
    )
    {
        self.dependencies = dependencies
        self.failOnError = failOnError
        self.format = format
        self.iamRoleArn = iamRoleArn
        self.mode = mode
        self.parallelism = parallelism
        self.parserConfiguration = parserConfiguration
        self.queueRequest = queueRequest
        self.s3BucketRegion = s3BucketRegion
        self.source = source
        self.updateSingleCardinalityProperties = updateSingleCardinalityProperties
        self.userProvidedEdgeIds = userProvidedEdgeIds
    }
}

public struct StartLoaderJobOutput: Swift.Sendable {
    /// Contains a loadId name-value pair that provides an identifier for the load operation.
    /// This member is required.
    public var payload: [Swift.String: Swift.String]?
    /// The HTTP return code indicating the status of the load job.
    /// This member is required.
    public var status: Swift.String?

    public init(
        payload: [Swift.String: Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.payload = payload
        self.status = status
    }
}

public struct StartMLDataProcessingJobInput: Swift.Sendable {
    /// A data specification file that describes how to load the exported graph data for training. The file is automatically generated by the Neptune export toolkit. The default is training-data-configuration.json.
    public var configFileName: Swift.String?
    /// A unique identifier for the new job. The default is an autogenerated UUID.
    public var id: Swift.String?
    /// The URI of the Amazon S3 location where you want SageMaker to download the data needed to run the data processing job.
    /// This member is required.
    public var inputDataS3Location: Swift.String?
    /// One of the two model types that Neptune ML currently supports: heterogeneous graph models (heterogeneous), and knowledge graph (kge). The default is none. If not specified, Neptune ML chooses the model type automatically based on the data.
    public var modelType: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that SageMaker can assume to perform tasks on your behalf. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?
    /// The job ID of a completed data processing job run on an earlier version of the data.
    public var previousDataProcessingJobId: Swift.String?
    /// The URI of the Amazon S3 location where you want SageMaker to save the results of a data processing job.
    /// This member is required.
    public var processedDataS3Location: Swift.String?
    /// The type of ML instance used during data processing. Its memory should be large enough to hold the processed dataset. The default is the smallest ml.r5 type whose memory is ten times larger than the size of the exported graph data on disk.
    public var processingInstanceType: Swift.String?
    /// The disk volume size of the processing instance. Both input data and processed data are stored on disk, so the volume size must be large enough to hold both data sets. The default is 0. If not specified or 0, Neptune ML chooses the volume size automatically based on the data size.
    public var processingInstanceVolumeSizeInGB: Swift.Int?
    /// Timeout in seconds for the data processing job. The default is 86,400 (1 day).
    public var processingTimeOutInSeconds: Swift.Int?
    /// The Amazon Key Management Service (Amazon KMS) key that SageMaker uses to encrypt the output of the processing job. The default is none.
    public var s3OutputEncryptionKMSKey: Swift.String?
    /// The ARN of an IAM role for SageMaker execution. This must be listed in your DB cluster parameter group or an error will occur.
    public var sagemakerIamRoleArn: Swift.String?
    /// The VPC security group IDs. The default is None.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the subnets in the Neptune VPC. The default is None.
    public var subnets: [Swift.String]?
    /// The Amazon Key Management Service (Amazon KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        configFileName: Swift.String? = nil,
        id: Swift.String? = nil,
        inputDataS3Location: Swift.String? = nil,
        modelType: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        previousDataProcessingJobId: Swift.String? = nil,
        processedDataS3Location: Swift.String? = nil,
        processingInstanceType: Swift.String? = nil,
        processingInstanceVolumeSizeInGB: Swift.Int? = nil,
        processingTimeOutInSeconds: Swift.Int? = nil,
        s3OutputEncryptionKMSKey: Swift.String? = nil,
        sagemakerIamRoleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.configFileName = configFileName
        self.id = id
        self.inputDataS3Location = inputDataS3Location
        self.modelType = modelType
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.previousDataProcessingJobId = previousDataProcessingJobId
        self.processedDataS3Location = processedDataS3Location
        self.processingInstanceType = processingInstanceType
        self.processingInstanceVolumeSizeInGB = processingInstanceVolumeSizeInGB
        self.processingTimeOutInSeconds = processingTimeOutInSeconds
        self.s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKey
        self.sagemakerIamRoleArn = sagemakerIamRoleArn
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

public struct StartMLDataProcessingJobOutput: Swift.Sendable {
    /// The ARN of the data processing job.
    public var arn: Swift.String?
    /// The time it took to create the new processing job, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new data processing job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

extension NeptunedataClientTypes {

    /// Contains custom model training parameters. See [Custom models in Neptune ML](https://docs.aws.amazon.com/neptune/latest/userguide/machine-learning-custom-models.html).
    public struct CustomModelTrainingParameters: Swift.Sendable {
        /// The path to the Amazon S3 location where the Python module implementing your model is located. This must point to a valid existing Amazon S3 location that contains, at a minimum, a training script, a transform script, and a model-hpo-configuration.json file.
        /// This member is required.
        public var sourceS3DirectoryPath: Swift.String?
        /// The name of the entry point in your module of a script that performs model training and takes hyperparameters as command-line arguments, including fixed hyperparameters. The default is training.py.
        public var trainingEntryPointScript: Swift.String?
        /// The name of the entry point in your module of a script that should be run after the best model from the hyperparameter search has been identified, to compute the model artifacts necessary for model deployment. It should be able to run with no command-line arguments.The default is transform.py.
        public var transformEntryPointScript: Swift.String?

        public init(
            sourceS3DirectoryPath: Swift.String? = nil,
            trainingEntryPointScript: Swift.String? = nil,
            transformEntryPointScript: Swift.String? = nil
        )
        {
            self.sourceS3DirectoryPath = sourceS3DirectoryPath
            self.trainingEntryPointScript = trainingEntryPointScript
            self.transformEntryPointScript = transformEntryPointScript
        }
    }
}

public struct StartMLModelTrainingJobInput: Swift.Sendable {
    /// The type of ML instance used in preparing and managing training of ML models. This is a CPU instance chosen based on memory requirements for processing the training data and model.
    public var baseProcessingInstanceType: Swift.String?
    /// The configuration for custom model training. This is a JSON object.
    public var customModelTrainingParameters: NeptunedataClientTypes.CustomModelTrainingParameters?
    /// The job ID of the completed data-processing job that has created the data that the training will work with.
    /// This member is required.
    public var dataProcessingJobId: Swift.String?
    /// Optimizes the cost of training machine-learning models by using Amazon Elastic Compute Cloud spot instances. The default is False.
    public var enableManagedSpotTraining: Swift.Bool?
    /// A unique identifier for the new job. The default is An autogenerated UUID.
    public var id: Swift.String?
    /// Maximum total number of training jobs to start for the hyperparameter tuning job. The default is 2. Neptune ML automatically tunes the hyperparameters of the machine learning model. To obtain a model that performs well, use at least 10 jobs (in other words, set maxHPONumberOfTrainingJobs to 10). In general, the more tuning runs, the better the results.
    public var maxHPONumberOfTrainingJobs: Swift.Int?
    /// Maximum number of parallel training jobs to start for the hyperparameter tuning job. The default is 2. The number of parallel jobs you can run is limited by the available resources on your training instance.
    public var maxHPOParallelTrainingJobs: Swift.Int?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?
    /// The job ID of a completed model-training job that you want to update incrementally based on updated data.
    public var previousModelTrainingJobId: Swift.String?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt the output of the processing job. The default is none.
    public var s3OutputEncryptionKMSKey: Swift.String?
    /// The ARN of an IAM role for SageMaker execution.This must be listed in your DB cluster parameter group or an error will occur.
    public var sagemakerIamRoleArn: Swift.String?
    /// The VPC security group IDs. The default is None.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the subnets in the Neptune VPC. The default is None.
    public var subnets: [Swift.String]?
    /// The location in Amazon S3 where the model artifacts are to be stored.
    /// This member is required.
    public var trainModelS3Location: Swift.String?
    /// The type of ML instance used for model training. All Neptune ML models support CPU, GPU, and multiGPU training. The default is ml.p3.2xlarge. Choosing the right instance type for training depends on the task type, graph size, and your budget.
    public var trainingInstanceType: Swift.String?
    /// The disk volume size of the training instance. Both input data and the output model are stored on disk, so the volume size must be large enough to hold both data sets. The default is 0. If not specified or 0, Neptune ML selects a disk volume size based on the recommendation generated in the data processing step.
    public var trainingInstanceVolumeSizeInGB: Swift.Int?
    /// Timeout in seconds for the training job. The default is 86,400 (1 day).
    public var trainingTimeOutInSeconds: Swift.Int?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        baseProcessingInstanceType: Swift.String? = nil,
        customModelTrainingParameters: NeptunedataClientTypes.CustomModelTrainingParameters? = nil,
        dataProcessingJobId: Swift.String? = nil,
        enableManagedSpotTraining: Swift.Bool? = nil,
        id: Swift.String? = nil,
        maxHPONumberOfTrainingJobs: Swift.Int? = nil,
        maxHPOParallelTrainingJobs: Swift.Int? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        previousModelTrainingJobId: Swift.String? = nil,
        s3OutputEncryptionKMSKey: Swift.String? = nil,
        sagemakerIamRoleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        trainModelS3Location: Swift.String? = nil,
        trainingInstanceType: Swift.String? = nil,
        trainingInstanceVolumeSizeInGB: Swift.Int? = nil,
        trainingTimeOutInSeconds: Swift.Int? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.baseProcessingInstanceType = baseProcessingInstanceType
        self.customModelTrainingParameters = customModelTrainingParameters
        self.dataProcessingJobId = dataProcessingJobId
        self.enableManagedSpotTraining = enableManagedSpotTraining
        self.id = id
        self.maxHPONumberOfTrainingJobs = maxHPONumberOfTrainingJobs
        self.maxHPOParallelTrainingJobs = maxHPOParallelTrainingJobs
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.previousModelTrainingJobId = previousModelTrainingJobId
        self.s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKey
        self.sagemakerIamRoleArn = sagemakerIamRoleArn
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.trainModelS3Location = trainModelS3Location
        self.trainingInstanceType = trainingInstanceType
        self.trainingInstanceVolumeSizeInGB = trainingInstanceVolumeSizeInGB
        self.trainingTimeOutInSeconds = trainingTimeOutInSeconds
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

public struct StartMLModelTrainingJobOutput: Swift.Sendable {
    /// The ARN of the new model training job.
    public var arn: Swift.String?
    /// The model training job creation time, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new model training job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

extension NeptunedataClientTypes {

    /// Contains custom model transform parameters. See [Use a trained model to generate new model artifacts](https://docs.aws.amazon.com/neptune/latest/userguide/machine-learning-model-transform.html).
    public struct CustomModelTransformParameters: Swift.Sendable {
        /// The path to the Amazon S3 location where the Python module implementing your model is located. This must point to a valid existing Amazon S3 location that contains, at a minimum, a training script, a transform script, and a model-hpo-configuration.json file.
        /// This member is required.
        public var sourceS3DirectoryPath: Swift.String?
        /// The name of the entry point in your module of a script that should be run after the best model from the hyperparameter search has been identified, to compute the model artifacts necessary for model deployment. It should be able to run with no command-line arguments. The default is transform.py.
        public var transformEntryPointScript: Swift.String?

        public init(
            sourceS3DirectoryPath: Swift.String? = nil,
            transformEntryPointScript: Swift.String? = nil
        )
        {
            self.sourceS3DirectoryPath = sourceS3DirectoryPath
            self.transformEntryPointScript = transformEntryPointScript
        }
    }
}

public struct StartMLModelTransformJobInput: Swift.Sendable {
    /// The type of ML instance used in preparing and managing training of ML models. This is an ML compute instance chosen based on memory requirements for processing the training data and model.
    public var baseProcessingInstanceType: Swift.String?
    /// The disk volume size of the training instance in gigabytes. The default is 0. Both input data and the output model are stored on disk, so the volume size must be large enough to hold both data sets. If not specified or 0, Neptune ML selects a disk volume size based on the recommendation generated in the data processing step.
    public var baseProcessingInstanceVolumeSizeInGB: Swift.Int?
    /// Configuration information for a model transform using a custom model. The customModelTransformParameters object contains the following fields, which must have values compatible with the saved model parameters from the training job:
    public var customModelTransformParameters: NeptunedataClientTypes.CustomModelTransformParameters?
    /// The job ID of a completed data-processing job. You must include either dataProcessingJobId and a mlModelTrainingJobId, or a trainingJobName.
    public var dataProcessingJobId: Swift.String?
    /// A unique identifier for the new job. The default is an autogenerated UUID.
    public var id: Swift.String?
    /// The job ID of a completed model-training job. You must include either dataProcessingJobId and a mlModelTrainingJobId, or a trainingJobName.
    public var mlModelTrainingJobId: Swift.String?
    /// The location in Amazon S3 where the model artifacts are to be stored.
    /// This member is required.
    public var modelTransformOutputS3Location: Swift.String?
    /// The ARN of an IAM role that provides Neptune access to SageMaker and Amazon S3 resources. This must be listed in your DB cluster parameter group or an error will occur.
    public var neptuneIamRoleArn: Swift.String?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt the output of the processing job. The default is none.
    public var s3OutputEncryptionKMSKey: Swift.String?
    /// The ARN of an IAM role for SageMaker execution. This must be listed in your DB cluster parameter group or an error will occur.
    public var sagemakerIamRoleArn: Swift.String?
    /// The VPC security group IDs. The default is None.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the subnets in the Neptune VPC. The default is None.
    public var subnets: [Swift.String]?
    /// The name of a completed SageMaker training job. You must include either dataProcessingJobId and a mlModelTrainingJobId, or a trainingJobName.
    public var trainingJobName: Swift.String?
    /// The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to the ML compute instances that run the training job. The default is None.
    public var volumeEncryptionKMSKey: Swift.String?

    public init(
        baseProcessingInstanceType: Swift.String? = nil,
        baseProcessingInstanceVolumeSizeInGB: Swift.Int? = nil,
        customModelTransformParameters: NeptunedataClientTypes.CustomModelTransformParameters? = nil,
        dataProcessingJobId: Swift.String? = nil,
        id: Swift.String? = nil,
        mlModelTrainingJobId: Swift.String? = nil,
        modelTransformOutputS3Location: Swift.String? = nil,
        neptuneIamRoleArn: Swift.String? = nil,
        s3OutputEncryptionKMSKey: Swift.String? = nil,
        sagemakerIamRoleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        trainingJobName: Swift.String? = nil,
        volumeEncryptionKMSKey: Swift.String? = nil
    )
    {
        self.baseProcessingInstanceType = baseProcessingInstanceType
        self.baseProcessingInstanceVolumeSizeInGB = baseProcessingInstanceVolumeSizeInGB
        self.customModelTransformParameters = customModelTransformParameters
        self.dataProcessingJobId = dataProcessingJobId
        self.id = id
        self.mlModelTrainingJobId = mlModelTrainingJobId
        self.modelTransformOutputS3Location = modelTransformOutputS3Location
        self.neptuneIamRoleArn = neptuneIamRoleArn
        self.s3OutputEncryptionKMSKey = s3OutputEncryptionKMSKey
        self.sagemakerIamRoleArn = sagemakerIamRoleArn
        self.securityGroupIds = securityGroupIds
        self.subnets = subnets
        self.trainingJobName = trainingJobName
        self.volumeEncryptionKMSKey = volumeEncryptionKMSKey
    }
}

public struct StartMLModelTransformJobOutput: Swift.Sendable {
    /// The ARN of the model transform job.
    public var arn: Swift.String?
    /// The creation time of the model transform job, in milliseconds.
    public var creationTimeInMillis: Swift.Int?
    /// The unique ID of the new model transform job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimeInMillis: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimeInMillis = creationTimeInMillis
        self.id = id
    }
}

extension CancelGremlinQueryInput {

    static func urlPathProvider(_ value: CancelGremlinQueryInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/gremlin/status/\(queryId.urlPercentEncoding())"
    }
}

extension CancelLoaderJobInput {

    static func urlPathProvider(_ value: CancelLoaderJobInput) -> Swift.String? {
        guard let loadId = value.loadId else {
            return nil
        }
        return "/loader/\(loadId.urlPercentEncoding())"
    }
}

extension CancelMLDataProcessingJobInput {

    static func urlPathProvider(_ value: CancelMLDataProcessingJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/dataprocessing/\(id.urlPercentEncoding())"
    }
}

extension CancelMLDataProcessingJobInput {

    static func queryItemProvider(_ value: CancelMLDataProcessingJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        if let clean = value.clean {
            let cleanQueryItem = Smithy.URIQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
            items.append(cleanQueryItem)
        }
        return items
    }
}

extension CancelMLModelTrainingJobInput {

    static func urlPathProvider(_ value: CancelMLModelTrainingJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/modeltraining/\(id.urlPercentEncoding())"
    }
}

extension CancelMLModelTrainingJobInput {

    static func queryItemProvider(_ value: CancelMLModelTrainingJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        if let clean = value.clean {
            let cleanQueryItem = Smithy.URIQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
            items.append(cleanQueryItem)
        }
        return items
    }
}

extension CancelMLModelTransformJobInput {

    static func urlPathProvider(_ value: CancelMLModelTransformJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/modeltransform/\(id.urlPercentEncoding())"
    }
}

extension CancelMLModelTransformJobInput {

    static func queryItemProvider(_ value: CancelMLModelTransformJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        if let clean = value.clean {
            let cleanQueryItem = Smithy.URIQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
            items.append(cleanQueryItem)
        }
        return items
    }
}

extension CancelOpenCypherQueryInput {

    static func urlPathProvider(_ value: CancelOpenCypherQueryInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/opencypher/status/\(queryId.urlPercentEncoding())"
    }
}

extension CancelOpenCypherQueryInput {

    static func queryItemProvider(_ value: CancelOpenCypherQueryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let silent = value.silent {
            let silentQueryItem = Smithy.URIQueryItem(name: "silent".urlPercentEncoding(), value: Swift.String(silent).urlPercentEncoding())
            items.append(silentQueryItem)
        }
        return items
    }
}

extension CreateMLEndpointInput {

    static func urlPathProvider(_ value: CreateMLEndpointInput) -> Swift.String? {
        return "/ml/endpoints"
    }
}

extension DeleteMLEndpointInput {

    static func urlPathProvider(_ value: DeleteMLEndpointInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/endpoints/\(id.urlPercentEncoding())"
    }
}

extension DeleteMLEndpointInput {

    static func queryItemProvider(_ value: DeleteMLEndpointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        if let clean = value.clean {
            let cleanQueryItem = Smithy.URIQueryItem(name: "clean".urlPercentEncoding(), value: Swift.String(clean).urlPercentEncoding())
            items.append(cleanQueryItem)
        }
        return items
    }
}

extension DeletePropertygraphStatisticsInput {

    static func urlPathProvider(_ value: DeletePropertygraphStatisticsInput) -> Swift.String? {
        return "/propertygraph/statistics"
    }
}

extension DeleteSparqlStatisticsInput {

    static func urlPathProvider(_ value: DeleteSparqlStatisticsInput) -> Swift.String? {
        return "/sparql/statistics"
    }
}

extension ExecuteFastResetInput {

    static func urlPathProvider(_ value: ExecuteFastResetInput) -> Swift.String? {
        return "/system"
    }
}

extension ExecuteGremlinExplainQueryInput {

    static func urlPathProvider(_ value: ExecuteGremlinExplainQueryInput) -> Swift.String? {
        return "/gremlin/explain"
    }
}

extension ExecuteGremlinProfileQueryInput {

    static func urlPathProvider(_ value: ExecuteGremlinProfileQueryInput) -> Swift.String? {
        return "/gremlin/profile"
    }
}

extension ExecuteGremlinQueryInput {

    static func urlPathProvider(_ value: ExecuteGremlinQueryInput) -> Swift.String? {
        return "/gremlin"
    }
}

extension ExecuteGremlinQueryInput {

    static func headerProvider(_ value: ExecuteGremlinQueryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let serializer = value.serializer {
            items.add(SmithyHTTPAPI.Header(name: "accept", value: Swift.String(serializer)))
        }
        return items
    }
}

extension ExecuteOpenCypherExplainQueryInput {

    static func urlPathProvider(_ value: ExecuteOpenCypherExplainQueryInput) -> Swift.String? {
        return "/opencypher/explain"
    }
}

extension ExecuteOpenCypherQueryInput {

    static func urlPathProvider(_ value: ExecuteOpenCypherQueryInput) -> Swift.String? {
        return "/opencypher"
    }
}

extension GetEngineStatusInput {

    static func urlPathProvider(_ value: GetEngineStatusInput) -> Swift.String? {
        return "/status"
    }
}

extension GetGremlinQueryStatusInput {

    static func urlPathProvider(_ value: GetGremlinQueryStatusInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/gremlin/status/\(queryId.urlPercentEncoding())"
    }
}

extension GetLoaderJobStatusInput {

    static func urlPathProvider(_ value: GetLoaderJobStatusInput) -> Swift.String? {
        guard let loadId = value.loadId else {
            return nil
        }
        return "/loader/\(loadId.urlPercentEncoding())"
    }
}

extension GetLoaderJobStatusInput {

    static func queryItemProvider(_ value: GetLoaderJobStatusInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let errorsPerPage = value.errorsPerPage {
            let errorsPerPageQueryItem = Smithy.URIQueryItem(name: "errorsPerPage".urlPercentEncoding(), value: Swift.String(errorsPerPage).urlPercentEncoding())
            items.append(errorsPerPageQueryItem)
        }
        if let details = value.details {
            let detailsQueryItem = Smithy.URIQueryItem(name: "details".urlPercentEncoding(), value: Swift.String(details).urlPercentEncoding())
            items.append(detailsQueryItem)
        }
        if let page = value.page {
            let pageQueryItem = Smithy.URIQueryItem(name: "page".urlPercentEncoding(), value: Swift.String(page).urlPercentEncoding())
            items.append(pageQueryItem)
        }
        if let errors = value.errors {
            let errorsQueryItem = Smithy.URIQueryItem(name: "errors".urlPercentEncoding(), value: Swift.String(errors).urlPercentEncoding())
            items.append(errorsQueryItem)
        }
        return items
    }
}

extension GetMLDataProcessingJobInput {

    static func urlPathProvider(_ value: GetMLDataProcessingJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/dataprocessing/\(id.urlPercentEncoding())"
    }
}

extension GetMLDataProcessingJobInput {

    static func queryItemProvider(_ value: GetMLDataProcessingJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension GetMLEndpointInput {

    static func urlPathProvider(_ value: GetMLEndpointInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/endpoints/\(id.urlPercentEncoding())"
    }
}

extension GetMLEndpointInput {

    static func queryItemProvider(_ value: GetMLEndpointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension GetMLModelTrainingJobInput {

    static func urlPathProvider(_ value: GetMLModelTrainingJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/modeltraining/\(id.urlPercentEncoding())"
    }
}

extension GetMLModelTrainingJobInput {

    static func queryItemProvider(_ value: GetMLModelTrainingJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension GetMLModelTransformJobInput {

    static func urlPathProvider(_ value: GetMLModelTransformJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/ml/modeltransform/\(id.urlPercentEncoding())"
    }
}

extension GetMLModelTransformJobInput {

    static func queryItemProvider(_ value: GetMLModelTransformJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension GetOpenCypherQueryStatusInput {

    static func urlPathProvider(_ value: GetOpenCypherQueryStatusInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/opencypher/status/\(queryId.urlPercentEncoding())"
    }
}

extension GetPropertygraphStatisticsInput {

    static func urlPathProvider(_ value: GetPropertygraphStatisticsInput) -> Swift.String? {
        return "/propertygraph/statistics"
    }
}

extension GetPropertygraphStreamInput {

    static func urlPathProvider(_ value: GetPropertygraphStreamInput) -> Swift.String? {
        return "/propertygraph/stream"
    }
}

extension GetPropertygraphStreamInput {

    static func headerProvider(_ value: GetPropertygraphStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let encoding = value.encoding {
            items.add(SmithyHTTPAPI.Header(name: "Accept-Encoding", value: Swift.String(encoding.rawValue)))
        }
        return items
    }
}

extension GetPropertygraphStreamInput {

    static func queryItemProvider(_ value: GetPropertygraphStreamInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let commitNum = value.commitNum {
            let commitNumQueryItem = Smithy.URIQueryItem(name: "commitNum".urlPercentEncoding(), value: Swift.String(commitNum).urlPercentEncoding())
            items.append(commitNumQueryItem)
        }
        if let opNum = value.opNum {
            let opNumQueryItem = Smithy.URIQueryItem(name: "opNum".urlPercentEncoding(), value: Swift.String(opNum).urlPercentEncoding())
            items.append(opNumQueryItem)
        }
        if let iteratorType = value.iteratorType {
            let iteratorTypeQueryItem = Smithy.URIQueryItem(name: "iteratorType".urlPercentEncoding(), value: Swift.String(iteratorType.rawValue).urlPercentEncoding())
            items.append(iteratorTypeQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension GetPropertygraphSummaryInput {

    static func urlPathProvider(_ value: GetPropertygraphSummaryInput) -> Swift.String? {
        return "/propertygraph/statistics/summary"
    }
}

extension GetPropertygraphSummaryInput {

    static func queryItemProvider(_ value: GetPropertygraphSummaryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let mode = value.mode {
            let modeQueryItem = Smithy.URIQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        return items
    }
}

extension GetRDFGraphSummaryInput {

    static func urlPathProvider(_ value: GetRDFGraphSummaryInput) -> Swift.String? {
        return "/rdf/statistics/summary"
    }
}

extension GetRDFGraphSummaryInput {

    static func queryItemProvider(_ value: GetRDFGraphSummaryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let mode = value.mode {
            let modeQueryItem = Smithy.URIQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        return items
    }
}

extension GetSparqlStatisticsInput {

    static func urlPathProvider(_ value: GetSparqlStatisticsInput) -> Swift.String? {
        return "/sparql/statistics"
    }
}

extension GetSparqlStreamInput {

    static func urlPathProvider(_ value: GetSparqlStreamInput) -> Swift.String? {
        return "/sparql/stream"
    }
}

extension GetSparqlStreamInput {

    static func headerProvider(_ value: GetSparqlStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let encoding = value.encoding {
            items.add(SmithyHTTPAPI.Header(name: "Accept-Encoding", value: Swift.String(encoding.rawValue)))
        }
        return items
    }
}

extension GetSparqlStreamInput {

    static func queryItemProvider(_ value: GetSparqlStreamInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let commitNum = value.commitNum {
            let commitNumQueryItem = Smithy.URIQueryItem(name: "commitNum".urlPercentEncoding(), value: Swift.String(commitNum).urlPercentEncoding())
            items.append(commitNumQueryItem)
        }
        if let opNum = value.opNum {
            let opNumQueryItem = Smithy.URIQueryItem(name: "opNum".urlPercentEncoding(), value: Swift.String(opNum).urlPercentEncoding())
            items.append(opNumQueryItem)
        }
        if let iteratorType = value.iteratorType {
            let iteratorTypeQueryItem = Smithy.URIQueryItem(name: "iteratorType".urlPercentEncoding(), value: Swift.String(iteratorType.rawValue).urlPercentEncoding())
            items.append(iteratorTypeQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListGremlinQueriesInput {

    static func urlPathProvider(_ value: ListGremlinQueriesInput) -> Swift.String? {
        return "/gremlin/status"
    }
}

extension ListGremlinQueriesInput {

    static func queryItemProvider(_ value: ListGremlinQueriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeWaiting = value.includeWaiting {
            let includeWaitingQueryItem = Smithy.URIQueryItem(name: "includeWaiting".urlPercentEncoding(), value: Swift.String(includeWaiting).urlPercentEncoding())
            items.append(includeWaitingQueryItem)
        }
        return items
    }
}

extension ListLoaderJobsInput {

    static func urlPathProvider(_ value: ListLoaderJobsInput) -> Swift.String? {
        return "/loader"
    }
}

extension ListLoaderJobsInput {

    static func queryItemProvider(_ value: ListLoaderJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeQueuedLoads = value.includeQueuedLoads {
            let includeQueuedLoadsQueryItem = Smithy.URIQueryItem(name: "includeQueuedLoads".urlPercentEncoding(), value: Swift.String(includeQueuedLoads).urlPercentEncoding())
            items.append(includeQueuedLoadsQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListMLDataProcessingJobsInput {

    static func urlPathProvider(_ value: ListMLDataProcessingJobsInput) -> Swift.String? {
        return "/ml/dataprocessing"
    }
}

extension ListMLDataProcessingJobsInput {

    static func queryItemProvider(_ value: ListMLDataProcessingJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension ListMLEndpointsInput {

    static func urlPathProvider(_ value: ListMLEndpointsInput) -> Swift.String? {
        return "/ml/endpoints"
    }
}

extension ListMLEndpointsInput {

    static func queryItemProvider(_ value: ListMLEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension ListMLModelTrainingJobsInput {

    static func urlPathProvider(_ value: ListMLModelTrainingJobsInput) -> Swift.String? {
        return "/ml/modeltraining"
    }
}

extension ListMLModelTrainingJobsInput {

    static func queryItemProvider(_ value: ListMLModelTrainingJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension ListMLModelTransformJobsInput {

    static func urlPathProvider(_ value: ListMLModelTransformJobsInput) -> Swift.String? {
        return "/ml/modeltransform"
    }
}

extension ListMLModelTransformJobsInput {

    static func queryItemProvider(_ value: ListMLModelTransformJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let neptuneIamRoleArn = value.neptuneIamRoleArn {
            let neptuneIamRoleArnQueryItem = Smithy.URIQueryItem(name: "neptuneIamRoleArn".urlPercentEncoding(), value: Swift.String(neptuneIamRoleArn).urlPercentEncoding())
            items.append(neptuneIamRoleArnQueryItem)
        }
        return items
    }
}

extension ListOpenCypherQueriesInput {

    static func urlPathProvider(_ value: ListOpenCypherQueriesInput) -> Swift.String? {
        return "/opencypher/status"
    }
}

extension ListOpenCypherQueriesInput {

    static func queryItemProvider(_ value: ListOpenCypherQueriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeWaiting = value.includeWaiting {
            let includeWaitingQueryItem = Smithy.URIQueryItem(name: "includeWaiting".urlPercentEncoding(), value: Swift.String(includeWaiting).urlPercentEncoding())
            items.append(includeWaitingQueryItem)
        }
        return items
    }
}

extension ManagePropertygraphStatisticsInput {

    static func urlPathProvider(_ value: ManagePropertygraphStatisticsInput) -> Swift.String? {
        return "/propertygraph/statistics"
    }
}

extension ManageSparqlStatisticsInput {

    static func urlPathProvider(_ value: ManageSparqlStatisticsInput) -> Swift.String? {
        return "/sparql/statistics"
    }
}

extension StartLoaderJobInput {

    static func urlPathProvider(_ value: StartLoaderJobInput) -> Swift.String? {
        return "/loader"
    }
}

extension StartMLDataProcessingJobInput {

    static func urlPathProvider(_ value: StartMLDataProcessingJobInput) -> Swift.String? {
        return "/ml/dataprocessing"
    }
}

extension StartMLModelTrainingJobInput {

    static func urlPathProvider(_ value: StartMLModelTrainingJobInput) -> Swift.String? {
        return "/ml/modeltraining"
    }
}

extension StartMLModelTransformJobInput {

    static func urlPathProvider(_ value: StartMLModelTransformJobInput) -> Swift.String? {
        return "/ml/modeltransform"
    }
}

extension CreateMLEndpointInput {

    static func write(value: CreateMLEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["instanceCount"].write(value.instanceCount)
        try writer["instanceType"].write(value.instanceType)
        try writer["mlModelTrainingJobId"].write(value.mlModelTrainingJobId)
        try writer["mlModelTransformJobId"].write(value.mlModelTransformJobId)
        try writer["modelName"].write(value.modelName)
        try writer["neptuneIamRoleArn"].write(value.neptuneIamRoleArn)
        try writer["update"].write(value.update)
        try writer["volumeEncryptionKMSKey"].write(value.volumeEncryptionKMSKey)
    }
}

extension ExecuteFastResetInput {

    static func write(value: ExecuteFastResetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["token"].write(value.token)
    }
}

extension ExecuteGremlinExplainQueryInput {

    static func write(value: ExecuteGremlinExplainQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["gremlin"].write(value.gremlinQuery)
    }
}

extension ExecuteGremlinProfileQueryInput {

    static func write(value: ExecuteGremlinProfileQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["profile.chop"].write(value.chop)
        try writer["gremlin"].write(value.gremlinQuery)
        try writer["profile.indexOps"].write(value.indexOps)
        try writer["profile.results"].write(value.results)
        try writer["profile.serializer"].write(value.serializer)
    }
}

extension ExecuteGremlinQueryInput {

    static func write(value: ExecuteGremlinQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["gremlin"].write(value.gremlinQuery)
    }
}

extension ExecuteOpenCypherExplainQueryInput {

    static func write(value: ExecuteOpenCypherExplainQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["explain"].write(value.explainMode)
        try writer["query"].write(value.openCypherQuery)
        try writer["parameters"].write(value.parameters)
    }
}

extension ExecuteOpenCypherQueryInput {

    static func write(value: ExecuteOpenCypherQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["query"].write(value.openCypherQuery)
        try writer["parameters"].write(value.parameters)
    }
}

extension ManagePropertygraphStatisticsInput {

    static func write(value: ManagePropertygraphStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].write(value.mode)
    }
}

extension ManageSparqlStatisticsInput {

    static func write(value: ManageSparqlStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].write(value.mode)
    }
}

extension StartLoaderJobInput {

    static func write(value: StartLoaderJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dependencies"].writeList(value.dependencies, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["failOnError"].write(value.failOnError)
        try writer["format"].write(value.format)
        try writer["iamRoleArn"].write(value.iamRoleArn)
        try writer["mode"].write(value.mode)
        try writer["parallelism"].write(value.parallelism)
        try writer["parserConfiguration"].writeMap(value.parserConfiguration, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["queueRequest"].write(value.queueRequest)
        try writer["region"].write(value.s3BucketRegion)
        try writer["source"].write(value.source)
        try writer["updateSingleCardinalityProperties"].write(value.updateSingleCardinalityProperties)
        try writer["userProvidedEdgeIds"].write(value.userProvidedEdgeIds)
    }
}

extension StartMLDataProcessingJobInput {

    static func write(value: StartMLDataProcessingJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configFileName"].write(value.configFileName)
        try writer["id"].write(value.id)
        try writer["inputDataS3Location"].write(value.inputDataS3Location)
        try writer["modelType"].write(value.modelType)
        try writer["neptuneIamRoleArn"].write(value.neptuneIamRoleArn)
        try writer["previousDataProcessingJobId"].write(value.previousDataProcessingJobId)
        try writer["processedDataS3Location"].write(value.processedDataS3Location)
        try writer["processingInstanceType"].write(value.processingInstanceType)
        try writer["processingInstanceVolumeSizeInGB"].write(value.processingInstanceVolumeSizeInGB)
        try writer["processingTimeOutInSeconds"].write(value.processingTimeOutInSeconds)
        try writer["s3OutputEncryptionKMSKey"].write(value.s3OutputEncryptionKMSKey)
        try writer["sagemakerIamRoleArn"].write(value.sagemakerIamRoleArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["volumeEncryptionKMSKey"].write(value.volumeEncryptionKMSKey)
    }
}

extension StartMLModelTrainingJobInput {

    static func write(value: StartMLModelTrainingJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseProcessingInstanceType"].write(value.baseProcessingInstanceType)
        try writer["customModelTrainingParameters"].write(value.customModelTrainingParameters, with: NeptunedataClientTypes.CustomModelTrainingParameters.write(value:to:))
        try writer["dataProcessingJobId"].write(value.dataProcessingJobId)
        try writer["enableManagedSpotTraining"].write(value.enableManagedSpotTraining)
        try writer["id"].write(value.id)
        try writer["maxHPONumberOfTrainingJobs"].write(value.maxHPONumberOfTrainingJobs)
        try writer["maxHPOParallelTrainingJobs"].write(value.maxHPOParallelTrainingJobs)
        try writer["neptuneIamRoleArn"].write(value.neptuneIamRoleArn)
        try writer["previousModelTrainingJobId"].write(value.previousModelTrainingJobId)
        try writer["s3OutputEncryptionKMSKey"].write(value.s3OutputEncryptionKMSKey)
        try writer["sagemakerIamRoleArn"].write(value.sagemakerIamRoleArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trainModelS3Location"].write(value.trainModelS3Location)
        try writer["trainingInstanceType"].write(value.trainingInstanceType)
        try writer["trainingInstanceVolumeSizeInGB"].write(value.trainingInstanceVolumeSizeInGB)
        try writer["trainingTimeOutInSeconds"].write(value.trainingTimeOutInSeconds)
        try writer["volumeEncryptionKMSKey"].write(value.volumeEncryptionKMSKey)
    }
}

extension StartMLModelTransformJobInput {

    static func write(value: StartMLModelTransformJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseProcessingInstanceType"].write(value.baseProcessingInstanceType)
        try writer["baseProcessingInstanceVolumeSizeInGB"].write(value.baseProcessingInstanceVolumeSizeInGB)
        try writer["customModelTransformParameters"].write(value.customModelTransformParameters, with: NeptunedataClientTypes.CustomModelTransformParameters.write(value:to:))
        try writer["dataProcessingJobId"].write(value.dataProcessingJobId)
        try writer["id"].write(value.id)
        try writer["mlModelTrainingJobId"].write(value.mlModelTrainingJobId)
        try writer["modelTransformOutputS3Location"].write(value.modelTransformOutputS3Location)
        try writer["neptuneIamRoleArn"].write(value.neptuneIamRoleArn)
        try writer["s3OutputEncryptionKMSKey"].write(value.s3OutputEncryptionKMSKey)
        try writer["sagemakerIamRoleArn"].write(value.sagemakerIamRoleArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trainingJobName"].write(value.trainingJobName)
        try writer["volumeEncryptionKMSKey"].write(value.volumeEncryptionKMSKey)
    }
}

extension CancelGremlinQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelGremlinQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelGremlinQueryOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CancelLoaderJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelLoaderJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelLoaderJobOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CancelMLDataProcessingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMLDataProcessingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMLDataProcessingJobOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CancelMLModelTrainingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMLModelTrainingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMLModelTrainingJobOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CancelMLModelTransformJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMLModelTransformJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMLModelTransformJobOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CancelOpenCypherQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelOpenCypherQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelOpenCypherQueryOutput()
        value.payload = try reader["payload"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateMLEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMLEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMLEndpointOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTimeInMillis = try reader["creationTimeInMillis"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DeleteMLEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMLEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMLEndpointOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeletePropertygraphStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePropertygraphStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePropertygraphStatisticsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.DeleteStatisticsValueMap.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteSparqlStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSparqlStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSparqlStatisticsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.DeleteStatisticsValueMap.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension ExecuteFastResetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteFastResetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteFastResetOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.FastResetToken.read(from:))
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension ExecuteGremlinExplainQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteGremlinExplainQueryOutput {
        var value = ExecuteGremlinExplainQueryOutput()
        switch httpResponse.body {
        case .data(let data):
            value.output = data
        case .stream(let stream):
            value.output = try stream.readToEnd()
        case .noStream:
            value.output = nil
        }
        return value
    }
}

extension ExecuteGremlinProfileQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteGremlinProfileQueryOutput {
        var value = ExecuteGremlinProfileQueryOutput()
        switch httpResponse.body {
        case .data(let data):
            value.output = data
        case .stream(let stream):
            value.output = try stream.readToEnd()
        case .noStream:
            value.output = nil
        }
        return value
    }
}

extension ExecuteGremlinQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteGremlinQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteGremlinQueryOutput()
        value.meta = try reader["meta"].readIfPresent()
        value.requestId = try reader["requestId"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: NeptunedataClientTypes.GremlinQueryStatusAttributes.read(from:))
        return value
    }
}

extension ExecuteOpenCypherExplainQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteOpenCypherExplainQueryOutput {
        var value = ExecuteOpenCypherExplainQueryOutput()
        switch httpResponse.body {
        case .data(let data):
            value.results = data
        case .stream(let stream):
            value.results = try stream.readToEnd()
        case .noStream:
            value.results = nil
        }
        return value
    }
}

extension ExecuteOpenCypherQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteOpenCypherQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteOpenCypherQueryOutput()
        value.results = try reader["results"].readIfPresent() ?? [:]
        return value
    }
}

extension GetEngineStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEngineStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEngineStatusOutput()
        value.dbEngineVersion = try reader["dbEngineVersion"].readIfPresent()
        value.dfeQueryEngine = try reader["dfeQueryEngine"].readIfPresent()
        value.features = try reader["features"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.gremlin = try reader["gremlin"].readIfPresent(with: NeptunedataClientTypes.QueryLanguageVersion.read(from:))
        value.labMode = try reader["labMode"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.opencypher = try reader["opencypher"].readIfPresent(with: NeptunedataClientTypes.QueryLanguageVersion.read(from:))
        value.role = try reader["role"].readIfPresent()
        value.rollingBackTrxCount = try reader["rollingBackTrxCount"].readIfPresent()
        value.rollingBackTrxEarliestStartTime = try reader["rollingBackTrxEarliestStartTime"].readIfPresent()
        value.settings = try reader["settings"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sparql = try reader["sparql"].readIfPresent(with: NeptunedataClientTypes.QueryLanguageVersion.read(from:))
        value.startTime = try reader["startTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetGremlinQueryStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGremlinQueryStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGremlinQueryStatusOutput()
        value.queryEvalStats = try reader["queryEvalStats"].readIfPresent(with: NeptunedataClientTypes.QueryEvalStats.read(from:))
        value.queryId = try reader["queryId"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        return value
    }
}

extension GetLoaderJobStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoaderJobStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoaderJobStatusOutput()
        value.payload = try reader["payload"].readIfPresent() ?? [:]
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension GetMLDataProcessingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLDataProcessingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLDataProcessingJobOutput()
        value.id = try reader["id"].readIfPresent()
        value.processingJob = try reader["processingJob"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetMLEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLEndpointOutput()
        value.endpoint = try reader["endpoint"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.endpointConfig = try reader["endpointConfig"].readIfPresent(with: NeptunedataClientTypes.MlConfigDefinition.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetMLModelTrainingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLModelTrainingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLModelTrainingJobOutput()
        value.hpoJob = try reader["hpoJob"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.mlModels = try reader["mlModels"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.MlConfigDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelTransformJob = try reader["modelTransformJob"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.processingJob = try reader["processingJob"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetMLModelTransformJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLModelTransformJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLModelTransformJobOutput()
        value.baseProcessingJob = try reader["baseProcessingJob"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.MlConfigDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.remoteModelTransformJob = try reader["remoteModelTransformJob"].readIfPresent(with: NeptunedataClientTypes.MlResourceDefinition.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetOpenCypherQueryStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOpenCypherQueryStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOpenCypherQueryStatusOutput()
        value.queryEvalStats = try reader["queryEvalStats"].readIfPresent(with: NeptunedataClientTypes.QueryEvalStats.read(from:))
        value.queryId = try reader["queryId"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        return value
    }
}

extension GetPropertygraphStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPropertygraphStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPropertygraphStatisticsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.Statistics.read(from:))
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension GetPropertygraphStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPropertygraphStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPropertygraphStreamOutput()
        value.format = try reader["format"].readIfPresent() ?? ""
        value.lastEventId = try reader["lastEventId"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.lastTrxTimestampInMillis = try reader["lastTrxTimestamp"].readIfPresent() ?? 0
        value.records = try reader["records"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.PropertygraphRecord.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.totalRecords = try reader["totalRecords"].readIfPresent() ?? 0
        return value
    }
}

extension GetPropertygraphSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPropertygraphSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPropertygraphSummaryOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.PropertygraphSummaryValueMap.read(from:))
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetRDFGraphSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRDFGraphSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRDFGraphSummaryOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.RDFGraphSummaryValueMap.read(from:))
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetSparqlStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSparqlStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSparqlStatisticsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.Statistics.read(from:))
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension GetSparqlStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSparqlStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSparqlStreamOutput()
        value.format = try reader["format"].readIfPresent() ?? ""
        value.lastEventId = try reader["lastEventId"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.lastTrxTimestampInMillis = try reader["lastTrxTimestamp"].readIfPresent() ?? 0
        value.records = try reader["records"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.SparqlRecord.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.totalRecords = try reader["totalRecords"].readIfPresent() ?? 0
        return value
    }
}

extension ListGremlinQueriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGremlinQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGremlinQueriesOutput()
        value.acceptedQueryCount = try reader["acceptedQueryCount"].readIfPresent()
        value.queries = try reader["queries"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.GremlinQueryStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.runningQueryCount = try reader["runningQueryCount"].readIfPresent()
        return value
    }
}

extension ListLoaderJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLoaderJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLoaderJobsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.LoaderIdResult.read(from:))
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension ListMLDataProcessingJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMLDataProcessingJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMLDataProcessingJobsOutput()
        value.ids = try reader["ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMLEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMLEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMLEndpointsOutput()
        value.ids = try reader["ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMLModelTrainingJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMLModelTrainingJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMLModelTrainingJobsOutput()
        value.ids = try reader["ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMLModelTransformJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMLModelTransformJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMLModelTransformJobsOutput()
        value.ids = try reader["ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOpenCypherQueriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpenCypherQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOpenCypherQueriesOutput()
        value.acceptedQueryCount = try reader["acceptedQueryCount"].readIfPresent()
        value.queries = try reader["queries"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.GremlinQueryStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.runningQueryCount = try reader["runningQueryCount"].readIfPresent()
        return value
    }
}

extension ManagePropertygraphStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ManagePropertygraphStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ManagePropertygraphStatisticsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.RefreshStatisticsIdMap.read(from:))
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension ManageSparqlStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ManageSparqlStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ManageSparqlStatisticsOutput()
        value.payload = try reader["payload"].readIfPresent(with: NeptunedataClientTypes.RefreshStatisticsIdMap.read(from:))
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension StartLoaderJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartLoaderJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartLoaderJobOutput()
        value.payload = try reader["payload"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.status = try reader["status"].readIfPresent() ?? ""
        return value
    }
}

extension StartMLDataProcessingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMLDataProcessingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMLDataProcessingJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTimeInMillis = try reader["creationTimeInMillis"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension StartMLModelTrainingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMLModelTrainingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMLModelTrainingJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTimeInMillis = try reader["creationTimeInMillis"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension StartMLModelTransformJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMLModelTransformJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMLModelTransformJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTimeInMillis = try reader["creationTimeInMillis"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

enum CancelGremlinQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelLoaderJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "BulkLoadIdNotFoundException": return try BulkLoadIdNotFoundException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LoadUrlAccessDeniedException": return try LoadUrlAccessDeniedException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMLDataProcessingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMLModelTrainingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMLModelTransformJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelOpenCypherQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNumericDataException": return try InvalidNumericDataException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMLEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMLEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePropertygraphStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSparqlStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteFastResetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "ServerShutdownException": return try ServerShutdownException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteGremlinExplainQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CancelledByUserException": return try CancelledByUserException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MalformedQueryException": return try MalformedQueryException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "QueryLimitExceededException": return try QueryLimitExceededException.makeError(baseError: baseError)
            case "QueryLimitException": return try QueryLimitException.makeError(baseError: baseError)
            case "QueryTooLargeException": return try QueryTooLargeException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteGremlinProfileQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CancelledByUserException": return try CancelledByUserException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MalformedQueryException": return try MalformedQueryException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "QueryLimitExceededException": return try QueryLimitExceededException.makeError(baseError: baseError)
            case "QueryLimitException": return try QueryLimitException.makeError(baseError: baseError)
            case "QueryTooLargeException": return try QueryTooLargeException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteGremlinQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CancelledByUserException": return try CancelledByUserException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MalformedQueryException": return try MalformedQueryException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "QueryLimitExceededException": return try QueryLimitExceededException.makeError(baseError: baseError)
            case "QueryLimitException": return try QueryLimitException.makeError(baseError: baseError)
            case "QueryTooLargeException": return try QueryTooLargeException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteOpenCypherExplainQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CancelledByUserException": return try CancelledByUserException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNumericDataException": return try InvalidNumericDataException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MalformedQueryException": return try MalformedQueryException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "QueryLimitExceededException": return try QueryLimitExceededException.makeError(baseError: baseError)
            case "QueryLimitException": return try QueryLimitException.makeError(baseError: baseError)
            case "QueryTooLargeException": return try QueryTooLargeException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteOpenCypherQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CancelledByUserException": return try CancelledByUserException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNumericDataException": return try InvalidNumericDataException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MalformedQueryException": return try MalformedQueryException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "QueryLimitExceededException": return try QueryLimitExceededException.makeError(baseError: baseError)
            case "QueryLimitException": return try QueryLimitException.makeError(baseError: baseError)
            case "QueryTooLargeException": return try QueryTooLargeException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEngineStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGremlinQueryStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoaderJobStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "BulkLoadIdNotFoundException": return try BulkLoadIdNotFoundException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LoadUrlAccessDeniedException": return try LoadUrlAccessDeniedException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLDataProcessingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLModelTrainingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLModelTransformJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOpenCypherQueryStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNumericDataException": return try InvalidNumericDataException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPropertygraphStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPropertygraphStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "ExpiredStreamException": return try ExpiredStreamException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "StreamRecordsNotFoundException": return try StreamRecordsNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPropertygraphSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRDFGraphSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSparqlStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSparqlStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "ExpiredStreamException": return try ExpiredStreamException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MemoryLimitExceededException": return try MemoryLimitExceededException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "StreamRecordsNotFoundException": return try StreamRecordsNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGremlinQueriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLoaderJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "BulkLoadIdNotFoundException": return try BulkLoadIdNotFoundException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LoadUrlAccessDeniedException": return try LoadUrlAccessDeniedException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMLDataProcessingJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMLEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMLModelTrainingJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMLModelTransformJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpenCypherQueriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "FailureByQueryException": return try FailureByQueryException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNumericDataException": return try InvalidNumericDataException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "ParsingException": return try ParsingException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "TimeLimitExceededException": return try TimeLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ManagePropertygraphStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ManageSparqlStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "ReadOnlyViolationException": return try ReadOnlyViolationException.makeError(baseError: baseError)
            case "StatisticsNotAvailableException": return try StatisticsNotAvailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartLoaderJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "BulkLoadIdNotFoundException": return try BulkLoadIdNotFoundException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LoadUrlAccessDeniedException": return try LoadUrlAccessDeniedException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "S3Exception": return try S3Exception.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMLDataProcessingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMLModelTrainingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMLModelTransformJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ClientTimeoutException": return try ClientTimeoutException.makeError(baseError: baseError)
            case "ConstraintViolationException": return try ConstraintViolationException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingParameterException": return try MissingParameterException.makeError(baseError: baseError)
            case "MLResourceNotFoundException": return try MLResourceNotFoundException.makeError(baseError: baseError)
            case "PreconditionsFailedException": return try PreconditionsFailedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ParsingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ParsingException {
        let reader = baseError.errorBodyReader
        var value = ParsingException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MissingParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MissingParameterException {
        let reader = baseError.errorBodyReader
        var value = MissingParameterException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TimeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TimeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = TimeLimitExceededException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionsFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionsFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionsFailedException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConstraintViolationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConstraintViolationException {
        let reader = baseError.errorBodyReader
        var value = ConstraintViolationException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClientTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ClientTimeoutException {
        let reader = baseError.errorBodyReader
        var value = ClientTimeoutException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FailureByQueryException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FailureByQueryException {
        let reader = baseError.errorBodyReader
        var value = FailureByQueryException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalArgumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IllegalArgumentException {
        let reader = baseError.errorBodyReader
        var value = IllegalArgumentException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LoadUrlAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LoadUrlAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = LoadUrlAccessDeniedException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BulkLoadIdNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BulkLoadIdNotFoundException {
        let reader = baseError.errorBodyReader
        var value = BulkLoadIdNotFoundException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MLResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MLResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = MLResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNumericDataException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidNumericDataException {
        let reader = baseError.errorBodyReader
        var value = InvalidNumericDataException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReadOnlyViolationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ReadOnlyViolationException {
        let reader = baseError.errorBodyReader
        var value = ReadOnlyViolationException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StatisticsNotAvailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StatisticsNotAvailableException {
        let reader = baseError.errorBodyReader
        var value = StatisticsNotAvailableException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MethodNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MethodNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = MethodNotAllowedException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServerShutdownException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServerShutdownException {
        let reader = baseError.errorBodyReader
        var value = ServerShutdownException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MemoryLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MemoryLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = MemoryLimitExceededException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CancelledByUserException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CancelledByUserException {
        let reader = baseError.errorBodyReader
        var value = CancelledByUserException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MalformedQueryException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MalformedQueryException {
        let reader = baseError.errorBodyReader
        var value = MalformedQueryException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> QueryLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = QueryLimitExceededException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryLimitException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> QueryLimitException {
        let reader = baseError.errorBodyReader
        var value = QueryLimitException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> QueryTooLargeException {
        let reader = baseError.errorBodyReader
        var value = QueryTooLargeException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExpiredStreamException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ExpiredStreamException {
        let reader = baseError.errorBodyReader
        var value = ExpiredStreamException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StreamRecordsNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StreamRecordsNotFoundException {
        let reader = baseError.errorBodyReader
        var value = StreamRecordsNotFoundException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> S3Exception {
        let reader = baseError.errorBodyReader
        var value = S3Exception()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.detailedMessage = try reader["detailedMessage"].readIfPresent() ?? ""
        value.properties.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NeptunedataClientTypes.DeleteStatisticsValueMap {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.DeleteStatisticsValueMap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.DeleteStatisticsValueMap()
        value.active = try reader["active"].readIfPresent()
        value.statisticsId = try reader["statisticsId"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.FastResetToken {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.FastResetToken {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.FastResetToken()
        value.token = try reader["token"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.GremlinQueryStatusAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.GremlinQueryStatusAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.GremlinQueryStatusAttributes()
        value.message = try reader["message"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.attributes = try reader["attributes"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.QueryLanguageVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.QueryLanguageVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.QueryLanguageVersion()
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension NeptunedataClientTypes.QueryEvalStats {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.QueryEvalStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.QueryEvalStats()
        value.waited = try reader["waited"].readIfPresent()
        value.elapsed = try reader["elapsed"].readIfPresent()
        value.cancelled = try reader["cancelled"].readIfPresent()
        value.subqueries = try reader["subqueries"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.MlResourceDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.MlResourceDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.MlResourceDefinition()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.outputLocation = try reader["outputLocation"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.cloudwatchLogUrl = try reader["cloudwatchLogUrl"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.MlConfigDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.MlConfigDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.MlConfigDefinition()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.Statistics {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.Statistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.Statistics()
        value.autoCompute = try reader["autoCompute"].readIfPresent()
        value.active = try reader["active"].readIfPresent()
        value.statisticsId = try reader["statisticsId"].readIfPresent()
        value.date = try reader["date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.note = try reader["note"].readIfPresent()
        value.signatureInfo = try reader["signatureInfo"].readIfPresent(with: NeptunedataClientTypes.StatisticsSummary.read(from:))
        return value
    }
}

extension NeptunedataClientTypes.StatisticsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.StatisticsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.StatisticsSummary()
        value.signatureCount = try reader["signatureCount"].readIfPresent()
        value.instanceCount = try reader["instanceCount"].readIfPresent()
        value.predicateCount = try reader["predicateCount"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.PropertygraphRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.PropertygraphRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.PropertygraphRecord()
        value.commitTimestampInMillis = try reader["commitTimestamp"].readIfPresent() ?? 0
        value.eventId = try reader["eventId"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.data = try reader["data"].readIfPresent(with: NeptunedataClientTypes.PropertygraphData.read(from:))
        value.op = try reader["op"].readIfPresent() ?? ""
        value.isLastOp = try reader["isLastOp"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.PropertygraphData {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.PropertygraphData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.PropertygraphData()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? [:]
        value.from = try reader["from"].readIfPresent()
        value.to = try reader["to"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.PropertygraphSummaryValueMap {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.PropertygraphSummaryValueMap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.PropertygraphSummaryValueMap()
        value.version = try reader["version"].readIfPresent()
        value.lastStatisticsComputationTime = try reader["lastStatisticsComputationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.graphSummary = try reader["graphSummary"].readIfPresent(with: NeptunedataClientTypes.PropertygraphSummary.read(from:))
        return value
    }
}

extension NeptunedataClientTypes.PropertygraphSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.PropertygraphSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.PropertygraphSummary()
        value.numNodes = try reader["numNodes"].readIfPresent()
        value.numEdges = try reader["numEdges"].readIfPresent()
        value.numNodeLabels = try reader["numNodeLabels"].readIfPresent()
        value.numEdgeLabels = try reader["numEdgeLabels"].readIfPresent()
        value.nodeLabels = try reader["nodeLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.edgeLabels = try reader["edgeLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.numNodeProperties = try reader["numNodeProperties"].readIfPresent()
        value.numEdgeProperties = try reader["numEdgeProperties"].readIfPresent()
        value.nodeProperties = try reader["nodeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.edgeProperties = try reader["edgeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.totalNodePropertyValues = try reader["totalNodePropertyValues"].readIfPresent()
        value.totalEdgePropertyValues = try reader["totalEdgePropertyValues"].readIfPresent()
        value.nodeStructures = try reader["nodeStructures"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.NodeStructure.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.edgeStructures = try reader["edgeStructures"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.EdgeStructure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptunedataClientTypes.EdgeStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.EdgeStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.EdgeStructure()
        value.count = try reader["count"].readIfPresent()
        value.edgeProperties = try reader["edgeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptunedataClientTypes.NodeStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.NodeStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.NodeStructure()
        value.count = try reader["count"].readIfPresent()
        value.nodeProperties = try reader["nodeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.distinctOutgoingEdgeLabels = try reader["distinctOutgoingEdgeLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptunedataClientTypes.RDFGraphSummaryValueMap {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.RDFGraphSummaryValueMap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.RDFGraphSummaryValueMap()
        value.version = try reader["version"].readIfPresent()
        value.lastStatisticsComputationTime = try reader["lastStatisticsComputationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.graphSummary = try reader["graphSummary"].readIfPresent(with: NeptunedataClientTypes.RDFGraphSummary.read(from:))
        return value
    }
}

extension NeptunedataClientTypes.RDFGraphSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.RDFGraphSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.RDFGraphSummary()
        value.numDistinctSubjects = try reader["numDistinctSubjects"].readIfPresent()
        value.numDistinctPredicates = try reader["numDistinctPredicates"].readIfPresent()
        value.numQuads = try reader["numQuads"].readIfPresent()
        value.numClasses = try reader["numClasses"].readIfPresent()
        value.classes = try reader["classes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.predicates = try reader["predicates"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.subjectStructures = try reader["subjectStructures"].readListIfPresent(memberReadingClosure: NeptunedataClientTypes.SubjectStructure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptunedataClientTypes.SubjectStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.SubjectStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.SubjectStructure()
        value.count = try reader["count"].readIfPresent()
        value.predicates = try reader["predicates"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptunedataClientTypes.SparqlRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.SparqlRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.SparqlRecord()
        value.commitTimestampInMillis = try reader["commitTimestamp"].readIfPresent() ?? 0
        value.eventId = try reader["eventId"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.data = try reader["data"].readIfPresent(with: NeptunedataClientTypes.SparqlData.read(from:))
        value.op = try reader["op"].readIfPresent() ?? ""
        value.isLastOp = try reader["isLastOp"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.SparqlData {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.SparqlData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.SparqlData()
        value.stmt = try reader["stmt"].readIfPresent() ?? ""
        return value
    }
}

extension NeptunedataClientTypes.GremlinQueryStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.GremlinQueryStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.GremlinQueryStatus()
        value.queryId = try reader["queryId"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        value.queryEvalStats = try reader["queryEvalStats"].readIfPresent(with: NeptunedataClientTypes.QueryEvalStats.read(from:))
        return value
    }
}

extension NeptunedataClientTypes.LoaderIdResult {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.LoaderIdResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.LoaderIdResult()
        value.loadIds = try reader["loadIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptunedataClientTypes.RefreshStatisticsIdMap {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptunedataClientTypes.RefreshStatisticsIdMap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptunedataClientTypes.RefreshStatisticsIdMap()
        value.statisticsId = try reader["statisticsId"].readIfPresent()
        return value
    }
}

extension NeptunedataClientTypes.CustomModelTrainingParameters {

    static func write(value: NeptunedataClientTypes.CustomModelTrainingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceS3DirectoryPath"].write(value.sourceS3DirectoryPath)
        try writer["trainingEntryPointScript"].write(value.trainingEntryPointScript)
        try writer["transformEntryPointScript"].write(value.transformEntryPointScript)
    }
}

extension NeptunedataClientTypes.CustomModelTransformParameters {

    static func write(value: NeptunedataClientTypes.CustomModelTransformParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceS3DirectoryPath"].write(value.sourceS3DirectoryPath)
        try writer["transformEntryPointScript"].write(value.transformEntryPointScript)
    }
}

public enum NeptunedataClientTypes {}
