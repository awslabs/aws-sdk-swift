// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagQueryConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagQueryConfiguration = self.tagQueryConfiguration {
            try encodeContainer.encode(tagQueryConfiguration, forKey: .tagQueryConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagQueryConfigurationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.TagQueryConfiguration.self, forKey: .tagQueryConfiguration)
        tagQueryConfiguration = tagQueryConfigurationDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// Includes all of the AppRegistry settings.
    public struct AppRegistryConfiguration: Swift.Equatable {
        /// Includes the definition of a tagQuery.
        public var tagQueryConfiguration: ServiceCatalogAppRegistryClientTypes.TagQueryConfiguration?

        public init(
            tagQueryConfiguration: ServiceCatalogAppRegistryClientTypes.TagQueryConfiguration? = nil
        )
        {
            self.tagQueryConfiguration = tagQueryConfiguration
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .dateTime, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// Represents a Amazon Web Services Service Catalog AppRegistry application that is the top-level node in a hierarchy of related cloud resource abstractions.
    public struct Application: Swift.Equatable {
        /// The Amazon resource name (ARN) that specifies the application across services.
        public var arn: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment when the application was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The identifier of the application.
        public var id: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment when the application was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the application. The name must be unique in the region in which you are creating the application.
        public var name: Swift.String?
        /// Key-value pairs you can use to associate with the application.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.tags = tags
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .dateTime, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// Summary of a Amazon Web Services Service Catalog AppRegistry application.
    public struct ApplicationSummary: Swift.Equatable {
        /// The Amazon resource name (ARN) that specifies the application across services.
        public var arn: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment when the application was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The identifier of the application.
        public var id: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment when the application was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the application. The name must be unique in the region in which you are creating the application.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension AssociateAttributeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        guard let attributeGroup = attributeGroup else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/attribute-groups/\(attributeGroup.urlPercentEncoding())"
    }
}

public struct AssociateAttributeGroupInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The name, ID, or ARN of the attribute group that holds the attributes to describe the application.
    /// This member is required.
    public var attributeGroup: Swift.String?

    public init(
        application: Swift.String? = nil,
        attributeGroup: Swift.String? = nil
    )
    {
        self.application = application
        self.attributeGroup = attributeGroup
    }
}

struct AssociateAttributeGroupInputBody: Swift.Equatable {
}

extension AssociateAttributeGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateAttributeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAttributeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.attributeGroupArn = output.attributeGroupArn
        } else {
            self.applicationArn = nil
            self.attributeGroupArn = nil
        }
    }
}

public struct AssociateAttributeGroupOutput: Swift.Equatable {
    /// The Amazon resource name (ARN) of the application that was augmented with attributes.
    public var applicationArn: Swift.String?
    /// The Amazon resource name (ARN) of the attribute group that contains the application's new attributes.
    public var attributeGroupArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        attributeGroupArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.attributeGroupArn = attributeGroupArn
    }
}

struct AssociateAttributeGroupOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let attributeGroupArn: Swift.String?
}

extension AssociateAttributeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case attributeGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let attributeGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeGroupArn)
        attributeGroupArn = attributeGroupArnDecoded
    }
}

enum AssociateAttributeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        guard let resourceType = resourceType else {
            return nil
        }
        guard let resource = resource else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/resources/\(resourceType.rawValue.urlPercentEncoding())/\(resource.urlPercentEncoding())"
    }
}

public struct AssociateResourceInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The name or ID of the resource of which the application will be associated.
    /// This member is required.
    public var resource: Swift.String?
    /// The type of resource of which the application will be associated.
    /// This member is required.
    public var resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init(
        application: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct AssociateResourceInputBody: Swift.Equatable {
}

extension AssociateResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct AssociateResourceOutput: Swift.Equatable {
    /// The Amazon resource name (ARN) of the application that was augmented with attributes.
    public var applicationArn: Swift.String?
    /// The Amazon resource name (ARN) that specifies the resource.
    public var resourceArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct AssociateResourceOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let resourceArn: Swift.String?
}

extension AssociateResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum AssociateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .dateTime, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// Represents a Amazon Web Services Service Catalog AppRegistry attribute group that is rich metadata which describes an application and its components.
    public struct AttributeGroup: Swift.Equatable {
        /// The Amazon resource name (ARN) that specifies the attribute group across services.
        public var arn: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment the attribute group was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the attribute group that the user provides.
        public var description: Swift.String?
        /// The globally unique attribute group identifier of the attribute group.
        public var id: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the attribute group.
        public var name: Swift.String?
        /// Key-value pairs you can use to associate with the attribute group.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.tags = tags
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The details related to a specific AttributeGroup.
    public struct AttributeGroupDetails: Swift.Equatable {
        /// The Amazon resource name (ARN) that specifies the attribute group.
        public var arn: Swift.String?
        /// The service principal that created the attribute group.
        public var createdBy: Swift.String?
        /// The unique identifier of the attribute group.
        public var id: Swift.String?
        /// This field is no longer supported. We recommend you don't use the field when using ListAttributeGroupsForApplication. The name of the attribute group.
        @available(*, deprecated, message: "This field is deprecated. We recommend not using the field when using ListAttributeGroupsForApplication.")
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdBy = createdBy
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .dateTime, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// Summary of a Amazon Web Services Service Catalog AppRegistry attribute group.
    public struct AttributeGroupSummary: Swift.Equatable {
        /// The Amazon resource name (ARN) that specifies the attribute group across services.
        public var arn: Swift.String?
        /// The service principal that created the attribute group.
        public var createdBy: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment the attribute group was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the attribute group that the user provides.
        public var description: Swift.String?
        /// The globally unique attribute group identifier of the attribute group.
        public var id: Swift.String?
        /// The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the attribute group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict when processing the request (for example, a resource with the given name already exists within the account).
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// A unique identifier that you provide to ensure idempotency. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The name of the application. The name must be unique in the region in which you are creating the application.
    /// This member is required.
    public var name: Swift.String?
    /// Key-value pairs you can use to associate with the application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// Information about the application.
    public var application: ServiceCatalogAppRegistryClientTypes.Application?

    public init(
        application: ServiceCatalogAppRegistryClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let application: ServiceCatalogAppRegistryClientTypes.Application?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAttributeGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAttributeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/attribute-groups"
    }
}

public struct CreateAttributeGroupInput: Swift.Equatable {
    /// A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.
    /// This member is required.
    public var attributes: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the attribute group that the user provides.
    public var description: Swift.String?
    /// The name of the attribute group.
    /// This member is required.
    public var name: Swift.String?
    /// Key-value pairs you can use to associate with the attribute group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        attributes: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAttributeGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let attributes: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateAttributeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case clientToken
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributes)
        attributes = attributesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAttributeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAttributeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct CreateAttributeGroupOutput: Swift.Equatable {
    /// Information about the attribute group.
    public var attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?

    public init(
        attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct CreateAttributeGroupOutputBody: Swift.Equatable {
    let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?
}

extension CreateAttributeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AttributeGroup.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

enum CreateAttributeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?

    public init(
        application: Swift.String? = nil
    )
    {
        self.application = application
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {
    /// Information about the deleted application.
    public var application: ServiceCatalogAppRegistryClientTypes.ApplicationSummary?

    public init(
        application: ServiceCatalogAppRegistryClientTypes.ApplicationSummary? = nil
    )
    {
        self.application = application
    }
}

struct DeleteApplicationOutputBody: Swift.Equatable {
    let application: ServiceCatalogAppRegistryClientTypes.ApplicationSummary?
}

extension DeleteApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ApplicationSummary.self, forKey: .application)
        application = applicationDecoded
    }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAttributeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attributeGroup = attributeGroup else {
            return nil
        }
        return "/attribute-groups/\(attributeGroup.urlPercentEncoding())"
    }
}

public struct DeleteAttributeGroupInput: Swift.Equatable {
    /// The name, ID, or ARN of the attribute group that holds the attributes to describe the application.
    /// This member is required.
    public var attributeGroup: Swift.String?

    public init(
        attributeGroup: Swift.String? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct DeleteAttributeGroupInputBody: Swift.Equatable {
}

extension DeleteAttributeGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttributeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAttributeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct DeleteAttributeGroupOutput: Swift.Equatable {
    /// Information about the deleted attribute group.
    public var attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary?

    public init(
        attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct DeleteAttributeGroupOutputBody: Swift.Equatable {
    let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary?
}

extension DeleteAttributeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

enum DeleteAttributeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateAttributeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        guard let attributeGroup = attributeGroup else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/attribute-groups/\(attributeGroup.urlPercentEncoding())"
    }
}

public struct DisassociateAttributeGroupInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The name, ID, or ARN of the attribute group that holds the attributes to describe the application.
    /// This member is required.
    public var attributeGroup: Swift.String?

    public init(
        application: Swift.String? = nil,
        attributeGroup: Swift.String? = nil
    )
    {
        self.application = application
        self.attributeGroup = attributeGroup
    }
}

struct DisassociateAttributeGroupInputBody: Swift.Equatable {
}

extension DisassociateAttributeGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAttributeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateAttributeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.attributeGroupArn = output.attributeGroupArn
        } else {
            self.applicationArn = nil
            self.attributeGroupArn = nil
        }
    }
}

public struct DisassociateAttributeGroupOutput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the application.
    public var applicationArn: Swift.String?
    /// The Amazon resource name (ARN) that specifies the attribute group.
    public var attributeGroupArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        attributeGroupArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.attributeGroupArn = attributeGroupArn
    }
}

struct DisassociateAttributeGroupOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let attributeGroupArn: Swift.String?
}

extension DisassociateAttributeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case attributeGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let attributeGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeGroupArn)
        attributeGroupArn = attributeGroupArnDecoded
    }
}

enum DisassociateAttributeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        guard let resourceType = resourceType else {
            return nil
        }
        guard let resource = resource else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/resources/\(resourceType.rawValue.urlPercentEncoding())/\(resource.urlPercentEncoding())"
    }
}

public struct DisassociateResourceInput: Swift.Equatable {
    /// The name or ID of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The name or ID of the resource.
    /// This member is required.
    public var resource: Swift.String?
    /// The type of the resource that is being disassociated.
    /// This member is required.
    public var resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init(
        application: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct DisassociateResourceInputBody: Swift.Equatable {
}

extension DisassociateResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct DisassociateResourceOutput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the application.
    public var applicationArn: Swift.String?
    /// The Amazon resource name (ARN) that specifies the resource.
    public var resourceArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct DisassociateResourceOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let resourceArn: Swift.String?
}

extension DisassociateResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum DisassociateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?

    public init(
        application: Swift.String? = nil
    )
    {
        self.application = application
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatedResourceCount = output.associatedResourceCount
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.integrations = output.integrations
            self.lastUpdateTime = output.lastUpdateTime
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.associatedResourceCount = 0
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.integrations = nil
            self.lastUpdateTime = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the application across services.
    public var arn: Swift.String?
    /// The number of top-level resources that were registered as part of this application.
    public var associatedResourceCount: Swift.Int
    /// The ISO-8601 formatted timestamp of the moment when the application was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the application.
    public var description: Swift.String?
    /// The identifier of the application.
    public var id: Swift.String?
    /// The information about the integration of the application with other services, such as Resource Groups.
    public var integrations: ServiceCatalogAppRegistryClientTypes.Integrations?
    /// The ISO-8601 formatted timestamp of the moment when the application was last updated.
    public var lastUpdateTime: ClientRuntime.Date?
    /// The name of the application. The name must be unique in the region in which you are creating the application.
    public var name: Swift.String?
    /// Key-value pairs associated with the application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        associatedResourceCount: Swift.Int = 0,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        integrations: ServiceCatalogAppRegistryClientTypes.Integrations? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.associatedResourceCount = associatedResourceCount
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.integrations = integrations
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastUpdateTime: ClientRuntime.Date?
    let associatedResourceCount: Swift.Int
    let tags: [Swift.String:Swift.String]?
    let integrations: ServiceCatalogAppRegistryClientTypes.Integrations?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatedResourceCount
        case creationTime
        case description
        case id
        case integrations
        case lastUpdateTime
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let associatedResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedResourceCount) ?? 0
        associatedResourceCount = associatedResourceCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let integrationsDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.Integrations.self, forKey: .integrations)
        integrations = integrationsDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssociatedResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        guard let resourceType = resourceType else {
            return nil
        }
        guard let resource = resource else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/resources/\(resourceType.rawValue.urlPercentEncoding())/\(resource.urlPercentEncoding())"
    }
}

public struct GetAssociatedResourceInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The name or ID of the resource associated with the application.
    /// This member is required.
    public var resource: Swift.String?
    /// The type of resource associated with the application.
    /// This member is required.
    public var resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init(
        application: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.application = application
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct GetAssociatedResourceInputBody: Swift.Equatable {
}

extension GetAssociatedResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssociatedResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssociatedResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resource = output.resource
        } else {
            self.resource = nil
        }
    }
}

public struct GetAssociatedResourceOutput: Swift.Equatable {
    /// The resource associated with the application.
    public var resource: ServiceCatalogAppRegistryClientTypes.Resource?

    public init(
        resource: ServiceCatalogAppRegistryClientTypes.Resource? = nil
    )
    {
        self.resource = resource
    }
}

struct GetAssociatedResourceOutputBody: Swift.Equatable {
    let resource: ServiceCatalogAppRegistryClientTypes.Resource?
}

extension GetAssociatedResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
    }
}

enum GetAssociatedResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAttributeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attributeGroup = attributeGroup else {
            return nil
        }
        return "/attribute-groups/\(attributeGroup.urlPercentEncoding())"
    }
}

public struct GetAttributeGroupInput: Swift.Equatable {
    /// The name, ID, or ARN of the attribute group that holds the attributes to describe the application.
    /// This member is required.
    public var attributeGroup: Swift.String?

    public init(
        attributeGroup: Swift.String? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct GetAttributeGroupInputBody: Swift.Equatable {
}

extension GetAttributeGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAttributeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAttributeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.attributes = output.attributes
            self.createdBy = output.createdBy
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastUpdateTime = output.lastUpdateTime
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.attributes = nil
            self.createdBy = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastUpdateTime = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetAttributeGroupOutput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the attribute group across services.
    public var arn: Swift.String?
    /// A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.
    public var attributes: Swift.String?
    /// The service principal that created the attribute group.
    public var createdBy: Swift.String?
    /// The ISO-8601 formatted timestamp of the moment the attribute group was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the attribute group that the user provides.
    public var description: Swift.String?
    /// The identifier of the attribute group.
    public var id: Swift.String?
    /// The ISO-8601 formatted timestamp of the moment the attribute group was last updated. This time is the same as the creationTime for a newly created attribute group.
    public var lastUpdateTime: ClientRuntime.Date?
    /// The name of the attribute group.
    public var name: Swift.String?
    /// Key-value pairs associated with the attribute group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        attributes: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.tags = tags
    }
}

struct GetAttributeGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let attributes: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastUpdateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let createdBy: Swift.String?
}

extension GetAttributeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case createdBy
        case creationTime
        case description
        case id
        case lastUpdateTime
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributes)
        attributes = attributesDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

enum GetAttributeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration"
    }
}

public struct GetConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetConfigurationInputBody: Swift.Equatable {
}

extension GetConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetConfigurationOutput: Swift.Equatable {
    /// Retrieves TagKey configuration from an account.
    public var configuration: ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration?

    public init(
        configuration: ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetConfigurationOutputBody: Swift.Equatable {
    let configuration: ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration?
}

extension GetConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogAppRegistryClientTypes.Integrations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroup = self.resourceGroup {
            try encodeContainer.encode(resourceGroup, forKey: .resourceGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ResourceGroup.self, forKey: .resourceGroup)
        resourceGroup = resourceGroupDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The information about the service integration.
    public struct Integrations: Swift.Equatable {
        /// The information about the resource group integration.
        public var resourceGroup: ServiceCatalogAppRegistryClientTypes.ResourceGroup?

        public init(
            resourceGroup: ServiceCatalogAppRegistryClientTypes.ResourceGroup? = nil
        )
        {
            self.resourceGroup = resourceGroup
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is experiencing internal problems.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// This list of applications.
    public var applications: [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        applications: [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[ServiceCatalogAppRegistryClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ServiceCatalogAppRegistryClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssociatedAttributeGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssociatedAttributeGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/attribute-groups"
    }
}

public struct ListAssociatedAttributeGroupsInput: Swift.Equatable {
    /// The name or ID of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        application: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociatedAttributeGroupsInputBody: Swift.Equatable {
}

extension ListAssociatedAttributeGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedAttributeGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociatedAttributeGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroups = output.attributeGroups
            self.nextToken = output.nextToken
        } else {
            self.attributeGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAttributeGroupsOutput: Swift.Equatable {
    /// A list of attribute group IDs.
    public var attributeGroups: [Swift.String]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        attributeGroups: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeGroups = attributeGroups
        self.nextToken = nextToken
    }
}

struct ListAssociatedAttributeGroupsOutputBody: Swift.Equatable {
    let attributeGroups: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedAttributeGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroups
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeGroups)
        var attributeGroupsDecoded0:[Swift.String]? = nil
        if let attributeGroupsContainer = attributeGroupsContainer {
            attributeGroupsDecoded0 = [Swift.String]()
            for string0 in attributeGroupsContainer {
                if let string0 = string0 {
                    attributeGroupsDecoded0?.append(string0)
                }
            }
        }
        attributeGroups = attributeGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociatedAttributeGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssociatedResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssociatedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/resources"
    }
}

public struct ListAssociatedResourcesInput: Swift.Equatable {
    /// The name, ID, or ARN of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        application: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociatedResourcesInputBody: Swift.Equatable {
}

extension ListAssociatedResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociatedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListAssociatedResourcesOutput: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?
    /// Information about the resources.
    public var resources: [ServiceCatalogAppRegistryClientTypes.ResourceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [ServiceCatalogAppRegistryClientTypes.ResourceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListAssociatedResourcesOutputBody: Swift.Equatable {
    let resources: [ServiceCatalogAppRegistryClientTypes.ResourceInfo]?
    let nextToken: Swift.String?
}

extension ListAssociatedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.ResourceInfo?].self, forKey: .resources)
        var resourcesDecoded0:[ServiceCatalogAppRegistryClientTypes.ResourceInfo]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [ServiceCatalogAppRegistryClientTypes.ResourceInfo]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociatedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAttributeGroupsForApplicationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAttributeGroupsForApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/attribute-group-details"
    }
}

public struct ListAttributeGroupsForApplicationInput: Swift.Equatable {
    /// The name or ID of the application.
    /// This member is required.
    public var application: Swift.String?
    /// The upper bound of the number of results to return. The value cannot exceed 25. If you omit this parameter, it defaults to 25. This value is optional.
    public var maxResults: Swift.Int?
    /// This token retrieves the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        application: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.application = application
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsForApplicationInputBody: Swift.Equatable {
}

extension ListAttributeGroupsForApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAttributeGroupsForApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttributeGroupsForApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroupsDetails = output.attributeGroupsDetails
            self.nextToken = output.nextToken
        } else {
            self.attributeGroupsDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttributeGroupsForApplicationOutput: Swift.Equatable {
    /// The details related to a specific attribute group.
    public var attributeGroupsDetails: [ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        attributeGroupsDetails: [ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeGroupsDetails = attributeGroupsDetails
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsForApplicationOutputBody: Swift.Equatable {
    let attributeGroupsDetails: [ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails]?
    let nextToken: Swift.String?
}

extension ListAttributeGroupsForApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroupsDetails
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails?].self, forKey: .attributeGroupsDetails)
        var attributeGroupsDetailsDecoded0:[ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails]? = nil
        if let attributeGroupsDetailsContainer = attributeGroupsDetailsContainer {
            attributeGroupsDetailsDecoded0 = [ServiceCatalogAppRegistryClientTypes.AttributeGroupDetails]()
            for structure0 in attributeGroupsDetailsContainer {
                if let structure0 = structure0 {
                    attributeGroupsDetailsDecoded0?.append(structure0)
                }
            }
        }
        attributeGroupsDetails = attributeGroupsDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttributeGroupsForApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAttributeGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAttributeGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/attribute-groups"
    }
}

public struct ListAttributeGroupsInput: Swift.Equatable {
    /// The upper bound of the number of results to return (cannot exceed 25). If this parameter is omitted, it defaults to 25. This value is optional.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsInputBody: Swift.Equatable {
}

extension ListAttributeGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAttributeGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttributeGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroups = output.attributeGroups
            self.nextToken = output.nextToken
        } else {
            self.attributeGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttributeGroupsOutput: Swift.Equatable {
    /// This list of attribute groups.
    public var attributeGroups: [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        attributeGroups: [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeGroups = attributeGroups
        self.nextToken = nextToken
    }
}

struct ListAttributeGroupsOutputBody: Swift.Equatable {
    let attributeGroups: [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]?
    let nextToken: Swift.String?
}

extension ListAttributeGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroups
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupsContainer = try containerValues.decodeIfPresent([ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary?].self, forKey: .attributeGroups)
        var attributeGroupsDecoded0:[ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]? = nil
        if let attributeGroupsContainer = attributeGroupsContainer {
            attributeGroupsDecoded0 = [ServiceCatalogAppRegistryClientTypes.AttributeGroupSummary]()
            for structure0 in attributeGroupsContainer {
                if let structure0 = structure0 {
                    attributeGroupsDecoded0?.append(structure0)
                }
            }
        }
        attributeGroups = attributeGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttributeGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags on the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }
}

extension PutConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration"
    }
}

public struct PutConfigurationInput: Swift.Equatable {
    /// Associates a TagKey configuration to an account.
    /// This member is required.
    public var configuration: ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration?

    public init(
        configuration: ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct PutConfigurationInputBody: Swift.Equatable {
    let configuration: ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration?
}

extension PutConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AppRegistryConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PutConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogAppRegistryClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associationTime
        case integrations
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associationTime = self.associationTime {
            try encodeContainer.encodeTimestamp(associationTime, format: .dateTime, forKey: .associationTime)
        }
        if let integrations = self.integrations {
            try encodeContainer.encode(integrations, forKey: .integrations)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let associationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let integrationsDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ResourceIntegrations.self, forKey: .integrations)
        integrations = integrationsDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The information about the resource.
    public struct Resource: Swift.Equatable {
        /// The Amazon resource name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time the resource was associated with the application.
        public var associationTime: ClientRuntime.Date?
        /// The service integration information about the resource.
        public var integrations: ServiceCatalogAppRegistryClientTypes.ResourceIntegrations?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            associationTime: ClientRuntime.Date? = nil,
            integrations: ServiceCatalogAppRegistryClientTypes.ResourceIntegrations? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.associationTime = associationTime
            self.integrations = integrations
            self.name = name
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The details related to the resource.
    public struct ResourceDetails: Swift.Equatable {
        /// The value of the tag.
        public var tagValue: Swift.String?

        public init(
            tagValue: Swift.String? = nil
        )
        {
            self.tagValue = tagValue
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.ResourceGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case errorMessage
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ResourceGroupState.self, forKey: .state)
        state = stateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The information about the resource group integration.
    public struct ResourceGroup: Swift.Equatable {
        /// The Amazon resource name (ARN) of the resource group.
        public var arn: Swift.String?
        /// The error message that generates when the propagation process for the resource group fails.
        public var errorMessage: Swift.String?
        /// The state of the propagation process for the resource group. The states includes: CREATING if the resource group is in the process of being created. CREATE_COMPLETE if the resource group was created successfully. CREATE_FAILED if the resource group failed to be created. UPDATING if the resource group is in the process of being updated. UPDATE_COMPLETE if the resource group updated successfully. UPDATE_FAILED if the resource group could not update successfully.
        public var state: ServiceCatalogAppRegistryClientTypes.ResourceGroupState?

        public init(
            arn: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            state: ServiceCatalogAppRegistryClientTypes.ResourceGroupState? = nil
        )
        {
            self.arn = arn
            self.errorMessage = errorMessage
            self.state = state
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes {
    public enum ResourceGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case creating
        case updateComplete
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceGroupState] {
            return [
                .createComplete,
                .createFailed,
                .creating,
                .updateComplete,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .updateComplete: return "UPDATE_COMPLETE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceGroupState(rawValue: rawValue) ?? ResourceGroupState.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogAppRegistryClientTypes.ResourceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case resourceDetails
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The information about the resource.
    public struct ResourceInfo: Swift.Equatable {
        /// The Amazon resource name (ARN) that specifies the resource across services.
        public var arn: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The details related to the resource.
        public var resourceDetails: ServiceCatalogAppRegistryClientTypes.ResourceDetails?
        /// Provides information about the Service Catalog App Registry resource type.
        public var resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceDetails: ServiceCatalogAppRegistryClientTypes.ResourceDetails? = nil,
            resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.resourceDetails = resourceDetails
            self.resourceType = resourceType
        }
    }

}

extension ServiceCatalogAppRegistryClientTypes.ResourceIntegrations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroup = self.resourceGroup {
            try encodeContainer.encode(resourceGroup, forKey: .resourceGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.ResourceGroup.self, forKey: .resourceGroup)
        resourceGroup = resourceGroupDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The service integration information about the resource.
    public struct ResourceIntegrations: Swift.Equatable {
        /// The information about the integration of Resource Groups.
        public var resourceGroup: ServiceCatalogAppRegistryClientTypes.ResourceGroup?

        public init(
            resourceGroup: ServiceCatalogAppRegistryClientTypes.ResourceGroup? = nil
        )
        {
            self.resourceGroup = resourceGroup
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cfnStack
        case resourceTagValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .cfnStack,
                .resourceTagValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cfnStack: return "CFN_STACK"
            case .resourceTagValue: return "RESOURCE_TAG_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of resources per account has been reached.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    public enum SyncAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noAction
        case startSync
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncAction] {
            return [
                .noAction,
                .startSync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noAction: return "NO_ACTION"
            case .startSync: return "START_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncAction(rawValue: rawValue) ?? SyncAction.sdkUnknown(rawValue)
        }
    }
}

extension SyncResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceType = resourceType else {
            return nil
        }
        guard let resource = resource else {
            return nil
        }
        return "/sync/\(resourceType.rawValue.urlPercentEncoding())/\(resource.urlPercentEncoding())"
    }
}

public struct SyncResourceInput: Swift.Equatable {
    /// An entity you can work with and specify with a name or ID. Examples include an Amazon EC2 instance, an Amazon Web Services CloudFormation stack, or an Amazon S3 bucket.
    /// This member is required.
    public var resource: Swift.String?
    /// The type of resource of which the application will be associated.
    /// This member is required.
    public var resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType?

    public init(
        resource: Swift.String? = nil,
        resourceType: ServiceCatalogAppRegistryClientTypes.ResourceType? = nil
    )
    {
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct SyncResourceInputBody: Swift.Equatable {
}

extension SyncResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SyncResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SyncResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionTaken = output.actionTaken
            self.applicationArn = output.applicationArn
            self.resourceArn = output.resourceArn
        } else {
            self.actionTaken = nil
            self.applicationArn = nil
            self.resourceArn = nil
        }
    }
}

public struct SyncResourceOutput: Swift.Equatable {
    /// The results of the output if an application is associated with an ARN value, which could be syncStarted or None.
    public var actionTaken: ServiceCatalogAppRegistryClientTypes.SyncAction?
    /// The Amazon resource name (ARN) that specifies the application.
    public var applicationArn: Swift.String?
    /// The Amazon resource name (ARN) that specifies the resource.
    public var resourceArn: Swift.String?

    public init(
        actionTaken: ServiceCatalogAppRegistryClientTypes.SyncAction? = nil,
        applicationArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.actionTaken = actionTaken
        self.applicationArn = applicationArn
        self.resourceArn = resourceArn
    }
}

struct SyncResourceOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let resourceArn: Swift.String?
    let actionTaken: ServiceCatalogAppRegistryClientTypes.SyncAction?
}

extension SyncResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTaken
        case applicationArn
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionTakenDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.SyncAction.self, forKey: .actionTaken)
        actionTaken = actionTakenDecoded
    }
}

enum SyncResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogAppRegistryClientTypes.TagQueryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
    }
}

extension ServiceCatalogAppRegistryClientTypes {
    /// The definition of tagQuery. Specifies which resources are associated with an application.
    public struct TagQueryConfiguration: Swift.Equatable {
        /// Condition in the IAM policy that associates resources to an application.
        public var tagKey: Swift.String?

        public init(
            tagKey: Swift.String? = nil
        )
        {
            self.tagKey = tagKey
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of API requests has been exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message associated with the Throttling exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The originating service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon resource name (ARN) that specifies the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The name, ID, or ARN of the application that will be updated.
    /// This member is required.
    public var application: Swift.String?
    /// The new description of the application.
    public var description: Swift.String?
    /// Deprecated: The new name of the application. The name must be unique in the region in which you are updating the application. Please do not use this field as we have stopped supporting name updates.
    @available(*, deprecated, message: "Name update for application is deprecated.")
    public var name: Swift.String?

    public init(
        application: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.application = application
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// The updated information of the application.
    public var application: ServiceCatalogAppRegistryClientTypes.Application?

    public init(
        application: ServiceCatalogAppRegistryClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let application: ServiceCatalogAppRegistryClientTypes.Application?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAttributeGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAttributeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attributeGroup = attributeGroup else {
            return nil
        }
        return "/attribute-groups/\(attributeGroup.urlPercentEncoding())"
    }
}

public struct UpdateAttributeGroupInput: Swift.Equatable {
    /// The name, ID, or ARN of the attribute group that holds the attributes to describe the application.
    /// This member is required.
    public var attributeGroup: Swift.String?
    /// A JSON string in the form of nested key-value pairs that represent the attributes in the group and describes an application and its components.
    public var attributes: Swift.String?
    /// The description of the attribute group that the user provides.
    public var description: Swift.String?
    /// Deprecated: The new name of the attribute group. The name must be unique in the region in which you are updating the attribute group. Please do not use this field as we have stopped supporting name updates.
    @available(*, deprecated, message: "Name update for attribute group is deprecated.")
    public var name: Swift.String?

    public init(
        attributeGroup: Swift.String? = nil,
        attributes: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.attributeGroup = attributeGroup
        self.attributes = attributes
        self.description = description
        self.name = name
    }
}

struct UpdateAttributeGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let attributes: Swift.String?
}

extension UpdateAttributeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension UpdateAttributeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAttributeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeGroup = output.attributeGroup
        } else {
            self.attributeGroup = nil
        }
    }
}

public struct UpdateAttributeGroupOutput: Swift.Equatable {
    /// The updated information of the attribute group.
    public var attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?

    public init(
        attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup? = nil
    )
    {
        self.attributeGroup = attributeGroup
    }
}

struct UpdateAttributeGroupOutputBody: Swift.Equatable {
    let attributeGroup: ServiceCatalogAppRegistryClientTypes.AttributeGroup?
}

extension UpdateAttributeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeGroupDecoded = try containerValues.decodeIfPresent(ServiceCatalogAppRegistryClientTypes.AttributeGroup.self, forKey: .attributeGroup)
        attributeGroup = attributeGroupDecoded
    }
}

enum UpdateAttributeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
