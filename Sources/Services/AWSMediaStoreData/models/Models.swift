// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ContainerNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ContainerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified container was not found for the specified account.
public struct ContainerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContainerNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContainerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContainerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteObjectInput: Swift.Equatable {
    /// The path (including the file name) where the object is stored in the container. Format: //
    /// This member is required.
    public var path: Swift.String?

    public init(
        path: Swift.String? = nil
    )
    {
        self.path = path
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
}

extension DeleteObjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteObjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ObjectNotFoundException": return try await ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DescribeObjectInput: Swift.Equatable {
    /// The path (including the file name) where the object is stored in the container. Format: //
    /// This member is required.
    public var path: Swift.String?

    public init(
        path: Swift.String? = nil
    )
    {
        self.path = path
    }
}

struct DescribeObjectInputBody: Swift.Equatable {
}

extension DescribeObjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = TimestampFormatter(format: .httpDate).date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
    }
}

public struct DescribeObjectOutput: Swift.Equatable {
    /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9). Headers with a custom user-defined value are also accepted.
    public var cacheControl: Swift.String?
    /// The length of the object in bytes.
    public var contentLength: Swift.Int?
    /// The content type of the object.
    public var contentType: Swift.String?
    /// The ETag that represents a unique instance of the object.
    public var eTag: Swift.String?
    /// The date and time that the object was last modified.
    public var lastModified: ClientRuntime.Date?

    public init(
        cacheControl: Swift.String? = nil,
        contentLength: Swift.Int? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil
    )
    {
        self.cacheControl = cacheControl
        self.contentLength = contentLength
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
    }
}

enum DescribeObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ObjectNotFoundException": return try await ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        return items
    }
}

extension GetObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetObjectInput: Swift.Equatable {
    /// The path (including the file name) where the object is stored in the container. Format: // For example, to upload the file mlaw.avi to the folder path premium\canada in the container movies, enter the path premium/canada/mlaw.avi. Do not include the container name in this path. If the path includes any folders that don't exist yet, the service creates them. For example, suppose you have an existing premium/usa subfolder. If you specify premium/canada, the service creates a canada subfolder in the premium folder. You then have two subfolders, usa and canada, in the premium folder. There is no correlation between the path to the source and the path (folders) in the container in AWS Elemental MediaStore. For more information about folders and how they exist in a container, see the [AWS Elemental MediaStore User Guide](http://docs.aws.amazon.com/mediastore/latest/ug/). The file name is the name that is assigned to the file that you upload. The file can have the same name inside and outside of AWS Elemental MediaStore, or it can have the same name. The file name can include or omit an extension.
    /// This member is required.
    public var path: Swift.String?
    /// The range bytes of an object to retrieve. For more information about the Range header, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35). AWS Elemental MediaStore ignores this header for partially uploaded objects that have streaming upload availability.
    public var range: Swift.String?

    public init(
        path: Swift.String? = nil,
        range: Swift.String? = nil
    )
    {
        self.path = path
        self.range = range
    }
}

struct GetObjectInputBody: Swift.Equatable {
}

extension GetObjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = nil
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = TimestampFormatter(format: .httpDate).date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.body = .data(data)
        case .stream(let stream):
            self.body = .stream(stream)
        case .none:
            self.body = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct GetObjectOutput: Swift.Equatable {
    /// The bytes of the object.
    public var body: ClientRuntime.ByteStream?
    /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP spec at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9). Headers with a custom user-defined value are also accepted.
    public var cacheControl: Swift.String?
    /// The length of the object in bytes.
    public var contentLength: Swift.Int?
    /// The range of bytes to retrieve.
    public var contentRange: Swift.String?
    /// The content type of the object.
    public var contentType: Swift.String?
    /// The ETag that represents a unique instance of the object.
    public var eTag: Swift.String?
    /// The date and time that the object was last modified.
    public var lastModified: ClientRuntime.Date?
    /// The HTML status code of the request. Status codes ranging from 200 to 299 indicate success. All other status codes indicate the type of error that occurred.
    /// This member is required.
    public var statusCode: Swift.Int

    public init(
        body: ClientRuntime.ByteStream? = nil,
        cacheControl: Swift.String? = nil,
        contentLength: Swift.Int? = nil,
        contentRange: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.body = body
        self.cacheControl = cacheControl
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
        self.statusCode = statusCode
    }
}

struct GetObjectOutputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
    let statusCode: Swift.Int
}

extension GetObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
        case statusCode = "StatusCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
    }
}

enum GetObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ObjectNotFoundException": return try await ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestedRangeNotSatisfiableException": return try await RequestedRangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreDataClientTypes.Item: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentLength = "ContentLength"
        case contentType = "ContentType"
        case eTag = "ETag"
        case lastModified = "LastModified"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentLength = self.contentLength {
            try encodeContainer.encode(contentLength, forKey: .contentLength)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MediaStoreDataClientTypes.ItemType.self, forKey: .type)
        type = typeDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentLength)
        contentLength = contentLengthDecoded
    }
}

extension MediaStoreDataClientTypes {
    /// A metadata entry for a folder or object.
    public struct Item: Swift.Equatable {
        /// The length of the item in bytes.
        public var contentLength: Swift.Int?
        /// The content type of the item.
        public var contentType: Swift.String?
        /// The ETag that represents a unique instance of the item.
        public var eTag: Swift.String?
        /// The date and time that the item was last modified.
        public var lastModified: ClientRuntime.Date?
        /// The name of the item.
        public var name: Swift.String?
        /// The item type (folder or object).
        public var type: MediaStoreDataClientTypes.ItemType?

        public init(
            contentLength: Swift.Int? = nil,
            contentType: Swift.String? = nil,
            eTag: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: MediaStoreDataClientTypes.ItemType? = nil
        )
        {
            self.contentLength = contentLength
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.name = name
            self.type = type
        }
    }

}

extension MediaStoreDataClientTypes {
    public enum ItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case folder
        case object
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemType] {
            return [
                .folder,
                .object,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .folder: return "FOLDER"
            case .object: return "OBJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
        }
    }
}

extension ListItemsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let path = path {
                let pathQueryItem = ClientRuntime.URLQueryItem(name: "Path".urlPercentEncoding(), value: Swift.String(path).urlPercentEncoding())
                items.append(pathQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListItemsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListItems request with MaxResults set at 500. Although 2,000 items match your request, the service returns no more than the first 500 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 1,000 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListItems request with MaxResults set at 500. The service returns the first batch of results (up to 500) and a NextToken value. To see the next batch of results, you can submit the ListItems request a second time and specify the NextToken value. Tokens expire after 15 minutes.
    public var nextToken: Swift.String?
    /// The path in the container from which to retrieve items. Format: //
    public var path: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        path: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.path = path
    }
}

struct ListItemsInputBody: Swift.Equatable {
}

extension ListItemsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListItemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListItemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListItemsOutput: Swift.Equatable {
    /// The metadata entries for the folders and objects at the requested path.
    public var items: [MediaStoreDataClientTypes.Item]?
    /// The token that can be used in a request to view the next set of results. For example, you submit a ListItems request that matches 2,000 items with MaxResults set at 500. The service returns the first batch of results (up to 500) and a NextToken value that can be used to fetch the next batch of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaStoreDataClientTypes.Item]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListItemsOutputBody: Swift.Equatable {
    let items: [MediaStoreDataClientTypes.Item]?
    let nextToken: Swift.String?
}

extension ListItemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaStoreDataClientTypes.Item?].self, forKey: .items)
        var itemsDecoded0:[MediaStoreDataClientTypes.Item]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaStoreDataClientTypes.Item]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ObjectNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ObjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Could not perform an operation on an object that does not exist.
public struct ObjectNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ObjectNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ObjectNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ObjectNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodyBody = ClientRuntime.HttpBody(byteStream: body)
            input.builder.withBody(bodyBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension PutObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let cacheControl = cacheControl {
            items.add(Header(name: "Cache-Control", value: Swift.String(cacheControl)))
        }
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let storageClass = storageClass {
            items.add(Header(name: "x-amz-storage-class", value: Swift.String(storageClass.rawValue)))
        }
        if let uploadAvailability = uploadAvailability {
            items.add(Header(name: "x-amz-upload-availability", value: Swift.String(uploadAvailability.rawValue)))
        }
        return items
    }
}

extension PutObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct PutObjectInput: Swift.Equatable {
    /// The bytes to be stored.
    /// This member is required.
    public var body: ClientRuntime.ByteStream?
    /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9). Headers with a custom user-defined value are also accepted.
    public var cacheControl: Swift.String?
    /// The content type of the object.
    public var contentType: Swift.String?
    /// The path (including the file name) where the object is stored in the container. Format: // For example, to upload the file mlaw.avi to the folder path premium\canada in the container movies, enter the path premium/canada/mlaw.avi. Do not include the container name in this path. If the path includes any folders that don't exist yet, the service creates them. For example, suppose you have an existing premium/usa subfolder. If you specify premium/canada, the service creates a canada subfolder in the premium folder. You then have two subfolders, usa and canada, in the premium folder. There is no correlation between the path to the source and the path (folders) in the container in AWS Elemental MediaStore. For more information about folders and how they exist in a container, see the [AWS Elemental MediaStore User Guide](http://docs.aws.amazon.com/mediastore/latest/ug/). The file name is the name that is assigned to the file that you upload. The file can have the same name inside and outside of AWS Elemental MediaStore, or it can have the same name. The file name can include or omit an extension.
    /// This member is required.
    public var path: Swift.String?
    /// Indicates the storage class of a Put request. Defaults to high-performance temporal storage class, and objects are persisted into durable storage shortly after being received.
    public var storageClass: MediaStoreDataClientTypes.StorageClass?
    /// Indicates the availability of an object while it is still uploading. If the value is set to streaming, the object is available for downloading after some initial buffering but before the object is uploaded completely. If the value is set to standard, the object is available for downloading only when it is uploaded completely. The default value for this header is standard. To use this header, you must also set the HTTP Transfer-Encoding header to chunked.
    public var uploadAvailability: MediaStoreDataClientTypes.UploadAvailability?

    public init(
        body: ClientRuntime.ByteStream? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        path: Swift.String? = nil,
        storageClass: MediaStoreDataClientTypes.StorageClass? = nil,
        uploadAvailability: MediaStoreDataClientTypes.UploadAvailability? = nil
    )
    {
        self.body = body
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.path = path
        self.storageClass = storageClass
        self.uploadAvailability = uploadAvailability
    }
}

struct PutObjectInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension PutObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentSHA256 = output.contentSHA256
            self.eTag = output.eTag
            self.storageClass = output.storageClass
        } else {
            self.contentSHA256 = nil
            self.eTag = nil
            self.storageClass = nil
        }
    }
}

public struct PutObjectOutput: Swift.Equatable {
    /// The SHA256 digest of the object that is persisted.
    public var contentSHA256: Swift.String?
    /// Unique identifier of the object in the container.
    public var eTag: Swift.String?
    /// The storage class where the object was persisted. The class should be “Temporal”.
    public var storageClass: MediaStoreDataClientTypes.StorageClass?

    public init(
        contentSHA256: Swift.String? = nil,
        eTag: Swift.String? = nil,
        storageClass: MediaStoreDataClientTypes.StorageClass? = nil
    )
    {
        self.contentSHA256 = contentSHA256
        self.eTag = eTag
        self.storageClass = storageClass
    }
}

struct PutObjectOutputBody: Swift.Equatable {
    let contentSHA256: Swift.String?
    let eTag: Swift.String?
    let storageClass: MediaStoreDataClientTypes.StorageClass?
}

extension PutObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSHA256 = "ContentSHA256"
        case eTag = "ETag"
        case storageClass = "StorageClass"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSHA256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentSHA256)
        contentSHA256 = contentSHA256Decoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(MediaStoreDataClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

enum PutObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestedRangeNotSatisfiableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestedRangeNotSatisfiableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested content range is not valid.
public struct RequestedRangeNotSatisfiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestedRangeNotSatisfiableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestedRangeNotSatisfiableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestedRangeNotSatisfiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreDataClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case temporal
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .temporal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .temporal: return "TEMPORAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension MediaStoreDataClientTypes {
    public enum UploadAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case standard
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadAvailability] {
            return [
                .standard,
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .standard: return "STANDARD"
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadAvailability(rawValue: rawValue) ?? UploadAvailability.sdkUnknown(rawValue)
        }
    }
}
