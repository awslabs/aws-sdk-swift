// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension GlueClient {
    /// Paginate over `[GetBlueprintRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBlueprintRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBlueprintRunsOutput`
    public func getBlueprintRunsPaginated(input: GetBlueprintRunsInput) -> ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBlueprintRuns(input:))
    }
}

extension GetBlueprintRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBlueprintRunsInput {
        return GetBlueprintRunsInput(
            blueprintName: self.blueprintName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetClassifiersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetClassifiersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetClassifiersOutput`
    public func getClassifiersPaginated(input: GetClassifiersInput) -> ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutput> {
        return ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getClassifiers(input:))
    }
}

extension GetClassifiersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetClassifiersInput {
        return GetClassifiersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetColumnStatisticsTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetColumnStatisticsTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetColumnStatisticsTaskRunsOutput`
    public func getColumnStatisticsTaskRunsPaginated(input: GetColumnStatisticsTaskRunsInput) -> ClientRuntime.PaginatorSequence<GetColumnStatisticsTaskRunsInput, GetColumnStatisticsTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetColumnStatisticsTaskRunsInput, GetColumnStatisticsTaskRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getColumnStatisticsTaskRuns(input:))
    }
}

extension GetColumnStatisticsTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetColumnStatisticsTaskRunsInput {
        return GetColumnStatisticsTaskRunsInput(
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetConnectionsOutput`
    public func getConnectionsPaginated(input: GetConnectionsInput) -> ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getConnections(input:))
    }
}

extension GetConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectionsInput {
        return GetConnectionsInput(
            catalogId: self.catalogId,
            filter: self.filter,
            hidePassword: self.hidePassword,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetCrawlerMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCrawlerMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCrawlerMetricsOutput`
    public func getCrawlerMetricsPaginated(input: GetCrawlerMetricsInput) -> ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutput> {
        return ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCrawlerMetrics(input:))
    }
}

extension GetCrawlerMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlerMetricsInput {
        return GetCrawlerMetricsInput(
            crawlerNameList: self.crawlerNameList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetCrawlersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCrawlersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCrawlersOutput`
    public func getCrawlersPaginated(input: GetCrawlersInput) -> ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutput> {
        return ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCrawlers(input:))
    }
}

extension GetCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlersInput {
        return GetCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetDatabasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDatabasesOutput`
    public func getDatabasesPaginated(input: GetDatabasesInput) -> ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutput> {
        return ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getDatabases(input:))
    }
}

extension GetDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDatabasesInput {
        return GetDatabasesInput(
            catalogId: self.catalogId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType
        )}
}
extension GlueClient {
    /// Paginate over `[GetDevEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDevEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDevEndpointsOutput`
    public func getDevEndpointsPaginated(input: GetDevEndpointsInput) -> ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getDevEndpoints(input:))
    }
}

extension GetDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDevEndpointsInput {
        return GetDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetJobRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetJobRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetJobRunsOutput`
    public func getJobRunsPaginated(input: GetJobRunsInput) -> ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getJobRuns(input:))
    }
}

extension GetJobRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobRunsInput {
        return GetJobRunsInput(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetJobsOutput`
    public func getJobsPaginated(input: GetJobsInput) -> ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutput> {
        return ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getJobs(input:))
    }
}

extension GetJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobsInput {
        return GetJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetMLTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMLTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMLTaskRunsOutput`
    public func getMLTaskRunsPaginated(input: GetMLTaskRunsInput) -> ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getMLTaskRuns(input:))
    }
}

extension GetMLTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTaskRunsInput {
        return GetMLTaskRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            transformId: self.transformId
        )}
}
extension GlueClient {
    /// Paginate over `[GetMLTransformsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMLTransformsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMLTransformsOutput`
    public func getMLTransformsPaginated(input: GetMLTransformsInput) -> ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutput> {
        return ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getMLTransforms(input:))
    }
}

extension GetMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTransformsInput {
        return GetMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )}
}
extension GlueClient {
    /// Paginate over `[GetPartitionIndexesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPartitionIndexesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPartitionIndexesOutput`
    public func getPartitionIndexesPaginated(input: GetPartitionIndexesInput) -> ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutput> {
        return ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPartitionIndexes(input:))
    }
}

extension GetPartitionIndexesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionIndexesInput {
        return GetPartitionIndexesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            nextToken: token,
            tableName: self.tableName
        )}
}

extension PaginatorSequence where OperationStackInput == GetPartitionIndexesInput, OperationStackOutput == GetPartitionIndexesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getPartitionIndexesPaginated`
    /// to access the nested member `[GlueClientTypes.PartitionIndexDescriptor]`
    /// - Returns: `[GlueClientTypes.PartitionIndexDescriptor]`
    public func partitionIndexDescriptorList() async throws -> [GlueClientTypes.PartitionIndexDescriptor] {
        return try await self.asyncCompactMap { item in item.partitionIndexDescriptorList }
    }
}
extension GlueClient {
    /// Paginate over `[GetPartitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPartitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPartitionsOutput`
    public func getPartitionsPaginated(input: GetPartitionsInput) -> ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutput> {
        return ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPartitions(input:))
    }
}

extension GetPartitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionsInput {
        return GetPartitionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            excludeColumnSchema: self.excludeColumnSchema,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            segment: self.segment,
            tableName: self.tableName,
            transactionId: self.transactionId
        )}
}
extension GlueClient {
    /// Paginate over `[GetResourcePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourcePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutput`
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetResourcePoliciesInput, OperationStackOutput == GetResourcePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getResourcePoliciesPaginated`
    /// to access the nested member `[GlueClientTypes.GluePolicy]`
    /// - Returns: `[GlueClientTypes.GluePolicy]`
    public func getResourcePoliciesResponseList() async throws -> [GlueClientTypes.GluePolicy] {
        return try await self.asyncCompactMap { item in item.getResourcePoliciesResponseList }
    }
}
extension GlueClient {
    /// Paginate over `[GetSecurityConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSecurityConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSecurityConfigurationsOutput`
    public func getSecurityConfigurationsPaginated(input: GetSecurityConfigurationsInput) -> ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getSecurityConfigurations(input:))
    }
}

extension GetSecurityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSecurityConfigurationsInput {
        return GetSecurityConfigurationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetSecurityConfigurationsInput, OperationStackOutput == GetSecurityConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getSecurityConfigurationsPaginated`
    /// to access the nested member `[GlueClientTypes.SecurityConfiguration]`
    /// - Returns: `[GlueClientTypes.SecurityConfiguration]`
    public func securityConfigurations() async throws -> [GlueClientTypes.SecurityConfiguration] {
        return try await self.asyncCompactMap { item in item.securityConfigurations }
    }
}
extension GlueClient {
    /// Paginate over `[GetTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTablesOutput`
    public func getTablesPaginated(input: GetTablesInput) -> ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutput> {
        return ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTables(input:))
    }
}

extension GetTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTablesInput {
        return GetTablesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            transactionId: self.transactionId
        )}
}
extension GlueClient {
    /// Paginate over `[GetTableVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTableVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTableVersionsOutput`
    public func getTableVersionsPaginated(input: GetTableVersionsInput) -> ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutput> {
        return ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTableVersions(input:))
    }
}

extension GetTableVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTableVersionsInput {
        return GetTableVersionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetTriggersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTriggersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTriggersOutput`
    public func getTriggersPaginated(input: GetTriggersInput) -> ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutput> {
        return ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTriggers(input:))
    }
}

extension GetTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTriggersInput {
        return GetTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetUnfilteredPartitionsMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUnfilteredPartitionsMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUnfilteredPartitionsMetadataOutput`
    public func getUnfilteredPartitionsMetadataPaginated(input: GetUnfilteredPartitionsMetadataInput) -> ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutput> {
        return ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getUnfilteredPartitionsMetadata(input:))
    }
}

extension GetUnfilteredPartitionsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUnfilteredPartitionsMetadataInput {
        return GetUnfilteredPartitionsMetadataInput(
            auditContext: self.auditContext,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            segment: self.segment,
            supportedPermissionTypes: self.supportedPermissionTypes,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetUserDefinedFunctionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUserDefinedFunctionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUserDefinedFunctionsOutput`
    public func getUserDefinedFunctionsPaginated(input: GetUserDefinedFunctionsInput) -> ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutput> {
        return ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getUserDefinedFunctions(input:))
    }
}

extension GetUserDefinedFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUserDefinedFunctionsInput {
        return GetUserDefinedFunctionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            pattern: self.pattern
        )}
}
extension GlueClient {
    /// Paginate over `[GetWorkflowRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetWorkflowRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetWorkflowRunsOutput`
    public func getWorkflowRunsPaginated(input: GetWorkflowRunsInput) -> ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getWorkflowRuns(input:))
    }
}

extension GetWorkflowRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetWorkflowRunsInput {
        return GetWorkflowRunsInput(
            includeGraph: self.includeGraph,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListBlueprintsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBlueprintsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBlueprintsOutput`
    public func listBlueprintsPaginated(input: ListBlueprintsInput) -> ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutput> {
        return ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBlueprints(input:))
    }
}

extension ListBlueprintsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBlueprintsInput {
        return ListBlueprintsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListColumnStatisticsTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListColumnStatisticsTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListColumnStatisticsTaskRunsOutput`
    public func listColumnStatisticsTaskRunsPaginated(input: ListColumnStatisticsTaskRunsInput) -> ClientRuntime.PaginatorSequence<ListColumnStatisticsTaskRunsInput, ListColumnStatisticsTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListColumnStatisticsTaskRunsInput, ListColumnStatisticsTaskRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listColumnStatisticsTaskRuns(input:))
    }
}

extension ListColumnStatisticsTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListColumnStatisticsTaskRunsInput {
        return ListColumnStatisticsTaskRunsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListCrawlersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCrawlersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCrawlersOutput`
    public func listCrawlersPaginated(input: ListCrawlersInput) -> ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutput> {
        return ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCrawlers(input:))
    }
}

extension ListCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCrawlersInput {
        return ListCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListCustomEntityTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCustomEntityTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCustomEntityTypesOutput`
    public func listCustomEntityTypesPaginated(input: ListCustomEntityTypesInput) -> ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCustomEntityTypes(input:))
    }
}

extension ListCustomEntityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomEntityTypesInput {
        return ListCustomEntityTypesInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityResultsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityResultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityResultsOutput`
    public func listDataQualityResultsPaginated(input: ListDataQualityResultsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityResultsInput, ListDataQualityResultsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityResultsInput, ListDataQualityResultsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityResults(input:))
    }
}

extension ListDataQualityResultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityResultsInput {
        return ListDataQualityResultsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRuleRecommendationRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRuleRecommendationRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRuleRecommendationRunsOutput`
    public func listDataQualityRuleRecommendationRunsPaginated(input: ListDataQualityRuleRecommendationRunsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRuleRecommendationRunsInput, ListDataQualityRuleRecommendationRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRuleRecommendationRunsInput, ListDataQualityRuleRecommendationRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityRuleRecommendationRuns(input:))
    }
}

extension ListDataQualityRuleRecommendationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRuleRecommendationRunsInput {
        return ListDataQualityRuleRecommendationRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRulesetEvaluationRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRulesetEvaluationRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRulesetEvaluationRunsOutput`
    public func listDataQualityRulesetEvaluationRunsPaginated(input: ListDataQualityRulesetEvaluationRunsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRulesetEvaluationRunsInput, ListDataQualityRulesetEvaluationRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRulesetEvaluationRunsInput, ListDataQualityRulesetEvaluationRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityRulesetEvaluationRuns(input:))
    }
}

extension ListDataQualityRulesetEvaluationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRulesetEvaluationRunsInput {
        return ListDataQualityRulesetEvaluationRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRulesetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRulesetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRulesetsOutput`
    public func listDataQualityRulesetsPaginated(input: ListDataQualityRulesetsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRulesetsInput, ListDataQualityRulesetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRulesetsInput, ListDataQualityRulesetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityRulesets(input:))
    }
}

extension ListDataQualityRulesetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRulesetsInput {
        return ListDataQualityRulesetsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListDevEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevEndpointsOutput`
    public func listDevEndpointsPaginated(input: ListDevEndpointsInput) -> ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevEndpoints(input:))
    }
}

extension ListDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevEndpointsInput {
        return ListDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListMLTransformsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMLTransformsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMLTransformsOutput`
    public func listMLTransformsPaginated(input: ListMLTransformsInput) -> ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutput> {
        return ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMLTransforms(input:))
    }
}

extension ListMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMLTransformsInput {
        return ListMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListRegistriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRegistriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRegistriesOutput`
    public func listRegistriesPaginated(input: ListRegistriesInput) -> ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutput> {
        return ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRegistries(input:))
    }
}

extension ListRegistriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegistriesInput {
        return ListRegistriesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRegistriesInput, OperationStackOutput == ListRegistriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRegistriesPaginated`
    /// to access the nested member `[GlueClientTypes.RegistryListItem]`
    /// - Returns: `[GlueClientTypes.RegistryListItem]`
    public func registries() async throws -> [GlueClientTypes.RegistryListItem] {
        return try await self.asyncCompactMap { item in item.registries }
    }
}
extension GlueClient {
    /// Paginate over `[ListSchemasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutput`
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            maxResults: self.maxResults,
            nextToken: token,
            registryId: self.registryId
        )}
}

extension PaginatorSequence where OperationStackInput == ListSchemasInput, OperationStackOutput == ListSchemasOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
    /// to access the nested member `[GlueClientTypes.SchemaListItem]`
    /// - Returns: `[GlueClientTypes.SchemaListItem]`
    public func schemas() async throws -> [GlueClientTypes.SchemaListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension GlueClient {
    /// Paginate over `[ListSchemaVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemaVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemaVersionsOutput`
    public func listSchemaVersionsPaginated(input: ListSchemaVersionsInput) -> ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSchemaVersions(input:))
    }
}

extension ListSchemaVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaVersionsInput {
        return ListSchemaVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            schemaId: self.schemaId
        )}
}

extension PaginatorSequence where OperationStackInput == ListSchemaVersionsInput, OperationStackOutput == ListSchemaVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemaVersionsPaginated`
    /// to access the nested member `[GlueClientTypes.SchemaVersionListItem]`
    /// - Returns: `[GlueClientTypes.SchemaVersionListItem]`
    public func schemas() async throws -> [GlueClientTypes.SchemaVersionListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension GlueClient {
    /// Paginate over `[ListSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSessionsOutput`
    public func listSessionsPaginated(input: ListSessionsInput) -> ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSessions(input:))
    }
}

extension ListSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSessionsInput {
        return ListSessionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            requestOrigin: self.requestOrigin,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListTableOptimizerRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTableOptimizerRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTableOptimizerRunsOutput`
    public func listTableOptimizerRunsPaginated(input: ListTableOptimizerRunsInput) -> ClientRuntime.PaginatorSequence<ListTableOptimizerRunsInput, ListTableOptimizerRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListTableOptimizerRunsInput, ListTableOptimizerRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTableOptimizerRuns(input:))
    }
}

extension ListTableOptimizerRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTableOptimizerRunsInput {
        return ListTableOptimizerRunsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName,
            type: self.type
        )}
}
extension GlueClient {
    /// Paginate over `[ListTriggersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTriggersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTriggersOutput`
    public func listTriggersPaginated(input: ListTriggersInput) -> ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutput> {
        return ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTriggers(input:))
    }
}

extension ListTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTriggersInput {
        return ListTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListWorkflowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowsOutput`
    public func listWorkflowsPaginated(input: ListWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkflows(input:))
    }
}

extension ListWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowsInput {
        return ListWorkflowsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[SearchTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchTablesOutput`
    public func searchTablesPaginated(input: SearchTablesInput) -> ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutput> {
        return ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchTables(input:))
    }
}

extension SearchTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchTablesInput {
        return SearchTablesInput(
            catalogId: self.catalogId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType,
            searchText: self.searchText,
            sortCriteria: self.sortCriteria
        )}
}
