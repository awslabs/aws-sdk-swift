// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension GlueClient {
    /// Paginate over `[GetBlueprintRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBlueprintRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBlueprintRunsOutput`
    public func getBlueprintRunsPaginated(input: GetBlueprintRunsInput) -> ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutput>(input: input, inputKey: \GetBlueprintRunsInput.nextToken, outputKey: \GetBlueprintRunsOutput.nextToken, paginationFunction: self.getBlueprintRuns(input:))
    }
}

extension GetBlueprintRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBlueprintRunsInput {
        return GetBlueprintRunsInput(
            blueprintName: self.blueprintName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetClassifiersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetClassifiersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetClassifiersOutput`
    public func getClassifiersPaginated(input: GetClassifiersInput) -> ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutput> {
        return ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutput>(input: input, inputKey: \GetClassifiersInput.nextToken, outputKey: \GetClassifiersOutput.nextToken, paginationFunction: self.getClassifiers(input:))
    }
}

extension GetClassifiersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetClassifiersInput {
        return GetClassifiersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetConnectionsOutput`
    public func getConnectionsPaginated(input: GetConnectionsInput) -> ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput>(input: input, inputKey: \GetConnectionsInput.nextToken, outputKey: \GetConnectionsOutput.nextToken, paginationFunction: self.getConnections(input:))
    }
}

extension GetConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectionsInput {
        return GetConnectionsInput(
            catalogId: self.catalogId,
            filter: self.filter,
            hidePassword: self.hidePassword,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetCrawlerMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCrawlerMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCrawlerMetricsOutput`
    public func getCrawlerMetricsPaginated(input: GetCrawlerMetricsInput) -> ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutput> {
        return ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutput>(input: input, inputKey: \GetCrawlerMetricsInput.nextToken, outputKey: \GetCrawlerMetricsOutput.nextToken, paginationFunction: self.getCrawlerMetrics(input:))
    }
}

extension GetCrawlerMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlerMetricsInput {
        return GetCrawlerMetricsInput(
            crawlerNameList: self.crawlerNameList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetCrawlersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCrawlersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCrawlersOutput`
    public func getCrawlersPaginated(input: GetCrawlersInput) -> ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutput> {
        return ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutput>(input: input, inputKey: \GetCrawlersInput.nextToken, outputKey: \GetCrawlersOutput.nextToken, paginationFunction: self.getCrawlers(input:))
    }
}

extension GetCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlersInput {
        return GetCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetDatabasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDatabasesOutput`
    public func getDatabasesPaginated(input: GetDatabasesInput) -> ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutput> {
        return ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutput>(input: input, inputKey: \GetDatabasesInput.nextToken, outputKey: \GetDatabasesOutput.nextToken, paginationFunction: self.getDatabases(input:))
    }
}

extension GetDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDatabasesInput {
        return GetDatabasesInput(
            catalogId: self.catalogId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType
        )}
}
extension GlueClient {
    /// Paginate over `[GetDevEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDevEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDevEndpointsOutput`
    public func getDevEndpointsPaginated(input: GetDevEndpointsInput) -> ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutput>(input: input, inputKey: \GetDevEndpointsInput.nextToken, outputKey: \GetDevEndpointsOutput.nextToken, paginationFunction: self.getDevEndpoints(input:))
    }
}

extension GetDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDevEndpointsInput {
        return GetDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetJobRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetJobRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetJobRunsOutput`
    public func getJobRunsPaginated(input: GetJobRunsInput) -> ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutput>(input: input, inputKey: \GetJobRunsInput.nextToken, outputKey: \GetJobRunsOutput.nextToken, paginationFunction: self.getJobRuns(input:))
    }
}

extension GetJobRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobRunsInput {
        return GetJobRunsInput(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetJobsOutput`
    public func getJobsPaginated(input: GetJobsInput) -> ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutput> {
        return ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutput>(input: input, inputKey: \GetJobsInput.nextToken, outputKey: \GetJobsOutput.nextToken, paginationFunction: self.getJobs(input:))
    }
}

extension GetJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobsInput {
        return GetJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetMLTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMLTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMLTaskRunsOutput`
    public func getMLTaskRunsPaginated(input: GetMLTaskRunsInput) -> ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutput>(input: input, inputKey: \GetMLTaskRunsInput.nextToken, outputKey: \GetMLTaskRunsOutput.nextToken, paginationFunction: self.getMLTaskRuns(input:))
    }
}

extension GetMLTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTaskRunsInput {
        return GetMLTaskRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            transformId: self.transformId
        )}
}
extension GlueClient {
    /// Paginate over `[GetMLTransformsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMLTransformsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMLTransformsOutput`
    public func getMLTransformsPaginated(input: GetMLTransformsInput) -> ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutput> {
        return ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutput>(input: input, inputKey: \GetMLTransformsInput.nextToken, outputKey: \GetMLTransformsOutput.nextToken, paginationFunction: self.getMLTransforms(input:))
    }
}

extension GetMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTransformsInput {
        return GetMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )}
}
extension GlueClient {
    /// Paginate over `[GetPartitionIndexesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPartitionIndexesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPartitionIndexesOutput`
    public func getPartitionIndexesPaginated(input: GetPartitionIndexesInput) -> ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutput> {
        return ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutput>(input: input, inputKey: \GetPartitionIndexesInput.nextToken, outputKey: \GetPartitionIndexesOutput.nextToken, paginationFunction: self.getPartitionIndexes(input:))
    }
}

extension GetPartitionIndexesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionIndexesInput {
        return GetPartitionIndexesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            nextToken: token,
            tableName: self.tableName
        )}
}

extension PaginatorSequence where Input == GetPartitionIndexesInput, Output == GetPartitionIndexesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getPartitionIndexesPaginated`
    /// to access the nested member `[GlueClientTypes.PartitionIndexDescriptor]`
    /// - Returns: `[GlueClientTypes.PartitionIndexDescriptor]`
    public func partitionIndexDescriptorList() async throws -> [GlueClientTypes.PartitionIndexDescriptor] {
        return try await self.asyncCompactMap { item in item.partitionIndexDescriptorList }
    }
}
extension GlueClient {
    /// Paginate over `[GetPartitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPartitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPartitionsOutput`
    public func getPartitionsPaginated(input: GetPartitionsInput) -> ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutput> {
        return ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutput>(input: input, inputKey: \GetPartitionsInput.nextToken, outputKey: \GetPartitionsOutput.nextToken, paginationFunction: self.getPartitions(input:))
    }
}

extension GetPartitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionsInput {
        return GetPartitionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            excludeColumnSchema: self.excludeColumnSchema,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            segment: self.segment,
            tableName: self.tableName,
            transactionId: self.transactionId
        )}
}
extension GlueClient {
    /// Paginate over `[GetResourcePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourcePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutput`
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput>(input: input, inputKey: \GetResourcePoliciesInput.nextToken, outputKey: \GetResourcePoliciesOutput.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == GetResourcePoliciesInput, Output == GetResourcePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getResourcePoliciesPaginated`
    /// to access the nested member `[GlueClientTypes.GluePolicy]`
    /// - Returns: `[GlueClientTypes.GluePolicy]`
    public func getResourcePoliciesResponseList() async throws -> [GlueClientTypes.GluePolicy] {
        return try await self.asyncCompactMap { item in item.getResourcePoliciesResponseList }
    }
}
extension GlueClient {
    /// Paginate over `[GetSecurityConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSecurityConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSecurityConfigurationsOutput`
    public func getSecurityConfigurationsPaginated(input: GetSecurityConfigurationsInput) -> ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutput>(input: input, inputKey: \GetSecurityConfigurationsInput.nextToken, outputKey: \GetSecurityConfigurationsOutput.nextToken, paginationFunction: self.getSecurityConfigurations(input:))
    }
}

extension GetSecurityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSecurityConfigurationsInput {
        return GetSecurityConfigurationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == GetSecurityConfigurationsInput, Output == GetSecurityConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getSecurityConfigurationsPaginated`
    /// to access the nested member `[GlueClientTypes.SecurityConfiguration]`
    /// - Returns: `[GlueClientTypes.SecurityConfiguration]`
    public func securityConfigurations() async throws -> [GlueClientTypes.SecurityConfiguration] {
        return try await self.asyncCompactMap { item in item.securityConfigurations }
    }
}
extension GlueClient {
    /// Paginate over `[GetTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTablesOutput`
    public func getTablesPaginated(input: GetTablesInput) -> ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutput> {
        return ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutput>(input: input, inputKey: \GetTablesInput.nextToken, outputKey: \GetTablesOutput.nextToken, paginationFunction: self.getTables(input:))
    }
}

extension GetTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTablesInput {
        return GetTablesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            transactionId: self.transactionId
        )}
}
extension GlueClient {
    /// Paginate over `[GetTableVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTableVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTableVersionsOutput`
    public func getTableVersionsPaginated(input: GetTableVersionsInput) -> ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutput> {
        return ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutput>(input: input, inputKey: \GetTableVersionsInput.nextToken, outputKey: \GetTableVersionsOutput.nextToken, paginationFunction: self.getTableVersions(input:))
    }
}

extension GetTableVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTableVersionsInput {
        return GetTableVersionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetTriggersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTriggersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTriggersOutput`
    public func getTriggersPaginated(input: GetTriggersInput) -> ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutput> {
        return ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutput>(input: input, inputKey: \GetTriggersInput.nextToken, outputKey: \GetTriggersOutput.nextToken, paginationFunction: self.getTriggers(input:))
    }
}

extension GetTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTriggersInput {
        return GetTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetUnfilteredPartitionsMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUnfilteredPartitionsMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUnfilteredPartitionsMetadataOutput`
    public func getUnfilteredPartitionsMetadataPaginated(input: GetUnfilteredPartitionsMetadataInput) -> ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutput> {
        return ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutput>(input: input, inputKey: \GetUnfilteredPartitionsMetadataInput.nextToken, outputKey: \GetUnfilteredPartitionsMetadataOutput.nextToken, paginationFunction: self.getUnfilteredPartitionsMetadata(input:))
    }
}

extension GetUnfilteredPartitionsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUnfilteredPartitionsMetadataInput {
        return GetUnfilteredPartitionsMetadataInput(
            auditContext: self.auditContext,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            segment: self.segment,
            supportedPermissionTypes: self.supportedPermissionTypes,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetUserDefinedFunctionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUserDefinedFunctionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUserDefinedFunctionsOutput`
    public func getUserDefinedFunctionsPaginated(input: GetUserDefinedFunctionsInput) -> ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutput> {
        return ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutput>(input: input, inputKey: \GetUserDefinedFunctionsInput.nextToken, outputKey: \GetUserDefinedFunctionsOutput.nextToken, paginationFunction: self.getUserDefinedFunctions(input:))
    }
}

extension GetUserDefinedFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUserDefinedFunctionsInput {
        return GetUserDefinedFunctionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            pattern: self.pattern
        )}
}
extension GlueClient {
    /// Paginate over `[GetWorkflowRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetWorkflowRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetWorkflowRunsOutput`
    public func getWorkflowRunsPaginated(input: GetWorkflowRunsInput) -> ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutput>(input: input, inputKey: \GetWorkflowRunsInput.nextToken, outputKey: \GetWorkflowRunsOutput.nextToken, paginationFunction: self.getWorkflowRuns(input:))
    }
}

extension GetWorkflowRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetWorkflowRunsInput {
        return GetWorkflowRunsInput(
            includeGraph: self.includeGraph,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListBlueprintsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBlueprintsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBlueprintsOutput`
    public func listBlueprintsPaginated(input: ListBlueprintsInput) -> ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutput> {
        return ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutput>(input: input, inputKey: \ListBlueprintsInput.nextToken, outputKey: \ListBlueprintsOutput.nextToken, paginationFunction: self.listBlueprints(input:))
    }
}

extension ListBlueprintsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBlueprintsInput {
        return ListBlueprintsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListCrawlersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCrawlersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCrawlersOutput`
    public func listCrawlersPaginated(input: ListCrawlersInput) -> ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutput> {
        return ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutput>(input: input, inputKey: \ListCrawlersInput.nextToken, outputKey: \ListCrawlersOutput.nextToken, paginationFunction: self.listCrawlers(input:))
    }
}

extension ListCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCrawlersInput {
        return ListCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListCustomEntityTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCustomEntityTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCustomEntityTypesOutput`
    public func listCustomEntityTypesPaginated(input: ListCustomEntityTypesInput) -> ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutput>(input: input, inputKey: \ListCustomEntityTypesInput.nextToken, outputKey: \ListCustomEntityTypesOutput.nextToken, paginationFunction: self.listCustomEntityTypes(input:))
    }
}

extension ListCustomEntityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomEntityTypesInput {
        return ListCustomEntityTypesInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityResultsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityResultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityResultsOutput`
    public func listDataQualityResultsPaginated(input: ListDataQualityResultsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityResultsInput, ListDataQualityResultsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityResultsInput, ListDataQualityResultsOutput>(input: input, inputKey: \ListDataQualityResultsInput.nextToken, outputKey: \ListDataQualityResultsOutput.nextToken, paginationFunction: self.listDataQualityResults(input:))
    }
}

extension ListDataQualityResultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityResultsInput {
        return ListDataQualityResultsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRuleRecommendationRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRuleRecommendationRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRuleRecommendationRunsOutput`
    public func listDataQualityRuleRecommendationRunsPaginated(input: ListDataQualityRuleRecommendationRunsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRuleRecommendationRunsInput, ListDataQualityRuleRecommendationRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRuleRecommendationRunsInput, ListDataQualityRuleRecommendationRunsOutput>(input: input, inputKey: \ListDataQualityRuleRecommendationRunsInput.nextToken, outputKey: \ListDataQualityRuleRecommendationRunsOutput.nextToken, paginationFunction: self.listDataQualityRuleRecommendationRuns(input:))
    }
}

extension ListDataQualityRuleRecommendationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRuleRecommendationRunsInput {
        return ListDataQualityRuleRecommendationRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRulesetEvaluationRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRulesetEvaluationRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRulesetEvaluationRunsOutput`
    public func listDataQualityRulesetEvaluationRunsPaginated(input: ListDataQualityRulesetEvaluationRunsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRulesetEvaluationRunsInput, ListDataQualityRulesetEvaluationRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRulesetEvaluationRunsInput, ListDataQualityRulesetEvaluationRunsOutput>(input: input, inputKey: \ListDataQualityRulesetEvaluationRunsInput.nextToken, outputKey: \ListDataQualityRulesetEvaluationRunsOutput.nextToken, paginationFunction: self.listDataQualityRulesetEvaluationRuns(input:))
    }
}

extension ListDataQualityRulesetEvaluationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRulesetEvaluationRunsInput {
        return ListDataQualityRulesetEvaluationRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRulesetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRulesetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRulesetsOutput`
    public func listDataQualityRulesetsPaginated(input: ListDataQualityRulesetsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRulesetsInput, ListDataQualityRulesetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRulesetsInput, ListDataQualityRulesetsOutput>(input: input, inputKey: \ListDataQualityRulesetsInput.nextToken, outputKey: \ListDataQualityRulesetsOutput.nextToken, paginationFunction: self.listDataQualityRulesets(input:))
    }
}

extension ListDataQualityRulesetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRulesetsInput {
        return ListDataQualityRulesetsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListDevEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevEndpointsOutput`
    public func listDevEndpointsPaginated(input: ListDevEndpointsInput) -> ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutput>(input: input, inputKey: \ListDevEndpointsInput.nextToken, outputKey: \ListDevEndpointsOutput.nextToken, paginationFunction: self.listDevEndpoints(input:))
    }
}

extension ListDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevEndpointsInput {
        return ListDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \ListJobsInput.nextToken, outputKey: \ListJobsOutput.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListMLTransformsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMLTransformsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMLTransformsOutput`
    public func listMLTransformsPaginated(input: ListMLTransformsInput) -> ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutput> {
        return ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutput>(input: input, inputKey: \ListMLTransformsInput.nextToken, outputKey: \ListMLTransformsOutput.nextToken, paginationFunction: self.listMLTransforms(input:))
    }
}

extension ListMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMLTransformsInput {
        return ListMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListRegistriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRegistriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRegistriesOutput`
    public func listRegistriesPaginated(input: ListRegistriesInput) -> ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutput> {
        return ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutput>(input: input, inputKey: \ListRegistriesInput.nextToken, outputKey: \ListRegistriesOutput.nextToken, paginationFunction: self.listRegistries(input:))
    }
}

extension ListRegistriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegistriesInput {
        return ListRegistriesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRegistriesInput, Output == ListRegistriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRegistriesPaginated`
    /// to access the nested member `[GlueClientTypes.RegistryListItem]`
    /// - Returns: `[GlueClientTypes.RegistryListItem]`
    public func registries() async throws -> [GlueClientTypes.RegistryListItem] {
        return try await self.asyncCompactMap { item in item.registries }
    }
}
extension GlueClient {
    /// Paginate over `[ListSchemasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutput`
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput>(input: input, inputKey: \ListSchemasInput.nextToken, outputKey: \ListSchemasOutput.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            maxResults: self.maxResults,
            nextToken: token,
            registryId: self.registryId
        )}
}

extension PaginatorSequence where Input == ListSchemasInput, Output == ListSchemasOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
    /// to access the nested member `[GlueClientTypes.SchemaListItem]`
    /// - Returns: `[GlueClientTypes.SchemaListItem]`
    public func schemas() async throws -> [GlueClientTypes.SchemaListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension GlueClient {
    /// Paginate over `[ListSchemaVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemaVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemaVersionsOutput`
    public func listSchemaVersionsPaginated(input: ListSchemaVersionsInput) -> ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutput>(input: input, inputKey: \ListSchemaVersionsInput.nextToken, outputKey: \ListSchemaVersionsOutput.nextToken, paginationFunction: self.listSchemaVersions(input:))
    }
}

extension ListSchemaVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaVersionsInput {
        return ListSchemaVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            schemaId: self.schemaId
        )}
}

extension PaginatorSequence where Input == ListSchemaVersionsInput, Output == ListSchemaVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemaVersionsPaginated`
    /// to access the nested member `[GlueClientTypes.SchemaVersionListItem]`
    /// - Returns: `[GlueClientTypes.SchemaVersionListItem]`
    public func schemas() async throws -> [GlueClientTypes.SchemaVersionListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension GlueClient {
    /// Paginate over `[ListSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSessionsOutput`
    public func listSessionsPaginated(input: ListSessionsInput) -> ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutput>(input: input, inputKey: \ListSessionsInput.nextToken, outputKey: \ListSessionsOutput.nextToken, paginationFunction: self.listSessions(input:))
    }
}

extension ListSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSessionsInput {
        return ListSessionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            requestOrigin: self.requestOrigin,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListTriggersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTriggersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTriggersOutput`
    public func listTriggersPaginated(input: ListTriggersInput) -> ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutput> {
        return ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutput>(input: input, inputKey: \ListTriggersInput.nextToken, outputKey: \ListTriggersOutput.nextToken, paginationFunction: self.listTriggers(input:))
    }
}

extension ListTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTriggersInput {
        return ListTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListWorkflowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowsOutput`
    public func listWorkflowsPaginated(input: ListWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput>(input: input, inputKey: \ListWorkflowsInput.nextToken, outputKey: \ListWorkflowsOutput.nextToken, paginationFunction: self.listWorkflows(input:))
    }
}

extension ListWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowsInput {
        return ListWorkflowsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[SearchTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchTablesOutput`
    public func searchTablesPaginated(input: SearchTablesInput) -> ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutput> {
        return ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutput>(input: input, inputKey: \SearchTablesInput.nextToken, outputKey: \SearchTablesOutput.nextToken, paginationFunction: self.searchTables(input:))
    }
}

extension SearchTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchTablesInput {
        return SearchTablesInput(
            catalogId: self.catalogId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType,
            searchText: self.searchText,
            sortCriteria: self.sortCriteria
        )}
}
